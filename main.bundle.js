module.exports = "181550\n{\"version\":0,\"id\":\"36790873476c0ab38943a6ecc3964e639625927eb731d649cacb00f1ad567a60\",\"main\":\"/main.js\",\"imports\":{},\"resolutions\":{\"/lib/inspector.js\":{\"#package\":\"/package.json\",\"pear-inspect\":\"/node_modules/pear-inspect/index.js\"},\"/main.js\":{\"#package\":\"/package.json\",\"./lib/inspector\":\"/lib/inspector.js\",\"@holepunchto/keet-backend\":\"/node_modules/@holepunchto/keet-backend/index.js\",\"@holepunchto/keet-backend-rpc/server\":\"/node_modules/@holepunchto/keet-backend-rpc/server.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"hyperdht/package\":\"/node_modules/hyperdht/package.json\",\"tiny-buffer-rpc\":\"/node_modules/tiny-buffer-rpc/index.js\",\"tiny-buffer-rpc/any\":\"/node_modules/tiny-buffer-rpc/any.js\"},\"/node_modules/@holepunchto/bip39/index.js\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\",\"./wordlist\":\"/node_modules/@holepunchto/bip39/wordlist/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/@holepunchto/bip39/package.json\":{},\"/node_modules/@holepunchto/bip39/wordlist/chinese_simplified.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/bip39/wordlist/chinese_traditional.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/bip39/wordlist/czech.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/bip39/wordlist/english.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/bip39/wordlist/french.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/bip39/wordlist/index.js\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\",\"./chinese_simplified.json\":\"/node_modules/@holepunchto/bip39/wordlist/chinese_simplified.json\",\"./chinese_traditional.json\":\"/node_modules/@holepunchto/bip39/wordlist/chinese_traditional.json\",\"./czech.json\":\"/node_modules/@holepunchto/bip39/wordlist/czech.json\",\"./english.json\":\"/node_modules/@holepunchto/bip39/wordlist/english.json\",\"./french.json\":\"/node_modules/@holepunchto/bip39/wordlist/french.json\",\"./italian.json\":\"/node_modules/@holepunchto/bip39/wordlist/italian.json\",\"./japanese.json\":\"/node_modules/@holepunchto/bip39/wordlist/japanese.json\",\"./korean.json\":\"/node_modules/@holepunchto/bip39/wordlist/korean.json\",\"./lookup.json\":\"/node_modules/@holepunchto/bip39/wordlist/lookup.json\",\"./portuguese.json\":\"/node_modules/@holepunchto/bip39/wordlist/portuguese.json\",\"./russian.json\":\"/node_modules/@holepunchto/bip39/wordlist/russian.json\",\"./spanish.json\":\"/node_modules/@holepunchto/bip39/wordlist/spanish.json\",\"./turkish.json\":\"/node_modules/@holepunchto/bip39/wordlist/turkish.json\"},\"/node_modules/@holepunchto/bip39/wordlist/italian.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/bip39/wordlist/japanese.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/bip39/wordlist/korean.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/bip39/wordlist/lookup.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/bip39/wordlist/portuguese.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/bip39/wordlist/russian.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/bip39/wordlist/spanish.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/bip39/wordlist/turkish.json\":{\"#package\":\"/node_modules/@holepunchto/bip39/package.json\"},\"/node_modules/@holepunchto/blind-mirror/client.js\":{\"#package\":\"/node_modules/@holepunchto/blind-mirror/package.json\",\"./lib/client.js\":\"/node_modules/@holepunchto/blind-mirror/lib/client.js\"},\"/node_modules/@holepunchto/blind-mirror/lib/backoff.js\":{\"#package\":\"/node_modules/@holepunchto/blind-mirror/package.json\"},\"/node_modules/@holepunchto/blind-mirror/lib/client.js\":{\"#package\":\"/node_modules/@holepunchto/blind-mirror/package.json\",\"./backoff.js\":\"/node_modules/@holepunchto/blind-mirror/lib/backoff.js\",\"./messages.js\":\"/node_modules/@holepunchto/blind-mirror/lib/messages.js\",\"./select.js\":\"/node_modules/@holepunchto/blind-mirror/lib/select.js\",\"./wait-for-rpc.js\":\"/node_modules/@holepunchto/blind-mirror/lib/wait-for-rpc.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"hyperdht\":\"/node_modules/hyperdht/index.js\",\"protomux-rpc\":\"/node_modules/protomux-rpc/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/@holepunchto/blind-mirror/lib/messages.js\":{\"#package\":\"/node_modules/@holepunchto/blind-mirror/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/blind-mirror/lib/select.js\":{\"#package\":\"/node_modules/@holepunchto/blind-mirror/package.json\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"xor-distance\":\"/node_modules/xor-distance/index.js\"},\"/node_modules/@holepunchto/blind-mirror/lib/wait-for-rpc.js\":{\"#package\":\"/node_modules/@holepunchto/blind-mirror/package.json\"},\"/node_modules/@holepunchto/blind-mirror/package.json\":{\"#package\":\"/node_modules/@holepunchto/blind-mirror/package.json\"},\"/node_modules/@holepunchto/hmac/hash/sha256.js\":{\"#package\":\"/node_modules/@holepunchto/hmac/package.json\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/@holepunchto/hmac/hash/sha512.js\":{\"#package\":\"/node_modules/@holepunchto/hmac/package.json\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/@holepunchto/hmac/index.js\":{\"#package\":\"/node_modules/@holepunchto/hmac/package.json\",\"./hash/sha256\":\"/node_modules/@holepunchto/hmac/hash/sha256.js\",\"./hash/sha512\":\"/node_modules/@holepunchto/hmac/hash/sha512.js\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/@holepunchto/hmac/package.json\":{},\"/node_modules/@holepunchto/hyperindex/index.js\":{\"#package\":\"/node_modules/@holepunchto/hyperindex/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"index-encoder\":\"/node_modules/index-encoder/index.js\",\"mutexify/promise\":\"/node_modules/mutexify/promise.js\",\"streamx\":\"/node_modules/streamx/index.js\",\"sub-encoder\":\"/node_modules/sub-encoder/index.js\"},\"/node_modules/@holepunchto/hyperindex/package.json\":{\"#package\":\"/node_modules/@holepunchto/hyperindex/package.json\"},\"/node_modules/@holepunchto/keet-backend-rpc/package.json\":{},\"/node_modules/@holepunchto/keet-backend-rpc/server.js\":{\"#package\":\"/node_modules/@holepunchto/keet-backend-rpc/package.json\",\"streamx\":\"/node_modules/streamx/index.js\",\"tiny-buffer-rpc/any\":\"/node_modules/tiny-buffer-rpc/any.js\"},\"/node_modules/@holepunchto/keet-backend/apis/error.js\":{\"#package\":\"/node_modules/@holepunchto/keet-backend/package.json\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-backend/apis/network.js\":{\"#package\":\"/node_modules/@holepunchto/keet-backend/package.json\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-backend/apis/payments.js\":{\"#package\":\"/node_modules/@holepunchto/keet-backend/package.json\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-backend/apis/preferences.js\":{\"#package\":\"/node_modules/@holepunchto/keet-backend/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"hyperbee\":\"/node_modules/hyperbee/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-backend/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-backend/package.json\",\"./apis/error\":\"/node_modules/@holepunchto/keet-backend/apis/error.js\",\"./apis/network\":\"/node_modules/@holepunchto/keet-backend/apis/network.js\",\"./apis/payments\":\"/node_modules/@holepunchto/keet-backend/apis/payments.js\",\"./apis/preferences\":\"/node_modules/@holepunchto/keet-backend/apis/preferences.js\",\"@holepunchto/keet-call/server\":\"/node_modules/@holepunchto/keet-call/server/index.js\",\"@holepunchto/keet-core\":\"/node_modules/@holepunchto/keet-core/index.js\",\"@holepunchto/keet-default-config\":\"/node_modules/@holepunchto/keet-default-config/index.js\",\"corestore\":\"/node_modules/corestore/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"hyperswarm\":\"/node_modules/hyperswarm/index.js\",\"rache\":\"/node_modules/rache/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/@holepunchto/keet-backend/package.json\":{},\"/node_modules/@holepunchto/keet-call/lib/common.js\":{\"#package\":\"/node_modules/@holepunchto/keet-call/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/@holepunchto/keet-call/lib/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-call/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-call/package.json\":{},\"/node_modules/@holepunchto/keet-call/server/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-call/package.json\",\"../lib/common\":\"/node_modules/@holepunchto/keet-call/lib/common.js\",\"./media\":\"/node_modules/@holepunchto/keet-call/server/media.js\",\"./presence\":\"/node_modules/@holepunchto/keet-call/server/presence.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/@holepunchto/keet-call/server/media.js\":{\"#package\":\"/node_modules/@holepunchto/keet-call/package.json\",\"../lib/common\":\"/node_modules/@holepunchto/keet-call/lib/common.js\",\"./webrtc\":\"/node_modules/@holepunchto/keet-call/server/webrtc.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-call/server/presence.js\":{\"#package\":\"/node_modules/@holepunchto/keet-call/package.json\",\"../lib/common\":\"/node_modules/@holepunchto/keet-call/lib/common.js\",\"../lib/messages\":\"/node_modules/@holepunchto/keet-call/lib/messages.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"hypercore\":\"/node_modules/hypercore/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-call/server/webrtc.js\":{\"#package\":\"/node_modules/@holepunchto/keet-call/package.json\",\"../lib/messages\":\"/node_modules/@holepunchto/keet-call/lib/messages.js\",\"events\":\"/node_modules/bare-events/index.js\",\"hypercore\":\"/node_modules/hypercore/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/@holepunchto/keet-core-api/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-api/package.json\",\"./lib/chat\":\"/node_modules/@holepunchto/keet-core-api/lib/chat.js\",\"./lib/config\":\"/node_modules/@holepunchto/keet-core-api/lib/config.js\",\"./lib/errors\":\"/node_modules/@holepunchto/keet-core-api/lib/errors.js\",\"./lib/features\":\"/node_modules/@holepunchto/keet-core-api/lib/features.js\",\"./lib/internal\":\"/node_modules/@holepunchto/keet-core-api/lib/internal.js\",\"./lib/mailbox\":\"/node_modules/@holepunchto/keet-core-api/lib/mailbox.js\",\"./lib/members\":\"/node_modules/@holepunchto/keet-core-api/lib/members.js\",\"./lib/preferences\":\"/node_modules/@holepunchto/keet-core-api/lib/preferences.js\"},\"/node_modules/@holepunchto/keet-core-api/lib/chat.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-api/package.json\"},\"/node_modules/@holepunchto/keet-core-api/lib/config.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-api/package.json\"},\"/node_modules/@holepunchto/keet-core-api/lib/errors.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-api/package.json\"},\"/node_modules/@holepunchto/keet-core-api/lib/features.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-api/package.json\"},\"/node_modules/@holepunchto/keet-core-api/lib/internal.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-api/package.json\"},\"/node_modules/@holepunchto/keet-core-api/lib/mailbox.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-api/package.json\"},\"/node_modules/@holepunchto/keet-core-api/lib/members.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-api/package.json\"},\"/node_modules/@holepunchto/keet-core-api/lib/preferences.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-api/package.json\"},\"/node_modules/@holepunchto/keet-core-api/package.json\":{},\"/node_modules/@holepunchto/keet-core-schemas/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./lib/chat\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/index.js\",\"./lib/config\":\"/node_modules/@holepunchto/keet-core-schemas/lib/config/index.js\",\"./lib/devices\":\"/node_modules/@holepunchto/keet-core-schemas/lib/devices/index.js\",\"./lib/internal\":\"/node_modules/@holepunchto/keet-core-schemas/lib/internal/index.js\",\"./lib/invitations\":\"/node_modules/@holepunchto/keet-core-schemas/lib/invitations/index.js\",\"./lib/keet\":\"/node_modules/@holepunchto/keet-core-schemas/lib/keet/index.js\",\"./lib/mailbox\":\"/node_modules/@holepunchto/keet-core-schemas/lib/mailbox/index.js\",\"./lib/members\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/index.js\",\"./lib/plugins\":\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/index.js\",\"./lib/plugins/private-profile\":\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/private-profile/index.js\",\"./lib/private-devices\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-devices/index.js\",\"./lib/private-mailbox\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-mailbox/index.js\",\"./lib/private-rooms\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-rooms/index.js\",\"./lib/reactions\":\"/node_modules/@holepunchto/keet-core-schemas/lib/reactions/index.js\",\"./lib/schema-builder\":\"/node_modules/@holepunchto/keet-core-schemas/lib/schema-builder.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../members/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/messages.js\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/messages.js\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/ops.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/messages.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/config/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../chat/messages.js\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/messages.js\",\"../internal\":\"/node_modules/@holepunchto/keet-core-schemas/lib/internal/index.js\",\"./messages.js\":\"/node_modules/@holepunchto/keet-core-schemas/lib/config/messages.js\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/config/ops.js\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/config/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/config/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/devices/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../members/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/messages.js\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/devices/messages.js\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/devices/ops.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/devices/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/devices/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../members/messages.js\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/messages.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/internal/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../plugins/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/messages.js\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/internal/ops.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"sub-encoder\":\"/node_modules/sub-encoder/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/internal/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../plugins/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/messages.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/invitations/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/invitations/messages.js\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/invitations/ops.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/invitations/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/invitations/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/invitations/messages.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/keet/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/keet/messages.js\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/keet/ops.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/keet/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/keet/ops.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/keet/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../chat/ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/ops.js\",\"../config/ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/config/ops.js\",\"../devices/ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/devices/ops.js\",\"../internal/ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/internal/ops.js\",\"../invitations/ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/invitations/ops.js\",\"../mailbox/ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/mailbox/ops.js\",\"../members/ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/ops.js\",\"../plugins/ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/ops.js\",\"../private-devices/ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-devices/ops.js\",\"../private-mailbox/ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-mailbox/ops.js\",\"../private-rooms/ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-rooms/ops.js\",\"../reactions/ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/reactions/ops.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/mailbox/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../chat/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/messages.js\",\"../members/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/messages.js\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/mailbox/messages.js\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/mailbox/ops.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/mailbox/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../chat/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/messages.js\",\"../members/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/messages.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/mailbox/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./messages.js\":\"/node_modules/@holepunchto/keet-core-schemas/lib/mailbox/messages.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/members/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/messages.js\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/ops.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/members/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/members/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/messages.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/ops.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"sub-encoder\":\"/node_modules/sub-encoder/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/private-profile/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/private-profile/messages.js\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/private-profile/ops.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/private-profile/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/private-profile/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-devices/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-devices/ops.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-devices/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-mailbox/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../chat/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/messages.js\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-mailbox/messages.js\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-mailbox/ops.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-mailbox/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../chat/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/messages.js\",\"../members/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/messages.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-mailbox/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../chat/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/messages.js\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-mailbox/messages.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-rooms/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-rooms/messages.js\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-rooms/ops.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-rooms/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-rooms/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/reactions/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../chat/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/messages.js\",\"../members/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/messages.js\",\"./messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/reactions/messages.js\",\"./ops\":\"/node_modules/@holepunchto/keet-core-schemas/lib/reactions/ops.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/reactions/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../members/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/messages.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/reactions/ops.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"../chat/messages\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/messages.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/lib/schema-builder.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core-schemas/package.json\",\"./chat\":\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/index.js\",\"./config\":\"/node_modules/@holepunchto/keet-core-schemas/lib/config/index.js\",\"./devices\":\"/node_modules/@holepunchto/keet-core-schemas/lib/devices/index.js\",\"./invitations\":\"/node_modules/@holepunchto/keet-core-schemas/lib/invitations/index.js\",\"./mailbox\":\"/node_modules/@holepunchto/keet-core-schemas/lib/mailbox/index.js\",\"./members\":\"/node_modules/@holepunchto/keet-core-schemas/lib/members/index.js\",\"./private-devices\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-devices/index.js\",\"./private-mailbox\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-mailbox/index.js\",\"./private-rooms\":\"/node_modules/@holepunchto/keet-core-schemas/lib/private-rooms/index.js\",\"./reactions\":\"/node_modules/@holepunchto/keet-core-schemas/lib/reactions/index.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\"},\"/node_modules/@holepunchto/keet-core-schemas/package.json\":{},\"/node_modules/@holepunchto/keet-core/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"./lib/activity\":\"/node_modules/@holepunchto/keet-core/lib/activity.js\",\"./lib/drives\":\"/node_modules/@holepunchto/keet-core/lib/drives.js\",\"./lib/identity\":\"/node_modules/@holepunchto/keet-core/lib/identity/index.js\",\"./lib/local\":\"/node_modules/@holepunchto/keet-core/lib/local/index.js\",\"./lib/local/messages\":\"/node_modules/@holepunchto/keet-core/lib/local/messages.js\",\"./lib/pairing\":\"/node_modules/@holepunchto/keet-core/lib/pairing/index.js\",\"./lib/room\":\"/node_modules/@holepunchto/keet-core/lib/room/index.js\",\"./lib/room/chat\":\"/node_modules/@holepunchto/keet-core/lib/room/chat.js\",\"./lib/room/invitations\":\"/node_modules/@holepunchto/keet-core/lib/room/invitations.js\",\"./package.json\":\"/node_modules/@holepunchto/keet-core/package.json\",\"@holepunchto/blind-mirror/client\":\"/node_modules/@holepunchto/blind-mirror/client.js\",\"@holepunchto/blind-mirror/package.json\":\"/node_modules/@holepunchto/blind-mirror/package.json\",\"@holepunchto/hyperindex/package.json\":\"/node_modules/@holepunchto/hyperindex/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-identity-key/package.json\":\"/node_modules/@holepunchto/keet-identity-key/package.json\",\"@holepunchto/keet-indexing/package.json\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-push\":\"/node_modules/@holepunchto/keet-push/index.js\",\"@holepunchto/keet-push/package.json\":\"/node_modules/@holepunchto/keet-push/package.json\",\"autobase/package.json\":\"/node_modules/autobase/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"blind-pairing\":\"/node_modules/blind-pairing/index.js\",\"blind-pairing/package.json\":\"/node_modules/blind-pairing/package.json\",\"corestore/package.json\":\"/node_modules/corestore/package.json\",\"debounceify\":\"/node_modules/debounceify/index.js\",\"hyperbee/package.json\":\"/node_modules/hyperbee/package.json\",\"hypercore\":\"/node_modules/hypercore/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"hypercore/package.json\":\"/node_modules/hypercore/package.json\",\"hyperdrive\":\"/node_modules/hyperdrive/index.js\",\"hyperdrive/package.json\":\"/node_modules/hyperdrive/package.json\",\"mutexify/promise\":\"/node_modules/mutexify/promise.js\",\"parallel-transformx\":\"/node_modules/parallel-transformx/index.js\",\"promaphore\":\"/node_modules/promaphore/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\",\"tiny-buffer-map\":\"/node_modules/tiny-buffer-map/index.js\",\"xor-distance\":\"/node_modules/xor-distance/index.js\",\"z32\":\"/node_modules/z32/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/activity.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"autobase\":\"/node_modules/autobase/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"debounceify\":\"/node_modules/debounceify/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/drives.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"hyperdrive\":\"/node_modules/hyperdrive/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"serve-drive\":\"/node_modules/serve-drive/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/identity/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"./messages.js\":\"/node_modules/@holepunchto/keet-core/lib/identity/messages.js\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-identity-key\":\"/node_modules/@holepunchto/keet-identity-key/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"blind-pairing\":\"/node_modules/blind-pairing/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"debounceify\":\"/node_modules/debounceify/index.js\",\"hyperbee\":\"/node_modules/hyperbee/index.js\",\"hyperbee-diff-stream\":\"/node_modules/hyperbee-diff-stream/index.js\",\"hypercore\":\"/node_modules/hypercore/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/identity/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/identity/plugin.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/local/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"./messages.js\":\"/node_modules/@holepunchto/keet-core/lib/local/messages.js\",\"./transaction.js\":\"/node_modules/@holepunchto/keet-core/lib/local/transaction.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"hyperbee\":\"/node_modules/hyperbee/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"mutexify/promise\":\"/node_modules/mutexify/promise.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/local/messages.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\",\"blind-pairing\":\"/node_modules/blind-pairing/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/local/transaction.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"./messages.js\":\"/node_modules/@holepunchto/keet-core/lib/local/messages.js\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"hyperdrive\":\"/node_modules/hyperdrive/index.js\",\"parallel-transformx\":\"/node_modules/parallel-transformx/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/pairing/client.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"../identity\":\"/node_modules/@holepunchto/keet-core/lib/identity/index.js\",\"../local/messages\":\"/node_modules/@holepunchto/keet-core/lib/local/messages.js\",\"../room/invitations\":\"/node_modules/@holepunchto/keet-core/lib/room/invitations.js\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"blind-pairing\":\"/node_modules/blind-pairing/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"debounceify\":\"/node_modules/debounceify/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\",\"tiny-buffer-map\":\"/node_modules/tiny-buffer-map/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/pairing/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"./client\":\"/node_modules/@holepunchto/keet-core/lib/pairing/client.js\",\"./server\":\"/node_modules/@holepunchto/keet-core/lib/pairing/server.js\",\"blind-pairing\":\"/node_modules/blind-pairing/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/pairing/server.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"../identity\":\"/node_modules/@holepunchto/keet-core/lib/identity/index.js\",\"../room/invitations\":\"/node_modules/@holepunchto/keet-core/lib/room/invitations.js\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"debounceify\":\"/node_modules/debounceify/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\",\"tiny-buffer-map\":\"/node_modules/tiny-buffer-map/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/room/chat.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"parallel-transformx\":\"/node_modules/parallel-transformx/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/room/commands.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/room/config.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/room/devices.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"./invitations.js\":\"/node_modules/@holepunchto/keet-core/lib/room/invitations.js\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/room/files.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"fs\":\"/node_modules/bare-fs/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"path\":\"/node_modules/bare-path/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/room/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"../identity\":\"/node_modules/@holepunchto/keet-core/lib/identity/index.js\",\"./chat\":\"/node_modules/@holepunchto/keet-core/lib/room/chat.js\",\"./commands\":\"/node_modules/@holepunchto/keet-core/lib/room/commands.js\",\"./config\":\"/node_modules/@holepunchto/keet-core/lib/room/config.js\",\"./devices\":\"/node_modules/@holepunchto/keet-core/lib/room/devices.js\",\"./files\":\"/node_modules/@holepunchto/keet-core/lib/room/files.js\",\"./invitations\":\"/node_modules/@holepunchto/keet-core/lib/room/invitations.js\",\"./mailbox\":\"/node_modules/@holepunchto/keet-core/lib/room/mailbox.js\",\"./members\":\"/node_modules/@holepunchto/keet-core/lib/room/members.js\",\"./plugins\":\"/node_modules/@holepunchto/keet-core/lib/room/plugins.js\",\"./private-mailbox\":\"/node_modules/@holepunchto/keet-core/lib/room/private-mailbox.js\",\"./reactions\":\"/node_modules/@holepunchto/keet-core/lib/room/reactions.js\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"@holepunchto/keet-indexing\":\"/node_modules/@holepunchto/keet-indexing/index.js\",\"autobase\":\"/node_modules/autobase/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"blind-pairing\":\"/node_modules/blind-pairing/index.js\",\"debounceify\":\"/node_modules/debounceify/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/room/invitations.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"blind-pairing\":\"/node_modules/blind-pairing/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/room/mailbox.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"../identity\":\"/node_modules/@holepunchto/keet-core/lib/identity/index.js\",\"./chat\":\"/node_modules/@holepunchto/keet-core/lib/room/chat.js\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/room/members.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"parallel-transformx\":\"/node_modules/parallel-transformx/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/room/plugins.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"../identity/plugin.js\":\"/node_modules/@holepunchto/keet-core/lib/identity/plugin.js\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\",\"sub-encoder\":\"/node_modules/sub-encoder/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/room/private-mailbox.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\"},\"/node_modules/@holepunchto/keet-core/lib/room/reactions.js\":{\"#package\":\"/node_modules/@holepunchto/keet-core/package.json\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-core/package.json\":{},\"/node_modules/@holepunchto/keet-default-config/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-default-config/package.json\"},\"/node_modules/@holepunchto/keet-default-config/package.json\":{},\"/node_modules/@holepunchto/keet-identity-key/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-identity-key/package.json\",\"./lib/crypto\":\"/node_modules/@holepunchto/keet-identity-key/lib/crypto.js\",\"./lib/encoding\":\"/node_modules/@holepunchto/keet-identity-key/lib/encoding.js\",\"./lib/keychain\":\"/node_modules/@holepunchto/keet-identity-key/lib/keychain.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-identity-key/lib/crypto.js\":{\"#package\":\"/node_modules/@holepunchto/keet-identity-key/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/@holepunchto/keet-identity-key/lib/encoding.js\":{\"#package\":\"/node_modules/@holepunchto/keet-identity-key/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-identity-key/lib/keychain.js\":{\"#package\":\"/node_modules/@holepunchto/keet-identity-key/package.json\",\"./crypto\":\"/node_modules/@holepunchto/keet-identity-key/lib/crypto.js\",\"@holepunchto/bip39\":\"/node_modules/@holepunchto/bip39/index.js\",\"@holepunchto/hmac\":\"/node_modules/@holepunchto/hmac/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/@holepunchto/keet-identity-key/package.json\":{\"#package\":\"/node_modules/@holepunchto/keet-identity-key/package.json\"},\"/node_modules/@holepunchto/keet-indexing/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"./lib/chat\":\"/node_modules/@holepunchto/keet-indexing/lib/chat/index.js\",\"./lib/config\":\"/node_modules/@holepunchto/keet-indexing/lib/config/index.js\",\"./lib/devices\":\"/node_modules/@holepunchto/keet-indexing/lib/devices/index.js\",\"./lib/internal\":\"/node_modules/@holepunchto/keet-indexing/lib/internal/index.js\",\"./lib/invitations\":\"/node_modules/@holepunchto/keet-indexing/lib/invitations/index.js\",\"./lib/mailbox\":\"/node_modules/@holepunchto/keet-indexing/lib/mailbox/index.js\",\"./lib/members\":\"/node_modules/@holepunchto/keet-indexing/lib/members/index.js\",\"./lib/plugins\":\"/node_modules/@holepunchto/keet-indexing/lib/plugins/index.js\",\"./lib/private-profile\":\"/node_modules/@holepunchto/keet-indexing/lib/private-profile/index.js\",\"./lib/reactions\":\"/node_modules/@holepunchto/keet-indexing/lib/reactions/index.js\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"hyperbee\":\"/node_modules/hyperbee/index.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/chat/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/config/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/devices/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"../invitations\":\"/node_modules/@holepunchto/keet-indexing/lib/invitations/index.js\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"@holepunchto/keet-identity-key\":\"/node_modules/@holepunchto/keet-identity-key/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/internal/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/invitations/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"blind-pairing-core\":\"/node_modules/blind-pairing-core/index.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/mailbox/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/members/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"@holepunchto/keet-identity-key\":\"/node_modules/@holepunchto/keet-identity-key/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"tiny-buffer-map\":\"/node_modules/tiny-buffer-map/index.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/plugins/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"../../plugins/kv-store/apply.js\":\"/node_modules/@holepunchto/keet-indexing/plugins/kv-store/apply.js\",\"../../plugins/private-profile/apply.js\":\"/node_modules/@holepunchto/keet-indexing/plugins/private-profile/apply.js\",\"../../plugins/word-count/apply.js\":\"/node_modules/@holepunchto/keet-indexing/plugins/word-count/apply.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/private-profile/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"./private-devices\":\"/node_modules/@holepunchto/keet-indexing/lib/private-profile/private-devices.js\",\"./private-mailbox\":\"/node_modules/@holepunchto/keet-indexing/lib/private-profile/private-mailbox.js\",\"./private-rooms\":\"/node_modules/@holepunchto/keet-indexing/lib/private-profile/private-rooms.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/private-profile/private-devices.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/private-profile/private-mailbox.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/private-profile/private-rooms.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/@holepunchto/keet-indexing/lib/reactions/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/@holepunchto/keet-indexing/package.json\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\"},\"/node_modules/@holepunchto/keet-indexing/plugins/kv-store/apply.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"sub-encoder\":\"/node_modules/sub-encoder/index.js\"},\"/node_modules/@holepunchto/keet-indexing/plugins/private-profile/apply.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/hyperindex\":\"/node_modules/@holepunchto/hyperindex/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"sub-encoder\":\"/node_modules/sub-encoder/index.js\"},\"/node_modules/@holepunchto/keet-indexing/plugins/word-count/apply.js\":{\"#package\":\"/node_modules/@holepunchto/keet-indexing/package.json\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"sub-encoder\":\"/node_modules/sub-encoder/index.js\"},\"/node_modules/@holepunchto/keet-push/index.js\":{\"#package\":\"/node_modules/@holepunchto/keet-push/package.json\",\"./lib/encoding\":\"/node_modules/@holepunchto/keet-push/lib/encoding.js\",\"./lib/notifications\":\"/node_modules/@holepunchto/keet-push/lib/notifications.js\",\"@hyperswarm/rpc\":\"/node_modules/@hyperswarm/rpc/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\"},\"/node_modules/@holepunchto/keet-push/lib/encoding.js\":{\"#package\":\"/node_modules/@holepunchto/keet-push/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/@holepunchto/keet-push/lib/notifications.js\":{\"#package\":\"/node_modules/@holepunchto/keet-push/package.json\",\"./encoding\":\"/node_modules/@holepunchto/keet-push/lib/encoding.js\",\"@holepunchto/keet-core-api\":\"/node_modules/@holepunchto/keet-core-api/index.js\",\"@holepunchto/keet-core-schemas\":\"/node_modules/@holepunchto/keet-core-schemas/index.js\",\"autobase/lib/messages.js\":\"/node_modules/autobase/lib/messages.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"hypercore\":\"/node_modules/hypercore/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore/lib/block-encryption.js\":\"/node_modules/hypercore/lib/block-encryption.js\",\"hypercore/lib/messages.js\":\"/node_modules/hypercore/lib/messages.js\",\"path\":\"/node_modules/bare-path/index.js\",\"sodium-native\":\"/node_modules/sodium-native/index.js\"},\"/node_modules/@holepunchto/keet-push/package.json\":{\"#package\":\"/node_modules/@holepunchto/keet-push/package.json\"},\"/node_modules/@hyperswarm/rpc/index.js\":{\"#package\":\"/node_modules/@hyperswarm/rpc/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"hyperdht\":\"/node_modules/hyperdht/index.js\",\"protomux-rpc\":\"/node_modules/protomux-rpc/index.js\"},\"/node_modules/@hyperswarm/rpc/package.json\":{},\"/node_modules/@hyperswarm/secret-stream/index.js\":{\"#package\":\"/node_modules/@hyperswarm/secret-stream/package.json\",\"./lib/bridge\":\"/node_modules/@hyperswarm/secret-stream/lib/bridge.js\",\"./lib/handshake\":\"/node_modules/@hyperswarm/secret-stream/lib/handshake.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"sodium-secretstream\":\"/node_modules/sodium-secretstream/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\",\"streamx\":\"/node_modules/streamx/index.js\",\"timeout-refresh\":\"/node_modules/timeout-refresh/index.js\",\"unslab\":\"/node_modules/unslab/index.js\"},\"/node_modules/@hyperswarm/secret-stream/lib/bridge.js\":{\"#package\":\"/node_modules/@hyperswarm/secret-stream/package.json\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/@hyperswarm/secret-stream/lib/handshake.js\":{\"#package\":\"/node_modules/@hyperswarm/secret-stream/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"noise-curve-ed\":\"/node_modules/noise-curve-ed/index.js\",\"noise-handshake\":\"/node_modules/noise-handshake/noise.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/@hyperswarm/secret-stream/package.json\":{},\"/node_modules/autobase/index.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"./lib/active-writers\":\"/node_modules/autobase/lib/active-writers.js\",\"./lib/core-pool\":\"/node_modules/autobase/lib/core-pool.js\",\"./lib/extension\":\"/node_modules/autobase/lib/extension.js\",\"./lib/linearizer\":\"/node_modules/autobase/lib/linearizer.js\",\"./lib/messages\":\"/node_modules/autobase/lib/messages.js\",\"./lib/store\":\"/node_modules/autobase/lib/store.js\",\"./lib/system\":\"/node_modules/autobase/lib/system.js\",\"./lib/timer\":\"/node_modules/autobase/lib/timer.js\",\"./lib/wakeup\":\"/node_modules/autobase/lib/wakeup.js\",\"./lib/writer\":\"/node_modules/autobase/lib/writer.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"core-coupler\":\"/node_modules/core-coupler/index.js\",\"debounceify\":\"/node_modules/debounceify/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"mutexify/promise\":\"/node_modules/mutexify/promise.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"signal-promise\":\"/node_modules/signal-promise/index.js\"},\"/node_modules/autobase/lib/active-writers.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/autobase/lib/clock.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"tiny-buffer-map\":\"/node_modules/tiny-buffer-map/index.js\"},\"/node_modules/autobase/lib/consensus.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"./clock\":\"/node_modules/autobase/lib/clock.js\",\"tiny-buffer-map\":\"/node_modules/tiny-buffer-map/index.js\"},\"/node_modules/autobase/lib/core-pool.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/autobase/lib/core.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"./extension\":\"/node_modules/autobase/lib/extension.js\",\"./messages\":\"/node_modules/autobase/lib/messages.js\",\"./signer\":\"/node_modules/autobase/lib/signer.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"hypercore/errors\":\"/node_modules/hypercore/errors.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/autobase/lib/extension.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"./messages\":\"/node_modules/autobase/lib/messages.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/autobase/lib/linearizer.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"./clock\":\"/node_modules/autobase/lib/clock.js\",\"./consensus\":\"/node_modules/autobase/lib/consensus.js\",\"./topolist\":\"/node_modules/autobase/lib/topolist.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\"},\"/node_modules/autobase/lib/messages.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\"},\"/node_modules/autobase/lib/node-buffer.js\":{\"#package\":\"/node_modules/autobase/package.json\"},\"/node_modules/autobase/lib/signer.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"hypercore/lib/multisig.js\":\"/node_modules/hypercore/lib/multisig.js\"},\"/node_modules/autobase/lib/store.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"./core\":\"/node_modules/autobase/lib/core.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"hypercore\":\"/node_modules/hypercore/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\"},\"/node_modules/autobase/lib/system.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"./messages\":\"/node_modules/autobase/lib/messages.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"hyperbee\":\"/node_modules/hyperbee/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"sub-encoder\":\"/node_modules/sub-encoder/index.js\"},\"/node_modules/autobase/lib/timer.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/autobase/lib/topolist.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\"},\"/node_modules/autobase/lib/wakeup.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\"},\"/node_modules/autobase/lib/writer.js\":{\"#package\":\"/node_modules/autobase/package.json\",\"./linearizer\":\"/node_modules/autobase/lib/linearizer.js\",\"./node-buffer\":\"/node_modules/autobase/lib/node-buffer.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"signal-promise\":\"/node_modules/signal-promise/index.js\"},\"/node_modules/autobase/package.json\":{\"#package\":\"/node_modules/autobase/package.json\"},\"/node_modules/b4a/index.js\":{\"#package\":\"/node_modules/b4a/package.json\"},\"/node_modules/b4a/package.json\":{},\"/node_modules/bare-crypto/binding.js\":{\"#package\":\"/node_modules/bare-crypto/package.json\",\".\":{\"ios\":\"linked:bare-crypto.1.4.0.framework/bare-crypto.1.4.0\",\"android\":\"linked:libbare-crypto.1.4.0.so\"}},\"/node_modules/bare-crypto/index.js\":{\"#package\":\"/node_modules/bare-crypto/package.json\",\"./binding\":\"/node_modules/bare-crypto/binding.js\",\"./lib/constants\":\"/node_modules/bare-crypto/lib/constants.js\",\"./lib/errors\":\"/node_modules/bare-crypto/lib/errors.js\",\"./web\":\"/node_modules/bare-crypto/web.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-crypto/lib/constants.js\":{\"#package\":\"/node_modules/bare-crypto/package.json\",\"../binding\":\"/node_modules/bare-crypto/binding.js\"},\"/node_modules/bare-crypto/lib/errors.js\":{\"#package\":\"/node_modules/bare-crypto/package.json\"},\"/node_modules/bare-crypto/package.json\":{},\"/node_modules/bare-crypto/web.js\":{\"#package\":\"/node_modules/bare-crypto/package.json\",\".\":\"/node_modules/bare-crypto/index.js\"},\"/node_modules/bare-dns/binding.js\":{\"#package\":\"/node_modules/bare-dns/package.json\",\".\":{\"ios\":\"linked:bare-dns.1.0.5.framework/bare-dns.1.0.5\",\"android\":\"linked:libbare-dns.1.0.5.so\"}},\"/node_modules/bare-dns/index.js\":{\"#package\":\"/node_modules/bare-dns/package.json\",\"./binding\":\"/node_modules/bare-dns/binding.js\"},\"/node_modules/bare-dns/package.json\":{},\"/node_modules/bare-events/index.js\":{\"#package\":\"/node_modules/bare-events/package.json\",\"./lib/errors\":\"/node_modules/bare-events/lib/errors.js\"},\"/node_modules/bare-events/lib/errors.js\":{\"#package\":\"/node_modules/bare-events/package.json\"},\"/node_modules/bare-events/package.json\":{},\"/node_modules/bare-fs/binding.js\":{\"#package\":\"/node_modules/bare-fs/package.json\",\".\":{\"ios\":\"linked:bare-fs.4.0.1.framework/bare-fs.4.0.1\",\"android\":\"linked:libbare-fs.4.0.1.so\"}},\"/node_modules/bare-fs/index.js\":{\"#package\":\"/node_modules/bare-fs/package.json\",\"./binding\":\"/node_modules/bare-fs/binding.js\",\"bare-events\":\"/node_modules/bare-events/index.js\",\"bare-path\":\"/node_modules/bare-path/index.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-fs/package.json\":{},\"/node_modules/bare-http1/index.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./lib/agent\":\"/node_modules/bare-http1/lib/agent.js\",\"./lib/client-connection\":\"/node_modules/bare-http1/lib/client-connection.js\",\"./lib/client-request\":\"/node_modules/bare-http1/lib/client-request.js\",\"./lib/constants\":\"/node_modules/bare-http1/lib/constants.js\",\"./lib/incoming-message\":\"/node_modules/bare-http1/lib/incoming-message.js\",\"./lib/outgoing-message\":\"/node_modules/bare-http1/lib/outgoing-message.js\",\"./lib/server\":\"/node_modules/bare-http1/lib/server.js\",\"./lib/server-connection\":\"/node_modules/bare-http1/lib/server-connection.js\",\"./lib/server-response\":\"/node_modules/bare-http1/lib/server-response.js\"},\"/node_modules/bare-http1/lib/agent.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./client-connection\":\"/node_modules/bare-http1/lib/client-connection.js\",\"bare-tcp\":\"/node_modules/bare-tcp/index.js\"},\"/node_modules/bare-http1/lib/client-connection.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./constants\":\"/node_modules/bare-http1/lib/constants.js\",\"./errors\":\"/node_modules/bare-http1/lib/errors.js\",\"./incoming-message\":\"/node_modules/bare-http1/lib/incoming-message.js\"},\"/node_modules/bare-http1/lib/client-request.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./agent\":\"/node_modules/bare-http1/lib/agent.js\",\"./outgoing-message\":\"/node_modules/bare-http1/lib/outgoing-message.js\"},\"/node_modules/bare-http1/lib/constants.js\":{\"#package\":\"/node_modules/bare-http1/package.json\"},\"/node_modules/bare-http1/lib/errors.js\":{\"#package\":\"/node_modules/bare-http1/package.json\"},\"/node_modules/bare-http1/lib/incoming-message.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-http1/lib/outgoing-message.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./errors\":\"/node_modules/bare-http1/lib/errors.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-http1/lib/server-connection.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./constants\":\"/node_modules/bare-http1/lib/constants.js\",\"./incoming-message\":\"/node_modules/bare-http1/lib/incoming-message.js\",\"./server-response\":\"/node_modules/bare-http1/lib/server-response.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\",\"bare-tcp\":\"/node_modules/bare-tcp/index.js\"},\"/node_modules/bare-http1/lib/server-response.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./constants\":\"/node_modules/bare-http1/lib/constants.js\",\"./outgoing-message\":\"/node_modules/bare-http1/lib/outgoing-message.js\"},\"/node_modules/bare-http1/lib/server.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./server-connection\":\"/node_modules/bare-http1/lib/server-connection.js\",\"bare-tcp\":\"/node_modules/bare-tcp/index.js\"},\"/node_modules/bare-http1/package.json\":{},\"/node_modules/bare-https/index.js\":{\"#package\":\"/node_modules/bare-https/package.json\",\"bare-http1\":\"/node_modules/bare-http1/index.js\",\"bare-tcp\":\"/node_modules/bare-tcp/index.js\",\"bare-tls\":\"/node_modules/bare-tls/index.js\"},\"/node_modules/bare-https/package.json\":{},\"/node_modules/bare-inspector/binding.js\":{\"#package\":\"/node_modules/bare-inspector/package.json\",\".\":{\"ios\":\"linked:bare-inspector.3.0.2.framework/bare-inspector.3.0.2\",\"android\":\"linked:libbare-inspector.3.0.2.so\"}},\"/node_modules/bare-inspector/index.js\":{\"#package\":\"/node_modules/bare-inspector/package.json\",\"./lib/console\":\"/node_modules/bare-inspector/lib/console.js\",\"./lib/heap-snapshot\":\"/node_modules/bare-inspector/lib/heap-snapshot.js\",\"./lib/server\":\"/node_modules/bare-inspector/lib/server.js\",\"./lib/session\":\"/node_modules/bare-inspector/lib/session.js\"},\"/node_modules/bare-inspector/lib/console.js\":{\"#package\":\"/node_modules/bare-inspector/package.json\",\"../binding\":\"/node_modules/bare-inspector/binding.js\"},\"/node_modules/bare-inspector/lib/constants.js\":{\"#package\":\"/node_modules/bare-inspector/package.json\"},\"/node_modules/bare-inspector/lib/heap-snapshot.js\":{\"#package\":\"/node_modules/bare-inspector/package.json\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-inspector/lib/server.js\":{\"#package\":\"/node_modules/bare-inspector/package.json\",\"./session\":\"/node_modules/bare-inspector/lib/session.js\",\"bare-events\":\"/node_modules/bare-events/index.js\",\"bare-http1\":\"/node_modules/bare-http1/index.js\",\"bare-url\":\"/node_modules/bare-url/index.js\",\"bare-ws\":\"/node_modules/bare-ws/index.js\"},\"/node_modules/bare-inspector/lib/session.js\":{\"#package\":\"/node_modules/bare-inspector/package.json\",\"../binding\":\"/node_modules/bare-inspector/binding.js\",\"./constants\":\"/node_modules/bare-inspector/lib/constants.js\",\"bare-events\":\"/node_modules/bare-events/index.js\"},\"/node_modules/bare-inspector/package.json\":{},\"/node_modules/bare-os/binding.js\":{\"#package\":\"/node_modules/bare-os/package.json\",\".\":{\"ios\":\"linked:bare-os.3.4.0.framework/bare-os.3.4.0\",\"android\":\"linked:libbare-os.3.4.0.so\"}},\"/node_modules/bare-os/index.js\":{\"#package\":\"/node_modules/bare-os/package.json\",\"./binding\":\"/node_modules/bare-os/binding.js\",\"./lib/constants\":\"/node_modules/bare-os/lib/constants.js\",\"./lib/errors\":\"/node_modules/bare-os/lib/errors.js\"},\"/node_modules/bare-os/lib/constants.js\":{\"#package\":\"/node_modules/bare-os/package.json\",\"../binding\":\"/node_modules/bare-os/binding.js\"},\"/node_modules/bare-os/lib/errors.js\":{\"#package\":\"/node_modules/bare-os/package.json\"},\"/node_modules/bare-os/package.json\":{},\"/node_modules/bare-path/index.js\":{\"#package\":\"/node_modules/bare-path/package.json\",\"./lib/posix\":\"/node_modules/bare-path/lib/posix.js\",\"./lib/win32\":\"/node_modules/bare-path/lib/win32.js\"},\"/node_modules/bare-path/lib/constants.js\":{\"#package\":\"/node_modules/bare-path/package.json\"},\"/node_modules/bare-path/lib/posix.js\":{\"#package\":\"/node_modules/bare-path/package.json\",\"./constants\":\"/node_modules/bare-path/lib/constants.js\",\"./shared\":\"/node_modules/bare-path/lib/shared.js\",\"./win32\":\"/node_modules/bare-path/lib/win32.js\",\"bare-os\":\"/node_modules/bare-os/index.js\"},\"/node_modules/bare-path/lib/shared.js\":{\"#package\":\"/node_modules/bare-path/package.json\",\"./constants\":\"/node_modules/bare-path/lib/constants.js\"},\"/node_modules/bare-path/lib/win32.js\":{\"#package\":\"/node_modules/bare-path/package.json\",\"./constants\":\"/node_modules/bare-path/lib/constants.js\",\"./posix\":\"/node_modules/bare-path/lib/posix.js\",\"./shared\":\"/node_modules/bare-path/lib/shared.js\",\"bare-os\":\"/node_modules/bare-os/index.js\"},\"/node_modules/bare-path/package.json\":{},\"/node_modules/bare-stream/index.js\":{\"#package\":\"/node_modules/bare-stream/package.json\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/bare-stream/package.json\":{},\"/node_modules/bare-tcp/binding.js\":{\"#package\":\"/node_modules/bare-tcp/package.json\",\".\":{\"ios\":\"linked:bare-tcp.1.9.1.framework/bare-tcp.1.9.1\",\"android\":\"linked:libbare-tcp.1.9.1.so\"}},\"/node_modules/bare-tcp/index.js\":{\"#package\":\"/node_modules/bare-tcp/package.json\",\"./binding\":\"/node_modules/bare-tcp/binding.js\",\"./lib/constants\":\"/node_modules/bare-tcp/lib/constants.js\",\"./lib/errors\":\"/node_modules/bare-tcp/lib/errors.js\",\"./lib/ip\":\"/node_modules/bare-tcp/lib/ip.js\",\"bare-dns\":\"/node_modules/bare-dns/index.js\",\"bare-events\":\"/node_modules/bare-events/index.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-tcp/lib/constants.js\":{\"#package\":\"/node_modules/bare-tcp/package.json\"},\"/node_modules/bare-tcp/lib/errors.js\":{\"#package\":\"/node_modules/bare-tcp/package.json\"},\"/node_modules/bare-tcp/lib/ip.js\":{\"#package\":\"/node_modules/bare-tcp/package.json\"},\"/node_modules/bare-tcp/package.json\":{},\"/node_modules/bare-tls/binding.js\":{\"#package\":\"/node_modules/bare-tls/package.json\",\".\":{\"ios\":\"linked:bare-tls.1.2.1.framework/bare-tls.1.2.1\",\"android\":\"linked:libbare-tls.1.2.1.so\"}},\"/node_modules/bare-tls/index.js\":{\"#package\":\"/node_modules/bare-tls/package.json\",\"./binding\":\"/node_modules/bare-tls/binding.js\",\"./lib/constants\":\"/node_modules/bare-tls/lib/constants.js\",\"./lib/errors\":\"/node_modules/bare-tls/lib/errors.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-tls/lib/constants.js\":{\"#package\":\"/node_modules/bare-tls/package.json\"},\"/node_modules/bare-tls/lib/errors.js\":{\"#package\":\"/node_modules/bare-tls/package.json\"},\"/node_modules/bare-tls/package.json\":{},\"/node_modules/bare-url/binding.js\":{\"#package\":\"/node_modules/bare-url/package.json\",\".\":{\"ios\":\"linked:bare-url.2.1.3.framework/bare-url.2.1.3\",\"android\":\"linked:libbare-url.2.1.3.so\"}},\"/node_modules/bare-url/index.js\":{\"#package\":\"/node_modules/bare-url/package.json\",\"./binding\":\"/node_modules/bare-url/binding.js\",\"./lib/errors\":\"/node_modules/bare-url/lib/errors.js\",\"bare-path\":\"/node_modules/bare-path/index.js\"},\"/node_modules/bare-url/lib/errors.js\":{\"#package\":\"/node_modules/bare-url/package.json\"},\"/node_modules/bare-url/package.json\":{},\"/node_modules/bare-ws/index.js\":{\"#package\":\"/node_modules/bare-ws/package.json\",\"./lib/server\":\"/node_modules/bare-ws/lib/server.js\",\"./lib/socket\":\"/node_modules/bare-ws/lib/socket.js\"},\"/node_modules/bare-ws/lib/constants.js\":{\"#package\":\"/node_modules/bare-ws/package.json\"},\"/node_modules/bare-ws/lib/errors.js\":{\"#package\":\"/node_modules/bare-ws/package.json\",\"./constants\":\"/node_modules/bare-ws/lib/constants.js\"},\"/node_modules/bare-ws/lib/frame.js\":{\"#package\":\"/node_modules/bare-ws/package.json\",\"./errors\":\"/node_modules/bare-ws/lib/errors.js\",\"bare-crypto\":\"/node_modules/bare-crypto/index.js\"},\"/node_modules/bare-ws/lib/server.js\":{\"#package\":\"/node_modules/bare-ws/package.json\",\"./constants\":\"/node_modules/bare-ws/lib/constants.js\",\"./errors\":\"/node_modules/bare-ws/lib/errors.js\",\"./socket\":\"/node_modules/bare-ws/lib/socket.js\",\"bare-crypto\":\"/node_modules/bare-crypto/index.js\",\"bare-events\":\"/node_modules/bare-events/index.js\",\"bare-http1\":\"/node_modules/bare-http1/index.js\",\"bare-https\":\"/node_modules/bare-https/index.js\"},\"/node_modules/bare-ws/lib/socket.js\":{\"#package\":\"/node_modules/bare-ws/package.json\",\"./constants\":\"/node_modules/bare-ws/lib/constants.js\",\"./errors\":\"/node_modules/bare-ws/lib/errors.js\",\"./frame\":\"/node_modules/bare-ws/lib/frame.js\",\"bare-crypto\":\"/node_modules/bare-crypto/index.js\",\"bare-http1\":\"/node_modules/bare-http1/index.js\",\"bare-https\":\"/node_modules/bare-https/index.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-ws/package.json\":{},\"/node_modules/big-sparse-array/index.js\":{\"#package\":\"/node_modules/big-sparse-array/package.json\"},\"/node_modules/big-sparse-array/package.json\":{},\"/node_modules/binary-stream-equals/index.js\":{\"#package\":\"/node_modules/binary-stream-equals/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/binary-stream-equals/package.json\":{},\"/node_modules/bits-to-bytes/index.js\":{\"#package\":\"/node_modules/bits-to-bytes/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/bits-to-bytes/package.json\":{},\"/node_modules/blind-pairing-core/index.js\":{\"#package\":\"/node_modules/blind-pairing-core/package.json\",\"./lib/errors\":\"/node_modules/blind-pairing-core/lib/errors.js\",\"./lib/messages\":\"/node_modules/blind-pairing-core/lib/messages.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/blind-pairing-core/lib/errors.js\":{\"#package\":\"/node_modules/blind-pairing-core/package.json\"},\"/node_modules/blind-pairing-core/lib/messages.js\":{\"#package\":\"/node_modules/blind-pairing-core/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/blind-pairing-core/package.json\":{},\"/node_modules/blind-pairing/index.js\":{\"#package\":\"/node_modules/blind-pairing/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"blind-pairing-core\":\"/node_modules/blind-pairing-core/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"debounceify\":\"/node_modules/debounceify/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"is-options\":\"/node_modules/is-options/index.js\",\"protomux\":\"/node_modules/protomux/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"xache\":\"/node_modules/xache/index.js\"},\"/node_modules/blind-pairing/package.json\":{\"#package\":\"/node_modules/blind-pairing/package.json\"},\"/node_modules/blind-relay/index.js\":{\"#package\":\"/node_modules/blind-relay/package.json\",\"./lib/errors\":\"/node_modules/blind-relay/lib/errors.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"bits-to-bytes\":\"/node_modules/bits-to-bytes/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"compact-encoding-bitfield\":\"/node_modules/compact-encoding-bitfield/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"hypertrace\":\"/node_modules/hypertrace/index.js\",\"protomux\":\"/node_modules/protomux/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/blind-relay/lib/errors.js\":{\"#package\":\"/node_modules/blind-relay/package.json\"},\"/node_modules/blind-relay/package.json\":{},\"/node_modules/bogon/index.js\":{\"#package\":\"/node_modules/bogon/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"compact-encoding-net\":\"/node_modules/compact-encoding-net/index.js\"},\"/node_modules/bogon/package.json\":{},\"/node_modules/codecs/index.js\":{\"#package\":\"/node_modules/codecs/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/codecs/package.json\":{},\"/node_modules/compact-encoding-bitfield/index.js\":{\"#package\":\"/node_modules/compact-encoding-bitfield/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/compact-encoding-bitfield/package.json\":{},\"/node_modules/compact-encoding-net/index.js\":{\"#package\":\"/node_modules/compact-encoding-net/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/compact-encoding-net/package.json\":{},\"/node_modules/compact-encoding/endian.js\":{\"#package\":\"/node_modules/compact-encoding/package.json\"},\"/node_modules/compact-encoding/index.js\":{\"#package\":\"/node_modules/compact-encoding/package.json\",\"./endian\":\"/node_modules/compact-encoding/endian.js\",\"./lexint\":\"/node_modules/compact-encoding/lexint.js\",\"./raw\":\"/node_modules/compact-encoding/raw.js\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/compact-encoding/lexint.js\":{\"#package\":\"/node_modules/compact-encoding/package.json\"},\"/node_modules/compact-encoding/package.json\":{},\"/node_modules/compact-encoding/raw.js\":{\"#package\":\"/node_modules/compact-encoding/package.json\",\"./endian\":\"/node_modules/compact-encoding/endian.js\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/core-coupler/index.js\":{\"#package\":\"/node_modules/core-coupler/package.json\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/core-coupler/package.json\":{},\"/node_modules/corestore/index.js\":{\"#package\":\"/node_modules/corestore/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"hypercore\":\"/node_modules/hypercore/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"read-write-mutexify\":\"/node_modules/read-write-mutexify/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\",\"xache\":\"/node_modules/xache/index.js\"},\"/node_modules/corestore/package.json\":{},\"/node_modules/crc-native/binding.js\":{\"#package\":\"/node_modules/crc-native/package.json\",\"node-gyp-build\":\"/node_modules/node-gyp-build/index.js\"},\"/node_modules/crc-native/index.js\":{\"#package\":\"/node_modules/crc-native/package.json\",\"./binding\":\"/node_modules/crc-native/binding.js\"},\"/node_modules/crc-native/package.json\":{},\"/node_modules/crc-universal/fallback.js\":{\"#package\":\"/node_modules/crc-universal/package.json\",\"./lookup\":\"/node_modules/crc-universal/lookup.js\"},\"/node_modules/crc-universal/index.js\":{\"#package\":\"/node_modules/crc-universal/package.json\",\"./fallback\":\"/node_modules/crc-universal/fallback.js\",\"crc-native\":\"/node_modules/crc-native/index.js\"},\"/node_modules/crc-universal/lookup.js\":{\"#package\":\"/node_modules/crc-universal/package.json\"},\"/node_modules/crc-universal/package.json\":{},\"/node_modules/debounceify/index.js\":{\"#package\":\"/node_modules/debounceify/package.json\"},\"/node_modules/debounceify/package.json\":{},\"/node_modules/dht-rpc/index.js\":{\"#package\":\"/node_modules/dht-rpc/package.json\",\"./lib/commands\":\"/node_modules/dht-rpc/lib/commands.js\",\"./lib/errors\":\"/node_modules/dht-rpc/lib/errors.js\",\"./lib/io\":\"/node_modules/dht-rpc/lib/io.js\",\"./lib/peer\":\"/node_modules/dht-rpc/lib/peer.js\",\"./lib/query\":\"/node_modules/dht-rpc/lib/query.js\",\"./lib/session\":\"/node_modules/dht-rpc/lib/session.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"kademlia-routing-table\":\"/node_modules/kademlia-routing-table/index.js\",\"nat-sampler\":\"/node_modules/nat-sampler/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\",\"time-ordered-set\":\"/node_modules/time-ordered-set/index.js\",\"udx-native\":\"/node_modules/udx-native/lib/udx.js\"},\"/node_modules/dht-rpc/lib/commands.js\":{\"#package\":\"/node_modules/dht-rpc/package.json\"},\"/node_modules/dht-rpc/lib/errors.js\":{\"#package\":\"/node_modules/dht-rpc/package.json\"},\"/node_modules/dht-rpc/lib/io.js\":{\"#package\":\"/node_modules/dht-rpc/package.json\",\"./errors\":\"/node_modules/dht-rpc/lib/errors.js\",\"./peer\":\"/node_modules/dht-rpc/lib/peer.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"fast-fifo\":\"/node_modules/fast-fifo/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/dht-rpc/lib/peer.js\":{\"#package\":\"/node_modules/dht-rpc/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"compact-encoding-net\":\"/node_modules/compact-encoding-net/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/dht-rpc/lib/query.js\":{\"#package\":\"/node_modules/dht-rpc/package.json\",\"./commands\":\"/node_modules/dht-rpc/lib/commands.js\",\"./peer\":\"/node_modules/dht-rpc/lib/peer.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/dht-rpc/lib/session.js\":{\"#package\":\"/node_modules/dht-rpc/package.json\"},\"/node_modules/dht-rpc/package.json\":{},\"/node_modules/fast-fifo/fixed-size.js\":{\"#package\":\"/node_modules/fast-fifo/package.json\"},\"/node_modules/fast-fifo/index.js\":{\"#package\":\"/node_modules/fast-fifo/package.json\",\"./fixed-size\":\"/node_modules/fast-fifo/fixed-size.js\"},\"/node_modules/fast-fifo/package.json\":{},\"/node_modules/flat-tree/index.js\":{\"#package\":\"/node_modules/flat-tree/package.json\"},\"/node_modules/flat-tree/package.json\":{},\"/node_modules/fs-native-extensions/binding.js\":{\"#package\":\"/node_modules/fs-native-extensions/package.json\",\"node-gyp-build\":\"/node_modules/node-gyp-build/index.js\"},\"/node_modules/fs-native-extensions/index.js\":{\"#package\":\"/node_modules/fs-native-extensions/package.json\",\"./binding\":\"/node_modules/fs-native-extensions/binding.js\",\"which-runtime\":\"/node_modules/which-runtime/index.js\"},\"/node_modules/fs-native-extensions/package.json\":{},\"/node_modules/get-mime-type/index.js\":{\"#package\":\"/node_modules/get-mime-type/package.json\"},\"/node_modules/get-mime-type/package.json\":{},\"/node_modules/hyperbee-diff-stream/index.js\":{\"#package\":\"/node_modules/hyperbee-diff-stream/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"codecs\":\"/node_modules/codecs/index.js\",\"sorted-union-stream\":\"/node_modules/sorted-union-stream/index.js\"},\"/node_modules/hyperbee-diff-stream/package.json\":{},\"/node_modules/hyperbee/index.js\":{\"#package\":\"/node_modules/hyperbee/package.json\",\"./iterators/diff\":\"/node_modules/hyperbee/iterators/diff.js\",\"./iterators/history\":\"/node_modules/hyperbee/iterators/history.js\",\"./iterators/range\":\"/node_modules/hyperbee/iterators/range.js\",\"./lib/extension\":\"/node_modules/hyperbee/lib/extension.js\",\"./lib/messages\":\"/node_modules/hyperbee/lib/messages.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"codecs\":\"/node_modules/codecs/index.js\",\"debounceify\":\"/node_modules/debounceify/index.js\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\",\"mutexify/promise\":\"/node_modules/mutexify/promise.js\",\"rache\":\"/node_modules/rache/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\",\"unslab\":\"/node_modules/unslab/index.js\"},\"/node_modules/hyperbee/iterators/diff.js\":{\"#package\":\"/node_modules/hyperbee/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/hyperbee/iterators/history.js\":{\"#package\":\"/node_modules/hyperbee/package.json\"},\"/node_modules/hyperbee/iterators/range.js\":{\"#package\":\"/node_modules/hyperbee/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/hyperbee/lib/extension.js\":{\"#package\":\"/node_modules/hyperbee/package.json\",\"./messages\":\"/node_modules/hyperbee/lib/messages.js\"},\"/node_modules/hyperbee/lib/messages.js\":{\"#package\":\"/node_modules/hyperbee/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"protocol-buffers-encodings\":\"/node_modules/protocol-buffers-encodings/index.js\"},\"/node_modules/hyperbee/package.json\":{},\"/node_modules/hyperblobs/index.js\":{\"#package\":\"/node_modules/hyperblobs/package.json\",\"./lib/monitor\":\"/node_modules/hyperblobs/lib/monitor.js\",\"./lib/streams\":\"/node_modules/hyperblobs/lib/streams.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"mutexify\":\"/node_modules/mutexify/index.js\"},\"/node_modules/hyperblobs/lib/monitor.js\":{\"#package\":\"/node_modules/hyperblobs/package.json\",\"events\":\"/node_modules/bare-events/index.js\",\"speedometer\":\"/node_modules/speedometer/index.js\"},\"/node_modules/hyperblobs/lib/prefetcher.js\":{\"#package\":\"/node_modules/hyperblobs/package.json\"},\"/node_modules/hyperblobs/lib/streams.js\":{\"#package\":\"/node_modules/hyperblobs/package.json\",\"./prefetcher\":\"/node_modules/hyperblobs/lib/prefetcher.js\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/hyperblobs/package.json\":{},\"/node_modules/hypercore-crypto/index.js\":{\"#package\":\"/node_modules/hypercore-crypto/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/hypercore-crypto/package.json\":{},\"/node_modules/hypercore-errors/index.js\":{\"#package\":\"/node_modules/hypercore-errors/package.json\"},\"/node_modules/hypercore-errors/package.json\":{},\"/node_modules/hypercore-id-encoding/index.js\":{\"#package\":\"/node_modules/hypercore-id-encoding/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"z32\":\"/node_modules/z32/index.js\"},\"/node_modules/hypercore-id-encoding/package.json\":{},\"/node_modules/hypercore/errors.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\"},\"/node_modules/hypercore/index.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"./lib/batch\":\"/node_modules/hypercore/lib/batch.js\",\"./lib/block-encryption\":\"/node_modules/hypercore/lib/block-encryption.js\",\"./lib/core\":\"/node_modules/hypercore/lib/core.js\",\"./lib/download\":\"/node_modules/hypercore/lib/download.js\",\"./lib/info\":\"/node_modules/hypercore/lib/info.js\",\"./lib/replicator\":\"/node_modules/hypercore/lib/replicator.js\",\"./lib/streams\":\"/node_modules/hypercore/lib/streams.js\",\"./lib/verifier\":\"/node_modules/hypercore/lib/verifier.js\",\"@hyperswarm/secret-stream\":\"/node_modules/@hyperswarm/secret-stream/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"is-options\":\"/node_modules/is-options/index.js\",\"protomux\":\"/node_modules/protomux/index.js\",\"random-access-file\":\"/node_modules/random-access-file/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"unslab\":\"/node_modules/unslab/index.js\",\"xache\":\"/node_modules/xache/index.js\",\"z32\":\"/node_modules/z32/index.js\"},\"/node_modules/hypercore/lib/audit.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"flat-tree\":\"/node_modules/flat-tree/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\"},\"/node_modules/hypercore/lib/batch.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/hypercore/lib/big-header.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"./messages\":\"/node_modules/hypercore/lib/messages.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/hypercore/lib/bitfield.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"./compat\":\"/node_modules/hypercore/lib/compat.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"big-sparse-array\":\"/node_modules/big-sparse-array/index.js\"},\"/node_modules/hypercore/lib/block-encryption.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"./caps\":\"/node_modules/hypercore/lib/caps.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/hypercore/lib/block-store.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\"},\"/node_modules/hypercore/lib/caps.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/hypercore/lib/compat.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"quickbit-universal\":\"/node_modules/quickbit-universal/index.js\",\"quickbit-universal/fallback\":\"/node_modules/quickbit-universal/fallback.js\"},\"/node_modules/hypercore/lib/core.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"./audit\":\"/node_modules/hypercore/lib/audit.js\",\"./big-header\":\"/node_modules/hypercore/lib/big-header.js\",\"./bitfield\":\"/node_modules/hypercore/lib/bitfield.js\",\"./block-store\":\"/node_modules/hypercore/lib/block-store.js\",\"./info\":\"/node_modules/hypercore/lib/info.js\",\"./merkle-tree\":\"/node_modules/hypercore/lib/merkle-tree.js\",\"./messages\":\"/node_modules/hypercore/lib/messages.js\",\"./mutex\":\"/node_modules/hypercore/lib/mutex.js\",\"./oplog\":\"/node_modules/hypercore/lib/oplog.js\",\"./remote-bitfield\":\"/node_modules/hypercore/lib/remote-bitfield.js\",\"./verifier\":\"/node_modules/hypercore/lib/verifier.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\",\"unslab\":\"/node_modules/unslab/index.js\"},\"/node_modules/hypercore/lib/download.js\":{\"#package\":\"/node_modules/hypercore/package.json\"},\"/node_modules/hypercore/lib/hotswap-queue.js\":{\"#package\":\"/node_modules/hypercore/package.json\"},\"/node_modules/hypercore/lib/info.js\":{\"#package\":\"/node_modules/hypercore/package.json\"},\"/node_modules/hypercore/lib/merkle-tree.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"./caps\":\"/node_modules/hypercore/lib/caps.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"flat-tree\":\"/node_modules/flat-tree/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\",\"unslab\":\"/node_modules/unslab/index.js\",\"xache\":\"/node_modules/xache/index.js\"},\"/node_modules/hypercore/lib/messages.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"./caps\":\"/node_modules/hypercore/lib/caps.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\",\"unslab\":\"/node_modules/unslab/index.js\"},\"/node_modules/hypercore/lib/multisig.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"./messages\":\"/node_modules/hypercore/lib/messages.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"flat-tree\":\"/node_modules/flat-tree/index.js\"},\"/node_modules/hypercore/lib/mutex.js\":{\"#package\":\"/node_modules/hypercore/package.json\"},\"/node_modules/hypercore/lib/oplog.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"crc-universal\":\"/node_modules/crc-universal/index.js\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\"},\"/node_modules/hypercore/lib/receiver-queue.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"fast-fifo\":\"/node_modules/fast-fifo/index.js\"},\"/node_modules/hypercore/lib/remote-bitfield.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"./compat\":\"/node_modules/hypercore/lib/compat.js\",\"big-sparse-array\":\"/node_modules/big-sparse-array/index.js\"},\"/node_modules/hypercore/lib/replicator.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"./caps\":\"/node_modules/hypercore/lib/caps.js\",\"./hotswap-queue\":\"/node_modules/hypercore/lib/hotswap-queue.js\",\"./messages\":\"/node_modules/hypercore/lib/messages.js\",\"./receiver-queue\":\"/node_modules/hypercore/lib/receiver-queue.js\",\"./remote-bitfield\":\"/node_modules/hypercore/lib/remote-bitfield.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"flat-tree\":\"/node_modules/flat-tree/index.js\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\",\"random-array-iterator\":\"/node_modules/random-array-iterator/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/hypercore/lib/streams.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/hypercore/lib/verifier.js\":{\"#package\":\"/node_modules/hypercore/package.json\",\"./caps\":\"/node_modules/hypercore/lib/caps.js\",\"./messages\":\"/node_modules/hypercore/lib/messages.js\",\"./multisig\":\"/node_modules/hypercore/lib/multisig.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"flat-tree\":\"/node_modules/flat-tree/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\",\"unslab\":\"/node_modules/unslab/index.js\"},\"/node_modules/hypercore/package.json\":{},\"/node_modules/hyperdht/index.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"./lib/connect\":\"/node_modules/hyperdht/lib/connect.js\",\"./lib/connection-pool\":\"/node_modules/hyperdht/lib/connection-pool.js\",\"./lib/constants\":\"/node_modules/hyperdht/lib/constants.js\",\"./lib/crypto\":\"/node_modules/hyperdht/lib/crypto.js\",\"./lib/errors\":\"/node_modules/hyperdht/lib/errors.js\",\"./lib/messages\":\"/node_modules/hyperdht/lib/messages.js\",\"./lib/persistent\":\"/node_modules/hyperdht/lib/persistent.js\",\"./lib/raw-stream-set\":\"/node_modules/hyperdht/lib/raw-stream-set.js\",\"./lib/router\":\"/node_modules/hyperdht/lib/router.js\",\"./lib/server\":\"/node_modules/hyperdht/lib/server.js\",\"./lib/socket-pool\":\"/node_modules/hyperdht/lib/socket-pool.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"dht-rpc\":\"/node_modules/dht-rpc/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/hyperdht/lib/announcer.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"./constants\":\"/node_modules/hyperdht/lib/constants.js\",\"./encode\":\"/node_modules/hyperdht/lib/encode.js\",\"./messages\":\"/node_modules/hyperdht/lib/messages.js\",\"./persistent\":\"/node_modules/hyperdht/lib/persistent.js\",\"./sleeper\":\"/node_modules/hyperdht/lib/sleeper.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"signal-promise\":\"/node_modules/signal-promise/index.js\"},\"/node_modules/hyperdht/lib/connect.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"./constants\":\"/node_modules/hyperdht/lib/constants.js\",\"./crypto\":\"/node_modules/hyperdht/lib/crypto.js\",\"./errors\":\"/node_modules/hyperdht/lib/errors.js\",\"./holepuncher\":\"/node_modules/hyperdht/lib/holepuncher.js\",\"./noise-wrap\":\"/node_modules/hyperdht/lib/noise-wrap.js\",\"./secure-payload\":\"/node_modules/hyperdht/lib/secure-payload.js\",\"./semaphore\":\"/node_modules/hyperdht/lib/semaphore.js\",\"./sleeper\":\"/node_modules/hyperdht/lib/sleeper.js\",\"@hyperswarm/secret-stream\":\"/node_modules/@hyperswarm/secret-stream/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"blind-relay\":\"/node_modules/blind-relay/index.js\",\"bogon\":\"/node_modules/bogon/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"unslab\":\"/node_modules/unslab/index.js\"},\"/node_modules/hyperdht/lib/connection-pool.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"./errors\":\"/node_modules/hyperdht/lib/errors.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"events\":\"/node_modules/bare-events/index.js\"},\"/node_modules/hyperdht/lib/constants.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\"},\"/node_modules/hyperdht/lib/crypto.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/hyperdht/lib/encode.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/hyperdht/lib/errors.js\":{\"#package\":\"/node_modules/hyperdht/package.json\"},\"/node_modules/hyperdht/lib/holepuncher.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"./constants\":\"/node_modules/hyperdht/lib/constants.js\",\"./nat\":\"/node_modules/hyperdht/lib/nat.js\",\"./sleeper\":\"/node_modules/hyperdht/lib/sleeper.js\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/hyperdht/lib/messages.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"compact-encoding-net\":\"/node_modules/compact-encoding-net/index.js\"},\"/node_modules/hyperdht/lib/nat.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"../lib/constants\":\"/node_modules/hyperdht/lib/constants.js\"},\"/node_modules/hyperdht/lib/noise-wrap.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"./constants\":\"/node_modules/hyperdht/lib/constants.js\",\"./errors\":\"/node_modules/hyperdht/lib/errors.js\",\"./messages\":\"/node_modules/hyperdht/lib/messages.js\",\"@hyperswarm/secret-stream\":\"/node_modules/@hyperswarm/secret-stream/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"noise-curve-ed\":\"/node_modules/noise-curve-ed/index.js\",\"noise-handshake\":\"/node_modules/noise-handshake/noise.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/hyperdht/lib/persistent.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"./constants\":\"/node_modules/hyperdht/lib/constants.js\",\"./encode\":\"/node_modules/hyperdht/lib/encode.js\",\"./messages\":\"/node_modules/hyperdht/lib/messages.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"record-cache\":\"/node_modules/record-cache/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\",\"unslab\":\"/node_modules/unslab/index.js\",\"xache\":\"/node_modules/xache/index.js\"},\"/node_modules/hyperdht/lib/raw-stream-set.js\":{\"#package\":\"/node_modules/hyperdht/package.json\"},\"/node_modules/hyperdht/lib/router.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"./constants\":\"/node_modules/hyperdht/lib/constants.js\",\"./errors\":\"/node_modules/hyperdht/lib/errors.js\",\"./messages\":\"/node_modules/hyperdht/lib/messages.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"xache\":\"/node_modules/xache/index.js\"},\"/node_modules/hyperdht/lib/secure-payload.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"./messages\":\"/node_modules/hyperdht/lib/messages.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/hyperdht/lib/semaphore.js\":{\"#package\":\"/node_modules/hyperdht/package.json\"},\"/node_modules/hyperdht/lib/server.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"./announcer\":\"/node_modules/hyperdht/lib/announcer.js\",\"./constants\":\"/node_modules/hyperdht/lib/constants.js\",\"./crypto\":\"/node_modules/hyperdht/lib/crypto.js\",\"./errors\":\"/node_modules/hyperdht/lib/errors.js\",\"./holepuncher\":\"/node_modules/hyperdht/lib/holepuncher.js\",\"./noise-wrap\":\"/node_modules/hyperdht/lib/noise-wrap.js\",\"./secure-payload\":\"/node_modules/hyperdht/lib/secure-payload.js\",\"@hyperswarm/secret-stream\":\"/node_modules/@hyperswarm/secret-stream/index.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"blind-relay\":\"/node_modules/blind-relay/index.js\",\"bogon\":\"/node_modules/bogon/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/hyperdht/lib/sleeper.js\":{\"#package\":\"/node_modules/hyperdht/package.json\"},\"/node_modules/hyperdht/lib/socket-pool.js\":{\"#package\":\"/node_modules/hyperdht/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/hyperdht/package.json\":{\"#package\":\"/node_modules/hyperdht/package.json\"},\"/node_modules/hyperdrive/index.js\":{\"#package\":\"/node_modules/hyperdrive/package.json\",\"./lib/monitor\":\"/node_modules/hyperdrive/lib/monitor.js\",\"hyperbee\":\"/node_modules/hyperbee/index.js\",\"hyperblobs\":\"/node_modules/hyperblobs/index.js\",\"hypercore\":\"/node_modules/hypercore/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore-errors\":\"/node_modules/hypercore-errors/index.js\",\"is-options\":\"/node_modules/is-options/index.js\",\"mirror-drive\":\"/node_modules/mirror-drive/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\",\"sub-encoder\":\"/node_modules/sub-encoder/index.js\",\"unix-path-resolve\":\"/node_modules/unix-path-resolve/index.js\"},\"/node_modules/hyperdrive/lib/monitor.js\":{\"#package\":\"/node_modules/hyperdrive/package.json\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"speedometer\":\"/node_modules/speedometer/index.js\"},\"/node_modules/hyperdrive/package.json\":{\"#package\":\"/node_modules/hyperdrive/package.json\"},\"/node_modules/hyperswarm/index.js\":{\"#package\":\"/node_modules/hyperswarm/package.json\",\"./lib/connection-set\":\"/node_modules/hyperswarm/lib/connection-set.js\",\"./lib/peer-discovery\":\"/node_modules/hyperswarm/lib/peer-discovery.js\",\"./lib/peer-info\":\"/node_modules/hyperswarm/lib/peer-info.js\",\"./lib/retry-timer\":\"/node_modules/hyperswarm/lib/retry-timer.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"hyperdht\":\"/node_modules/hyperdht/index.js\",\"shuffled-priority-queue\":\"/node_modules/shuffled-priority-queue/index.js\",\"unslab\":\"/node_modules/unslab/index.js\"},\"/node_modules/hyperswarm/lib/bulk-timer.js\":{\"#package\":\"/node_modules/hyperswarm/package.json\"},\"/node_modules/hyperswarm/lib/connection-set.js\":{\"#package\":\"/node_modules/hyperswarm/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/hyperswarm/lib/peer-discovery.js\":{\"#package\":\"/node_modules/hyperswarm/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/hyperswarm/lib/peer-info.js\":{\"#package\":\"/node_modules/hyperswarm/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"unslab\":\"/node_modules/unslab/index.js\"},\"/node_modules/hyperswarm/lib/retry-timer.js\":{\"#package\":\"/node_modules/hyperswarm/package.json\",\"./bulk-timer\":\"/node_modules/hyperswarm/lib/bulk-timer.js\"},\"/node_modules/hyperswarm/package.json\":{},\"/node_modules/hypertrace/index.js\":{\"#package\":\"/node_modules/hypertrace/package.json\"},\"/node_modules/hypertrace/package.json\":{},\"/node_modules/index-encoder/index.js\":{\"#package\":\"/node_modules/index-encoder/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/index-encoder/package.json\":{},\"/node_modules/is-options/index.js\":{\"#package\":\"/node_modules/is-options/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/is-options/package.json\":{},\"/node_modules/kademlia-routing-table/index.js\":{\"#package\":\"/node_modules/kademlia-routing-table/package.json\",\"events\":\"/node_modules/bare-events/index.js\"},\"/node_modules/kademlia-routing-table/package.json\":{},\"/node_modules/mirror-drive/index.js\":{\"#package\":\"/node_modules/mirror-drive/package.json\",\"binary-stream-equals\":\"/node_modules/binary-stream-equals/index.js\",\"same-data\":\"/node_modules/same-data/index.js\"},\"/node_modules/mirror-drive/package.json\":{},\"/node_modules/mutexify/index.js\":{\"#package\":\"/node_modules/mutexify/package.json\",\"queue-tick\":\"/node_modules/queue-tick/process-next-tick.js\"},\"/node_modules/mutexify/package.json\":{},\"/node_modules/mutexify/promise.js\":{\"#package\":\"/node_modules/mutexify/package.json\",\".\":\"/node_modules/mutexify/index.js\"},\"/node_modules/nanoassert/index.js\":{\"#package\":\"/node_modules/nanoassert/package.json\"},\"/node_modules/nanoassert/package.json\":{},\"/node_modules/nat-sampler/index.js\":{\"#package\":\"/node_modules/nat-sampler/package.json\"},\"/node_modules/nat-sampler/package.json\":{},\"/node_modules/node-gyp-build/index.js\":{\"#package\":\"/node_modules/node-gyp-build/package.json\",\"./node-gyp-build.js\":\"/node_modules/node-gyp-build/node-gyp-build.js\"},\"/node_modules/node-gyp-build/node-gyp-build.js\":{\"#package\":\"/node_modules/node-gyp-build/package.json\",\"fs\":\"builtin:fs\",\"os\":\"builtin:os\",\"path\":\"builtin:path\"},\"/node_modules/node-gyp-build/package.json\":{},\"/node_modules/noise-curve-ed/index.js\":{\"#package\":\"/node_modules/noise-curve-ed/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/noise-curve-ed/package.json\":{},\"/node_modules/noise-handshake/cipher.js\":{\"#package\":\"/node_modules/noise-handshake/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/noise-handshake/dh.js\":{\"#package\":\"/node_modules/noise-handshake/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/noise-handshake/hkdf.js\":{\"#package\":\"/node_modules/noise-handshake/package.json\",\"./hmac\":\"/node_modules/noise-handshake/hmac.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\"},\"/node_modules/noise-handshake/hmac.js\":{\"#package\":\"/node_modules/noise-handshake/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/noise-handshake/noise.js\":{\"#package\":\"/node_modules/noise-handshake/package.json\",\"./hkdf\":\"/node_modules/noise-handshake/hkdf.js\",\"./symmetric-state\":\"/node_modules/noise-handshake/symmetric-state.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\"},\"/node_modules/noise-handshake/package.json\":{},\"/node_modules/noise-handshake/symmetric-state.js\":{\"#package\":\"/node_modules/noise-handshake/package.json\",\"./cipher\":\"/node_modules/noise-handshake/cipher.js\",\"./dh\":\"/node_modules/noise-handshake/dh.js\",\"./hkdf\":\"/node_modules/noise-handshake/hkdf.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"nanoassert\":\"/node_modules/nanoassert/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/parallel-transformx/index.js\":{\"#package\":\"/node_modules/parallel-transformx/package.json\",\"fast-fifo/fixed-size\":\"/node_modules/fast-fifo/fixed-size.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/parallel-transformx/package.json\":{},\"/node_modules/pear-inspect/index.js\":{\"#package\":\"/node_modules/pear-inspect/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"hyperdht\":\"/node_modules/hyperdht/index.js\",\"inspector\":\"/node_modules/bare-inspector/index.js\",\"path\":\"/node_modules/bare-path/index.js\",\"which-runtime\":\"/node_modules/which-runtime/index.js\"},\"/node_modules/pear-inspect/package.json\":{},\"/node_modules/promaphore/index.js\":{\"#package\":\"/node_modules/promaphore/package.json\"},\"/node_modules/promaphore/package.json\":{},\"/node_modules/protocol-buffers-encodings/index.js\":{\"#package\":\"/node_modules/protocol-buffers-encodings/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"signed-varint\":\"/node_modules/signed-varint/index.js\",\"varint\":\"/node_modules/varint/index.js\"},\"/node_modules/protocol-buffers-encodings/package.json\":{},\"/node_modules/protomux-rpc/index.js\":{\"#package\":\"/node_modules/protomux-rpc/package.json\",\"./lib/errors\":\"/node_modules/protomux-rpc/lib/errors.js\",\"bits-to-bytes\":\"/node_modules/bits-to-bytes/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"compact-encoding-bitfield\":\"/node_modules/compact-encoding-bitfield/index.js\",\"events\":\"/node_modules/bare-events/index.js\",\"protomux\":\"/node_modules/protomux/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\"},\"/node_modules/protomux-rpc/lib/errors.js\":{\"#package\":\"/node_modules/protomux-rpc/package.json\"},\"/node_modules/protomux-rpc/package.json\":{},\"/node_modules/protomux/index.js\":{\"#package\":\"/node_modules/protomux/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"queue-tick\":\"/node_modules/queue-tick/process-next-tick.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"unslab\":\"/node_modules/unslab/index.js\"},\"/node_modules/protomux/package.json\":{},\"/node_modules/queue-tick/package.json\":{},\"/node_modules/queue-tick/process-next-tick.js\":{\"#package\":\"/node_modules/queue-tick/package.json\",\"./queue-microtask\":\"/node_modules/queue-tick/queue-microtask.js\"},\"/node_modules/queue-tick/queue-microtask.js\":{\"#package\":\"/node_modules/queue-tick/package.json\"},\"/node_modules/quickbit-native/binding.js\":{\"#package\":\"/node_modules/quickbit-native/package.json\",\"node-gyp-build\":\"/node_modules/node-gyp-build/index.js\"},\"/node_modules/quickbit-native/index.js\":{\"#package\":\"/node_modules/quickbit-native/package.json\",\"./binding\":\"/node_modules/quickbit-native/binding.js\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/quickbit-native/package.json\":{},\"/node_modules/quickbit-universal/fallback.js\":{\"#package\":\"/node_modules/quickbit-universal/package.json\",\"simdle-universal\":\"/node_modules/simdle-universal/index.js\"},\"/node_modules/quickbit-universal/index.js\":{\"#package\":\"/node_modules/quickbit-universal/package.json\",\"./fallback\":\"/node_modules/quickbit-universal/fallback.js\",\"quickbit-native\":\"/node_modules/quickbit-native/index.js\"},\"/node_modules/quickbit-universal/package.json\":{},\"/node_modules/rache/index.js\":{\"#package\":\"/node_modules/rache/package.json\"},\"/node_modules/rache/package.json\":{},\"/node_modules/random-access-file/index.js\":{\"#package\":\"/node_modules/random-access-file/package.json\",\"fs\":\"/node_modules/bare-fs/index.js\",\"fs-native-extensions\":\"/node_modules/fs-native-extensions/index.js\",\"path\":\"/node_modules/bare-path/index.js\",\"random-access-storage\":\"/node_modules/random-access-storage/index.js\"},\"/node_modules/random-access-file/package.json\":{},\"/node_modules/random-access-storage/index.js\":{\"#package\":\"/node_modules/random-access-storage/package.json\",\"events\":\"/node_modules/bare-events/index.js\",\"queue-tick\":\"/node_modules/queue-tick/process-next-tick.js\"},\"/node_modules/random-access-storage/package.json\":{},\"/node_modules/random-array-iterator/index.js\":{\"#package\":\"/node_modules/random-array-iterator/package.json\"},\"/node_modules/random-array-iterator/package.json\":{},\"/node_modules/range-parser/index.js\":{\"#package\":\"/node_modules/range-parser/package.json\"},\"/node_modules/range-parser/package.json\":{},\"/node_modules/read-write-mutexify/index.js\":{\"#package\":\"/node_modules/read-write-mutexify/package.json\"},\"/node_modules/read-write-mutexify/package.json\":{},\"/node_modules/ready-resource/index.js\":{\"#package\":\"/node_modules/ready-resource/package.json\",\"events\":\"/node_modules/bare-events/index.js\"},\"/node_modules/ready-resource/package.json\":{},\"/node_modules/record-cache/index.js\":{\"#package\":\"/node_modules/record-cache/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/record-cache/package.json\":{},\"/node_modules/safety-catch/index.js\":{\"#package\":\"/node_modules/safety-catch/package.json\"},\"/node_modules/safety-catch/package.json\":{},\"/node_modules/same-data/index.js\":{\"#package\":\"/node_modules/same-data/package.json\"},\"/node_modules/same-data/package.json\":{},\"/node_modules/serve-drive/index.js\":{\"#package\":\"/node_modules/serve-drive/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"get-mime-type\":\"/node_modules/get-mime-type/index.js\",\"http\":\"/node_modules/serve-drive/node_modules/bare-http1/index.js\",\"hypercore-crypto\":\"/node_modules/hypercore-crypto/index.js\",\"hypercore-id-encoding\":\"/node_modules/hypercore-id-encoding/index.js\",\"range-parser\":\"/node_modules/range-parser/index.js\",\"ready-resource\":\"/node_modules/ready-resource/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\",\"unix-path-resolve\":\"/node_modules/unix-path-resolve/index.js\"},\"/node_modules/serve-drive/node_modules/bare-dns/binding.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-dns/package.json\",\".\":{\"ios\":\"linked:bare-dns.2.0.4.framework/bare-dns.2.0.4\",\"android\":\"linked:libbare-dns.2.0.4.so\"}},\"/node_modules/serve-drive/node_modules/bare-dns/index.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-dns/package.json\",\"./binding\":\"/node_modules/serve-drive/node_modules/bare-dns/binding.js\"},\"/node_modules/serve-drive/node_modules/bare-dns/package.json\":{},\"/node_modules/serve-drive/node_modules/bare-http1/index.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-http1/package.json\",\"./lib/agent\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/agent.js\",\"./lib/client-connection\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/client-connection.js\",\"./lib/client-request\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/client-request.js\",\"./lib/constants\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/constants.js\",\"./lib/incoming-message\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/incoming-message.js\",\"./lib/outgoing-message\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/outgoing-message.js\",\"./lib/server\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/server.js\",\"./lib/server-connection\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/server-connection.js\",\"./lib/server-response\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/server-response.js\"},\"/node_modules/serve-drive/node_modules/bare-http1/lib/agent.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-http1/package.json\",\"./client-connection\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/client-connection.js\",\"bare-tcp\":\"/node_modules/serve-drive/node_modules/bare-tcp/index.js\"},\"/node_modules/serve-drive/node_modules/bare-http1/lib/client-connection.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-http1/package.json\",\"./constants\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/constants.js\",\"./errors\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/errors.js\",\"./incoming-message\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/incoming-message.js\"},\"/node_modules/serve-drive/node_modules/bare-http1/lib/client-request.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-http1/package.json\",\"./agent\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/agent.js\",\"./outgoing-message\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/outgoing-message.js\"},\"/node_modules/serve-drive/node_modules/bare-http1/lib/constants.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-http1/package.json\"},\"/node_modules/serve-drive/node_modules/bare-http1/lib/errors.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-http1/package.json\"},\"/node_modules/serve-drive/node_modules/bare-http1/lib/incoming-message.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-http1/package.json\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/serve-drive/node_modules/bare-http1/lib/outgoing-message.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-http1/package.json\",\"./errors\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/errors.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/serve-drive/node_modules/bare-http1/lib/server-connection.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-http1/package.json\",\"./constants\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/constants.js\",\"./incoming-message\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/incoming-message.js\",\"./server-response\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/server-response.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\",\"bare-tcp\":\"/node_modules/serve-drive/node_modules/bare-tcp/index.js\"},\"/node_modules/serve-drive/node_modules/bare-http1/lib/server-response.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-http1/package.json\",\"./constants\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/constants.js\",\"./outgoing-message\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/outgoing-message.js\"},\"/node_modules/serve-drive/node_modules/bare-http1/lib/server.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-http1/package.json\",\"./server-connection\":\"/node_modules/serve-drive/node_modules/bare-http1/lib/server-connection.js\",\"bare-tcp\":\"/node_modules/serve-drive/node_modules/bare-tcp/index.js\"},\"/node_modules/serve-drive/node_modules/bare-http1/package.json\":{},\"/node_modules/serve-drive/node_modules/bare-tcp/binding.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-tcp/package.json\",\".\":{\"ios\":\"linked:bare-tcp.2.0.3.framework/bare-tcp.2.0.3\",\"android\":\"linked:libbare-tcp.2.0.3.so\"}},\"/node_modules/serve-drive/node_modules/bare-tcp/index.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-tcp/package.json\",\"./binding\":\"/node_modules/serve-drive/node_modules/bare-tcp/binding.js\",\"./lib/constants\":\"/node_modules/serve-drive/node_modules/bare-tcp/lib/constants.js\",\"./lib/errors\":\"/node_modules/serve-drive/node_modules/bare-tcp/lib/errors.js\",\"./lib/ip\":\"/node_modules/serve-drive/node_modules/bare-tcp/lib/ip.js\",\"bare-dns\":\"/node_modules/serve-drive/node_modules/bare-dns/index.js\",\"bare-events\":\"/node_modules/bare-events/index.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/serve-drive/node_modules/bare-tcp/lib/constants.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-tcp/package.json\"},\"/node_modules/serve-drive/node_modules/bare-tcp/lib/errors.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-tcp/package.json\"},\"/node_modules/serve-drive/node_modules/bare-tcp/lib/ip.js\":{\"#package\":\"/node_modules/serve-drive/node_modules/bare-tcp/package.json\"},\"/node_modules/serve-drive/node_modules/bare-tcp/package.json\":{},\"/node_modules/serve-drive/package.json\":{},\"/node_modules/shuffled-priority-queue/index.js\":{\"#package\":\"/node_modules/shuffled-priority-queue/package.json\",\"unordered-set\":\"/node_modules/unordered-set/index.js\"},\"/node_modules/shuffled-priority-queue/package.json\":{},\"/node_modules/signal-promise/index.js\":{\"#package\":\"/node_modules/signal-promise/package.json\"},\"/node_modules/signal-promise/package.json\":{},\"/node_modules/signed-varint/index.js\":{\"#package\":\"/node_modules/signed-varint/package.json\",\"varint\":\"/node_modules/varint/index.js\"},\"/node_modules/signed-varint/package.json\":{},\"/node_modules/simdle-native/binding.js\":{\"#package\":\"/node_modules/simdle-native/package.json\",\"node-gyp-build\":\"/node_modules/node-gyp-build/index.js\"},\"/node_modules/simdle-native/index.js\":{\"#package\":\"/node_modules/simdle-native/package.json\",\"./binding\":\"/node_modules/simdle-native/binding.js\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/simdle-native/package.json\":{},\"/node_modules/simdle-universal/fallback.js\":{\"#package\":\"/node_modules/simdle-universal/package.json\",\"./scalar\":\"/node_modules/simdle-universal/scalar.js\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/simdle-universal/index.js\":{\"#package\":\"/node_modules/simdle-universal/package.json\",\"./fallback\":\"/node_modules/simdle-universal/fallback.js\",\"simdle-native\":\"/node_modules/simdle-native/index.js\"},\"/node_modules/simdle-universal/package.json\":{},\"/node_modules/simdle-universal/scalar.js\":{\"#package\":\"/node_modules/simdle-universal/package.json\"},\"/node_modules/sodium-native/index.js\":{\"#package\":\"/node_modules/sodium-native/package.json\",\"node-gyp-build\":\"/node_modules/node-gyp-build/index.js\"},\"/node_modules/sodium-native/package.json\":{},\"/node_modules/sodium-secretstream/index.js\":{\"#package\":\"/node_modules/sodium-secretstream/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"sodium-universal\":\"/node_modules/sodium-universal/index.js\"},\"/node_modules/sodium-secretstream/package.json\":{},\"/node_modules/sodium-universal/index.js\":{\"#package\":\"/node_modules/sodium-universal/package.json\",\"sodium-native\":\"/node_modules/sodium-native/index.js\"},\"/node_modules/sodium-universal/package.json\":{},\"/node_modules/sorted-union-stream/index.js\":{\"#package\":\"/node_modules/sorted-union-stream/package.json\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/sorted-union-stream/package.json\":{},\"/node_modules/speedometer/index.js\":{\"#package\":\"/node_modules/speedometer/package.json\"},\"/node_modules/speedometer/package.json\":{},\"/node_modules/streamx/index.js\":{\"#package\":\"/node_modules/streamx/package.json\",\"events\":\"/node_modules/bare-events/index.js\",\"fast-fifo\":\"/node_modules/fast-fifo/index.js\",\"text-decoder\":\"/node_modules/text-decoder/index.js\"},\"/node_modules/streamx/package.json\":{},\"/node_modules/sub-encoder/index.js\":{\"#package\":\"/node_modules/sub-encoder/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"codecs\":\"/node_modules/codecs/index.js\"},\"/node_modules/sub-encoder/package.json\":{},\"/node_modules/text-decoder/index.js\":{\"#package\":\"/node_modules/text-decoder/package.json\",\"./lib/pass-through-decoder\":\"/node_modules/text-decoder/lib/pass-through-decoder.js\",\"./lib/utf8-decoder\":\"/node_modules/text-decoder/lib/utf8-decoder.js\"},\"/node_modules/text-decoder/lib/pass-through-decoder.js\":{\"#package\":\"/node_modules/text-decoder/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/text-decoder/lib/utf8-decoder.js\":{\"#package\":\"/node_modules/text-decoder/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/text-decoder/package.json\":{},\"/node_modules/time-ordered-set/index.js\":{\"#package\":\"/node_modules/time-ordered-set/package.json\"},\"/node_modules/time-ordered-set/package.json\":{},\"/node_modules/timeout-refresh/browser.js\":{\"#package\":\"/node_modules/timeout-refresh/package.json\"},\"/node_modules/timeout-refresh/index.js\":{\"#package\":\"/node_modules/timeout-refresh/package.json\",\"./browser\":\"/node_modules/timeout-refresh/browser.js\",\"./node\":\"/node_modules/timeout-refresh/node.js\"},\"/node_modules/timeout-refresh/node.js\":{\"#package\":\"/node_modules/timeout-refresh/package.json\"},\"/node_modules/timeout-refresh/package.json\":{},\"/node_modules/tiny-buffer-map/index.js\":{\"#package\":\"/node_modules/tiny-buffer-map/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/tiny-buffer-map/package.json\":{},\"/node_modules/tiny-buffer-rpc/any.js\":{\"#package\":\"/node_modules/tiny-buffer-rpc/package.json\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/tiny-buffer-rpc/index.js\":{\"#package\":\"/node_modules/tiny-buffer-rpc/package.json\",\"./messages.js\":\"/node_modules/tiny-buffer-rpc/messages.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\",\"safety-catch\":\"/node_modules/safety-catch/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/tiny-buffer-rpc/messages.js\":{\"#package\":\"/node_modules/tiny-buffer-rpc/package.json\",\"compact-encoding\":\"/node_modules/compact-encoding/index.js\"},\"/node_modules/tiny-buffer-rpc/package.json\":{},\"/node_modules/udx-native/binding.js\":{\"#package\":\"/node_modules/udx-native/package.json\",\"node-gyp-build\":\"/node_modules/node-gyp-build/index.js\"},\"/node_modules/udx-native/lib/ip.js\":{\"#package\":\"/node_modules/udx-native/package.json\"},\"/node_modules/udx-native/lib/network-interfaces.js\":{\"#package\":\"/node_modules/udx-native/package.json\",\"../binding\":\"/node_modules/udx-native/binding.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"events\":\"/node_modules/bare-events/index.js\"},\"/node_modules/udx-native/lib/socket.js\":{\"#package\":\"/node_modules/udx-native/package.json\",\"../binding\":\"/node_modules/udx-native/binding.js\",\"./ip\":\"/node_modules/udx-native/lib/ip.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"events\":\"/node_modules/bare-events/index.js\"},\"/node_modules/udx-native/lib/stream.js\":{\"#package\":\"/node_modules/udx-native/package.json\",\"../binding\":\"/node_modules/udx-native/binding.js\",\"./ip\":\"/node_modules/udx-native/lib/ip.js\",\"b4a\":\"/node_modules/b4a/index.js\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/udx-native/lib/udx.js\":{\"#package\":\"/node_modules/udx-native/package.json\",\"../binding\":\"/node_modules/udx-native/binding.js\",\"./ip\":\"/node_modules/udx-native/lib/ip.js\",\"./network-interfaces\":\"/node_modules/udx-native/lib/network-interfaces.js\",\"./socket\":\"/node_modules/udx-native/lib/socket.js\",\"./stream\":\"/node_modules/udx-native/lib/stream.js\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/udx-native/package.json\":{},\"/node_modules/unix-path-resolve/index.js\":{\"#package\":\"/node_modules/unix-path-resolve/package.json\"},\"/node_modules/unix-path-resolve/package.json\":{},\"/node_modules/unordered-set/index.js\":{\"#package\":\"/node_modules/unordered-set/package.json\"},\"/node_modules/unordered-set/package.json\":{},\"/node_modules/unslab/index.js\":{\"#package\":\"/node_modules/unslab/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/unslab/package.json\":{},\"/node_modules/varint/decode.js\":{\"#package\":\"/node_modules/varint/package.json\"},\"/node_modules/varint/encode.js\":{\"#package\":\"/node_modules/varint/package.json\"},\"/node_modules/varint/index.js\":{\"#package\":\"/node_modules/varint/package.json\",\"./decode.js\":\"/node_modules/varint/decode.js\",\"./encode.js\":\"/node_modules/varint/encode.js\",\"./length.js\":\"/node_modules/varint/length.js\"},\"/node_modules/varint/length.js\":{\"#package\":\"/node_modules/varint/package.json\"},\"/node_modules/varint/package.json\":{},\"/node_modules/which-runtime/index.js\":{\"#package\":\"/node_modules/which-runtime/package.json\"},\"/node_modules/which-runtime/package.json\":{},\"/node_modules/xache/index.js\":{\"#package\":\"/node_modules/xache/package.json\"},\"/node_modules/xache/package.json\":{},\"/node_modules/xor-distance/index.js\":{\"#package\":\"/node_modules/xor-distance/package.json\"},\"/node_modules/xor-distance/package.json\":{},\"/node_modules/z32/index.js\":{\"#package\":\"/node_modules/z32/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/z32/package.json\":{},\"/package.json\":{}},\"addons\":[\"linked:bare-crypto.1.4.0.framework/bare-crypto.1.4.0\",\"linked:bare-dns.1.0.5.framework/bare-dns.1.0.5\",\"linked:bare-dns.2.0.4.framework/bare-dns.2.0.4\",\"linked:bare-fs.4.0.1.framework/bare-fs.4.0.1\",\"linked:bare-inspector.3.0.2.framework/bare-inspector.3.0.2\",\"linked:bare-os.3.4.0.framework/bare-os.3.4.0\",\"linked:bare-tcp.1.9.1.framework/bare-tcp.1.9.1\",\"linked:bare-tcp.2.0.3.framework/bare-tcp.2.0.3\",\"linked:bare-tls.1.2.1.framework/bare-tls.1.2.1\",\"linked:bare-url.2.1.3.framework/bare-url.2.1.3\",\"linked:libbare-crypto.1.4.0.so\",\"linked:libbare-dns.1.0.5.so\",\"linked:libbare-dns.2.0.4.so\",\"linked:libbare-fs.4.0.1.so\",\"linked:libbare-inspector.3.0.2.so\",\"linked:libbare-os.3.4.0.so\",\"linked:libbare-tcp.1.9.1.so\",\"linked:libbare-tcp.2.0.3.so\",\"linked:libbare-tls.1.2.1.so\",\"linked:libbare-url.2.1.3.so\"],\"assets\":[],\"files\":{\"/lib/inspector.js\":{\"offset\":0,\"length\":513,\"mode\":420},\"/main.js\":{\"offset\":513,\"length\":2732,\"mode\":420},\"/node_modules/@holepunchto/bip39/index.js\":{\"offset\":3245,\"length\":4141,\"mode\":420},\"/node_modules/@holepunchto/bip39/package.json\":{\"offset\":7386,\"length\":793,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/chinese_simplified.json\":{\"offset\":8179,\"length\":12289,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/chinese_traditional.json\":{\"offset\":20468,\"length\":12289,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/czech.json\":{\"offset\":32757,\"length\":19042,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/english.json\":{\"offset\":51799,\"length\":17213,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/french.json\":{\"offset\":69012,\"length\":20874,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/index.js\":{\"offset\":89886,\"length\":1406,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/italian.json\":{\"offset\":91292,\"length\":20130,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/japanese.json\":{\"offset\":111422,\"length\":30520,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/korean.json\":{\"offset\":141942,\"length\":41929,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/lookup.json\":{\"offset\":183871,\"length\":592224,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/portuguese.json\":{\"offset\":776095,\"length\":19768,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/russian.json\":{\"offset\":795863,\"length\":30635,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/spanish.json\":{\"offset\":826498,\"length\":18093,\"mode\":420},\"/node_modules/@holepunchto/bip39/wordlist/turkish.json\":{\"offset\":844591,\"length\":19421,\"mode\":420},\"/node_modules/@holepunchto/blind-mirror/client.js\":{\"offset\":864012,\"length\":44,\"mode\":420},\"/node_modules/@holepunchto/blind-mirror/lib/backoff.js\":{\"offset\":864056,\"length\":773,\"mode\":420},\"/node_modules/@holepunchto/blind-mirror/lib/client.js\":{\"offset\":864829,\"length\":5005,\"mode\":420},\"/node_modules/@holepunchto/blind-mirror/lib/messages.js\":{\"offset\":869834,\"length\":1229,\"mode\":420},\"/node_modules/@holepunchto/blind-mirror/lib/select.js\":{\"offset\":871063,\"length\":536,\"mode\":420},\"/node_modules/@holepunchto/blind-mirror/lib/wait-for-rpc.js\":{\"offset\":871599,\"length\":476,\"mode\":420},\"/node_modules/@holepunchto/blind-mirror/package.json\":{\"offset\":872075,\"length\":1209,\"mode\":420},\"/node_modules/@holepunchto/hmac/hash/sha256.js\":{\"offset\":873284,\"length\":284,\"mode\":420},\"/node_modules/@holepunchto/hmac/hash/sha512.js\":{\"offset\":873568,\"length\":284,\"mode\":420},\"/node_modules/@holepunchto/hmac/index.js\":{\"offset\":873852,\"length\":2063,\"mode\":420},\"/node_modules/@holepunchto/hmac/package.json\":{\"offset\":875915,\"length\":655,\"mode\":420},\"/node_modules/@holepunchto/hyperindex/index.js\":{\"offset\":876570,\"length\":9466,\"mode\":420},\"/node_modules/@holepunchto/hyperindex/package.json\":{\"offset\":886036,\"length\":1122,\"mode\":420},\"/node_modules/@holepunchto/keet-backend-rpc/package.json\":{\"offset\":887158,\"length\":977,\"mode\":420},\"/node_modules/@holepunchto/keet-backend-rpc/server.js\":{\"offset\":888135,\"length\":30602,\"mode\":420},\"/node_modules/@holepunchto/keet-backend/apis/error.js\":{\"offset\":918737,\"length\":879,\"mode\":420},\"/node_modules/@holepunchto/keet-backend/apis/network.js\":{\"offset\":919616,\"length\":1045,\"mode\":420},\"/node_modules/@holepunchto/keet-backend/apis/payments.js\":{\"offset\":920661,\"length\":447,\"mode\":420},\"/node_modules/@holepunchto/keet-backend/apis/preferences.js\":{\"offset\":921108,\"length\":1822,\"mode\":420},\"/node_modules/@holepunchto/keet-backend/index.js\":{\"offset\":922930,\"length\":4716,\"mode\":420},\"/node_modules/@holepunchto/keet-backend/package.json\":{\"offset\":927646,\"length\":1299,\"mode\":420},\"/node_modules/@holepunchto/keet-call/lib/common.js\":{\"offset\":928945,\"length\":2420,\"mode\":420},\"/node_modules/@holepunchto/keet-call/lib/messages.js\":{\"offset\":931365,\"length\":1527,\"mode\":420},\"/node_modules/@holepunchto/keet-call/package.json\":{\"offset\":932892,\"length\":1200,\"mode\":420},\"/node_modules/@holepunchto/keet-call/server/index.js\":{\"offset\":934092,\"length\":7528,\"mode\":420},\"/node_modules/@holepunchto/keet-call/server/media.js\":{\"offset\":941620,\"length\":3995,\"mode\":420},\"/node_modules/@holepunchto/keet-call/server/presence.js\":{\"offset\":945615,\"length\":12749,\"mode\":420},\"/node_modules/@holepunchto/keet-call/server/webrtc.js\":{\"offset\":958364,\"length\":3956,\"mode\":420},\"/node_modules/@holepunchto/keet-core-api/index.js\":{\"offset\":962320,\"length\":982,\"mode\":420},\"/node_modules/@holepunchto/keet-core-api/lib/chat.js\":{\"offset\":963302,\"length\":869,\"mode\":420},\"/node_modules/@holepunchto/keet-core-api/lib/config.js\":{\"offset\":964171,\"length\":663,\"mode\":420},\"/node_modules/@holepunchto/keet-core-api/lib/errors.js\":{\"offset\":964834,\"length\":5864,\"mode\":420},\"/node_modules/@holepunchto/keet-core-api/lib/features.js\":{\"offset\":970698,\"length\":953,\"mode\":420},\"/node_modules/@holepunchto/keet-core-api/lib/internal.js\":{\"offset\":971651,\"length\":250,\"mode\":420},\"/node_modules/@holepunchto/keet-core-api/lib/mailbox.js\":{\"offset\":971901,\"length\":275,\"mode\":420},\"/node_modules/@holepunchto/keet-core-api/lib/members.js\":{\"offset\":972176,\"length\":1171,\"mode\":420},\"/node_modules/@holepunchto/keet-core-api/lib/preferences.js\":{\"offset\":973347,\"length\":411,\"mode\":420},\"/node_modules/@holepunchto/keet-core-api/package.json\":{\"offset\":973758,\"length\":511,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/index.js\":{\"offset\":974269,\"length\":1064,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/index.js\":{\"offset\":975333,\"length\":1370,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/messages.js\":{\"offset\":976703,\"length\":14243,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/chat/ops.js\":{\"offset\":990946,\"length\":3659,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/config/index.js\":{\"offset\":994605,\"length\":1907,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/config/messages.js\":{\"offset\":996512,\"length\":962,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/config/ops.js\":{\"offset\":997474,\"length\":1075,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/devices/index.js\":{\"offset\":998549,\"length\":1021,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/devices/messages.js\":{\"offset\":999570,\"length\":1202,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/devices/ops.js\":{\"offset\":1000772,\"length\":4061,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/internal/index.js\":{\"offset\":1004833,\"length\":1122,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/internal/ops.js\":{\"offset\":1005955,\"length\":2898,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/invitations/index.js\":{\"offset\":1008853,\"length\":565,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/invitations/messages.js\":{\"offset\":1009418,\"length\":4472,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/invitations/ops.js\":{\"offset\":1013890,\"length\":1224,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/keet/index.js\":{\"offset\":1015114,\"length\":223,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/keet/messages.js\":{\"offset\":1015337,\"length\":870,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/keet/ops.js\":{\"offset\":1016207,\"length\":3518,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/mailbox/index.js\":{\"offset\":1019725,\"length\":1365,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/mailbox/messages.js\":{\"offset\":1021090,\"length\":3526,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/mailbox/ops.js\":{\"offset\":1024616,\"length\":2507,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/members/index.js\":{\"offset\":1027123,\"length\":1915,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/members/messages.js\":{\"offset\":1029038,\"length\":4378,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/members/ops.js\":{\"offset\":1033416,\"length\":3219,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/index.js\":{\"offset\":1036635,\"length\":362,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/messages.js\":{\"offset\":1036997,\"length\":927,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/ops.js\":{\"offset\":1037924,\"length\":802,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/private-profile/index.js\":{\"offset\":1038726,\"length\":788,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/private-profile/messages.js\":{\"offset\":1039514,\"length\":400,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/plugins/private-profile/ops.js\":{\"offset\":1039914,\"length\":1375,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-devices/index.js\":{\"offset\":1041289,\"length\":558,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-devices/ops.js\":{\"offset\":1041847,\"length\":835,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-mailbox/index.js\":{\"offset\":1042682,\"length\":1421,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-mailbox/messages.js\":{\"offset\":1044103,\"length\":3858,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-mailbox/ops.js\":{\"offset\":1047961,\"length\":3640,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-rooms/index.js\":{\"offset\":1051601,\"length\":467,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-rooms/messages.js\":{\"offset\":1052068,\"length\":429,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/private-rooms/ops.js\":{\"offset\":1052497,\"length\":631,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/reactions/index.js\":{\"offset\":1053128,\"length\":899,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/reactions/messages.js\":{\"offset\":1054027,\"length\":1091,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/reactions/ops.js\":{\"offset\":1055118,\"length\":879,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/lib/schema-builder.js\":{\"offset\":1055997,\"length\":5857,\"mode\":420},\"/node_modules/@holepunchto/keet-core-schemas/package.json\":{\"offset\":1061854,\"length\":545,\"mode\":420},\"/node_modules/@holepunchto/keet-core/index.js\":{\"offset\":1062399,\"length\":71428,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/activity.js\":{\"offset\":1133827,\"length\":6103,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/drives.js\":{\"offset\":1139930,\"length\":6478,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/identity/index.js\":{\"offset\":1146408,\"length\":30396,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/identity/messages.js\":{\"offset\":1176804,\"length\":2280,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/identity/plugin.js\":{\"offset\":1179084,\"length\":2455,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/local/index.js\":{\"offset\":1181539,\"length\":11447,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/local/messages.js\":{\"offset\":1192986,\"length\":6924,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/local/transaction.js\":{\"offset\":1199910,\"length\":9681,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/pairing/client.js\":{\"offset\":1209591,\"length\":14076,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/pairing/index.js\":{\"offset\":1223667,\"length\":1115,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/pairing/server.js\":{\"offset\":1224782,\"length\":8764,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/room/chat.js\":{\"offset\":1233546,\"length\":6530,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/room/commands.js\":{\"offset\":1240076,\"length\":1103,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/room/config.js\":{\"offset\":1241179,\"length\":5348,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/room/devices.js\":{\"offset\":1246527,\"length\":3475,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/room/files.js\":{\"offset\":1250002,\"length\":3778,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/room/index.js\":{\"offset\":1253780,\"length\":27037,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/room/invitations.js\":{\"offset\":1280817,\"length\":3678,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/room/mailbox.js\":{\"offset\":1284495,\"length\":3882,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/room/members.js\":{\"offset\":1288377,\"length\":12001,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/room/plugins.js\":{\"offset\":1300378,\"length\":5740,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/room/private-mailbox.js\":{\"offset\":1306118,\"length\":6133,\"mode\":420},\"/node_modules/@holepunchto/keet-core/lib/room/reactions.js\":{\"offset\":1312251,\"length\":2538,\"mode\":420},\"/node_modules/@holepunchto/keet-core/package.json\":{\"offset\":1314789,\"length\":2288,\"mode\":420},\"/node_modules/@holepunchto/keet-default-config/index.js\":{\"offset\":1317077,\"length\":2026,\"mode\":420},\"/node_modules/@holepunchto/keet-default-config/package.json\":{\"offset\":1319103,\"length\":588,\"mode\":420},\"/node_modules/@holepunchto/keet-identity-key/index.js\":{\"offset\":1319691,\"length\":6320,\"mode\":420},\"/node_modules/@holepunchto/keet-identity-key/lib/crypto.js\":{\"offset\":1326011,\"length\":552,\"mode\":420},\"/node_modules/@holepunchto/keet-identity-key/lib/encoding.js\":{\"offset\":1326563,\"length\":3695,\"mode\":420},\"/node_modules/@holepunchto/keet-identity-key/lib/keychain.js\":{\"offset\":1330258,\"length\":3090,\"mode\":420},\"/node_modules/@holepunchto/keet-identity-key/package.json\":{\"offset\":1333348,\"length\":897,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/index.js\":{\"offset\":1334245,\"length\":5453,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/chat/index.js\":{\"offset\":1339698,\"length\":10065,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/config/index.js\":{\"offset\":1349763,\"length\":5427,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/devices/index.js\":{\"offset\":1355190,\"length\":9935,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/internal/index.js\":{\"offset\":1365125,\"length\":4709,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/invitations/index.js\":{\"offset\":1369834,\"length\":2636,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/mailbox/index.js\":{\"offset\":1372470,\"length\":5000,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/members/index.js\":{\"offset\":1377470,\"length\":20707,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/plugins/index.js\":{\"offset\":1398177,\"length\":1617,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/private-profile/index.js\":{\"offset\":1399794,\"length\":1927,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/private-profile/private-devices.js\":{\"offset\":1401721,\"length\":1443,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/private-profile/private-mailbox.js\":{\"offset\":1403164,\"length\":5750,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/private-profile/private-rooms.js\":{\"offset\":1408914,\"length\":1246,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/lib/reactions/index.js\":{\"offset\":1410160,\"length\":5471,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/package.json\":{\"offset\":1415631,\"length\":1147,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/plugins/kv-store/apply.js\":{\"offset\":1416778,\"length\":938,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/plugins/private-profile/apply.js\":{\"offset\":1417716,\"length\":2727,\"mode\":420},\"/node_modules/@holepunchto/keet-indexing/plugins/word-count/apply.js\":{\"offset\":1420443,\"length\":845,\"mode\":420},\"/node_modules/@holepunchto/keet-push/index.js\":{\"offset\":1421288,\"length\":2481,\"mode\":420},\"/node_modules/@holepunchto/keet-push/lib/encoding.js\":{\"offset\":1423769,\"length\":1026,\"mode\":420},\"/node_modules/@holepunchto/keet-push/lib/notifications.js\":{\"offset\":1424795,\"length\":8586,\"mode\":420},\"/node_modules/@holepunchto/keet-push/package.json\":{\"offset\":1433381,\"length\":1172,\"mode\":420},\"/node_modules/@hyperswarm/rpc/index.js\":{\"offset\":1434553,\"length\":6914,\"mode\":420},\"/node_modules/@hyperswarm/rpc/package.json\":{\"offset\":1441467,\"length\":910,\"mode\":420},\"/node_modules/@hyperswarm/secret-stream/index.js\":{\"offset\":1442377,\"length\":16646,\"mode\":420},\"/node_modules/@hyperswarm/secret-stream/lib/bridge.js\":{\"offset\":1459023,\"length\":1285,\"mode\":420},\"/node_modules/@hyperswarm/secret-stream/lib/handshake.js\":{\"offset\":1460308,\"length\":1959,\"mode\":420},\"/node_modules/@hyperswarm/secret-stream/package.json\":{\"offset\":1462267,\"length\":1032,\"mode\":420},\"/node_modules/autobase/index.js\":{\"offset\":1463299,\"length\":67070,\"mode\":420},\"/node_modules/autobase/lib/active-writers.js\":{\"offset\":1530369,\"length\":660,\"mode\":420},\"/node_modules/autobase/lib/clock.js\":{\"offset\":1531029,\"length\":757,\"mode\":420},\"/node_modules/autobase/lib/consensus.js\":{\"offset\":1531786,\"length\":11658,\"mode\":420},\"/node_modules/autobase/lib/core-pool.js\":{\"offset\":1543444,\"length\":1087,\"mode\":420},\"/node_modules/autobase/lib/core.js\":{\"offset\":1544531,\"length\":24554,\"mode\":420},\"/node_modules/autobase/lib/extension.js\":{\"offset\":1569085,\"length\":1722,\"mode\":420},\"/node_modules/autobase/lib/linearizer.js\":{\"offset\":1570807,\"length\":8782,\"mode\":420},\"/node_modules/autobase/lib/messages.js\":{\"offset\":1579589,\"length\":12035,\"mode\":420},\"/node_modules/autobase/lib/node-buffer.js\":{\"offset\":1591624,\"length\":1571,\"mode\":420},\"/node_modules/autobase/lib/signer.js\":{\"offset\":1593195,\"length\":4096,\"mode\":420},\"/node_modules/autobase/lib/store.js\":{\"offset\":1597291,\"length\":6453,\"mode\":420},\"/node_modules/autobase/lib/system.js\":{\"offset\":1603744,\"length\":11246,\"mode\":420},\"/node_modules/autobase/lib/timer.js\":{\"offset\":1614990,\"length\":2947,\"mode\":420},\"/node_modules/autobase/lib/topolist.js\":{\"offset\":1617937,\"length\":2277,\"mode\":420},\"/node_modules/autobase/lib/wakeup.js\":{\"offset\":1620214,\"length\":4087,\"mode\":420},\"/node_modules/autobase/lib/writer.js\":{\"offset\":1624301,\"length\":11987,\"mode\":420},\"/node_modules/autobase/package.json\":{\"offset\":1636288,\"length\":1685,\"mode\":420},\"/node_modules/b4a/index.js\":{\"offset\":1637973,\"length\":4092,\"mode\":420},\"/node_modules/b4a/package.json\":{\"offset\":1642065,\"length\":701,\"mode\":420},\"/node_modules/bare-crypto/binding.js\":{\"offset\":1642766,\"length\":33,\"mode\":420},\"/node_modules/bare-crypto/index.js\":{\"offset\":1642799,\"length\":2798,\"mode\":420},\"/node_modules/bare-crypto/lib/constants.js\":{\"offset\":1645597,\"length\":211,\"mode\":420},\"/node_modules/bare-crypto/lib/errors.js\":{\"offset\":1645808,\"length\":450,\"mode\":420},\"/node_modules/bare-crypto/package.json\":{\"offset\":1646258,\"length\":1349,\"mode\":420},\"/node_modules/bare-crypto/web.js\":{\"offset\":1647607,\"length\":195,\"mode\":420},\"/node_modules/bare-dns/binding.js\":{\"offset\":1647802,\"length\":33,\"mode\":420},\"/node_modules/bare-dns/index.js\":{\"offset\":1647835,\"length\":860,\"mode\":420},\"/node_modules/bare-dns/package.json\":{\"offset\":1648695,\"length\":772,\"mode\":420},\"/node_modules/bare-events/index.js\":{\"offset\":1649467,\"length\":6999,\"mode\":420},\"/node_modules/bare-events/lib/errors.js\":{\"offset\":1656466,\"length\":711,\"mode\":420},\"/node_modules/bare-events/package.json\":{\"offset\":1657177,\"length\":944,\"mode\":420},\"/node_modules/bare-fs/binding.js\":{\"offset\":1658121,\"length\":33,\"mode\":420},\"/node_modules/bare-fs/index.js\":{\"offset\":1658154,\"length\":59807,\"mode\":420},\"/node_modules/bare-fs/package.json\":{\"offset\":1717961,\"length\":926,\"mode\":420},\"/node_modules/bare-http1/index.js\":{\"offset\":1718887,\"length\":1912,\"mode\":420},\"/node_modules/bare-http1/lib/agent.js\":{\"offset\":1720799,\"length\":2806,\"mode\":420},\"/node_modules/bare-http1/lib/client-connection.js\":{\"offset\":1723605,\"length\":6041,\"mode\":420},\"/node_modules/bare-http1/lib/client-request.js\":{\"offset\":1729646,\"length\":2531,\"mode\":420},\"/node_modules/bare-http1/lib/constants.js\":{\"offset\":1732177,\"length\":2121,\"mode\":420},\"/node_modules/bare-http1/lib/errors.js\":{\"offset\":1734298,\"length\":549,\"mode\":420},\"/node_modules/bare-http1/lib/incoming-message.js\":{\"offset\":1734847,\"length\":944,\"mode\":420},\"/node_modules/bare-http1/lib/outgoing-message.js\":{\"offset\":1735791,\"length\":1032,\"mode\":420},\"/node_modules/bare-http1/lib/server-connection.js\":{\"offset\":1736823,\"length\":6349,\"mode\":420},\"/node_modules/bare-http1/lib/server-response.js\":{\"offset\":1743172,\"length\":2679,\"mode\":420},\"/node_modules/bare-http1/lib/server.js\":{\"offset\":1745851,\"length\":942,\"mode\":420},\"/node_modules/bare-http1/package.json\":{\"offset\":1746793,\"length\":816,\"mode\":420},\"/node_modules/bare-https/index.js\":{\"offset\":1747609,\"length\":2738,\"mode\":420},\"/node_modules/bare-https/package.json\":{\"offset\":1750347,\"length\":777,\"mode\":420},\"/node_modules/bare-inspector/binding.js\":{\"offset\":1751124,\"length\":33,\"mode\":420},\"/node_modules/bare-inspector/index.js\":{\"offset\":1751157,\"length\":181,\"mode\":420},\"/node_modules/bare-inspector/lib/console.js\":{\"offset\":1751338,\"length\":214,\"mode\":420},\"/node_modules/bare-inspector/lib/constants.js\":{\"offset\":1751552,\"length\":75,\"mode\":420},\"/node_modules/bare-inspector/lib/heap-snapshot.js\":{\"offset\":1751627,\"length\":677,\"mode\":420},\"/node_modules/bare-inspector/lib/server.js\":{\"offset\":1752304,\"length\":2696,\"mode\":420},\"/node_modules/bare-inspector/lib/session.js\":{\"offset\":1755000,\"length\":2131,\"mode\":420},\"/node_modules/bare-inspector/package.json\":{\"offset\":1757131,\"length\":1156,\"mode\":420},\"/node_modules/bare-os/binding.js\":{\"offset\":1758287,\"length\":33,\"mode\":420},\"/node_modules/bare-os/index.js\":{\"offset\":1758320,\"length\":2141,\"mode\":420},\"/node_modules/bare-os/lib/constants.js\":{\"offset\":1760461,\"length\":113,\"mode\":420},\"/node_modules/bare-os/lib/errors.js\":{\"offset\":1760574,\"length\":479,\"mode\":420},\"/node_modules/bare-os/package.json\":{\"offset\":1761053,\"length\":1022,\"mode\":420},\"/node_modules/bare-path/index.js\":{\"offset\":1762075,\"length\":306,\"mode\":420},\"/node_modules/bare-path/lib/constants.js\":{\"offset\":1762381,\"length\":247,\"mode\":420},\"/node_modules/bare-path/lib/posix.js\":{\"offset\":1762628,\"length\":5991,\"mode\":420},\"/node_modules/bare-path/lib/shared.js\":{\"offset\":1768619,\"length\":1888,\"mode\":420},\"/node_modules/bare-path/lib/win32.js\":{\"offset\":1770507,\"length\":13427,\"mode\":420},\"/node_modules/bare-path/package.json\":{\"offset\":1783934,\"length\":796,\"mode\":420},\"/node_modules/bare-stream/index.js\":{\"offset\":1784730,\"length\":7649,\"mode\":420},\"/node_modules/bare-stream/package.json\":{\"offset\":1792379,\"length\":1237,\"mode\":420},\"/node_modules/bare-tcp/binding.js\":{\"offset\":1793616,\"length\":33,\"mode\":420},\"/node_modules/bare-tcp/index.js\":{\"offset\":1793649,\"length\":12710,\"mode\":420},\"/node_modules/bare-tcp/lib/constants.js\":{\"offset\":1806359,\"length\":167,\"mode\":420},\"/node_modules/bare-tcp/lib/errors.js\":{\"offset\":1806526,\"length\":799,\"mode\":420},\"/node_modules/bare-tcp/lib/ip.js\":{\"offset\":1807325,\"length\":2179,\"mode\":420},\"/node_modules/bare-tcp/package.json\":{\"offset\":1809504,\"length\":959,\"mode\":420},\"/node_modules/bare-tls/binding.js\":{\"offset\":1810463,\"length\":33,\"mode\":420},\"/node_modules/bare-tls/index.js\":{\"offset\":1810496,\"length\":4290,\"mode\":420},\"/node_modules/bare-tls/lib/constants.js\":{\"offset\":1814786,\"length\":55,\"mode\":420},\"/node_modules/bare-tls/lib/errors.js\":{\"offset\":1814841,\"length\":361,\"mode\":420},\"/node_modules/bare-tls/package.json\":{\"offset\":1815202,\"length\":978,\"mode\":420},\"/node_modules/bare-url/binding.js\":{\"offset\":1816180,\"length\":33,\"mode\":420},\"/node_modules/bare-url/index.js\":{\"offset\":1816213,\"length\":7957,\"mode\":420},\"/node_modules/bare-url/lib/errors.js\":{\"offset\":1824170,\"length\":881,\"mode\":420},\"/node_modules/bare-url/package.json\":{\"offset\":1825051,\"length\":1104,\"mode\":420},\"/node_modules/bare-ws/index.js\":{\"offset\":1826155,\"length\":82,\"mode\":420},\"/node_modules/bare-ws/lib/constants.js\":{\"offset\":1826237,\"length\":437,\"mode\":420},\"/node_modules/bare-ws/lib/errors.js\":{\"offset\":1826674,\"length\":3280,\"mode\":420},\"/node_modules/bare-ws/lib/frame.js\":{\"offset\":1829954,\"length\":3577,\"mode\":420},\"/node_modules/bare-ws/lib/server.js\":{\"offset\":1833531,\"length\":2710,\"mode\":420},\"/node_modules/bare-ws/lib/socket.js\":{\"offset\":1836241,\"length\":6805,\"mode\":420},\"/node_modules/bare-ws/package.json\":{\"offset\":1843046,\"length\":919,\"mode\":420},\"/node_modules/big-sparse-array/index.js\":{\"offset\":1843965,\"length\":2471,\"mode\":420},\"/node_modules/big-sparse-array/package.json\":{\"offset\":1846436,\"length\":636,\"mode\":420},\"/node_modules/binary-stream-equals/index.js\":{\"offset\":1847072,\"length\":2018,\"mode\":420},\"/node_modules/binary-stream-equals/package.json\":{\"offset\":1849090,\"length\":687,\"mode\":420},\"/node_modules/bits-to-bytes/index.js\":{\"offset\":1849777,\"length\":3083,\"mode\":420},\"/node_modules/bits-to-bytes/package.json\":{\"offset\":1852860,\"length\":708,\"mode\":420},\"/node_modules/blind-pairing-core/index.js\":{\"offset\":1853568,\"length\":10708,\"mode\":420},\"/node_modules/blind-pairing-core/lib/errors.js\":{\"offset\":1864276,\"length\":706,\"mode\":420},\"/node_modules/blind-pairing-core/lib/messages.js\":{\"offset\":1864982,\"length\":5348,\"mode\":420},\"/node_modules/blind-pairing-core/package.json\":{\"offset\":1870330,\"length\":951,\"mode\":420},\"/node_modules/blind-pairing/index.js\":{\"offset\":1871281,\"length\":16910,\"mode\":420},\"/node_modules/blind-pairing/package.json\":{\"offset\":1888191,\"length\":1000,\"mode\":420},\"/node_modules/blind-relay/index.js\":{\"offset\":1889191,\"length\":11630,\"mode\":420},\"/node_modules/blind-relay/lib/errors.js\":{\"offset\":1900821,\"length\":1043,\"mode\":420},\"/node_modules/blind-relay/package.json\":{\"offset\":1901864,\"length\":1074,\"mode\":420},\"/node_modules/bogon/index.js\":{\"offset\":1902938,\"length\":3961,\"mode\":420},\"/node_modules/bogon/package.json\":{\"offset\":1906899,\"length\":657,\"mode\":420},\"/node_modules/codecs/index.js\":{\"offset\":1907556,\"length\":2416,\"mode\":420},\"/node_modules/codecs/package.json\":{\"offset\":1909972,\"length\":655,\"mode\":420},\"/node_modules/compact-encoding-bitfield/index.js\":{\"offset\":1910627,\"length\":1963,\"mode\":420},\"/node_modules/compact-encoding-bitfield/package.json\":{\"offset\":1912590,\"length\":827,\"mode\":420},\"/node_modules/compact-encoding-net/index.js\":{\"offset\":1913417,\"length\":4109,\"mode\":420},\"/node_modules/compact-encoding-net/package.json\":{\"offset\":1917526,\"length\":734,\"mode\":420},\"/node_modules/compact-encoding/endian.js\":{\"offset\":1918260,\"length\":103,\"mode\":420},\"/node_modules/compact-encoding/index.js\":{\"offset\":1918363,\"length\":19073,\"mode\":420},\"/node_modules/compact-encoding/lexint.js\":{\"offset\":1937436,\"length\":2824,\"mode\":420},\"/node_modules/compact-encoding/package.json\":{\"offset\":1940260,\"length\":713,\"mode\":420},\"/node_modules/compact-encoding/raw.js\":{\"offset\":1940973,\"length\":4118,\"mode\":420},\"/node_modules/core-coupler/index.js\":{\"offset\":1945091,\"length\":1494,\"mode\":420},\"/node_modules/core-coupler/package.json\":{\"offset\":1946585,\"length\":599,\"mode\":420},\"/node_modules/corestore/index.js\":{\"offset\":1947184,\"length\":17602,\"mode\":420},\"/node_modules/corestore/package.json\":{\"offset\":1964786,\"length\":1099,\"mode\":420},\"/node_modules/crc-native/binding.js\":{\"offset\":1965885,\"length\":54,\"mode\":420},\"/node_modules/crc-native/index.js\":{\"offset\":1965939,\"length\":120,\"mode\":420},\"/node_modules/crc-native/package.json\":{\"offset\":1966059,\"length\":973,\"mode\":420},\"/node_modules/crc-universal/fallback.js\":{\"offset\":1967032,\"length\":2020,\"mode\":420},\"/node_modules/crc-universal/index.js\":{\"offset\":1969052,\"length\":257,\"mode\":420},\"/node_modules/crc-universal/lookup.js\":{\"offset\":1969309,\"length\":439,\"mode\":420},\"/node_modules/crc-universal/package.json\":{\"offset\":1969748,\"length\":816,\"mode\":420},\"/node_modules/debounceify/index.js\":{\"offset\":1970564,\"length\":585,\"mode\":420},\"/node_modules/debounceify/package.json\":{\"offset\":1971149,\"length\":567,\"mode\":420},\"/node_modules/dht-rpc/index.js\":{\"offset\":1971716,\"length\":24419,\"mode\":420},\"/node_modules/dht-rpc/lib/commands.js\":{\"offset\":1996135,\"length\":82,\"mode\":420},\"/node_modules/dht-rpc/lib/errors.js\":{\"offset\":1996217,\"length\":724,\"mode\":420},\"/node_modules/dht-rpc/lib/io.js\":{\"offset\":1996941,\"length\":15190,\"mode\":420},\"/node_modules/dht-rpc/lib/peer.js\":{\"offset\":2012131,\"length\":645,\"mode\":420},\"/node_modules/dht-rpc/lib/query.js\":{\"offset\":2012776,\"length\":9369,\"mode\":420},\"/node_modules/dht-rpc/lib/session.js\":{\"offset\":2022145,\"length\":1084,\"mode\":420},\"/node_modules/dht-rpc/package.json\":{\"offset\":2023229,\"length\":1067,\"mode\":420},\"/node_modules/fast-fifo/fixed-size.js\":{\"offset\":2024296,\"length\":875,\"mode\":420},\"/node_modules/fast-fifo/index.js\":{\"offset\":2025171,\"length\":972,\"mode\":420},\"/node_modules/fast-fifo/package.json\":{\"offset\":2026143,\"length\":682,\"mode\":420},\"/node_modules/flat-tree/index.js\":{\"offset\":2026825,\"length\":7590,\"mode\":420},\"/node_modules/flat-tree/package.json\":{\"offset\":2034415,\"length\":631,\"mode\":420},\"/node_modules/fs-native-extensions/binding.js\":{\"offset\":2035046,\"length\":54,\"mode\":420},\"/node_modules/fs-native-extensions/index.js\":{\"offset\":2035100,\"length\":4270,\"mode\":420},\"/node_modules/fs-native-extensions/package.json\":{\"offset\":2039370,\"length\":1569,\"mode\":420},\"/node_modules/get-mime-type/index.js\":{\"offset\":2040939,\"length\":63498,\"mode\":420},\"/node_modules/get-mime-type/package.json\":{\"offset\":2104437,\"length\":525,\"mode\":420},\"/node_modules/hyperbee-diff-stream/index.js\":{\"offset\":2104962,\"length\":4327,\"mode\":420},\"/node_modules/hyperbee-diff-stream/package.json\":{\"offset\":2109289,\"length\":963,\"mode\":420},\"/node_modules/hyperbee/index.js\":{\"offset\":2110252,\"length\":41379,\"mode\":420},\"/node_modules/hyperbee/iterators/diff.js\":{\"offset\":2151631,\"length\":5368,\"mode\":420},\"/node_modules/hyperbee/iterators/history.js\":{\"offset\":2156999,\"length\":1642,\"mode\":420},\"/node_modules/hyperbee/iterators/range.js\":{\"offset\":2158641,\"length\":4734,\"mode\":420},\"/node_modules/hyperbee/lib/extension.js\":{\"offset\":2163375,\"length\":3445,\"mode\":420},\"/node_modules/hyperbee/lib/messages.js\":{\"offset\":2166820,\"length\":28162,\"mode\":420},\"/node_modules/hyperbee/package.json\":{\"offset\":2194982,\"length\":1242,\"mode\":420},\"/node_modules/hyperblobs/index.js\":{\"offset\":2196224,\"length\":5327,\"mode\":420},\"/node_modules/hyperblobs/lib/monitor.js\":{\"offset\":2201551,\"length\":2393,\"mode\":420},\"/node_modules/hyperblobs/lib/prefetcher.js\":{\"offset\":2203944,\"length\":1638,\"mode\":420},\"/node_modules/hyperblobs/lib/streams.js\":{\"offset\":2205582,\"length\":3595,\"mode\":420},\"/node_modules/hyperblobs/package.json\":{\"offset\":2209177,\"length\":1056,\"mode\":420},\"/node_modules/hypercore-crypto/index.js\":{\"offset\":2210233,\"length\":4820,\"mode\":420},\"/node_modules/hypercore-crypto/package.json\":{\"offset\":2215053,\"length\":771,\"mode\":420},\"/node_modules/hypercore-errors/index.js\":{\"offset\":2215824,\"length\":3862,\"mode\":420},\"/node_modules/hypercore-errors/package.json\":{\"offset\":2219686,\"length\":604,\"mode\":420},\"/node_modules/hypercore-id-encoding/index.js\":{\"offset\":2220290,\"length\":923,\"mode\":420},\"/node_modules/hypercore-id-encoding/package.json\":{\"offset\":2221213,\"length\":799,\"mode\":420},\"/node_modules/hypercore/errors.js\":{\"offset\":2222012,\"length\":87,\"mode\":420},\"/node_modules/hypercore/index.js\":{\"offset\":2222099,\"length\":34150,\"mode\":420},\"/node_modules/hypercore/lib/audit.js\":{\"offset\":2256249,\"length\":3098,\"mode\":420},\"/node_modules/hypercore/lib/batch.js\":{\"offset\":2259347,\"length\":12366,\"mode\":420},\"/node_modules/hypercore/lib/big-header.js\":{\"offset\":2271713,\"length\":1270,\"mode\":420},\"/node_modules/hypercore/lib/bitfield.js\":{\"offset\":2272983,\"length\":11449,\"mode\":420},\"/node_modules/hypercore/lib/block-encryption.js\":{\"offset\":2284432,\"length\":2290,\"mode\":420},\"/node_modules/hypercore/lib/block-store.js\":{\"offset\":2286722,\"length\":1507,\"mode\":420},\"/node_modules/hypercore/lib/caps.js\":{\"offset\":2288229,\"length\":1515,\"mode\":420},\"/node_modules/hypercore/lib/compat.js\":{\"offset\":2289744,\"length\":477,\"mode\":420},\"/node_modules/hypercore/lib/core.js\":{\"offset\":2290221,\"length\":32348,\"mode\":420},\"/node_modules/hypercore/lib/download.js\":{\"offset\":2322569,\"length\":347,\"mode\":420},\"/node_modules/hypercore/lib/hotswap-queue.js\":{\"offset\":2322916,\"length\":1504,\"mode\":420},\"/node_modules/hypercore/lib/info.js\":{\"offset\":2324420,\"length\":1521,\"mode\":420},\"/node_modules/hypercore/lib/merkle-tree.js\":{\"offset\":2325941,\"length\":35420,\"mode\":420},\"/node_modules/hypercore/lib/messages.js\":{\"offset\":2361361,\"length\":26102,\"mode\":420},\"/node_modules/hypercore/lib/multisig.js\":{\"offset\":2387463,\"length\":2608,\"mode\":420},\"/node_modules/hypercore/lib/mutex.js\":{\"offset\":2390071,\"length\":927,\"mode\":420},\"/node_modules/hypercore/lib/oplog.js\":{\"offset\":2390998,\"length\":6328,\"mode\":420},\"/node_modules/hypercore/lib/receiver-queue.js\":{\"offset\":2397326,\"length\":1419,\"mode\":420},\"/node_modules/hypercore/lib/remote-bitfield.js\":{\"offset\":2398745,\"length\":8089,\"mode\":420},\"/node_modules/hypercore/lib/replicator.js\":{\"offset\":2406834,\"length\":70070,\"mode\":420},\"/node_modules/hypercore/lib/streams.js\":{\"offset\":2476904,\"length\":2857,\"mode\":420},\"/node_modules/hypercore/lib/verifier.js\":{\"offset\":2479761,\"length\":8768,\"mode\":420},\"/node_modules/hypercore/package.json\":{\"offset\":2488529,\"length\":2069,\"mode\":420},\"/node_modules/hyperdht/index.js\":{\"offset\":2490598,\"length\":14911,\"mode\":420},\"/node_modules/hyperdht/lib/announcer.js\":{\"offset\":2505509,\"length\":7252,\"mode\":420},\"/node_modules/hyperdht/lib/connect.js\":{\"offset\":2512761,\"length\":22662,\"mode\":420},\"/node_modules/hyperdht/lib/connection-pool.js\":{\"offset\":2535423,\"length\":3120,\"mode\":420},\"/node_modules/hyperdht/lib/constants.js\":{\"offset\":2538543,\"length\":1207,\"mode\":420},\"/node_modules/hyperdht/lib/crypto.js\":{\"offset\":2539750,\"length\":635,\"mode\":420},\"/node_modules/hyperdht/lib/encode.js\":{\"offset\":2540385,\"length\":447,\"mode\":420},\"/node_modules/hyperdht/lib/errors.js\":{\"offset\":2540832,\"length\":3713,\"mode\":420},\"/node_modules/hyperdht/lib/holepuncher.js\":{\"offset\":2544545,\"length\":10013,\"mode\":420},\"/node_modules/hyperdht/lib/messages.js\":{\"offset\":2554558,\"length\":10440,\"mode\":420},\"/node_modules/hyperdht/lib/nat.js\":{\"offset\":2564998,\"length\":4694,\"mode\":420},\"/node_modules/hyperdht/lib/noise-wrap.js\":{\"offset\":2569692,\"length\":1673,\"mode\":420},\"/node_modules/hyperdht/lib/persistent.js\":{\"offset\":2571365,\"length\":7857,\"mode\":420},\"/node_modules/hyperdht/lib/raw-stream-set.js\":{\"offset\":2579222,\"length\":1427,\"mode\":420},\"/node_modules/hyperdht/lib/router.js\":{\"offset\":2580649,\"length\":6411,\"mode\":420},\"/node_modules/hyperdht/lib/secure-payload.js\":{\"offset\":2587060,\"length\":1495,\"mode\":420},\"/node_modules/hyperdht/lib/semaphore.js\":{\"offset\":2588555,\"length\":995,\"mode\":420},\"/node_modules/hyperdht/lib/server.js\":{\"offset\":2589550,\"length\":19958,\"mode\":420},\"/node_modules/hyperdht/lib/sleeper.js\":{\"offset\":2609508,\"length\":693,\"mode\":420},\"/node_modules/hyperdht/lib/socket-pool.js\":{\"offset\":2610201,\"length\":4371,\"mode\":420},\"/node_modules/hyperdht/package.json\":{\"offset\":2614572,\"length\":1825,\"mode\":420},\"/node_modules/hyperdrive/index.js\":{\"offset\":2616397,\"length\":18660,\"mode\":420},\"/node_modules/hyperdrive/lib/monitor.js\":{\"offset\":2635057,\"length\":3778,\"mode\":420},\"/node_modules/hyperdrive/package.json\":{\"offset\":2638835,\"length\":1225,\"mode\":420},\"/node_modules/hyperswarm/index.js\":{\"offset\":2640060,\"length\":15627,\"mode\":420},\"/node_modules/hyperswarm/lib/bulk-timer.js\":{\"offset\":2655687,\"length\":732,\"mode\":420},\"/node_modules/hyperswarm/lib/connection-set.js\":{\"offset\":2656419,\"length\":775,\"mode\":420},\"/node_modules/hyperswarm/lib/peer-discovery.js\":{\"offset\":2657194,\"length\":7857,\"mode\":420},\"/node_modules/hyperswarm/lib/peer-info.js\":{\"offset\":2665051,\"length\":2623,\"mode\":420},\"/node_modules/hyperswarm/lib/retry-timer.js\":{\"offset\":2667674,\"length\":1821,\"mode\":420},\"/node_modules/hyperswarm/package.json\":{\"offset\":2669495,\"length\":1101,\"mode\":420},\"/node_modules/hypertrace/index.js\":{\"offset\":2670596,\"length\":3271,\"mode\":420},\"/node_modules/hypertrace/package.json\":{\"offset\":2673867,\"length\":386,\"mode\":420},\"/node_modules/index-encoder/index.js\":{\"offset\":2674253,\"length\":6644,\"mode\":420},\"/node_modules/index-encoder/package.json\":{\"offset\":2680897,\"length\":729,\"mode\":420},\"/node_modules/is-options/index.js\":{\"offset\":2681626,\"length\":140,\"mode\":420},\"/node_modules/is-options/package.json\":{\"offset\":2681766,\"length\":605,\"mode\":420},\"/node_modules/kademlia-routing-table/index.js\":{\"offset\":2682371,\"length\":4145,\"mode\":420},\"/node_modules/kademlia-routing-table/package.json\":{\"offset\":2686516,\"length\":967,\"mode\":420},\"/node_modules/mirror-drive/index.js\":{\"offset\":2687483,\"length\":4791,\"mode\":420},\"/node_modules/mirror-drive/package.json\":{\"offset\":2692274,\"length\":865,\"mode\":420},\"/node_modules/mutexify/index.js\":{\"offset\":2693139,\"length\":536,\"mode\":420},\"/node_modules/mutexify/package.json\":{\"offset\":2693675,\"length\":679,\"mode\":420},\"/node_modules/mutexify/promise.js\":{\"offset\":2694354,\"length\":324,\"mode\":420},\"/node_modules/nanoassert/index.js\":{\"offset\":2694678,\"length\":438,\"mode\":420},\"/node_modules/nanoassert/package.json\":{\"offset\":2695116,\"length\":647,\"mode\":420},\"/node_modules/nat-sampler/index.js\":{\"offset\":2695763,\"length\":1550,\"mode\":420},\"/node_modules/nat-sampler/package.json\":{\"offset\":2697313,\"length\":608,\"mode\":420},\"/node_modules/node-gyp-build/index.js\":{\"offset\":2697921,\"length\":390,\"mode\":420},\"/node_modules/node-gyp-build/node-gyp-build.js\":{\"offset\":2698311,\"length\":6078,\"mode\":420},\"/node_modules/node-gyp-build/package.json\":{\"offset\":2704389,\"length\":1004,\"mode\":420},\"/node_modules/noise-curve-ed/index.js\":{\"offset\":2705393,\"length\":1642,\"mode\":420},\"/node_modules/noise-curve-ed/package.json\":{\"offset\":2707035,\"length\":883,\"mode\":420},\"/node_modules/noise-handshake/cipher.js\":{\"offset\":2707918,\"length\":2533,\"mode\":420},\"/node_modules/noise-handshake/dh.js\":{\"offset\":2710451,\"length\":1439,\"mode\":420},\"/node_modules/noise-handshake/hkdf.js\":{\"offset\":2711890,\"length\":1305,\"mode\":420},\"/node_modules/noise-handshake/hmac.js\":{\"offset\":2713195,\"length\":1278,\"mode\":420},\"/node_modules/noise-handshake/noise.js\":{\"offset\":2714473,\"length\":6345,\"mode\":420},\"/node_modules/noise-handshake/package.json\":{\"offset\":2720818,\"length\":566,\"mode\":420},\"/node_modules/noise-handshake/symmetric-state.js\":{\"offset\":2721384,\"length\":2206,\"mode\":420},\"/node_modules/parallel-transformx/index.js\":{\"offset\":2723590,\"length\":2076,\"mode\":420},\"/node_modules/parallel-transformx/package.json\":{\"offset\":2725666,\"length\":526,\"mode\":420},\"/node_modules/pear-inspect/index.js\":{\"offset\":2726192,\"length\":7524,\"mode\":420},\"/node_modules/pear-inspect/package.json\":{\"offset\":2733716,\"length\":1308,\"mode\":420},\"/node_modules/promaphore/index.js\":{\"offset\":2735024,\"length\":995,\"mode\":420},\"/node_modules/promaphore/package.json\":{\"offset\":2736019,\"length\":450,\"mode\":420},\"/node_modules/protocol-buffers-encodings/index.js\":{\"offset\":2736469,\"length\":6489,\"mode\":420},\"/node_modules/protocol-buffers-encodings/package.json\":{\"offset\":2742958,\"length\":719,\"mode\":420},\"/node_modules/protomux-rpc/index.js\":{\"offset\":2743677,\"length\":8629,\"mode\":420},\"/node_modules/protomux-rpc/lib/errors.js\":{\"offset\":2752306,\"length\":1297,\"mode\":420},\"/node_modules/protomux-rpc/package.json\":{\"offset\":2753603,\"length\":1023,\"mode\":420},\"/node_modules/protomux/index.js\":{\"offset\":2754626,\"length\":18996,\"mode\":420},\"/node_modules/protomux/package.json\":{\"offset\":2773622,\"length\":816,\"mode\":420},\"/node_modules/queue-tick/package.json\":{\"offset\":2774438,\"length\":669,\"mode\":420},\"/node_modules/queue-tick/process-next-tick.js\":{\"offset\":2775107,\"length\":160,\"mode\":420},\"/node_modules/queue-tick/queue-microtask.js\":{\"offset\":2775267,\"length\":108,\"mode\":420},\"/node_modules/quickbit-native/binding.js\":{\"offset\":2775375,\"length\":54,\"mode\":420},\"/node_modules/quickbit-native/index.js\":{\"offset\":2775429,\"length\":4123,\"mode\":420},\"/node_modules/quickbit-native/package.json\":{\"offset\":2779552,\"length\":1019,\"mode\":420},\"/node_modules/quickbit-universal/fallback.js\":{\"offset\":2780571,\"length\":10204,\"mode\":420},\"/node_modules/quickbit-universal/index.js\":{\"offset\":2790775,\"length\":442,\"mode\":420},\"/node_modules/quickbit-universal/package.json\":{\"offset\":2791217,\"length\":908,\"mode\":420},\"/node_modules/rache/index.js\":{\"offset\":2792125,\"length\":2463,\"mode\":420},\"/node_modules/rache/package.json\":{\"offset\":2794588,\"length\":602,\"mode\":420},\"/node_modules/random-access-file/index.js\":{\"offset\":2795190,\"length\":6089,\"mode\":420},\"/node_modules/random-access-file/package.json\":{\"offset\":2801279,\"length\":1091,\"mode\":420},\"/node_modules/random-access-storage/index.js\":{\"offset\":2802370,\"length\":7557,\"mode\":420},\"/node_modules/random-access-storage/package.json\":{\"offset\":2809927,\"length\":861,\"mode\":420},\"/node_modules/random-array-iterator/index.js\":{\"offset\":2810788,\"length\":1001,\"mode\":420},\"/node_modules/random-array-iterator/package.json\":{\"offset\":2811789,\"length\":700,\"mode\":420},\"/node_modules/range-parser/index.js\":{\"offset\":2812489,\"length\":2900,\"mode\":420},\"/node_modules/range-parser/package.json\":{\"offset\":2815389,\"length\":1184,\"mode\":420},\"/node_modules/read-write-mutexify/index.js\":{\"offset\":2816573,\"length\":2646,\"mode\":420},\"/node_modules/read-write-mutexify/package.json\":{\"offset\":2819219,\"length\":602,\"mode\":420},\"/node_modules/ready-resource/index.js\":{\"offset\":2819821,\"length\":1032,\"mode\":420},\"/node_modules/ready-resource/package.json\":{\"offset\":2820853,\"length\":759,\"mode\":420},\"/node_modules/record-cache/index.js\":{\"offset\":2821612,\"length\":3668,\"mode\":420},\"/node_modules/record-cache/package.json\":{\"offset\":2825280,\"length\":612,\"mode\":420},\"/node_modules/safety-catch/index.js\":{\"offset\":2825892,\"length\":506,\"mode\":420},\"/node_modules/safety-catch/package.json\":{\"offset\":2826398,\"length\":547,\"mode\":420},\"/node_modules/same-data/index.js\":{\"offset\":2826945,\"length\":1126,\"mode\":420},\"/node_modules/same-data/package.json\":{\"offset\":2828071,\"length\":629,\"mode\":420},\"/node_modules/serve-drive/index.js\":{\"offset\":2828700,\"length\":8193,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-dns/binding.js\":{\"offset\":2836893,\"length\":33,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-dns/index.js\":{\"offset\":2836926,\"length\":895,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-dns/package.json\":{\"offset\":2837821,\"length\":939,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-http1/index.js\":{\"offset\":2838760,\"length\":1917,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-http1/lib/agent.js\":{\"offset\":2840677,\"length\":2834,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-http1/lib/client-connection.js\":{\"offset\":2843511,\"length\":6174,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-http1/lib/client-request.js\":{\"offset\":2849685,\"length\":2541,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-http1/lib/constants.js\":{\"offset\":2852226,\"length\":2121,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-http1/lib/errors.js\":{\"offset\":2854347,\"length\":545,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-http1/lib/incoming-message.js\":{\"offset\":2854892,\"length\":937,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-http1/lib/outgoing-message.js\":{\"offset\":2855829,\"length\":1023,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-http1/lib/server-connection.js\":{\"offset\":2856852,\"length\":6546,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-http1/lib/server-response.js\":{\"offset\":2863398,\"length\":2760,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-http1/lib/server.js\":{\"offset\":2866158,\"length\":956,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-http1/package.json\":{\"offset\":2867114,\"length\":867,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-tcp/binding.js\":{\"offset\":2867981,\"length\":33,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-tcp/index.js\":{\"offset\":2868014,\"length\":12375,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-tcp/lib/constants.js\":{\"offset\":2880389,\"length\":167,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-tcp/lib/errors.js\":{\"offset\":2880556,\"length\":841,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-tcp/lib/ip.js\":{\"offset\":2881397,\"length\":2204,\"mode\":420},\"/node_modules/serve-drive/node_modules/bare-tcp/package.json\":{\"offset\":2883601,\"length\":1126,\"mode\":420},\"/node_modules/serve-drive/package.json\":{\"offset\":2884727,\"length\":1215,\"mode\":420},\"/node_modules/shuffled-priority-queue/index.js\":{\"offset\":2885942,\"length\":2607,\"mode\":420},\"/node_modules/shuffled-priority-queue/package.json\":{\"offset\":2888549,\"length\":691,\"mode\":420},\"/node_modules/signal-promise/index.js\":{\"offset\":2889240,\"length\":1252,\"mode\":420},\"/node_modules/signal-promise/package.json\":{\"offset\":2890492,\"length\":503,\"mode\":420},\"/node_modules/signed-varint/index.js\":{\"offset\":2890995,\"length\":435,\"mode\":420},\"/node_modules/signed-varint/package.json\":{\"offset\":2891430,\"length\":523,\"mode\":420},\"/node_modules/simdle-native/binding.js\":{\"offset\":2891953,\"length\":54,\"mode\":420},\"/node_modules/simdle-native/index.js\":{\"offset\":2892007,\"length\":3203,\"mode\":420},\"/node_modules/simdle-native/package.json\":{\"offset\":2895210,\"length\":1009,\"mode\":420},\"/node_modules/simdle-universal/fallback.js\":{\"offset\":2896219,\"length\":5137,\"mode\":420},\"/node_modules/simdle-universal/index.js\":{\"offset\":2901356,\"length\":103,\"mode\":420},\"/node_modules/simdle-universal/package.json\":{\"offset\":2901459,\"length\":879,\"mode\":420},\"/node_modules/simdle-universal/scalar.js\":{\"offset\":2902338,\"length\":469,\"mode\":420},\"/node_modules/sodium-native/index.js\":{\"offset\":2902807,\"length\":54,\"mode\":420},\"/node_modules/sodium-native/package.json\":{\"offset\":2902861,\"length\":1094,\"mode\":420},\"/node_modules/sodium-secretstream/index.js\":{\"offset\":2903955,\"length\":2257,\"mode\":420},\"/node_modules/sodium-secretstream/package.json\":{\"offset\":2906212,\"length\":657,\"mode\":420},\"/node_modules/sodium-universal/index.js\":{\"offset\":2906869,\"length\":42,\"mode\":420},\"/node_modules/sodium-universal/package.json\":{\"offset\":2906911,\"length\":1064,\"mode\":420},\"/node_modules/sorted-union-stream/index.js\":{\"offset\":2907975,\"length\":3082,\"mode\":420},\"/node_modules/sorted-union-stream/package.json\":{\"offset\":2911057,\"length\":707,\"mode\":420},\"/node_modules/speedometer/index.js\":{\"offset\":2911764,\"length\":906,\"mode\":420},\"/node_modules/speedometer/package.json\":{\"offset\":2912670,\"length\":333,\"mode\":420},\"/node_modules/streamx/index.js\":{\"offset\":2913003,\"length\":33174,\"mode\":420},\"/node_modules/streamx/package.json\":{\"offset\":2946177,\"length\":912,\"mode\":420},\"/node_modules/sub-encoder/index.js\":{\"offset\":2947089,\"length\":1968,\"mode\":420},\"/node_modules/sub-encoder/package.json\":{\"offset\":2949057,\"length\":908,\"mode\":420},\"/node_modules/text-decoder/index.js\":{\"offset\":2949965,\"length\":1378,\"mode\":420},\"/node_modules/text-decoder/lib/pass-through-decoder.js\":{\"offset\":2951343,\"length\":273,\"mode\":420},\"/node_modules/text-decoder/lib/utf8-decoder.js\":{\"offset\":2951616,\"length\":2529,\"mode\":420},\"/node_modules/text-decoder/package.json\":{\"offset\":2954145,\"length\":987,\"mode\":420},\"/node_modules/time-ordered-set/index.js\":{\"offset\":2955132,\"length\":1444,\"mode\":420},\"/node_modules/time-ordered-set/package.json\":{\"offset\":2956576,\"length\":666,\"mode\":420},\"/node_modules/timeout-refresh/browser.js\":{\"offset\":2957242,\"length\":1098,\"mode\":420},\"/node_modules/timeout-refresh/index.js\":{\"offset\":2958340,\"length\":184,\"mode\":420},\"/node_modules/timeout-refresh/node.js\":{\"offset\":2958524,\"length\":928,\"mode\":420},\"/node_modules/timeout-refresh/package.json\":{\"offset\":2959452,\"length\":619,\"mode\":420},\"/node_modules/tiny-buffer-map/index.js\":{\"offset\":2960071,\"length\":936,\"mode\":420},\"/node_modules/tiny-buffer-map/package.json\":{\"offset\":2961007,\"length\":650,\"mode\":420},\"/node_modules/tiny-buffer-rpc/any.js\":{\"offset\":2961657,\"length\":2475,\"mode\":420},\"/node_modules/tiny-buffer-rpc/index.js\":{\"offset\":2964132,\"length\":11707,\"mode\":420},\"/node_modules/tiny-buffer-rpc/messages.js\":{\"offset\":2975839,\"length\":2105,\"mode\":420},\"/node_modules/tiny-buffer-rpc/package.json\":{\"offset\":2977944,\"length\":713,\"mode\":420},\"/node_modules/udx-native/binding.js\":{\"offset\":2978657,\"length\":54,\"mode\":420},\"/node_modules/udx-native/lib/ip.js\":{\"offset\":2978711,\"length\":2179,\"mode\":420},\"/node_modules/udx-native/lib/network-interfaces.js\":{\"offset\":2980890,\"length\":1335,\"mode\":420},\"/node_modules/udx-native/lib/socket.js\":{\"offset\":2982225,\"length\":7445,\"mode\":420},\"/node_modules/udx-native/lib/stream.js\":{\"offset\":2989670,\"length\":12546,\"mode\":420},\"/node_modules/udx-native/lib/udx.js\":{\"offset\":3002216,\"length\":2842,\"mode\":420},\"/node_modules/udx-native/package.json\":{\"offset\":3005058,\"length\":1469,\"mode\":420},\"/node_modules/unix-path-resolve/index.js\":{\"offset\":3006527,\"length\":1356,\"mode\":420},\"/node_modules/unix-path-resolve/package.json\":{\"offset\":3007883,\"length\":651,\"mode\":420},\"/node_modules/unordered-set/index.js\":{\"offset\":3008534,\"length\":677,\"mode\":420},\"/node_modules/unordered-set/package.json\":{\"offset\":3009211,\"length\":654,\"mode\":420},\"/node_modules/unslab/index.js\":{\"offset\":3009865,\"length\":913,\"mode\":420},\"/node_modules/unslab/package.json\":{\"offset\":3010778,\"length\":613,\"mode\":420},\"/node_modules/varint/decode.js\":{\"offset\":3011391,\"length\":508,\"mode\":420},\"/node_modules/varint/encode.js\":{\"offset\":3011899,\"length\":452,\"mode\":420},\"/node_modules/varint/index.js\":{\"offset\":3012351,\"length\":134,\"mode\":420},\"/node_modules/varint/length.js\":{\"offset\":3012485,\"length\":471,\"mode\":420},\"/node_modules/varint/package.json\":{\"offset\":3012956,\"length\":511,\"mode\":420},\"/node_modules/which-runtime/index.js\":{\"offset\":3013467,\"length\":1222,\"mode\":420},\"/node_modules/which-runtime/package.json\":{\"offset\":3014689,\"length\":602,\"mode\":420},\"/node_modules/xache/index.js\":{\"offset\":3015291,\"length\":2378,\"mode\":420},\"/node_modules/xache/package.json\":{\"offset\":3017669,\"length\":584,\"mode\":420},\"/node_modules/xor-distance/index.js\":{\"offset\":3018253,\"length\":702,\"mode\":420},\"/node_modules/xor-distance/package.json\":{\"offset\":3018955,\"length\":616,\"mode\":420},\"/node_modules/z32/index.js\":{\"offset\":3019571,\"length\":2654,\"mode\":420},\"/node_modules/z32/package.json\":{\"offset\":3022225,\"length\":701,\"mode\":420},\"/package.json\":{\"offset\":3022926,\"length\":2564,\"mode\":420}}}\nconst { Inspector } = require('pear-inspect')\n\nmodule.exports = class KeetInspector {\n  constructor() {\n    this._key = null\n    this._inspector = null\n  }\n\n  get key() {\n    return this._key\n  }\n\n  async enable() {\n    if (this._key) return this._key\n\n    this._inspector = new Inspector()\n\n    const key = await this._inspector.enable()\n    this._key = key.toString('hex')\n\n    return this._key\n  }\n\n  async disable() {\n    await this._inspector?.disable()\n    this._inspector = null\n    this._key = null\n  }\n}\n/* global Bare, BareKit */\n/* eslint-disable no-bitwise */\n\nconst RPC = require('tiny-buffer-rpc');\nconst any = require('tiny-buffer-rpc/any');\nconst id = require('hypercore-id-encoding');\nconst {version: dhtVersion} = require('hyperdht/package');\nconst KeetBackend = require('@holepunchto/keet-backend');\nconst registerServer = require('@holepunchto/keet-backend-rpc/server');\nconst KeetInspector = require('./lib/inspector');\n\nconst storage = Bare.argv[0];\nconst experimental = Bare.argv[1] === 'experimental';\n\nconst backend = new KeetBackend(storage, {experimental, mobile: true});\n\nconst rpc = new RPC(data => BareKit.IPC.write(data));\n\nBareKit.IPC.on('data', data => rpc.recv(data));\nregisterServer(backend, rpc);\n\nconst inspector = new KeetInspector();\n\nrpc.register(1 << 8, {\n  request: any,\n  response: any,\n  onstream: async stream => {\n    stream.on('error', noop);\n\n    if (backend.opened === false) {\n      await backend.ready();\n    }\n\n    if (stream.destroying) {\n      return;\n    }\n\n    backend._swarm\n      .on('update', onupdate)\n      .dht.on('nat-update', onupdate)\n      .on('network-update', onupdate);\n\n    stream.on('close', () => {\n      backend._swarm\n        .off('update', onupdate)\n        .dht.off('nat-update', onupdate)\n        .off('network-update', onupdate);\n    });\n\n    onupdate();\n\n    function onupdate() {\n      const {\n        host,\n        port,\n        online,\n        connections: {size: peerCount},\n      } = backend._swarm;\n\n      stream.write({host, port, online, peerCount, dhtVersion});\n    }\n  },\n});\n\nrpc.register(2 << 8, {\n  request: any,\n  response: any,\n  onrequest: async () => {\n    if (backend.opened === false) {\n      await backend.ready();\n    }\n\n    return id.encode(backend._swarm.keyPair.publicKey);\n  },\n});\n\nrpc.register(3 << 8, {\n  request: any,\n  response: any,\n  onrequest: () => inspector.enable(),\n});\n\nrpc.register(4 << 8, {\n  request: any,\n  response: any,\n  onrequest: inspector.disable(),\n});\n\nrpc.register(5 << 8, {\n  request: any,\n  response: any,\n  onrequest: inspector.key,\n});\n\nrpc.register(6 << 8, {\n  request: any,\n  response: any,\n  onstream: stream => {\n    stream.on('error', noop);\n\n    Bare.on('uncaughtException', onerror).on('unhandledRejection', onerror);\n\n    stream.on('close', () => {\n      Bare.off('uncaughtException', onerror).off('unhandledRejection', onerror);\n    });\n\n    function onerror(err) {\n      stream.write({message: err.message, stack: err.stack.toString()});\n    }\n  },\n});\n\nfunction noop() {}\n\n/**\n npx bare-pack --out app/main.bundle.js main.js --target ios-arm64 --target ios-arm64-simulator --target ios-x64-simulator --target android-arm --target android-arm64 --target android-ia32 --target android-x64 --linked\n */\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\nconst assert = require('nanoassert')\nconst { detectLanguage, loadWordlist } = require('./wordlist')\n\nmodule.exports = {\n  generateEntropy,\n  generateMnemonic,\n  normalizeMnemonic,\n  validateMnemonic,\n  mnemonicToSeed\n}\n\nfunction generateMnemonic ({ entropy = generateEntropy(), language = 'english' } = {}) {\n  const wordlist = loadWordlist(language)\n  const extended = computeCheckSum(entropy)\n\n  const words = []\n\n  for (const index of uint11Reader(extended)) {\n    words.push(wordlist[index])\n  }\n\n  const delimiter = language === 'japanese' ? '\\u3000' : ' '\n\n  return words.join(delimiter).trim()\n}\n\nfunction normalizeMnemonic (mnemonic) {\n  return mnemonic.trim().replace(/\\u3000/, ' ').split(/\\s+/).map(c => c.toLowerCase()).join(' ')\n}\n\nasync function mnemonicToSeed (mnemonic, passphrase = '') {\n  mnemonic = normalizeMnemonic(mnemonic)\n\n  if (!validateMnemonic(mnemonic)) {\n    throw new Error('Invalid mnemonic')\n  }\n\n  const input = b4a.from(mnemonic)\n  const salt = b4a.from('mnemonic' + passphrase)\n\n  const output = b4a.alloc(64)\n\n  await sodium.extension_pbkdf2_sha512_async(\n    output,\n    input,\n    salt,\n    2048,\n    64\n  )\n\n  return output\n}\n\nfunction validateMnemonic (mnemonic) {\n  const words = mnemonic.replace(/\\u3000/g, ' ').trim().split(' ')\n  const language = detectLanguage(words)\n\n  if (!language) return false\n  if (words.length % 3 !== 0) return false\n\n  const wordlist = loadWordlist(language)\n\n  const indexes = []\n  for (const word of words) {\n    const index = wordlist.indexOf(word)\n    if (index === -1) return false\n\n    indexes.push(index)\n  }\n\n  const bits = words.length * 11\n  const entropy = (bits * 32 / 33) >> 3\n\n  const extended = b4a.alloc(Math.ceil(bits / 8))\n  const seed = extended.subarray(0, entropy)\n\n  try {\n    uint11Writer(extended, indexes)\n  } catch (e) {\n    return false\n  }\n\n  return b4a.equals(extended, computeCheckSum(seed))\n}\n\nfunction sha256 (data, output = b4a.alloc(32)) {\n  sodium.crypto_hash_sha256(output, data)\n  return output\n}\n\nfunction computeCheckSum (seed) {\n  assert((seed.byteLength & 4) === 0, 'seed must be a multiple of 4 bytes')\n\n  const len = seed.byteLength\n  const cklen = len >> 2 // cksum bits\n  const total = len + Math.ceil(cklen / 8)\n\n  const output = b4a.alloc(len + 32)\n  output.set(seed)\n\n  const entropy = output.subarray(0, len)\n  const cksum = output.subarray(len)\n\n  sha256(entropy, cksum)\n\n  // only append cklen bits\n  output[total - 1] &= (0xff ^ (0xff >> cklen))\n\n  return output.subarray(0, total)\n}\n\nfunction generateEntropy (length = 32) {\n  const seed = b4a.alloc(length)\n  sodium.randombytes_buf(seed)\n\n  return seed\n}\n\nfunction * uint11Reader (state) {\n  yield * uintReader(state, 11)\n}\n\nfunction uint11Writer (buf, uints) {\n  return uintWriter(buf, uints, 11)\n}\n\nfunction * uintReader (buffer, width) {\n  const MASK = (2 << (width - 1)) - 1\n\n  let pos = 0\n  let value = 0\n\n  while (true) {\n    const offset = pos >> 3 // byte offset\n\n    if (offset >= buffer.byteLength) {\n      return value & MASK\n    }\n\n    const height = width - (pos % width)\n    const leftover = (offset + 1) * 8 - pos\n\n    value += shift(buffer[offset], height - leftover)\n\n    pos += Math.min(height, leftover)\n    if (pos % width) continue\n\n    yield value & MASK\n\n    value = 0\n  }\n}\n\nfunction uintWriter (buffer, uints, width) {\n  let pos = 0\n\n  while (true) {\n    const offset = pos >> 3 // byte offset\n\n    const i = Math.floor(pos / width)\n    if (i >= uints.length) break\n\n    if (offset >= buffer.length) {\n      throw new Error('Failed to encode uints')\n    }\n\n    const rem = 8 - pos % 8\n    const height = (i + 1) * width - pos\n\n    const value = shift(uints[i], rem - height)\n\n    buffer[offset] += mask(value, rem)\n\n    pos += Math.min(rem, height)\n  }\n\n  return buffer\n}\n\n// when n is positive, shift left n bits\n// when n is negative, shift right -n bits\nfunction shift (val, n) {\n  if (n === 0) return val\n  if (n > 0) return val << n\n\n  return val >> (-1 * n)\n}\n\nfunction mask (val, bits) {\n  if (bits < 32) return val & ((1 << bits) - 1)\n  return val % (2 ** bits)\n}\n{\n  \"name\": \"@holepunchto/bip39\",\n  \"version\": \"2.2.0\",\n  \"description\": \"BIP39 mnemonic for key derivation schemes\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"generate-wordlist\": \"node scripts/generate-wordlist.js\",\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"author\": \"Holepunch Inc\",\n  \"license\": \"Apache-2.0\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.4.0\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.6.6\",\n    \"nanoassert\": \"^2.0.0\",\n    \"sodium-universal\": \"^4.0.1\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"wordlist\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bip39.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bip39/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bip39#readme\"\n}\n[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"][\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"][\"abdikace\",\"abeceda\",\"adresa\",\"agrese\",\"akce\",\"aktovka\",\"alej\",\"alkohol\",\"amputace\",\"ananas\",\"andulka\",\"anekdota\",\"anketa\",\"antika\",\"anulovat\",\"archa\",\"arogance\",\"asfalt\",\"asistent\",\"aspirace\",\"astma\",\"astronom\",\"atlas\",\"atletika\",\"atol\",\"autobus\",\"azyl\",\"babka\",\"bachor\",\"bacil\",\"baculka\",\"badatel\",\"bageta\",\"bagr\",\"bahno\",\"bakterie\",\"balada\",\"baletka\",\"balkon\",\"balonek\",\"balvan\",\"balza\",\"bambus\",\"bankomat\",\"barbar\",\"baret\",\"barman\",\"baroko\",\"barva\",\"baterka\",\"batoh\",\"bavlna\",\"bazalka\",\"bazilika\",\"bazuka\",\"bedna\",\"beran\",\"beseda\",\"bestie\",\"beton\",\"bezinka\",\"bezmoc\",\"beztak\",\"bicykl\",\"bidlo\",\"biftek\",\"bikiny\",\"bilance\",\"biograf\",\"biolog\",\"bitva\",\"bizon\",\"blahobyt\",\"blatouch\",\"blecha\",\"bledule\",\"blesk\",\"blikat\",\"blizna\",\"blokovat\",\"bloudit\",\"blud\",\"bobek\",\"bobr\",\"bodlina\",\"bodnout\",\"bohatost\",\"bojkot\",\"bojovat\",\"bokorys\",\"bolest\",\"borec\",\"borovice\",\"bota\",\"boubel\",\"bouchat\",\"bouda\",\"boule\",\"bourat\",\"boxer\",\"bradavka\",\"brambora\",\"branka\",\"bratr\",\"brepta\",\"briketa\",\"brko\",\"brloh\",\"bronz\",\"broskev\",\"brunetka\",\"brusinka\",\"brzda\",\"brzy\",\"bublina\",\"bubnovat\",\"buchta\",\"buditel\",\"budka\",\"budova\",\"bufet\",\"bujarost\",\"bukvice\",\"buldok\",\"bulva\",\"bunda\",\"bunkr\",\"burza\",\"butik\",\"buvol\",\"buzola\",\"bydlet\",\"bylina\",\"bytovka\",\"bzukot\",\"capart\",\"carevna\",\"cedr\",\"cedule\",\"cejch\",\"cejn\",\"cela\",\"celer\",\"celkem\",\"celnice\",\"cenina\",\"cennost\",\"cenovka\",\"centrum\",\"cenzor\",\"cestopis\",\"cetka\",\"chalupa\",\"chapadlo\",\"charita\",\"chata\",\"chechtat\",\"chemie\",\"chichot\",\"chirurg\",\"chlad\",\"chleba\",\"chlubit\",\"chmel\",\"chmura\",\"chobot\",\"chochol\",\"chodba\",\"cholera\",\"chomout\",\"chopit\",\"choroba\",\"chov\",\"chrapot\",\"chrlit\",\"chrt\",\"chrup\",\"chtivost\",\"chudina\",\"chutnat\",\"chvat\",\"chvilka\",\"chvost\",\"chyba\",\"chystat\",\"chytit\",\"cibule\",\"cigareta\",\"cihelna\",\"cihla\",\"cinkot\",\"cirkus\",\"cisterna\",\"citace\",\"citrus\",\"cizinec\",\"cizost\",\"clona\",\"cokoliv\",\"couvat\",\"ctitel\",\"ctnost\",\"cudnost\",\"cuketa\",\"cukr\",\"cupot\",\"cvaknout\",\"cval\",\"cvik\",\"cvrkot\",\"cyklista\",\"daleko\",\"dareba\",\"datel\",\"datum\",\"dcera\",\"debata\",\"dechovka\",\"decibel\",\"deficit\",\"deflace\",\"dekl\",\"dekret\",\"demokrat\",\"deprese\",\"derby\",\"deska\",\"detektiv\",\"dikobraz\",\"diktovat\",\"dioda\",\"diplom\",\"disk\",\"displej\",\"divadlo\",\"divoch\",\"dlaha\",\"dlouho\",\"dluhopis\",\"dnes\",\"dobro\",\"dobytek\",\"docent\",\"dochutit\",\"dodnes\",\"dohled\",\"dohoda\",\"dohra\",\"dojem\",\"dojnice\",\"doklad\",\"dokola\",\"doktor\",\"dokument\",\"dolar\",\"doleva\",\"dolina\",\"doma\",\"dominant\",\"domluvit\",\"domov\",\"donutit\",\"dopad\",\"dopis\",\"doplnit\",\"doposud\",\"doprovod\",\"dopustit\",\"dorazit\",\"dorost\",\"dort\",\"dosah\",\"doslov\",\"dostatek\",\"dosud\",\"dosyta\",\"dotaz\",\"dotek\",\"dotknout\",\"doufat\",\"doutnat\",\"dovozce\",\"dozadu\",\"doznat\",\"dozorce\",\"drahota\",\"drak\",\"dramatik\",\"dravec\",\"draze\",\"drdol\",\"drobnost\",\"drogerie\",\"drozd\",\"drsnost\",\"drtit\",\"drzost\",\"duben\",\"duchovno\",\"dudek\",\"duha\",\"duhovka\",\"dusit\",\"dusno\",\"dutost\",\"dvojice\",\"dvorec\",\"dynamit\",\"ekolog\",\"ekonomie\",\"elektron\",\"elipsa\",\"email\",\"emise\",\"emoce\",\"empatie\",\"epizoda\",\"epocha\",\"epopej\",\"epos\",\"esej\",\"esence\",\"eskorta\",\"eskymo\",\"etiketa\",\"euforie\",\"evoluce\",\"exekuce\",\"exkurze\",\"expedice\",\"exploze\",\"export\",\"extrakt\",\"facka\",\"fajfka\",\"fakulta\",\"fanatik\",\"fantazie\",\"farmacie\",\"favorit\",\"fazole\",\"federace\",\"fejeton\",\"fenka\",\"fialka\",\"figurant\",\"filozof\",\"filtr\",\"finance\",\"finta\",\"fixace\",\"fjord\",\"flanel\",\"flirt\",\"flotila\",\"fond\",\"fosfor\",\"fotbal\",\"fotka\",\"foton\",\"frakce\",\"freska\",\"fronta\",\"fukar\",\"funkce\",\"fyzika\",\"galeje\",\"garant\",\"genetika\",\"geolog\",\"gilotina\",\"glazura\",\"glejt\",\"golem\",\"golfista\",\"gotika\",\"graf\",\"gramofon\",\"granule\",\"grep\",\"gril\",\"grog\",\"groteska\",\"guma\",\"hadice\",\"hadr\",\"hala\",\"halenka\",\"hanba\",\"hanopis\",\"harfa\",\"harpuna\",\"havran\",\"hebkost\",\"hejkal\",\"hejno\",\"hejtman\",\"hektar\",\"helma\",\"hematom\",\"herec\",\"herna\",\"heslo\",\"hezky\",\"historik\",\"hladovka\",\"hlasivky\",\"hlava\",\"hledat\",\"hlen\",\"hlodavec\",\"hloh\",\"hloupost\",\"hltat\",\"hlubina\",\"hluchota\",\"hmat\",\"hmota\",\"hmyz\",\"hnis\",\"hnojivo\",\"hnout\",\"hoblina\",\"hoboj\",\"hoch\",\"hodiny\",\"hodlat\",\"hodnota\",\"hodovat\",\"hojnost\",\"hokej\",\"holinka\",\"holka\",\"holub\",\"homole\",\"honitba\",\"honorace\",\"horal\",\"horda\",\"horizont\",\"horko\",\"horlivec\",\"hormon\",\"hornina\",\"horoskop\",\"horstvo\",\"hospoda\",\"hostina\",\"hotovost\",\"houba\",\"houf\",\"houpat\",\"houska\",\"hovor\",\"hradba\",\"hranice\",\"hravost\",\"hrazda\",\"hrbolek\",\"hrdina\",\"hrdlo\",\"hrdost\",\"hrnek\",\"hrobka\",\"hromada\",\"hrot\",\"hrouda\",\"hrozen\",\"hrstka\",\"hrubost\",\"hryzat\",\"hubenost\",\"hubnout\",\"hudba\",\"hukot\",\"humr\",\"husita\",\"hustota\",\"hvozd\",\"hybnost\",\"hydrant\",\"hygiena\",\"hymna\",\"hysterik\",\"idylka\",\"ihned\",\"ikona\",\"iluze\",\"imunita\",\"infekce\",\"inflace\",\"inkaso\",\"inovace\",\"inspekce\",\"internet\",\"invalida\",\"investor\",\"inzerce\",\"ironie\",\"jablko\",\"jachta\",\"jahoda\",\"jakmile\",\"jakost\",\"jalovec\",\"jantar\",\"jarmark\",\"jaro\",\"jasan\",\"jasno\",\"jatka\",\"javor\",\"jazyk\",\"jedinec\",\"jedle\",\"jednatel\",\"jehlan\",\"jekot\",\"jelen\",\"jelito\",\"jemnost\",\"jenom\",\"jepice\",\"jeseter\",\"jevit\",\"jezdec\",\"jezero\",\"jinak\",\"jindy\",\"jinoch\",\"jiskra\",\"jistota\",\"jitrnice\",\"jizva\",\"jmenovat\",\"jogurt\",\"jurta\",\"kabaret\",\"kabel\",\"kabinet\",\"kachna\",\"kadet\",\"kadidlo\",\"kahan\",\"kajak\",\"kajuta\",\"kakao\",\"kaktus\",\"kalamita\",\"kalhoty\",\"kalibr\",\"kalnost\",\"kamera\",\"kamkoliv\",\"kamna\",\"kanibal\",\"kanoe\",\"kantor\",\"kapalina\",\"kapela\",\"kapitola\",\"kapka\",\"kaple\",\"kapota\",\"kapr\",\"kapusta\",\"kapybara\",\"karamel\",\"karotka\",\"karton\",\"kasa\",\"katalog\",\"katedra\",\"kauce\",\"kauza\",\"kavalec\",\"kazajka\",\"kazeta\",\"kazivost\",\"kdekoliv\",\"kdesi\",\"kedluben\",\"kemp\",\"keramika\",\"kino\",\"klacek\",\"kladivo\",\"klam\",\"klapot\",\"klasika\",\"klaun\",\"klec\",\"klenba\",\"klepat\",\"klesnout\",\"klid\",\"klima\",\"klisna\",\"klobouk\",\"klokan\",\"klopa\",\"kloub\",\"klubovna\",\"klusat\",\"kluzkost\",\"kmen\",\"kmitat\",\"kmotr\",\"kniha\",\"knot\",\"koalice\",\"koberec\",\"kobka\",\"kobliha\",\"kobyla\",\"kocour\",\"kohout\",\"kojenec\",\"kokos\",\"koktejl\",\"kolaps\",\"koleda\",\"kolize\",\"kolo\",\"komando\",\"kometa\",\"komik\",\"komnata\",\"komora\",\"kompas\",\"komunita\",\"konat\",\"koncept\",\"kondice\",\"konec\",\"konfese\",\"kongres\",\"konina\",\"konkurs\",\"kontakt\",\"konzerva\",\"kopanec\",\"kopie\",\"kopnout\",\"koprovka\",\"korbel\",\"korektor\",\"kormidlo\",\"koroptev\",\"korpus\",\"koruna\",\"koryto\",\"korzet\",\"kosatec\",\"kostka\",\"kotel\",\"kotleta\",\"kotoul\",\"koukat\",\"koupelna\",\"kousek\",\"kouzlo\",\"kovboj\",\"koza\",\"kozoroh\",\"krabice\",\"krach\",\"krajina\",\"kralovat\",\"krasopis\",\"kravata\",\"kredit\",\"krejcar\",\"kresba\",\"kreveta\",\"kriket\",\"kritik\",\"krize\",\"krkavec\",\"krmelec\",\"krmivo\",\"krocan\",\"krok\",\"kronika\",\"kropit\",\"kroupa\",\"krovka\",\"krtek\",\"kruhadlo\",\"krupice\",\"krutost\",\"krvinka\",\"krychle\",\"krypta\",\"krystal\",\"kryt\",\"kudlanka\",\"kufr\",\"kujnost\",\"kukla\",\"kulajda\",\"kulich\",\"kulka\",\"kulomet\",\"kultura\",\"kuna\",\"kupodivu\",\"kurt\",\"kurzor\",\"kutil\",\"kvalita\",\"kvasinka\",\"kvestor\",\"kynolog\",\"kyselina\",\"kytara\",\"kytice\",\"kytka\",\"kytovec\",\"kyvadlo\",\"labrador\",\"lachtan\",\"ladnost\",\"laik\",\"lakomec\",\"lamela\",\"lampa\",\"lanovka\",\"lasice\",\"laso\",\"lastura\",\"latinka\",\"lavina\",\"lebka\",\"leckdy\",\"leden\",\"lednice\",\"ledovka\",\"ledvina\",\"legenda\",\"legie\",\"legrace\",\"lehce\",\"lehkost\",\"lehnout\",\"lektvar\",\"lenochod\",\"lentilka\",\"lepenka\",\"lepidlo\",\"letadlo\",\"letec\",\"letmo\",\"letokruh\",\"levhart\",\"levitace\",\"levobok\",\"libra\",\"lichotka\",\"lidojed\",\"lidskost\",\"lihovina\",\"lijavec\",\"lilek\",\"limetka\",\"linie\",\"linka\",\"linoleum\",\"listopad\",\"litina\",\"litovat\",\"lobista\",\"lodivod\",\"logika\",\"logoped\",\"lokalita\",\"loket\",\"lomcovat\",\"lopata\",\"lopuch\",\"lord\",\"losos\",\"lotr\",\"loudal\",\"louh\",\"louka\",\"louskat\",\"lovec\",\"lstivost\",\"lucerna\",\"lucifer\",\"lump\",\"lusk\",\"lustrace\",\"lvice\",\"lyra\",\"lyrika\",\"lysina\",\"madam\",\"madlo\",\"magistr\",\"mahagon\",\"majetek\",\"majitel\",\"majorita\",\"makak\",\"makovice\",\"makrela\",\"malba\",\"malina\",\"malovat\",\"malvice\",\"maminka\",\"mandle\",\"manko\",\"marnost\",\"masakr\",\"maskot\",\"masopust\",\"matice\",\"matrika\",\"maturita\",\"mazanec\",\"mazivo\",\"mazlit\",\"mazurka\",\"mdloba\",\"mechanik\",\"meditace\",\"medovina\",\"melasa\",\"meloun\",\"mentolka\",\"metla\",\"metoda\",\"metr\",\"mezera\",\"migrace\",\"mihnout\",\"mihule\",\"mikina\",\"mikrofon\",\"milenec\",\"milimetr\",\"milost\",\"mimika\",\"mincovna\",\"minibar\",\"minomet\",\"minulost\",\"miska\",\"mistr\",\"mixovat\",\"mladost\",\"mlha\",\"mlhovina\",\"mlok\",\"mlsat\",\"mluvit\",\"mnich\",\"mnohem\",\"mobil\",\"mocnost\",\"modelka\",\"modlitba\",\"mohyla\",\"mokro\",\"molekula\",\"momentka\",\"monarcha\",\"monokl\",\"monstrum\",\"montovat\",\"monzun\",\"mosaz\",\"moskyt\",\"most\",\"motivace\",\"motorka\",\"motyka\",\"moucha\",\"moudrost\",\"mozaika\",\"mozek\",\"mozol\",\"mramor\",\"mravenec\",\"mrkev\",\"mrtvola\",\"mrzet\",\"mrzutost\",\"mstitel\",\"mudrc\",\"muflon\",\"mulat\",\"mumie\",\"munice\",\"muset\",\"mutace\",\"muzeum\",\"muzikant\",\"myslivec\",\"mzda\",\"nabourat\",\"nachytat\",\"nadace\",\"nadbytek\",\"nadhoz\",\"nadobro\",\"nadpis\",\"nahlas\",\"nahnat\",\"nahodile\",\"nahradit\",\"naivita\",\"najednou\",\"najisto\",\"najmout\",\"naklonit\",\"nakonec\",\"nakrmit\",\"nalevo\",\"namazat\",\"namluvit\",\"nanometr\",\"naoko\",\"naopak\",\"naostro\",\"napadat\",\"napevno\",\"naplnit\",\"napnout\",\"naposled\",\"naprosto\",\"narodit\",\"naruby\",\"narychlo\",\"nasadit\",\"nasekat\",\"naslepo\",\"nastat\",\"natolik\",\"navenek\",\"navrch\",\"navzdory\",\"nazvat\",\"nebe\",\"nechat\",\"necky\",\"nedaleko\",\"nedbat\",\"neduh\",\"negace\",\"nehet\",\"nehoda\",\"nejen\",\"nejprve\",\"neklid\",\"nelibost\",\"nemilost\",\"nemoc\",\"neochota\",\"neonka\",\"nepokoj\",\"nerost\",\"nerv\",\"nesmysl\",\"nesoulad\",\"netvor\",\"neuron\",\"nevina\",\"nezvykle\",\"nicota\",\"nijak\",\"nikam\",\"nikdy\",\"nikl\",\"nikterak\",\"nitro\",\"nocleh\",\"nohavice\",\"nominace\",\"nora\",\"norek\",\"nositel\",\"nosnost\",\"nouze\",\"noviny\",\"novota\",\"nozdra\",\"nuda\",\"nudle\",\"nuget\",\"nutit\",\"nutnost\",\"nutrie\",\"nymfa\",\"obal\",\"obarvit\",\"obava\",\"obdiv\",\"obec\",\"obehnat\",\"obejmout\",\"obezita\",\"obhajoba\",\"obilnice\",\"objasnit\",\"objekt\",\"obklopit\",\"oblast\",\"oblek\",\"obliba\",\"obloha\",\"obluda\",\"obnos\",\"obohatit\",\"obojek\",\"obout\",\"obrazec\",\"obrna\",\"obruba\",\"obrys\",\"obsah\",\"obsluha\",\"obstarat\",\"obuv\",\"obvaz\",\"obvinit\",\"obvod\",\"obvykle\",\"obyvatel\",\"obzor\",\"ocas\",\"ocel\",\"ocenit\",\"ochladit\",\"ochota\",\"ochrana\",\"ocitnout\",\"odboj\",\"odbyt\",\"odchod\",\"odcizit\",\"odebrat\",\"odeslat\",\"odevzdat\",\"odezva\",\"odhadce\",\"odhodit\",\"odjet\",\"odjinud\",\"odkaz\",\"odkoupit\",\"odliv\",\"odluka\",\"odmlka\",\"odolnost\",\"odpad\",\"odpis\",\"odplout\",\"odpor\",\"odpustit\",\"odpykat\",\"odrazka\",\"odsoudit\",\"odstup\",\"odsun\",\"odtok\",\"odtud\",\"odvaha\",\"odveta\",\"odvolat\",\"odvracet\",\"odznak\",\"ofina\",\"ofsajd\",\"ohlas\",\"ohnisko\",\"ohrada\",\"ohrozit\",\"ohryzek\",\"okap\",\"okenice\",\"oklika\",\"okno\",\"okouzlit\",\"okovy\",\"okrasa\",\"okres\",\"okrsek\",\"okruh\",\"okupant\",\"okurka\",\"okusit\",\"olejnina\",\"olizovat\",\"omak\",\"omeleta\",\"omezit\",\"omladina\",\"omlouvat\",\"omluva\",\"omyl\",\"onehdy\",\"opakovat\",\"opasek\",\"operace\",\"opice\",\"opilost\",\"opisovat\",\"opora\",\"opozice\",\"opravdu\",\"oproti\",\"orbital\",\"orchestr\",\"orgie\",\"orlice\",\"orloj\",\"ortel\",\"osada\",\"oschnout\",\"osika\",\"osivo\",\"oslava\",\"oslepit\",\"oslnit\",\"oslovit\",\"osnova\",\"osoba\",\"osolit\",\"ospalec\",\"osten\",\"ostraha\",\"ostuda\",\"ostych\",\"osvojit\",\"oteplit\",\"otisk\",\"otop\",\"otrhat\",\"otrlost\",\"otrok\",\"otruby\",\"otvor\",\"ovanout\",\"ovar\",\"oves\",\"ovlivnit\",\"ovoce\",\"oxid\",\"ozdoba\",\"pachatel\",\"pacient\",\"padouch\",\"pahorek\",\"pakt\",\"palanda\",\"palec\",\"palivo\",\"paluba\",\"pamflet\",\"pamlsek\",\"panenka\",\"panika\",\"panna\",\"panovat\",\"panstvo\",\"pantofle\",\"paprika\",\"parketa\",\"parodie\",\"parta\",\"paruka\",\"paryba\",\"paseka\",\"pasivita\",\"pastelka\",\"patent\",\"patrona\",\"pavouk\",\"pazneht\",\"pazourek\",\"pecka\",\"pedagog\",\"pejsek\",\"peklo\",\"peloton\",\"penalta\",\"pendrek\",\"penze\",\"periskop\",\"pero\",\"pestrost\",\"petarda\",\"petice\",\"petrolej\",\"pevnina\",\"pexeso\",\"pianista\",\"piha\",\"pijavice\",\"pikle\",\"piknik\",\"pilina\",\"pilnost\",\"pilulka\",\"pinzeta\",\"pipeta\",\"pisatel\",\"pistole\",\"pitevna\",\"pivnice\",\"pivovar\",\"placenta\",\"plakat\",\"plamen\",\"planeta\",\"plastika\",\"platit\",\"plavidlo\",\"plaz\",\"plech\",\"plemeno\",\"plenta\",\"ples\",\"pletivo\",\"plevel\",\"plivat\",\"plnit\",\"plno\",\"plocha\",\"plodina\",\"plomba\",\"plout\",\"pluk\",\"plyn\",\"pobavit\",\"pobyt\",\"pochod\",\"pocit\",\"poctivec\",\"podat\",\"podcenit\",\"podepsat\",\"podhled\",\"podivit\",\"podklad\",\"podmanit\",\"podnik\",\"podoba\",\"podpora\",\"podraz\",\"podstata\",\"podvod\",\"podzim\",\"poezie\",\"pohanka\",\"pohnutka\",\"pohovor\",\"pohroma\",\"pohyb\",\"pointa\",\"pojistka\",\"pojmout\",\"pokazit\",\"pokles\",\"pokoj\",\"pokrok\",\"pokuta\",\"pokyn\",\"poledne\",\"polibek\",\"polknout\",\"poloha\",\"polynom\",\"pomalu\",\"pominout\",\"pomlka\",\"pomoc\",\"pomsta\",\"pomyslet\",\"ponechat\",\"ponorka\",\"ponurost\",\"popadat\",\"popel\",\"popisek\",\"poplach\",\"poprosit\",\"popsat\",\"popud\",\"poradce\",\"porce\",\"porod\",\"porucha\",\"poryv\",\"posadit\",\"posed\",\"posila\",\"poskok\",\"poslanec\",\"posoudit\",\"pospolu\",\"postava\",\"posudek\",\"posyp\",\"potah\",\"potkan\",\"potlesk\",\"potomek\",\"potrava\",\"potupa\",\"potvora\",\"poukaz\",\"pouto\",\"pouzdro\",\"povaha\",\"povidla\",\"povlak\",\"povoz\",\"povrch\",\"povstat\",\"povyk\",\"povzdech\",\"pozdrav\",\"pozemek\",\"poznatek\",\"pozor\",\"pozvat\",\"pracovat\",\"prahory\",\"praktika\",\"prales\",\"praotec\",\"praporek\",\"prase\",\"pravda\",\"princip\",\"prkno\",\"probudit\",\"procento\",\"prodej\",\"profese\",\"prohra\",\"projekt\",\"prolomit\",\"promile\",\"pronikat\",\"propad\",\"prorok\",\"prosba\",\"proton\",\"proutek\",\"provaz\",\"prskavka\",\"prsten\",\"prudkost\",\"prut\",\"prvek\",\"prvohory\",\"psanec\",\"psovod\",\"pstruh\",\"ptactvo\",\"puberta\",\"puch\",\"pudl\",\"pukavec\",\"puklina\",\"pukrle\",\"pult\",\"pumpa\",\"punc\",\"pupen\",\"pusa\",\"pusinka\",\"pustina\",\"putovat\",\"putyka\",\"pyramida\",\"pysk\",\"pytel\",\"racek\",\"rachot\",\"radiace\",\"radnice\",\"radon\",\"raft\",\"ragby\",\"raketa\",\"rakovina\",\"rameno\",\"rampouch\",\"rande\",\"rarach\",\"rarita\",\"rasovna\",\"rastr\",\"ratolest\",\"razance\",\"razidlo\",\"reagovat\",\"reakce\",\"recept\",\"redaktor\",\"referent\",\"reflex\",\"rejnok\",\"reklama\",\"rekord\",\"rekrut\",\"rektor\",\"reputace\",\"revize\",\"revma\",\"revolver\",\"rezerva\",\"riskovat\",\"riziko\",\"robotika\",\"rodokmen\",\"rohovka\",\"rokle\",\"rokoko\",\"romaneto\",\"ropovod\",\"ropucha\",\"rorejs\",\"rosol\",\"rostlina\",\"rotmistr\",\"rotoped\",\"rotunda\",\"roubenka\",\"roucho\",\"roup\",\"roura\",\"rovina\",\"rovnice\",\"rozbor\",\"rozchod\",\"rozdat\",\"rozeznat\",\"rozhodce\",\"rozinka\",\"rozjezd\",\"rozkaz\",\"rozloha\",\"rozmar\",\"rozpad\",\"rozruch\",\"rozsah\",\"roztok\",\"rozum\",\"rozvod\",\"rubrika\",\"ruchadlo\",\"rukavice\",\"rukopis\",\"ryba\",\"rybolov\",\"rychlost\",\"rydlo\",\"rypadlo\",\"rytina\",\"ryzost\",\"sadista\",\"sahat\",\"sako\",\"samec\",\"samizdat\",\"samota\",\"sanitka\",\"sardinka\",\"sasanka\",\"satelit\",\"sazba\",\"sazenice\",\"sbor\",\"schovat\",\"sebranka\",\"secese\",\"sedadlo\",\"sediment\",\"sedlo\",\"sehnat\",\"sejmout\",\"sekera\",\"sekta\",\"sekunda\",\"sekvoje\",\"semeno\",\"seno\",\"servis\",\"sesadit\",\"seshora\",\"seskok\",\"seslat\",\"sestra\",\"sesuv\",\"sesypat\",\"setba\",\"setina\",\"setkat\",\"setnout\",\"setrvat\",\"sever\",\"seznam\",\"shoda\",\"shrnout\",\"sifon\",\"silnice\",\"sirka\",\"sirotek\",\"sirup\",\"situace\",\"skafandr\",\"skalisko\",\"skanzen\",\"skaut\",\"skeptik\",\"skica\",\"skladba\",\"sklenice\",\"sklo\",\"skluz\",\"skoba\",\"skokan\",\"skoro\",\"skripta\",\"skrz\",\"skupina\",\"skvost\",\"skvrna\",\"slabika\",\"sladidlo\",\"slanina\",\"slast\",\"slavnost\",\"sledovat\",\"slepec\",\"sleva\",\"slezina\",\"slib\",\"slina\",\"sliznice\",\"slon\",\"sloupek\",\"slovo\",\"sluch\",\"sluha\",\"slunce\",\"slupka\",\"slza\",\"smaragd\",\"smetana\",\"smilstvo\",\"smlouva\",\"smog\",\"smrad\",\"smrk\",\"smrtka\",\"smutek\",\"smysl\",\"snad\",\"snaha\",\"snob\",\"sobota\",\"socha\",\"sodovka\",\"sokol\",\"sopka\",\"sotva\",\"souboj\",\"soucit\",\"soudce\",\"souhlas\",\"soulad\",\"soumrak\",\"souprava\",\"soused\",\"soutok\",\"souviset\",\"spalovna\",\"spasitel\",\"spis\",\"splav\",\"spodek\",\"spojenec\",\"spolu\",\"sponzor\",\"spornost\",\"spousta\",\"sprcha\",\"spustit\",\"sranda\",\"sraz\",\"srdce\",\"srna\",\"srnec\",\"srovnat\",\"srpen\",\"srst\",\"srub\",\"stanice\",\"starosta\",\"statika\",\"stavba\",\"stehno\",\"stezka\",\"stodola\",\"stolek\",\"stopa\",\"storno\",\"stoupat\",\"strach\",\"stres\",\"strhnout\",\"strom\",\"struna\",\"studna\",\"stupnice\",\"stvol\",\"styk\",\"subjekt\",\"subtropy\",\"suchar\",\"sudost\",\"sukno\",\"sundat\",\"sunout\",\"surikata\",\"surovina\",\"svah\",\"svalstvo\",\"svetr\",\"svatba\",\"svazek\",\"svisle\",\"svitek\",\"svoboda\",\"svodidlo\",\"svorka\",\"svrab\",\"sykavka\",\"sykot\",\"synek\",\"synovec\",\"sypat\",\"sypkost\",\"syrovost\",\"sysel\",\"sytost\",\"tabletka\",\"tabule\",\"tahoun\",\"tajemno\",\"tajfun\",\"tajga\",\"tajit\",\"tajnost\",\"taktika\",\"tamhle\",\"tampon\",\"tancovat\",\"tanec\",\"tanker\",\"tapeta\",\"tavenina\",\"tazatel\",\"technika\",\"tehdy\",\"tekutina\",\"telefon\",\"temnota\",\"tendence\",\"tenista\",\"tenor\",\"teplota\",\"tepna\",\"teprve\",\"terapie\",\"termoska\",\"textil\",\"ticho\",\"tiskopis\",\"titulek\",\"tkadlec\",\"tkanina\",\"tlapka\",\"tleskat\",\"tlukot\",\"tlupa\",\"tmel\",\"toaleta\",\"topinka\",\"topol\",\"torzo\",\"touha\",\"toulec\",\"tradice\",\"traktor\",\"tramp\",\"trasa\",\"traverza\",\"trefit\",\"trest\",\"trezor\",\"trhavina\",\"trhlina\",\"trochu\",\"trojice\",\"troska\",\"trouba\",\"trpce\",\"trpitel\",\"trpkost\",\"trubec\",\"truchlit\",\"truhlice\",\"trus\",\"trvat\",\"tudy\",\"tuhnout\",\"tuhost\",\"tundra\",\"turista\",\"turnaj\",\"tuzemsko\",\"tvaroh\",\"tvorba\",\"tvrdost\",\"tvrz\",\"tygr\",\"tykev\",\"ubohost\",\"uboze\",\"ubrat\",\"ubrousek\",\"ubrus\",\"ubytovna\",\"ucho\",\"uctivost\",\"udivit\",\"uhradit\",\"ujednat\",\"ujistit\",\"ujmout\",\"ukazatel\",\"uklidnit\",\"uklonit\",\"ukotvit\",\"ukrojit\",\"ulice\",\"ulita\",\"ulovit\",\"umyvadlo\",\"unavit\",\"uniforma\",\"uniknout\",\"upadnout\",\"uplatnit\",\"uplynout\",\"upoutat\",\"upravit\",\"uran\",\"urazit\",\"usednout\",\"usilovat\",\"usmrtit\",\"usnadnit\",\"usnout\",\"usoudit\",\"ustlat\",\"ustrnout\",\"utahovat\",\"utkat\",\"utlumit\",\"utonout\",\"utopenec\",\"utrousit\",\"uvalit\",\"uvolnit\",\"uvozovka\",\"uzdravit\",\"uzel\",\"uzenina\",\"uzlina\",\"uznat\",\"vagon\",\"valcha\",\"valoun\",\"vana\",\"vandal\",\"vanilka\",\"varan\",\"varhany\",\"varovat\",\"vcelku\",\"vchod\",\"vdova\",\"vedro\",\"vegetace\",\"vejce\",\"velbloud\",\"veletrh\",\"velitel\",\"velmoc\",\"velryba\",\"venkov\",\"veranda\",\"verze\",\"veselka\",\"veskrze\",\"vesnice\",\"vespodu\",\"vesta\",\"veterina\",\"veverka\",\"vibrace\",\"vichr\",\"videohra\",\"vidina\",\"vidle\",\"vila\",\"vinice\",\"viset\",\"vitalita\",\"vize\",\"vizitka\",\"vjezd\",\"vklad\",\"vkus\",\"vlajka\",\"vlak\",\"vlasec\",\"vlevo\",\"vlhkost\",\"vliv\",\"vlnovka\",\"vloupat\",\"vnucovat\",\"vnuk\",\"voda\",\"vodivost\",\"vodoznak\",\"vodstvo\",\"vojensky\",\"vojna\",\"vojsko\",\"volant\",\"volba\",\"volit\",\"volno\",\"voskovka\",\"vozidlo\",\"vozovna\",\"vpravo\",\"vrabec\",\"vracet\",\"vrah\",\"vrata\",\"vrba\",\"vrcholek\",\"vrhat\",\"vrstva\",\"vrtule\",\"vsadit\",\"vstoupit\",\"vstup\",\"vtip\",\"vybavit\",\"vybrat\",\"vychovat\",\"vydat\",\"vydra\",\"vyfotit\",\"vyhledat\",\"vyhnout\",\"vyhodit\",\"vyhradit\",\"vyhubit\",\"vyjasnit\",\"vyjet\",\"vyjmout\",\"vyklopit\",\"vykonat\",\"vylekat\",\"vymazat\",\"vymezit\",\"vymizet\",\"vymyslet\",\"vynechat\",\"vynikat\",\"vynutit\",\"vypadat\",\"vyplatit\",\"vypravit\",\"vypustit\",\"vyrazit\",\"vyrovnat\",\"vyrvat\",\"vyslovit\",\"vysoko\",\"vystavit\",\"vysunout\",\"vysypat\",\"vytasit\",\"vytesat\",\"vytratit\",\"vyvinout\",\"vyvolat\",\"vyvrhel\",\"vyzdobit\",\"vyznat\",\"vzadu\",\"vzbudit\",\"vzchopit\",\"vzdor\",\"vzduch\",\"vzdychat\",\"vzestup\",\"vzhledem\",\"vzkaz\",\"vzlykat\",\"vznik\",\"vzorek\",\"vzpoura\",\"vztah\",\"vztek\",\"xylofon\",\"zabrat\",\"zabydlet\",\"zachovat\",\"zadarmo\",\"zadusit\",\"zafoukat\",\"zahltit\",\"zahodit\",\"zahrada\",\"zahynout\",\"zajatec\",\"zajet\",\"zajistit\",\"zaklepat\",\"zakoupit\",\"zalepit\",\"zamezit\",\"zamotat\",\"zamyslet\",\"zanechat\",\"zanikat\",\"zaplatit\",\"zapojit\",\"zapsat\",\"zarazit\",\"zastavit\",\"zasunout\",\"zatajit\",\"zatemnit\",\"zatknout\",\"zaujmout\",\"zavalit\",\"zavelet\",\"zavinit\",\"zavolat\",\"zavrtat\",\"zazvonit\",\"zbavit\",\"zbrusu\",\"zbudovat\",\"zbytek\",\"zdaleka\",\"zdarma\",\"zdatnost\",\"zdivo\",\"zdobit\",\"zdroj\",\"zdvih\",\"zdymadlo\",\"zelenina\",\"zeman\",\"zemina\",\"zeptat\",\"zezadu\",\"zezdola\",\"zhatit\",\"zhltnout\",\"zhluboka\",\"zhotovit\",\"zhruba\",\"zima\",\"zimnice\",\"zjemnit\",\"zklamat\",\"zkoumat\",\"zkratka\",\"zkumavka\",\"zlato\",\"zlehka\",\"zloba\",\"zlom\",\"zlost\",\"zlozvyk\",\"zmapovat\",\"zmar\",\"zmatek\",\"zmije\",\"zmizet\",\"zmocnit\",\"zmodrat\",\"zmrzlina\",\"zmutovat\",\"znak\",\"znalost\",\"znamenat\",\"znovu\",\"zobrazit\",\"zotavit\",\"zoubek\",\"zoufale\",\"zplodit\",\"zpomalit\",\"zprava\",\"zprostit\",\"zprudka\",\"zprvu\",\"zrada\",\"zranit\",\"zrcadlo\",\"zrnitost\",\"zrno\",\"zrovna\",\"zrychlit\",\"zrzavost\",\"zticha\",\"ztratit\",\"zubovina\",\"zubr\",\"zvednout\",\"zvenku\",\"zvesela\",\"zvon\",\"zvrat\",\"zvukovod\",\"zvyk\"][\"abandon\",\"ability\",\"able\",\"about\",\"above\",\"absent\",\"absorb\",\"abstract\",\"absurd\",\"abuse\",\"access\",\"accident\",\"account\",\"accuse\",\"achieve\",\"acid\",\"acoustic\",\"acquire\",\"across\",\"act\",\"action\",\"actor\",\"actress\",\"actual\",\"adapt\",\"add\",\"addict\",\"address\",\"adjust\",\"admit\",\"adult\",\"advance\",\"advice\",\"aerobic\",\"affair\",\"afford\",\"afraid\",\"again\",\"age\",\"agent\",\"agree\",\"ahead\",\"aim\",\"air\",\"airport\",\"aisle\",\"alarm\",\"album\",\"alcohol\",\"alert\",\"alien\",\"all\",\"alley\",\"allow\",\"almost\",\"alone\",\"alpha\",\"already\",\"also\",\"alter\",\"always\",\"amateur\",\"amazing\",\"among\",\"amount\",\"amused\",\"analyst\",\"anchor\",\"ancient\",\"anger\",\"angle\",\"angry\",\"animal\",\"ankle\",\"announce\",\"annual\",\"another\",\"answer\",\"antenna\",\"antique\",\"anxiety\",\"any\",\"apart\",\"apology\",\"appear\",\"apple\",\"approve\",\"april\",\"arch\",\"arctic\",\"area\",\"arena\",\"argue\",\"arm\",\"armed\",\"armor\",\"army\",\"around\",\"arrange\",\"arrest\",\"arrive\",\"arrow\",\"art\",\"artefact\",\"artist\",\"artwork\",\"ask\",\"aspect\",\"assault\",\"asset\",\"assist\",\"assume\",\"asthma\",\"athlete\",\"atom\",\"attack\",\"attend\",\"attitude\",\"attract\",\"auction\",\"audit\",\"august\",\"aunt\",\"author\",\"auto\",\"autumn\",\"average\",\"avocado\",\"avoid\",\"awake\",\"aware\",\"away\",\"awesome\",\"awful\",\"awkward\",\"axis\",\"baby\",\"bachelor\",\"bacon\",\"badge\",\"bag\",\"balance\",\"balcony\",\"ball\",\"bamboo\",\"banana\",\"banner\",\"bar\",\"barely\",\"bargain\",\"barrel\",\"base\",\"basic\",\"basket\",\"battle\",\"beach\",\"bean\",\"beauty\",\"because\",\"become\",\"beef\",\"before\",\"begin\",\"behave\",\"behind\",\"believe\",\"below\",\"belt\",\"bench\",\"benefit\",\"best\",\"betray\",\"better\",\"between\",\"beyond\",\"bicycle\",\"bid\",\"bike\",\"bind\",\"biology\",\"bird\",\"birth\",\"bitter\",\"black\",\"blade\",\"blame\",\"blanket\",\"blast\",\"bleak\",\"bless\",\"blind\",\"blood\",\"blossom\",\"blouse\",\"blue\",\"blur\",\"blush\",\"board\",\"boat\",\"body\",\"boil\",\"bomb\",\"bone\",\"bonus\",\"book\",\"boost\",\"border\",\"boring\",\"borrow\",\"boss\",\"bottom\",\"bounce\",\"box\",\"boy\",\"bracket\",\"brain\",\"brand\",\"brass\",\"brave\",\"bread\",\"breeze\",\"brick\",\"bridge\",\"brief\",\"bright\",\"bring\",\"brisk\",\"broccoli\",\"broken\",\"bronze\",\"broom\",\"brother\",\"brown\",\"brush\",\"bubble\",\"buddy\",\"budget\",\"buffalo\",\"build\",\"bulb\",\"bulk\",\"bullet\",\"bundle\",\"bunker\",\"burden\",\"burger\",\"burst\",\"bus\",\"business\",\"busy\",\"butter\",\"buyer\",\"buzz\",\"cabbage\",\"cabin\",\"cable\",\"cactus\",\"cage\",\"cake\",\"call\",\"calm\",\"camera\",\"camp\",\"can\",\"canal\",\"cancel\",\"candy\",\"cannon\",\"canoe\",\"canvas\",\"canyon\",\"capable\",\"capital\",\"captain\",\"car\",\"carbon\",\"card\",\"cargo\",\"carpet\",\"carry\",\"cart\",\"case\",\"cash\",\"casino\",\"castle\",\"casual\",\"cat\",\"catalog\",\"catch\",\"category\",\"cattle\",\"caught\",\"cause\",\"caution\",\"cave\",\"ceiling\",\"celery\",\"cement\",\"census\",\"century\",\"cereal\",\"certain\",\"chair\",\"chalk\",\"champion\",\"change\",\"chaos\",\"chapter\",\"charge\",\"chase\",\"chat\",\"cheap\",\"check\",\"cheese\",\"chef\",\"cherry\",\"chest\",\"chicken\",\"chief\",\"child\",\"chimney\",\"choice\",\"choose\",\"chronic\",\"chuckle\",\"chunk\",\"churn\",\"cigar\",\"cinnamon\",\"circle\",\"citizen\",\"city\",\"civil\",\"claim\",\"clap\",\"clarify\",\"claw\",\"clay\",\"clean\",\"clerk\",\"clever\",\"click\",\"client\",\"cliff\",\"climb\",\"clinic\",\"clip\",\"clock\",\"clog\",\"close\",\"cloth\",\"cloud\",\"clown\",\"club\",\"clump\",\"cluster\",\"clutch\",\"coach\",\"coast\",\"coconut\",\"code\",\"coffee\",\"coil\",\"coin\",\"collect\",\"color\",\"column\",\"combine\",\"come\",\"comfort\",\"comic\",\"common\",\"company\",\"concert\",\"conduct\",\"confirm\",\"congress\",\"connect\",\"consider\",\"control\",\"convince\",\"cook\",\"cool\",\"copper\",\"copy\",\"coral\",\"core\",\"corn\",\"correct\",\"cost\",\"cotton\",\"couch\",\"country\",\"couple\",\"course\",\"cousin\",\"cover\",\"coyote\",\"crack\",\"cradle\",\"craft\",\"cram\",\"crane\",\"crash\",\"crater\",\"crawl\",\"crazy\",\"cream\",\"credit\",\"creek\",\"crew\",\"cricket\",\"crime\",\"crisp\",\"critic\",\"crop\",\"cross\",\"crouch\",\"crowd\",\"crucial\",\"cruel\",\"cruise\",\"crumble\",\"crunch\",\"crush\",\"cry\",\"crystal\",\"cube\",\"culture\",\"cup\",\"cupboard\",\"curious\",\"current\",\"curtain\",\"curve\",\"cushion\",\"custom\",\"cute\",\"cycle\",\"dad\",\"damage\",\"damp\",\"dance\",\"danger\",\"daring\",\"dash\",\"daughter\",\"dawn\",\"day\",\"deal\",\"debate\",\"debris\",\"decade\",\"december\",\"decide\",\"decline\",\"decorate\",\"decrease\",\"deer\",\"defense\",\"define\",\"defy\",\"degree\",\"delay\",\"deliver\",\"demand\",\"demise\",\"denial\",\"dentist\",\"deny\",\"depart\",\"depend\",\"deposit\",\"depth\",\"deputy\",\"derive\",\"describe\",\"desert\",\"design\",\"desk\",\"despair\",\"destroy\",\"detail\",\"detect\",\"develop\",\"device\",\"devote\",\"diagram\",\"dial\",\"diamond\",\"diary\",\"dice\",\"diesel\",\"diet\",\"differ\",\"digital\",\"dignity\",\"dilemma\",\"dinner\",\"dinosaur\",\"direct\",\"dirt\",\"disagree\",\"discover\",\"disease\",\"dish\",\"dismiss\",\"disorder\",\"display\",\"distance\",\"divert\",\"divide\",\"divorce\",\"dizzy\",\"doctor\",\"document\",\"dog\",\"doll\",\"dolphin\",\"domain\",\"donate\",\"donkey\",\"donor\",\"door\",\"dose\",\"double\",\"dove\",\"draft\",\"dragon\",\"drama\",\"drastic\",\"draw\",\"dream\",\"dress\",\"drift\",\"drill\",\"drink\",\"drip\",\"drive\",\"drop\",\"drum\",\"dry\",\"duck\",\"dumb\",\"dune\",\"during\",\"dust\",\"dutch\",\"duty\",\"dwarf\",\"dynamic\",\"eager\",\"eagle\",\"early\",\"earn\",\"earth\",\"easily\",\"east\",\"easy\",\"echo\",\"ecology\",\"economy\",\"edge\",\"edit\",\"educate\",\"effort\",\"egg\",\"eight\",\"either\",\"elbow\",\"elder\",\"electric\",\"elegant\",\"element\",\"elephant\",\"elevator\",\"elite\",\"else\",\"embark\",\"embody\",\"embrace\",\"emerge\",\"emotion\",\"employ\",\"empower\",\"empty\",\"enable\",\"enact\",\"end\",\"endless\",\"endorse\",\"enemy\",\"energy\",\"enforce\",\"engage\",\"engine\",\"enhance\",\"enjoy\",\"enlist\",\"enough\",\"enrich\",\"enroll\",\"ensure\",\"enter\",\"entire\",\"entry\",\"envelope\",\"episode\",\"equal\",\"equip\",\"era\",\"erase\",\"erode\",\"erosion\",\"error\",\"erupt\",\"escape\",\"essay\",\"essence\",\"estate\",\"eternal\",\"ethics\",\"evidence\",\"evil\",\"evoke\",\"evolve\",\"exact\",\"example\",\"excess\",\"exchange\",\"excite\",\"exclude\",\"excuse\",\"execute\",\"exercise\",\"exhaust\",\"exhibit\",\"exile\",\"exist\",\"exit\",\"exotic\",\"expand\",\"expect\",\"expire\",\"explain\",\"expose\",\"express\",\"extend\",\"extra\",\"eye\",\"eyebrow\",\"fabric\",\"face\",\"faculty\",\"fade\",\"faint\",\"faith\",\"fall\",\"false\",\"fame\",\"family\",\"famous\",\"fan\",\"fancy\",\"fantasy\",\"farm\",\"fashion\",\"fat\",\"fatal\",\"father\",\"fatigue\",\"fault\",\"favorite\",\"feature\",\"february\",\"federal\",\"fee\",\"feed\",\"feel\",\"female\",\"fence\",\"festival\",\"fetch\",\"fever\",\"few\",\"fiber\",\"fiction\",\"field\",\"figure\",\"file\",\"film\",\"filter\",\"final\",\"find\",\"fine\",\"finger\",\"finish\",\"fire\",\"firm\",\"first\",\"fiscal\",\"fish\",\"fit\",\"fitness\",\"fix\",\"flag\",\"flame\",\"flash\",\"flat\",\"flavor\",\"flee\",\"flight\",\"flip\",\"float\",\"flock\",\"floor\",\"flower\",\"fluid\",\"flush\",\"fly\",\"foam\",\"focus\",\"fog\",\"foil\",\"fold\",\"follow\",\"food\",\"foot\",\"force\",\"forest\",\"forget\",\"fork\",\"fortune\",\"forum\",\"forward\",\"fossil\",\"foster\",\"found\",\"fox\",\"fragile\",\"frame\",\"frequent\",\"fresh\",\"friend\",\"fringe\",\"frog\",\"front\",\"frost\",\"frown\",\"frozen\",\"fruit\",\"fuel\",\"fun\",\"funny\",\"furnace\",\"fury\",\"future\",\"gadget\",\"gain\",\"galaxy\",\"gallery\",\"game\",\"gap\",\"garage\",\"garbage\",\"garden\",\"garlic\",\"garment\",\"gas\",\"gasp\",\"gate\",\"gather\",\"gauge\",\"gaze\",\"general\",\"genius\",\"genre\",\"gentle\",\"genuine\",\"gesture\",\"ghost\",\"giant\",\"gift\",\"giggle\",\"ginger\",\"giraffe\",\"girl\",\"give\",\"glad\",\"glance\",\"glare\",\"glass\",\"glide\",\"glimpse\",\"globe\",\"gloom\",\"glory\",\"glove\",\"glow\",\"glue\",\"goat\",\"goddess\",\"gold\",\"good\",\"goose\",\"gorilla\",\"gospel\",\"gossip\",\"govern\",\"gown\",\"grab\",\"grace\",\"grain\",\"grant\",\"grape\",\"grass\",\"gravity\",\"great\",\"green\",\"grid\",\"grief\",\"grit\",\"grocery\",\"group\",\"grow\",\"grunt\",\"guard\",\"guess\",\"guide\",\"guilt\",\"guitar\",\"gun\",\"gym\",\"habit\",\"hair\",\"half\",\"hammer\",\"hamster\",\"hand\",\"happy\",\"harbor\",\"hard\",\"harsh\",\"harvest\",\"hat\",\"have\",\"hawk\",\"hazard\",\"head\",\"health\",\"heart\",\"heavy\",\"hedgehog\",\"height\",\"hello\",\"helmet\",\"help\",\"hen\",\"hero\",\"hidden\",\"high\",\"hill\",\"hint\",\"hip\",\"hire\",\"history\",\"hobby\",\"hockey\",\"hold\",\"hole\",\"holiday\",\"hollow\",\"home\",\"honey\",\"hood\",\"hope\",\"horn\",\"horror\",\"horse\",\"hospital\",\"host\",\"hotel\",\"hour\",\"hover\",\"hub\",\"huge\",\"human\",\"humble\",\"humor\",\"hundred\",\"hungry\",\"hunt\",\"hurdle\",\"hurry\",\"hurt\",\"husband\",\"hybrid\",\"ice\",\"icon\",\"idea\",\"identify\",\"idle\",\"ignore\",\"ill\",\"illegal\",\"illness\",\"image\",\"imitate\",\"immense\",\"immune\",\"impact\",\"impose\",\"improve\",\"impulse\",\"inch\",\"include\",\"income\",\"increase\",\"index\",\"indicate\",\"indoor\",\"industry\",\"infant\",\"inflict\",\"inform\",\"inhale\",\"inherit\",\"initial\",\"inject\",\"injury\",\"inmate\",\"inner\",\"innocent\",\"input\",\"inquiry\",\"insane\",\"insect\",\"inside\",\"inspire\",\"install\",\"intact\",\"interest\",\"into\",\"invest\",\"invite\",\"involve\",\"iron\",\"island\",\"isolate\",\"issue\",\"item\",\"ivory\",\"jacket\",\"jaguar\",\"jar\",\"jazz\",\"jealous\",\"jeans\",\"jelly\",\"jewel\",\"job\",\"join\",\"joke\",\"journey\",\"joy\",\"judge\",\"juice\",\"jump\",\"jungle\",\"junior\",\"junk\",\"just\",\"kangaroo\",\"keen\",\"keep\",\"ketchup\",\"key\",\"kick\",\"kid\",\"kidney\",\"kind\",\"kingdom\",\"kiss\",\"kit\",\"kitchen\",\"kite\",\"kitten\",\"kiwi\",\"knee\",\"knife\",\"knock\",\"know\",\"lab\",\"label\",\"labor\",\"ladder\",\"lady\",\"lake\",\"lamp\",\"language\",\"laptop\",\"large\",\"later\",\"latin\",\"laugh\",\"laundry\",\"lava\",\"law\",\"lawn\",\"lawsuit\",\"layer\",\"lazy\",\"leader\",\"leaf\",\"learn\",\"leave\",\"lecture\",\"left\",\"leg\",\"legal\",\"legend\",\"leisure\",\"lemon\",\"lend\",\"length\",\"lens\",\"leopard\",\"lesson\",\"letter\",\"level\",\"liar\",\"liberty\",\"library\",\"license\",\"life\",\"lift\",\"light\",\"like\",\"limb\",\"limit\",\"link\",\"lion\",\"liquid\",\"list\",\"little\",\"live\",\"lizard\",\"load\",\"loan\",\"lobster\",\"local\",\"lock\",\"logic\",\"lonely\",\"long\",\"loop\",\"lottery\",\"loud\",\"lounge\",\"love\",\"loyal\",\"lucky\",\"luggage\",\"lumber\",\"lunar\",\"lunch\",\"luxury\",\"lyrics\",\"machine\",\"mad\",\"magic\",\"magnet\",\"maid\",\"mail\",\"main\",\"major\",\"make\",\"mammal\",\"man\",\"manage\",\"mandate\",\"mango\",\"mansion\",\"manual\",\"maple\",\"marble\",\"march\",\"margin\",\"marine\",\"market\",\"marriage\",\"mask\",\"mass\",\"master\",\"match\",\"material\",\"math\",\"matrix\",\"matter\",\"maximum\",\"maze\",\"meadow\",\"mean\",\"measure\",\"meat\",\"mechanic\",\"medal\",\"media\",\"melody\",\"melt\",\"member\",\"memory\",\"mention\",\"menu\",\"mercy\",\"merge\",\"merit\",\"merry\",\"mesh\",\"message\",\"metal\",\"method\",\"middle\",\"midnight\",\"milk\",\"million\",\"mimic\",\"mind\",\"minimum\",\"minor\",\"minute\",\"miracle\",\"mirror\",\"misery\",\"miss\",\"mistake\",\"mix\",\"mixed\",\"mixture\",\"mobile\",\"model\",\"modify\",\"mom\",\"moment\",\"monitor\",\"monkey\",\"monster\",\"month\",\"moon\",\"moral\",\"more\",\"morning\",\"mosquito\",\"mother\",\"motion\",\"motor\",\"mountain\",\"mouse\",\"move\",\"movie\",\"much\",\"muffin\",\"mule\",\"multiply\",\"muscle\",\"museum\",\"mushroom\",\"music\",\"must\",\"mutual\",\"myself\",\"mystery\",\"myth\",\"naive\",\"name\",\"napkin\",\"narrow\",\"nasty\",\"nation\",\"nature\",\"near\",\"neck\",\"need\",\"negative\",\"neglect\",\"neither\",\"nephew\",\"nerve\",\"nest\",\"net\",\"network\",\"neutral\",\"never\",\"news\",\"next\",\"nice\",\"night\",\"noble\",\"noise\",\"nominee\",\"noodle\",\"normal\",\"north\",\"nose\",\"notable\",\"note\",\"nothing\",\"notice\",\"novel\",\"now\",\"nuclear\",\"number\",\"nurse\",\"nut\",\"oak\",\"obey\",\"object\",\"oblige\",\"obscure\",\"observe\",\"obtain\",\"obvious\",\"occur\",\"ocean\",\"october\",\"odor\",\"off\",\"offer\",\"office\",\"often\",\"oil\",\"okay\",\"old\",\"olive\",\"olympic\",\"omit\",\"once\",\"one\",\"onion\",\"online\",\"only\",\"open\",\"opera\",\"opinion\",\"oppose\",\"option\",\"orange\",\"orbit\",\"orchard\",\"order\",\"ordinary\",\"organ\",\"orient\",\"original\",\"orphan\",\"ostrich\",\"other\",\"outdoor\",\"outer\",\"output\",\"outside\",\"oval\",\"oven\",\"over\",\"own\",\"owner\",\"oxygen\",\"oyster\",\"ozone\",\"pact\",\"paddle\",\"page\",\"pair\",\"palace\",\"palm\",\"panda\",\"panel\",\"panic\",\"panther\",\"paper\",\"parade\",\"parent\",\"park\",\"parrot\",\"party\",\"pass\",\"patch\",\"path\",\"patient\",\"patrol\",\"pattern\",\"pause\",\"pave\",\"payment\",\"peace\",\"peanut\",\"pear\",\"peasant\",\"pelican\",\"pen\",\"penalty\",\"pencil\",\"people\",\"pepper\",\"perfect\",\"permit\",\"person\",\"pet\",\"phone\",\"photo\",\"phrase\",\"physical\",\"piano\",\"picnic\",\"picture\",\"piece\",\"pig\",\"pigeon\",\"pill\",\"pilot\",\"pink\",\"pioneer\",\"pipe\",\"pistol\",\"pitch\",\"pizza\",\"place\",\"planet\",\"plastic\",\"plate\",\"play\",\"please\",\"pledge\",\"pluck\",\"plug\",\"plunge\",\"poem\",\"poet\",\"point\",\"polar\",\"pole\",\"police\",\"pond\",\"pony\",\"pool\",\"popular\",\"portion\",\"position\",\"possible\",\"post\",\"potato\",\"pottery\",\"poverty\",\"powder\",\"power\",\"practice\",\"praise\",\"predict\",\"prefer\",\"prepare\",\"present\",\"pretty\",\"prevent\",\"price\",\"pride\",\"primary\",\"print\",\"priority\",\"prison\",\"private\",\"prize\",\"problem\",\"process\",\"produce\",\"profit\",\"program\",\"project\",\"promote\",\"proof\",\"property\",\"prosper\",\"protect\",\"proud\",\"provide\",\"public\",\"pudding\",\"pull\",\"pulp\",\"pulse\",\"pumpkin\",\"punch\",\"pupil\",\"puppy\",\"purchase\",\"purity\",\"purpose\",\"purse\",\"push\",\"put\",\"puzzle\",\"pyramid\",\"quality\",\"quantum\",\"quarter\",\"question\",\"quick\",\"quit\",\"quiz\",\"quote\",\"rabbit\",\"raccoon\",\"race\",\"rack\",\"radar\",\"radio\",\"rail\",\"rain\",\"raise\",\"rally\",\"ramp\",\"ranch\",\"random\",\"range\",\"rapid\",\"rare\",\"rate\",\"rather\",\"raven\",\"raw\",\"razor\",\"ready\",\"real\",\"reason\",\"rebel\",\"rebuild\",\"recall\",\"receive\",\"recipe\",\"record\",\"recycle\",\"reduce\",\"reflect\",\"reform\",\"refuse\",\"region\",\"regret\",\"regular\",\"reject\",\"relax\",\"release\",\"relief\",\"rely\",\"remain\",\"remember\",\"remind\",\"remove\",\"render\",\"renew\",\"rent\",\"reopen\",\"repair\",\"repeat\",\"replace\",\"report\",\"require\",\"rescue\",\"resemble\",\"resist\",\"resource\",\"response\",\"result\",\"retire\",\"retreat\",\"return\",\"reunion\",\"reveal\",\"review\",\"reward\",\"rhythm\",\"rib\",\"ribbon\",\"rice\",\"rich\",\"ride\",\"ridge\",\"rifle\",\"right\",\"rigid\",\"ring\",\"riot\",\"ripple\",\"risk\",\"ritual\",\"rival\",\"river\",\"road\",\"roast\",\"robot\",\"robust\",\"rocket\",\"romance\",\"roof\",\"rookie\",\"room\",\"rose\",\"rotate\",\"rough\",\"round\",\"route\",\"royal\",\"rubber\",\"rude\",\"rug\",\"rule\",\"run\",\"runway\",\"rural\",\"sad\",\"saddle\",\"sadness\",\"safe\",\"sail\",\"salad\",\"salmon\",\"salon\",\"salt\",\"salute\",\"same\",\"sample\",\"sand\",\"satisfy\",\"satoshi\",\"sauce\",\"sausage\",\"save\",\"say\",\"scale\",\"scan\",\"scare\",\"scatter\",\"scene\",\"scheme\",\"school\",\"science\",\"scissors\",\"scorpion\",\"scout\",\"scrap\",\"screen\",\"script\",\"scrub\",\"sea\",\"search\",\"season\",\"seat\",\"second\",\"secret\",\"section\",\"security\",\"seed\",\"seek\",\"segment\",\"select\",\"sell\",\"seminar\",\"senior\",\"sense\",\"sentence\",\"series\",\"service\",\"session\",\"settle\",\"setup\",\"seven\",\"shadow\",\"shaft\",\"shallow\",\"share\",\"shed\",\"shell\",\"sheriff\",\"shield\",\"shift\",\"shine\",\"ship\",\"shiver\",\"shock\",\"shoe\",\"shoot\",\"shop\",\"short\",\"shoulder\",\"shove\",\"shrimp\",\"shrug\",\"shuffle\",\"shy\",\"sibling\",\"sick\",\"side\",\"siege\",\"sight\",\"sign\",\"silent\",\"silk\",\"silly\",\"silver\",\"similar\",\"simple\",\"since\",\"sing\",\"siren\",\"sister\",\"situate\",\"six\",\"size\",\"skate\",\"sketch\",\"ski\",\"skill\",\"skin\",\"skirt\",\"skull\",\"slab\",\"slam\",\"sleep\",\"slender\",\"slice\",\"slide\",\"slight\",\"slim\",\"slogan\",\"slot\",\"slow\",\"slush\",\"small\",\"smart\",\"smile\",\"smoke\",\"smooth\",\"snack\",\"snake\",\"snap\",\"sniff\",\"snow\",\"soap\",\"soccer\",\"social\",\"sock\",\"soda\",\"soft\",\"solar\",\"soldier\",\"solid\",\"solution\",\"solve\",\"someone\",\"song\",\"soon\",\"sorry\",\"sort\",\"soul\",\"sound\",\"soup\",\"source\",\"south\",\"space\",\"spare\",\"spatial\",\"spawn\",\"speak\",\"special\",\"speed\",\"spell\",\"spend\",\"sphere\",\"spice\",\"spider\",\"spike\",\"spin\",\"spirit\",\"split\",\"spoil\",\"sponsor\",\"spoon\",\"sport\",\"spot\",\"spray\",\"spread\",\"spring\",\"spy\",\"square\",\"squeeze\",\"squirrel\",\"stable\",\"stadium\",\"staff\",\"stage\",\"stairs\",\"stamp\",\"stand\",\"start\",\"state\",\"stay\",\"steak\",\"steel\",\"stem\",\"step\",\"stereo\",\"stick\",\"still\",\"sting\",\"stock\",\"stomach\",\"stone\",\"stool\",\"story\",\"stove\",\"strategy\",\"street\",\"strike\",\"strong\",\"struggle\",\"student\",\"stuff\",\"stumble\",\"style\",\"subject\",\"submit\",\"subway\",\"success\",\"such\",\"sudden\",\"suffer\",\"sugar\",\"suggest\",\"suit\",\"summer\",\"sun\",\"sunny\",\"sunset\",\"super\",\"supply\",\"supreme\",\"sure\",\"surface\",\"surge\",\"surprise\",\"surround\",\"survey\",\"suspect\",\"sustain\",\"swallow\",\"swamp\",\"swap\",\"swarm\",\"swear\",\"sweet\",\"swift\",\"swim\",\"swing\",\"switch\",\"sword\",\"symbol\",\"symptom\",\"syrup\",\"system\",\"table\",\"tackle\",\"tag\",\"tail\",\"talent\",\"talk\",\"tank\",\"tape\",\"target\",\"task\",\"taste\",\"tattoo\",\"taxi\",\"teach\",\"team\",\"tell\",\"ten\",\"tenant\",\"tennis\",\"tent\",\"term\",\"test\",\"text\",\"thank\",\"that\",\"theme\",\"then\",\"theory\",\"there\",\"they\",\"thing\",\"this\",\"thought\",\"three\",\"thrive\",\"throw\",\"thumb\",\"thunder\",\"ticket\",\"tide\",\"tiger\",\"tilt\",\"timber\",\"time\",\"tiny\",\"tip\",\"tired\",\"tissue\",\"title\",\"toast\",\"tobacco\",\"today\",\"toddler\",\"toe\",\"together\",\"toilet\",\"token\",\"tomato\",\"tomorrow\",\"tone\",\"tongue\",\"tonight\",\"tool\",\"tooth\",\"top\",\"topic\",\"topple\",\"torch\",\"tornado\",\"tortoise\",\"toss\",\"total\",\"tourist\",\"toward\",\"tower\",\"town\",\"toy\",\"track\",\"trade\",\"traffic\",\"tragic\",\"train\",\"transfer\",\"trap\",\"trash\",\"travel\",\"tray\",\"treat\",\"tree\",\"trend\",\"trial\",\"tribe\",\"trick\",\"trigger\",\"trim\",\"trip\",\"trophy\",\"trouble\",\"truck\",\"true\",\"truly\",\"trumpet\",\"trust\",\"truth\",\"try\",\"tube\",\"tuition\",\"tumble\",\"tuna\",\"tunnel\",\"turkey\",\"turn\",\"turtle\",\"twelve\",\"twenty\",\"twice\",\"twin\",\"twist\",\"two\",\"type\",\"typical\",\"ugly\",\"umbrella\",\"unable\",\"unaware\",\"uncle\",\"uncover\",\"under\",\"undo\",\"unfair\",\"unfold\",\"unhappy\",\"uniform\",\"unique\",\"unit\",\"universe\",\"unknown\",\"unlock\",\"until\",\"unusual\",\"unveil\",\"update\",\"upgrade\",\"uphold\",\"upon\",\"upper\",\"upset\",\"urban\",\"urge\",\"usage\",\"use\",\"used\",\"useful\",\"useless\",\"usual\",\"utility\",\"vacant\",\"vacuum\",\"vague\",\"valid\",\"valley\",\"valve\",\"van\",\"vanish\",\"vapor\",\"various\",\"vast\",\"vault\",\"vehicle\",\"velvet\",\"vendor\",\"venture\",\"venue\",\"verb\",\"verify\",\"version\",\"very\",\"vessel\",\"veteran\",\"viable\",\"vibrant\",\"vicious\",\"victory\",\"video\",\"view\",\"village\",\"vintage\",\"violin\",\"virtual\",\"virus\",\"visa\",\"visit\",\"visual\",\"vital\",\"vivid\",\"vocal\",\"voice\",\"void\",\"volcano\",\"volume\",\"vote\",\"voyage\",\"wage\",\"wagon\",\"wait\",\"walk\",\"wall\",\"walnut\",\"want\",\"warfare\",\"warm\",\"warrior\",\"wash\",\"wasp\",\"waste\",\"water\",\"wave\",\"way\",\"wealth\",\"weapon\",\"wear\",\"weasel\",\"weather\",\"web\",\"wedding\",\"weekend\",\"weird\",\"welcome\",\"west\",\"wet\",\"whale\",\"what\",\"wheat\",\"wheel\",\"when\",\"where\",\"whip\",\"whisper\",\"wide\",\"width\",\"wife\",\"wild\",\"will\",\"win\",\"window\",\"wine\",\"wing\",\"wink\",\"winner\",\"winter\",\"wire\",\"wisdom\",\"wise\",\"wish\",\"witness\",\"wolf\",\"woman\",\"wonder\",\"wood\",\"wool\",\"word\",\"work\",\"world\",\"worry\",\"worth\",\"wrap\",\"wreck\",\"wrestle\",\"wrist\",\"write\",\"wrong\",\"yard\",\"year\",\"yellow\",\"you\",\"young\",\"youth\",\"zebra\",\"zero\",\"zone\",\"zoo\"][\"abaisser\",\"abandon\",\"abdiquer\",\"abeille\",\"abolir\",\"aborder\",\"aboutir\",\"aboyer\",\"abrasif\",\"abreuver\",\"abriter\",\"abroger\",\"abrupt\",\"absence\",\"absolu\",\"absurde\",\"abusif\",\"abyssal\",\"academie\",\"acajou\",\"acarien\",\"accabler\",\"accepter\",\"acclamer\",\"accolade\",\"accroche\",\"accuser\",\"acerbe\",\"achat\",\"acheter\",\"aciduler\",\"acier\",\"acompte\",\"acquerir\",\"acronyme\",\"acteur\",\"actif\",\"actuel\",\"adepte\",\"adequat\",\"adhesif\",\"adjectif\",\"adjuger\",\"admettre\",\"admirer\",\"adopter\",\"adorer\",\"adoucir\",\"adresse\",\"adroit\",\"adulte\",\"adverbe\",\"aerer\",\"aeronef\",\"affaire\",\"affecter\",\"affiche\",\"affreux\",\"affubler\",\"agacer\",\"agencer\",\"agile\",\"agiter\",\"agrafer\",\"agreable\",\"agrume\",\"aider\",\"aiguille\",\"ailier\",\"aimable\",\"aisance\",\"ajouter\",\"ajuster\",\"alarmer\",\"alchimie\",\"alerte\",\"algebre\",\"algue\",\"aliener\",\"aliment\",\"alleger\",\"alliage\",\"allouer\",\"allumer\",\"alourdir\",\"alpaga\",\"altesse\",\"alveole\",\"amateur\",\"ambigu\",\"ambre\",\"amenager\",\"amertume\",\"amidon\",\"amiral\",\"amorcer\",\"amour\",\"amovible\",\"amphibie\",\"ampleur\",\"amusant\",\"analyse\",\"anaphore\",\"anarchie\",\"anatomie\",\"ancien\",\"aneantir\",\"angle\",\"angoisse\",\"anguleux\",\"animal\",\"annexer\",\"annonce\",\"annuel\",\"anodin\",\"anomalie\",\"anonyme\",\"anormal\",\"antenne\",\"antidote\",\"anxieux\",\"apaiser\",\"aperitif\",\"aplanir\",\"apologie\",\"appareil\",\"appeler\",\"apporter\",\"appuyer\",\"aquarium\",\"aqueduc\",\"arbitre\",\"arbuste\",\"ardeur\",\"ardoise\",\"argent\",\"arlequin\",\"armature\",\"armement\",\"armoire\",\"armure\",\"arpenter\",\"arracher\",\"arriver\",\"arroser\",\"arsenic\",\"arteriel\",\"article\",\"aspect\",\"asphalte\",\"aspirer\",\"assaut\",\"asservir\",\"assiette\",\"associer\",\"assurer\",\"asticot\",\"astre\",\"astuce\",\"atelier\",\"atome\",\"atrium\",\"atroce\",\"attaque\",\"attentif\",\"attirer\",\"attraper\",\"aubaine\",\"auberge\",\"audace\",\"audible\",\"augurer\",\"aurore\",\"automne\",\"autruche\",\"avaler\",\"avancer\",\"avarice\",\"avenir\",\"averse\",\"aveugle\",\"aviateur\",\"avide\",\"avion\",\"aviser\",\"avoine\",\"avouer\",\"avril\",\"axial\",\"axiome\",\"badge\",\"bafouer\",\"bagage\",\"baguette\",\"baignade\",\"balancer\",\"balcon\",\"baleine\",\"balisage\",\"bambin\",\"bancaire\",\"bandage\",\"banlieue\",\"banniere\",\"banquier\",\"barbier\",\"baril\",\"baron\",\"barque\",\"barrage\",\"bassin\",\"bastion\",\"bataille\",\"bateau\",\"batterie\",\"baudrier\",\"bavarder\",\"belette\",\"belier\",\"belote\",\"benefice\",\"berceau\",\"berger\",\"berline\",\"bermuda\",\"besace\",\"besogne\",\"betail\",\"beurre\",\"biberon\",\"bicycle\",\"bidule\",\"bijou\",\"bilan\",\"bilingue\",\"billard\",\"binaire\",\"biologie\",\"biopsie\",\"biotype\",\"biscuit\",\"bison\",\"bistouri\",\"bitume\",\"bizarre\",\"blafard\",\"blague\",\"blanchir\",\"blessant\",\"blinder\",\"blond\",\"bloquer\",\"blouson\",\"bobard\",\"bobine\",\"boire\",\"boiser\",\"bolide\",\"bonbon\",\"bondir\",\"bonheur\",\"bonifier\",\"bonus\",\"bordure\",\"borne\",\"botte\",\"boucle\",\"boueux\",\"bougie\",\"boulon\",\"bouquin\",\"bourse\",\"boussole\",\"boutique\",\"boxeur\",\"branche\",\"brasier\",\"brave\",\"brebis\",\"breche\",\"breuvage\",\"bricoler\",\"brigade\",\"brillant\",\"brioche\",\"brique\",\"brochure\",\"broder\",\"bronzer\",\"brousse\",\"broyeur\",\"brume\",\"brusque\",\"brutal\",\"bruyant\",\"buffle\",\"buisson\",\"bulletin\",\"bureau\",\"burin\",\"bustier\",\"butiner\",\"butoir\",\"buvable\",\"buvette\",\"cabanon\",\"cabine\",\"cachette\",\"cadeau\",\"cadre\",\"cafeine\",\"caillou\",\"caisson\",\"calculer\",\"calepin\",\"calibre\",\"calmer\",\"calomnie\",\"calvaire\",\"camarade\",\"camera\",\"camion\",\"campagne\",\"canal\",\"caneton\",\"canon\",\"cantine\",\"canular\",\"capable\",\"caporal\",\"caprice\",\"capsule\",\"capter\",\"capuche\",\"carabine\",\"carbone\",\"caresser\",\"caribou\",\"carnage\",\"carotte\",\"carreau\",\"carton\",\"cascade\",\"casier\",\"casque\",\"cassure\",\"causer\",\"caution\",\"cavalier\",\"caverne\",\"caviar\",\"cedille\",\"ceinture\",\"celeste\",\"cellule\",\"cendrier\",\"censurer\",\"central\",\"cercle\",\"cerebral\",\"cerise\",\"cerner\",\"cerveau\",\"cesser\",\"chagrin\",\"chaise\",\"chaleur\",\"chambre\",\"chance\",\"chapitre\",\"charbon\",\"chasseur\",\"chaton\",\"chausson\",\"chavirer\",\"chemise\",\"chenille\",\"chequier\",\"chercher\",\"cheval\",\"chien\",\"chiffre\",\"chignon\",\"chimere\",\"chiot\",\"chlorure\",\"chocolat\",\"choisir\",\"chose\",\"chouette\",\"chrome\",\"chute\",\"cigare\",\"cigogne\",\"cimenter\",\"cinema\",\"cintrer\",\"circuler\",\"cirer\",\"cirque\",\"citerne\",\"citoyen\",\"citron\",\"civil\",\"clairon\",\"clameur\",\"claquer\",\"classe\",\"clavier\",\"client\",\"cligner\",\"climat\",\"clivage\",\"cloche\",\"clonage\",\"cloporte\",\"cobalt\",\"cobra\",\"cocasse\",\"cocotier\",\"coder\",\"codifier\",\"coffre\",\"cogner\",\"cohesion\",\"coiffer\",\"coincer\",\"colere\",\"colibri\",\"colline\",\"colmater\",\"colonel\",\"combat\",\"comedie\",\"commande\",\"compact\",\"concert\",\"conduire\",\"confier\",\"congeler\",\"connoter\",\"consonne\",\"contact\",\"convexe\",\"copain\",\"copie\",\"corail\",\"corbeau\",\"cordage\",\"corniche\",\"corpus\",\"correct\",\"cortege\",\"cosmique\",\"costume\",\"coton\",\"coude\",\"coupure\",\"courage\",\"couteau\",\"couvrir\",\"coyote\",\"crabe\",\"crainte\",\"cravate\",\"crayon\",\"creature\",\"crediter\",\"cremeux\",\"creuser\",\"crevette\",\"cribler\",\"crier\",\"cristal\",\"critere\",\"croire\",\"croquer\",\"crotale\",\"crucial\",\"cruel\",\"crypter\",\"cubique\",\"cueillir\",\"cuillere\",\"cuisine\",\"cuivre\",\"culminer\",\"cultiver\",\"cumuler\",\"cupide\",\"curatif\",\"curseur\",\"cyanure\",\"cycle\",\"cylindre\",\"cynique\",\"daigner\",\"damier\",\"danger\",\"danseur\",\"dauphin\",\"debattre\",\"debiter\",\"deborder\",\"debrider\",\"debutant\",\"decaler\",\"decembre\",\"dechirer\",\"decider\",\"declarer\",\"decorer\",\"decrire\",\"decupler\",\"dedale\",\"deductif\",\"deesse\",\"defensif\",\"defiler\",\"defrayer\",\"degager\",\"degivrer\",\"deglutir\",\"degrafer\",\"dejeuner\",\"delice\",\"deloger\",\"demander\",\"demeurer\",\"demolir\",\"denicher\",\"denouer\",\"dentelle\",\"denuder\",\"depart\",\"depenser\",\"dephaser\",\"deplacer\",\"deposer\",\"deranger\",\"derober\",\"desastre\",\"descente\",\"desert\",\"designer\",\"desobeir\",\"dessiner\",\"destrier\",\"detacher\",\"detester\",\"detourer\",\"detresse\",\"devancer\",\"devenir\",\"deviner\",\"devoir\",\"diable\",\"dialogue\",\"diamant\",\"dicter\",\"differer\",\"digerer\",\"digital\",\"digne\",\"diluer\",\"dimanche\",\"diminuer\",\"dioxyde\",\"directif\",\"diriger\",\"discuter\",\"disposer\",\"dissiper\",\"distance\",\"divertir\",\"diviser\",\"docile\",\"docteur\",\"dogme\",\"doigt\",\"domaine\",\"domicile\",\"dompter\",\"donateur\",\"donjon\",\"donner\",\"dopamine\",\"dortoir\",\"dorure\",\"dosage\",\"doseur\",\"dossier\",\"dotation\",\"douanier\",\"double\",\"douceur\",\"douter\",\"doyen\",\"dragon\",\"draper\",\"dresser\",\"dribbler\",\"droiture\",\"duperie\",\"duplexe\",\"durable\",\"durcir\",\"dynastie\",\"eblouir\",\"ecarter\",\"echarpe\",\"echelle\",\"eclairer\",\"eclipse\",\"eclore\",\"ecluse\",\"ecole\",\"economie\",\"ecorce\",\"ecouter\",\"ecraser\",\"ecremer\",\"ecrivain\",\"ecrou\",\"ecume\",\"ecureuil\",\"edifier\",\"eduquer\",\"effacer\",\"effectif\",\"effigie\",\"effort\",\"effrayer\",\"effusion\",\"egaliser\",\"egarer\",\"ejecter\",\"elaborer\",\"elargir\",\"electron\",\"elegant\",\"elephant\",\"eleve\",\"eligible\",\"elitisme\",\"eloge\",\"elucider\",\"eluder\",\"emballer\",\"embellir\",\"embryon\",\"emeraude\",\"emission\",\"emmener\",\"emotion\",\"emouvoir\",\"empereur\",\"employer\",\"emporter\",\"emprise\",\"emulsion\",\"encadrer\",\"enchere\",\"enclave\",\"encoche\",\"endiguer\",\"endosser\",\"endroit\",\"enduire\",\"energie\",\"enfance\",\"enfermer\",\"enfouir\",\"engager\",\"engin\",\"englober\",\"enigme\",\"enjamber\",\"enjeu\",\"enlever\",\"ennemi\",\"ennuyeux\",\"enrichir\",\"enrobage\",\"enseigne\",\"entasser\",\"entendre\",\"entier\",\"entourer\",\"entraver\",\"enumerer\",\"envahir\",\"enviable\",\"envoyer\",\"enzyme\",\"eolien\",\"epaissir\",\"epargne\",\"epatant\",\"epaule\",\"epicerie\",\"epidemie\",\"epier\",\"epilogue\",\"epine\",\"episode\",\"epitaphe\",\"epoque\",\"epreuve\",\"eprouver\",\"epuisant\",\"equerre\",\"equipe\",\"eriger\",\"erosion\",\"erreur\",\"eruption\",\"escalier\",\"espadon\",\"espece\",\"espiegle\",\"espoir\",\"esprit\",\"esquiver\",\"essayer\",\"essence\",\"essieu\",\"essorer\",\"estime\",\"estomac\",\"estrade\",\"etagere\",\"etaler\",\"etanche\",\"etatique\",\"eteindre\",\"etendoir\",\"eternel\",\"ethanol\",\"ethique\",\"ethnie\",\"etirer\",\"etoffer\",\"etoile\",\"etonnant\",\"etourdir\",\"etrange\",\"etroit\",\"etude\",\"euphorie\",\"evaluer\",\"evasion\",\"eventail\",\"evidence\",\"eviter\",\"evolutif\",\"evoquer\",\"exact\",\"exagerer\",\"exaucer\",\"exceller\",\"excitant\",\"exclusif\",\"excuse\",\"executer\",\"exemple\",\"exercer\",\"exhaler\",\"exhorter\",\"exigence\",\"exiler\",\"exister\",\"exotique\",\"expedier\",\"explorer\",\"exposer\",\"exprimer\",\"exquis\",\"extensif\",\"extraire\",\"exulter\",\"fable\",\"fabuleux\",\"facette\",\"facile\",\"facture\",\"faiblir\",\"falaise\",\"fameux\",\"famille\",\"farceur\",\"farfelu\",\"farine\",\"farouche\",\"fasciner\",\"fatal\",\"fatigue\",\"faucon\",\"fautif\",\"faveur\",\"favori\",\"febrile\",\"feconder\",\"federer\",\"felin\",\"femme\",\"femur\",\"fendoir\",\"feodal\",\"fermer\",\"feroce\",\"ferveur\",\"festival\",\"feuille\",\"feutre\",\"fevrier\",\"fiasco\",\"ficeler\",\"fictif\",\"fidele\",\"figure\",\"filature\",\"filetage\",\"filiere\",\"filleul\",\"filmer\",\"filou\",\"filtrer\",\"financer\",\"finir\",\"fiole\",\"firme\",\"fissure\",\"fixer\",\"flairer\",\"flamme\",\"flasque\",\"flatteur\",\"fleau\",\"fleche\",\"fleur\",\"flexion\",\"flocon\",\"flore\",\"fluctuer\",\"fluide\",\"fluvial\",\"folie\",\"fonderie\",\"fongible\",\"fontaine\",\"forcer\",\"forgeron\",\"formuler\",\"fortune\",\"fossile\",\"foudre\",\"fougere\",\"fouiller\",\"foulure\",\"fourmi\",\"fragile\",\"fraise\",\"franchir\",\"frapper\",\"frayeur\",\"fregate\",\"freiner\",\"frelon\",\"fremir\",\"frenesie\",\"frere\",\"friable\",\"friction\",\"frisson\",\"frivole\",\"froid\",\"fromage\",\"frontal\",\"frotter\",\"fruit\",\"fugitif\",\"fuite\",\"fureur\",\"furieux\",\"furtif\",\"fusion\",\"futur\",\"gagner\",\"galaxie\",\"galerie\",\"gambader\",\"garantir\",\"gardien\",\"garnir\",\"garrigue\",\"gazelle\",\"gazon\",\"geant\",\"gelatine\",\"gelule\",\"gendarme\",\"general\",\"genie\",\"genou\",\"gentil\",\"geologie\",\"geometre\",\"geranium\",\"germe\",\"gestuel\",\"geyser\",\"gibier\",\"gicler\",\"girafe\",\"givre\",\"glace\",\"glaive\",\"glisser\",\"globe\",\"gloire\",\"glorieux\",\"golfeur\",\"gomme\",\"gonfler\",\"gorge\",\"gorille\",\"goudron\",\"gouffre\",\"goulot\",\"goupille\",\"gourmand\",\"goutte\",\"graduel\",\"graffiti\",\"graine\",\"grand\",\"grappin\",\"gratuit\",\"gravir\",\"grenat\",\"griffure\",\"griller\",\"grimper\",\"grogner\",\"gronder\",\"grotte\",\"groupe\",\"gruger\",\"grutier\",\"gruyere\",\"guepard\",\"guerrier\",\"guide\",\"guimauve\",\"guitare\",\"gustatif\",\"gymnaste\",\"gyrostat\",\"habitude\",\"hachoir\",\"halte\",\"hameau\",\"hangar\",\"hanneton\",\"haricot\",\"harmonie\",\"harpon\",\"hasard\",\"helium\",\"hematome\",\"herbe\",\"herisson\",\"hermine\",\"heron\",\"hesiter\",\"heureux\",\"hiberner\",\"hibou\",\"hilarant\",\"histoire\",\"hiver\",\"homard\",\"hommage\",\"homogene\",\"honneur\",\"honorer\",\"honteux\",\"horde\",\"horizon\",\"horloge\",\"hormone\",\"horrible\",\"houleux\",\"housse\",\"hublot\",\"huileux\",\"humain\",\"humble\",\"humide\",\"humour\",\"hurler\",\"hydromel\",\"hygiene\",\"hymne\",\"hypnose\",\"idylle\",\"ignorer\",\"iguane\",\"illicite\",\"illusion\",\"image\",\"imbiber\",\"imiter\",\"immense\",\"immobile\",\"immuable\",\"impact\",\"imperial\",\"implorer\",\"imposer\",\"imprimer\",\"imputer\",\"incarner\",\"incendie\",\"incident\",\"incliner\",\"incolore\",\"indexer\",\"indice\",\"inductif\",\"inedit\",\"ineptie\",\"inexact\",\"infini\",\"infliger\",\"informer\",\"infusion\",\"ingerer\",\"inhaler\",\"inhiber\",\"injecter\",\"injure\",\"innocent\",\"inoculer\",\"inonder\",\"inscrire\",\"insecte\",\"insigne\",\"insolite\",\"inspirer\",\"instinct\",\"insulter\",\"intact\",\"intense\",\"intime\",\"intrigue\",\"intuitif\",\"inutile\",\"invasion\",\"inventer\",\"inviter\",\"invoquer\",\"ironique\",\"irradier\",\"irreel\",\"irriter\",\"isoler\",\"ivoire\",\"ivresse\",\"jaguar\",\"jaillir\",\"jambe\",\"janvier\",\"jardin\",\"jauger\",\"jaune\",\"javelot\",\"jetable\",\"jeton\",\"jeudi\",\"jeunesse\",\"joindre\",\"joncher\",\"jongler\",\"joueur\",\"jouissif\",\"journal\",\"jovial\",\"joyau\",\"joyeux\",\"jubiler\",\"jugement\",\"junior\",\"jupon\",\"juriste\",\"justice\",\"juteux\",\"juvenile\",\"kayak\",\"kimono\",\"kiosque\",\"label\",\"labial\",\"labourer\",\"lacerer\",\"lactose\",\"lagune\",\"laine\",\"laisser\",\"laitier\",\"lambeau\",\"lamelle\",\"lampe\",\"lanceur\",\"langage\",\"lanterne\",\"lapin\",\"largeur\",\"larme\",\"laurier\",\"lavabo\",\"lavoir\",\"lecture\",\"legal\",\"leger\",\"legume\",\"lessive\",\"lettre\",\"levier\",\"lexique\",\"lezard\",\"liasse\",\"liberer\",\"libre\",\"licence\",\"licorne\",\"liege\",\"lievre\",\"ligature\",\"ligoter\",\"ligue\",\"limer\",\"limite\",\"limonade\",\"limpide\",\"lineaire\",\"lingot\",\"lionceau\",\"liquide\",\"lisiere\",\"lister\",\"lithium\",\"litige\",\"littoral\",\"livreur\",\"logique\",\"lointain\",\"loisir\",\"lombric\",\"loterie\",\"louer\",\"lourd\",\"loutre\",\"louve\",\"loyal\",\"lubie\",\"lucide\",\"lucratif\",\"lueur\",\"lugubre\",\"luisant\",\"lumiere\",\"lunaire\",\"lundi\",\"luron\",\"lutter\",\"luxueux\",\"machine\",\"magasin\",\"magenta\",\"magique\",\"maigre\",\"maillon\",\"maintien\",\"mairie\",\"maison\",\"majorer\",\"malaxer\",\"malefice\",\"malheur\",\"malice\",\"mallette\",\"mammouth\",\"mandater\",\"maniable\",\"manquant\",\"manteau\",\"manuel\",\"marathon\",\"marbre\",\"marchand\",\"mardi\",\"maritime\",\"marqueur\",\"marron\",\"marteler\",\"mascotte\",\"massif\",\"materiel\",\"matiere\",\"matraque\",\"maudire\",\"maussade\",\"mauve\",\"maximal\",\"mechant\",\"meconnu\",\"medaille\",\"medecin\",\"mediter\",\"meduse\",\"meilleur\",\"melange\",\"melodie\",\"membre\",\"memoire\",\"menacer\",\"mener\",\"menhir\",\"mensonge\",\"mentor\",\"mercredi\",\"merite\",\"merle\",\"messager\",\"mesure\",\"metal\",\"meteore\",\"methode\",\"metier\",\"meuble\",\"miauler\",\"microbe\",\"miette\",\"mignon\",\"migrer\",\"milieu\",\"million\",\"mimique\",\"mince\",\"mineral\",\"minimal\",\"minorer\",\"minute\",\"miracle\",\"miroiter\",\"missile\",\"mixte\",\"mobile\",\"moderne\",\"moelleux\",\"mondial\",\"moniteur\",\"monnaie\",\"monotone\",\"monstre\",\"montagne\",\"monument\",\"moqueur\",\"morceau\",\"morsure\",\"mortier\",\"moteur\",\"motif\",\"mouche\",\"moufle\",\"moulin\",\"mousson\",\"mouton\",\"mouvant\",\"multiple\",\"munition\",\"muraille\",\"murene\",\"murmure\",\"muscle\",\"museum\",\"musicien\",\"mutation\",\"muter\",\"mutuel\",\"myriade\",\"myrtille\",\"mystere\",\"mythique\",\"nageur\",\"nappe\",\"narquois\",\"narrer\",\"natation\",\"nation\",\"nature\",\"naufrage\",\"nautique\",\"navire\",\"nebuleux\",\"nectar\",\"nefaste\",\"negation\",\"negliger\",\"negocier\",\"neige\",\"nerveux\",\"nettoyer\",\"neurone\",\"neutron\",\"neveu\",\"niche\",\"nickel\",\"nitrate\",\"niveau\",\"noble\",\"nocif\",\"nocturne\",\"noirceur\",\"noisette\",\"nomade\",\"nombreux\",\"nommer\",\"normatif\",\"notable\",\"notifier\",\"notoire\",\"nourrir\",\"nouveau\",\"novateur\",\"novembre\",\"novice\",\"nuage\",\"nuancer\",\"nuire\",\"nuisible\",\"numero\",\"nuptial\",\"nuque\",\"nutritif\",\"obeir\",\"objectif\",\"obliger\",\"obscur\",\"observer\",\"obstacle\",\"obtenir\",\"obturer\",\"occasion\",\"occuper\",\"ocean\",\"octobre\",\"octroyer\",\"octupler\",\"oculaire\",\"odeur\",\"odorant\",\"offenser\",\"officier\",\"offrir\",\"ogive\",\"oiseau\",\"oisillon\",\"olfactif\",\"olivier\",\"ombrage\",\"omettre\",\"onctueux\",\"onduler\",\"onereux\",\"onirique\",\"opale\",\"opaque\",\"operer\",\"opinion\",\"opportun\",\"opprimer\",\"opter\",\"optique\",\"orageux\",\"orange\",\"orbite\",\"ordonner\",\"oreille\",\"organe\",\"orgueil\",\"orifice\",\"ornement\",\"orque\",\"ortie\",\"osciller\",\"osmose\",\"ossature\",\"otarie\",\"ouragan\",\"ourson\",\"outil\",\"outrager\",\"ouvrage\",\"ovation\",\"oxyde\",\"oxygene\",\"ozone\",\"paisible\",\"palace\",\"palmares\",\"palourde\",\"palper\",\"panache\",\"panda\",\"pangolin\",\"paniquer\",\"panneau\",\"panorama\",\"pantalon\",\"papaye\",\"papier\",\"papoter\",\"papyrus\",\"paradoxe\",\"parcelle\",\"paresse\",\"parfumer\",\"parler\",\"parole\",\"parrain\",\"parsemer\",\"partager\",\"parure\",\"parvenir\",\"passion\",\"pasteque\",\"paternel\",\"patience\",\"patron\",\"pavillon\",\"pavoiser\",\"payer\",\"paysage\",\"peigne\",\"peintre\",\"pelage\",\"pelican\",\"pelle\",\"pelouse\",\"peluche\",\"pendule\",\"penetrer\",\"penible\",\"pensif\",\"penurie\",\"pepite\",\"peplum\",\"perdrix\",\"perforer\",\"periode\",\"permuter\",\"perplexe\",\"persil\",\"perte\",\"peser\",\"petale\",\"petit\",\"petrir\",\"peuple\",\"pharaon\",\"phobie\",\"phoque\",\"photon\",\"phrase\",\"physique\",\"piano\",\"pictural\",\"piece\",\"pierre\",\"pieuvre\",\"pilote\",\"pinceau\",\"pipette\",\"piquer\",\"pirogue\",\"piscine\",\"piston\",\"pivoter\",\"pixel\",\"pizza\",\"placard\",\"plafond\",\"plaisir\",\"planer\",\"plaque\",\"plastron\",\"plateau\",\"pleurer\",\"plexus\",\"pliage\",\"plomb\",\"plonger\",\"pluie\",\"plumage\",\"pochette\",\"poesie\",\"poete\",\"pointe\",\"poirier\",\"poisson\",\"poivre\",\"polaire\",\"policier\",\"pollen\",\"polygone\",\"pommade\",\"pompier\",\"ponctuel\",\"ponderer\",\"poney\",\"portique\",\"position\",\"posseder\",\"posture\",\"potager\",\"poteau\",\"potion\",\"pouce\",\"poulain\",\"poumon\",\"pourpre\",\"poussin\",\"pouvoir\",\"prairie\",\"pratique\",\"precieux\",\"predire\",\"prefixe\",\"prelude\",\"prenom\",\"presence\",\"pretexte\",\"prevoir\",\"primitif\",\"prince\",\"prison\",\"priver\",\"probleme\",\"proceder\",\"prodige\",\"profond\",\"progres\",\"proie\",\"projeter\",\"prologue\",\"promener\",\"propre\",\"prospere\",\"proteger\",\"prouesse\",\"proverbe\",\"prudence\",\"pruneau\",\"psychose\",\"public\",\"puceron\",\"puiser\",\"pulpe\",\"pulsar\",\"punaise\",\"punitif\",\"pupitre\",\"purifier\",\"puzzle\",\"pyramide\",\"quasar\",\"querelle\",\"question\",\"quietude\",\"quitter\",\"quotient\",\"racine\",\"raconter\",\"radieux\",\"ragondin\",\"raideur\",\"raisin\",\"ralentir\",\"rallonge\",\"ramasser\",\"rapide\",\"rasage\",\"ratisser\",\"ravager\",\"ravin\",\"rayonner\",\"reactif\",\"reagir\",\"realiser\",\"reanimer\",\"recevoir\",\"reciter\",\"reclamer\",\"recolter\",\"recruter\",\"reculer\",\"recycler\",\"rediger\",\"redouter\",\"refaire\",\"reflexe\",\"reformer\",\"refrain\",\"refuge\",\"regalien\",\"region\",\"reglage\",\"regulier\",\"reiterer\",\"rejeter\",\"rejouer\",\"relatif\",\"relever\",\"relief\",\"remarque\",\"remede\",\"remise\",\"remonter\",\"remplir\",\"remuer\",\"renard\",\"renfort\",\"renifler\",\"renoncer\",\"rentrer\",\"renvoi\",\"replier\",\"reporter\",\"reprise\",\"reptile\",\"requin\",\"reserve\",\"resineux\",\"resoudre\",\"respect\",\"rester\",\"resultat\",\"retablir\",\"retenir\",\"reticule\",\"retomber\",\"retracer\",\"reunion\",\"reussir\",\"revanche\",\"revivre\",\"revolte\",\"revulsif\",\"richesse\",\"rideau\",\"rieur\",\"rigide\",\"rigoler\",\"rincer\",\"riposter\",\"risible\",\"risque\",\"rituel\",\"rival\",\"riviere\",\"rocheux\",\"romance\",\"rompre\",\"ronce\",\"rondin\",\"roseau\",\"rosier\",\"rotatif\",\"rotor\",\"rotule\",\"rouge\",\"rouille\",\"rouleau\",\"routine\",\"royaume\",\"ruban\",\"rubis\",\"ruche\",\"ruelle\",\"rugueux\",\"ruiner\",\"ruisseau\",\"ruser\",\"rustique\",\"rythme\",\"sabler\",\"saboter\",\"sabre\",\"sacoche\",\"safari\",\"sagesse\",\"saisir\",\"salade\",\"salive\",\"salon\",\"saluer\",\"samedi\",\"sanction\",\"sanglier\",\"sarcasme\",\"sardine\",\"saturer\",\"saugrenu\",\"saumon\",\"sauter\",\"sauvage\",\"savant\",\"savonner\",\"scalpel\",\"scandale\",\"scelerat\",\"scenario\",\"sceptre\",\"schema\",\"science\",\"scinder\",\"score\",\"scrutin\",\"sculpter\",\"seance\",\"secable\",\"secher\",\"secouer\",\"secreter\",\"sedatif\",\"seduire\",\"seigneur\",\"sejour\",\"selectif\",\"semaine\",\"sembler\",\"semence\",\"seminal\",\"senateur\",\"sensible\",\"sentence\",\"separer\",\"sequence\",\"serein\",\"sergent\",\"serieux\",\"serrure\",\"serum\",\"service\",\"sesame\",\"sevir\",\"sevrage\",\"sextuple\",\"sideral\",\"siecle\",\"sieger\",\"siffler\",\"sigle\",\"signal\",\"silence\",\"silicium\",\"simple\",\"sincere\",\"sinistre\",\"siphon\",\"sirop\",\"sismique\",\"situer\",\"skier\",\"social\",\"socle\",\"sodium\",\"soigneux\",\"soldat\",\"soleil\",\"solitude\",\"soluble\",\"sombre\",\"sommeil\",\"somnoler\",\"sonde\",\"songeur\",\"sonnette\",\"sonore\",\"sorcier\",\"sortir\",\"sosie\",\"sottise\",\"soucieux\",\"soudure\",\"souffle\",\"soulever\",\"soupape\",\"source\",\"soutirer\",\"souvenir\",\"spacieux\",\"spatial\",\"special\",\"sphere\",\"spiral\",\"stable\",\"station\",\"sternum\",\"stimulus\",\"stipuler\",\"strict\",\"studieux\",\"stupeur\",\"styliste\",\"sublime\",\"substrat\",\"subtil\",\"subvenir\",\"succes\",\"sucre\",\"suffixe\",\"suggerer\",\"suiveur\",\"sulfate\",\"superbe\",\"supplier\",\"surface\",\"suricate\",\"surmener\",\"surprise\",\"sursaut\",\"survie\",\"suspect\",\"syllabe\",\"symbole\",\"symetrie\",\"synapse\",\"syntaxe\",\"systeme\",\"tabac\",\"tablier\",\"tactile\",\"tailler\",\"talent\",\"talisman\",\"talonner\",\"tambour\",\"tamiser\",\"tangible\",\"tapis\",\"taquiner\",\"tarder\",\"tarif\",\"tartine\",\"tasse\",\"tatami\",\"tatouage\",\"taupe\",\"taureau\",\"taxer\",\"temoin\",\"temporel\",\"tenaille\",\"tendre\",\"teneur\",\"tenir\",\"tension\",\"terminer\",\"terne\",\"terrible\",\"tetine\",\"texte\",\"theme\",\"theorie\",\"therapie\",\"thorax\",\"tibia\",\"tiede\",\"timide\",\"tirelire\",\"tiroir\",\"tissu\",\"titane\",\"titre\",\"tituber\",\"toboggan\",\"tolerant\",\"tomate\",\"tonique\",\"tonneau\",\"toponyme\",\"torche\",\"tordre\",\"tornade\",\"torpille\",\"torrent\",\"torse\",\"tortue\",\"totem\",\"toucher\",\"tournage\",\"tousser\",\"toxine\",\"traction\",\"trafic\",\"tragique\",\"trahir\",\"train\",\"trancher\",\"travail\",\"trefle\",\"tremper\",\"tresor\",\"treuil\",\"triage\",\"tribunal\",\"tricoter\",\"trilogie\",\"triomphe\",\"tripler\",\"triturer\",\"trivial\",\"trombone\",\"tronc\",\"tropical\",\"troupeau\",\"tuile\",\"tulipe\",\"tumulte\",\"tunnel\",\"turbine\",\"tuteur\",\"tutoyer\",\"tuyau\",\"tympan\",\"typhon\",\"typique\",\"tyran\",\"ubuesque\",\"ultime\",\"ultrason\",\"unanime\",\"unifier\",\"union\",\"unique\",\"unitaire\",\"univers\",\"uranium\",\"urbain\",\"urticant\",\"usage\",\"usine\",\"usuel\",\"usure\",\"utile\",\"utopie\",\"vacarme\",\"vaccin\",\"vagabond\",\"vague\",\"vaillant\",\"vaincre\",\"vaisseau\",\"valable\",\"valise\",\"vallon\",\"valve\",\"vampire\",\"vanille\",\"vapeur\",\"varier\",\"vaseux\",\"vassal\",\"vaste\",\"vecteur\",\"vedette\",\"vegetal\",\"vehicule\",\"veinard\",\"veloce\",\"vendredi\",\"venerer\",\"venger\",\"venimeux\",\"ventouse\",\"verdure\",\"verin\",\"vernir\",\"verrou\",\"verser\",\"vertu\",\"veston\",\"veteran\",\"vetuste\",\"vexant\",\"vexer\",\"viaduc\",\"viande\",\"victoire\",\"vidange\",\"video\",\"vignette\",\"vigueur\",\"vilain\",\"village\",\"vinaigre\",\"violon\",\"vipere\",\"virement\",\"virtuose\",\"virus\",\"visage\",\"viseur\",\"vision\",\"visqueux\",\"visuel\",\"vital\",\"vitesse\",\"viticole\",\"vitrine\",\"vivace\",\"vivipare\",\"vocation\",\"voguer\",\"voile\",\"voisin\",\"voiture\",\"volaille\",\"volcan\",\"voltiger\",\"volume\",\"vorace\",\"vortex\",\"voter\",\"vouloir\",\"voyage\",\"voyelle\",\"wagon\",\"xenon\",\"yacht\",\"zebre\",\"zenith\",\"zeste\",\"zoologie\"]// note all JSON files in this folder are generated with npm run generate-wordlist\nconst lookup = require('./lookup.json')\n\nmodule.exports = {\n  loadWordlist,\n  detectLanguage\n}\n\nfunction loadWordlist (language) {\n  switch (language) {\n    case 'chinese_simplified': return require('./chinese_simplified.json')\n    case 'chinese_traditional': return require('./chinese_traditional.json')\n    case 'czech': return require('./czech.json')\n    case 'english': return require('./english.json')\n    case 'french': return require('./french.json')\n    case 'italian': return require('./italian.json')\n    case 'japanese': return require('./japanese.json')\n    case 'korean': return require('./korean.json')\n    case 'portuguese': return require('./portuguese.json')\n    case 'russian': return require('./russian.json')\n    case 'spanish': return require('./spanish.json')\n    case 'turkish': return require('./turkish.json')\n  }\n\n  throw new Error('Unknown language: ' + language)\n}\n\nfunction detectLanguage (words) {\n  let candidate = null\n\n  for (const word of words) {\n    const languages = lookup[word]\n    if (!languages) return null\n\n    if (languages.length === 1) return languages[0]\n\n    if (!candidate) {\n      candidate = languages\n      continue\n    }\n\n    const intersect = candidate.filter(l => languages.includes(l))\n    if (intersect.length === 1) return intersect[0]\n  }\n\n  return candidate[0]\n}\n[\"abaco\",\"abbaglio\",\"abbinato\",\"abete\",\"abisso\",\"abolire\",\"abrasivo\",\"abrogato\",\"accadere\",\"accenno\",\"accusato\",\"acetone\",\"achille\",\"acido\",\"acqua\",\"acre\",\"acrilico\",\"acrobata\",\"acuto\",\"adagio\",\"addebito\",\"addome\",\"adeguato\",\"aderire\",\"adipe\",\"adottare\",\"adulare\",\"affabile\",\"affetto\",\"affisso\",\"affranto\",\"aforisma\",\"afoso\",\"africano\",\"agave\",\"agente\",\"agevole\",\"aggancio\",\"agire\",\"agitare\",\"agonismo\",\"agricolo\",\"agrumeto\",\"aguzzo\",\"alabarda\",\"alato\",\"albatro\",\"alberato\",\"albo\",\"albume\",\"alce\",\"alcolico\",\"alettone\",\"alfa\",\"algebra\",\"aliante\",\"alibi\",\"alimento\",\"allagato\",\"allegro\",\"allievo\",\"allodola\",\"allusivo\",\"almeno\",\"alogeno\",\"alpaca\",\"alpestre\",\"altalena\",\"alterno\",\"alticcio\",\"altrove\",\"alunno\",\"alveolo\",\"alzare\",\"amalgama\",\"amanita\",\"amarena\",\"ambito\",\"ambrato\",\"ameba\",\"america\",\"ametista\",\"amico\",\"ammasso\",\"ammenda\",\"ammirare\",\"ammonito\",\"amore\",\"ampio\",\"ampliare\",\"amuleto\",\"anacardo\",\"anagrafe\",\"analista\",\"anarchia\",\"anatra\",\"anca\",\"ancella\",\"ancora\",\"andare\",\"andrea\",\"anello\",\"angelo\",\"angolare\",\"angusto\",\"anima\",\"annegare\",\"annidato\",\"anno\",\"annuncio\",\"anonimo\",\"anticipo\",\"anzi\",\"apatico\",\"apertura\",\"apode\",\"apparire\",\"appetito\",\"appoggio\",\"approdo\",\"appunto\",\"aprile\",\"arabica\",\"arachide\",\"aragosta\",\"araldica\",\"arancio\",\"aratura\",\"arazzo\",\"arbitro\",\"archivio\",\"ardito\",\"arenile\",\"argento\",\"argine\",\"arguto\",\"aria\",\"armonia\",\"arnese\",\"arredato\",\"arringa\",\"arrosto\",\"arsenico\",\"arso\",\"artefice\",\"arzillo\",\"asciutto\",\"ascolto\",\"asepsi\",\"asettico\",\"asfalto\",\"asino\",\"asola\",\"aspirato\",\"aspro\",\"assaggio\",\"asse\",\"assoluto\",\"assurdo\",\"asta\",\"astenuto\",\"astice\",\"astratto\",\"atavico\",\"ateismo\",\"atomico\",\"atono\",\"attesa\",\"attivare\",\"attorno\",\"attrito\",\"attuale\",\"ausilio\",\"austria\",\"autista\",\"autonomo\",\"autunno\",\"avanzato\",\"avere\",\"avvenire\",\"avviso\",\"avvolgere\",\"azione\",\"azoto\",\"azzimo\",\"azzurro\",\"babele\",\"baccano\",\"bacino\",\"baco\",\"badessa\",\"badilata\",\"bagnato\",\"baita\",\"balcone\",\"baldo\",\"balena\",\"ballata\",\"balzano\",\"bambino\",\"bandire\",\"baraonda\",\"barbaro\",\"barca\",\"baritono\",\"barlume\",\"barocco\",\"basilico\",\"basso\",\"batosta\",\"battuto\",\"baule\",\"bava\",\"bavosa\",\"becco\",\"beffa\",\"belgio\",\"belva\",\"benda\",\"benevole\",\"benigno\",\"benzina\",\"bere\",\"berlina\",\"beta\",\"bibita\",\"bici\",\"bidone\",\"bifido\",\"biga\",\"bilancia\",\"bimbo\",\"binocolo\",\"biologo\",\"bipede\",\"bipolare\",\"birbante\",\"birra\",\"biscotto\",\"bisesto\",\"bisnonno\",\"bisonte\",\"bisturi\",\"bizzarro\",\"blando\",\"blatta\",\"bollito\",\"bonifico\",\"bordo\",\"bosco\",\"botanico\",\"bottino\",\"bozzolo\",\"braccio\",\"bradipo\",\"brama\",\"branca\",\"bravura\",\"bretella\",\"brevetto\",\"brezza\",\"briglia\",\"brillante\",\"brindare\",\"broccolo\",\"brodo\",\"bronzina\",\"brullo\",\"bruno\",\"bubbone\",\"buca\",\"budino\",\"buffone\",\"buio\",\"bulbo\",\"buono\",\"burlone\",\"burrasca\",\"bussola\",\"busta\",\"cadetto\",\"caduco\",\"calamaro\",\"calcolo\",\"calesse\",\"calibro\",\"calmo\",\"caloria\",\"cambusa\",\"camerata\",\"camicia\",\"cammino\",\"camola\",\"campale\",\"canapa\",\"candela\",\"cane\",\"canino\",\"canotto\",\"cantina\",\"capace\",\"capello\",\"capitolo\",\"capogiro\",\"cappero\",\"capra\",\"capsula\",\"carapace\",\"carcassa\",\"cardo\",\"carisma\",\"carovana\",\"carretto\",\"cartolina\",\"casaccio\",\"cascata\",\"caserma\",\"caso\",\"cassone\",\"castello\",\"casuale\",\"catasta\",\"catena\",\"catrame\",\"cauto\",\"cavillo\",\"cedibile\",\"cedrata\",\"cefalo\",\"celebre\",\"cellulare\",\"cena\",\"cenone\",\"centesimo\",\"ceramica\",\"cercare\",\"certo\",\"cerume\",\"cervello\",\"cesoia\",\"cespo\",\"ceto\",\"chela\",\"chiaro\",\"chicca\",\"chiedere\",\"chimera\",\"china\",\"chirurgo\",\"chitarra\",\"ciao\",\"ciclismo\",\"cifrare\",\"cigno\",\"cilindro\",\"ciottolo\",\"circa\",\"cirrosi\",\"citrico\",\"cittadino\",\"ciuffo\",\"civetta\",\"civile\",\"classico\",\"clinica\",\"cloro\",\"cocco\",\"codardo\",\"codice\",\"coerente\",\"cognome\",\"collare\",\"colmato\",\"colore\",\"colposo\",\"coltivato\",\"colza\",\"coma\",\"cometa\",\"commando\",\"comodo\",\"computer\",\"comune\",\"conciso\",\"condurre\",\"conferma\",\"congelare\",\"coniuge\",\"connesso\",\"conoscere\",\"consumo\",\"continuo\",\"convegno\",\"coperto\",\"copione\",\"coppia\",\"copricapo\",\"corazza\",\"cordata\",\"coricato\",\"cornice\",\"corolla\",\"corpo\",\"corredo\",\"corsia\",\"cortese\",\"cosmico\",\"costante\",\"cottura\",\"covato\",\"cratere\",\"cravatta\",\"creato\",\"credere\",\"cremoso\",\"crescita\",\"creta\",\"criceto\",\"crinale\",\"crisi\",\"critico\",\"croce\",\"cronaca\",\"crostata\",\"cruciale\",\"crusca\",\"cucire\",\"cuculo\",\"cugino\",\"cullato\",\"cupola\",\"curatore\",\"cursore\",\"curvo\",\"cuscino\",\"custode\",\"dado\",\"daino\",\"dalmata\",\"damerino\",\"daniela\",\"dannoso\",\"danzare\",\"datato\",\"davanti\",\"davvero\",\"debutto\",\"decennio\",\"deciso\",\"declino\",\"decollo\",\"decreto\",\"dedicato\",\"definito\",\"deforme\",\"degno\",\"delegare\",\"delfino\",\"delirio\",\"delta\",\"demenza\",\"denotato\",\"dentro\",\"deposito\",\"derapata\",\"derivare\",\"deroga\",\"descritto\",\"deserto\",\"desiderio\",\"desumere\",\"detersivo\",\"devoto\",\"diametro\",\"dicembre\",\"diedro\",\"difeso\",\"diffuso\",\"digerire\",\"digitale\",\"diluvio\",\"dinamico\",\"dinnanzi\",\"dipinto\",\"diploma\",\"dipolo\",\"diradare\",\"dire\",\"dirotto\",\"dirupo\",\"disagio\",\"discreto\",\"disfare\",\"disgelo\",\"disposto\",\"distanza\",\"disumano\",\"dito\",\"divano\",\"divelto\",\"dividere\",\"divorato\",\"doblone\",\"docente\",\"doganale\",\"dogma\",\"dolce\",\"domato\",\"domenica\",\"dominare\",\"dondolo\",\"dono\",\"dormire\",\"dote\",\"dottore\",\"dovuto\",\"dozzina\",\"drago\",\"druido\",\"dubbio\",\"dubitare\",\"ducale\",\"duna\",\"duomo\",\"duplice\",\"duraturo\",\"ebano\",\"eccesso\",\"ecco\",\"eclissi\",\"economia\",\"edera\",\"edicola\",\"edile\",\"editoria\",\"educare\",\"egemonia\",\"egli\",\"egoismo\",\"egregio\",\"elaborato\",\"elargire\",\"elegante\",\"elencato\",\"eletto\",\"elevare\",\"elfico\",\"elica\",\"elmo\",\"elsa\",\"eluso\",\"emanato\",\"emblema\",\"emesso\",\"emiro\",\"emotivo\",\"emozione\",\"empirico\",\"emulo\",\"endemico\",\"enduro\",\"energia\",\"enfasi\",\"enoteca\",\"entrare\",\"enzima\",\"epatite\",\"epilogo\",\"episodio\",\"epocale\",\"eppure\",\"equatore\",\"erario\",\"erba\",\"erboso\",\"erede\",\"eremita\",\"erigere\",\"ermetico\",\"eroe\",\"erosivo\",\"errante\",\"esagono\",\"esame\",\"esanime\",\"esaudire\",\"esca\",\"esempio\",\"esercito\",\"esibito\",\"esigente\",\"esistere\",\"esito\",\"esofago\",\"esortato\",\"esoso\",\"espanso\",\"espresso\",\"essenza\",\"esso\",\"esteso\",\"estimare\",\"estonia\",\"estroso\",\"esultare\",\"etilico\",\"etnico\",\"etrusco\",\"etto\",\"euclideo\",\"europa\",\"evaso\",\"evidenza\",\"evitato\",\"evoluto\",\"evviva\",\"fabbrica\",\"faccenda\",\"fachiro\",\"falco\",\"famiglia\",\"fanale\",\"fanfara\",\"fango\",\"fantasma\",\"fare\",\"farfalla\",\"farinoso\",\"farmaco\",\"fascia\",\"fastoso\",\"fasullo\",\"faticare\",\"fato\",\"favoloso\",\"febbre\",\"fecola\",\"fede\",\"fegato\",\"felpa\",\"feltro\",\"femmina\",\"fendere\",\"fenomeno\",\"fermento\",\"ferro\",\"fertile\",\"fessura\",\"festivo\",\"fetta\",\"feudo\",\"fiaba\",\"fiducia\",\"fifa\",\"figurato\",\"filo\",\"finanza\",\"finestra\",\"finire\",\"fiore\",\"fiscale\",\"fisico\",\"fiume\",\"flacone\",\"flamenco\",\"flebo\",\"flemma\",\"florido\",\"fluente\",\"fluoro\",\"fobico\",\"focaccia\",\"focoso\",\"foderato\",\"foglio\",\"folata\",\"folclore\",\"folgore\",\"fondente\",\"fonetico\",\"fonia\",\"fontana\",\"forbito\",\"forchetta\",\"foresta\",\"formica\",\"fornaio\",\"foro\",\"fortezza\",\"forzare\",\"fosfato\",\"fosso\",\"fracasso\",\"frana\",\"frassino\",\"fratello\",\"freccetta\",\"frenata\",\"fresco\",\"frigo\",\"frollino\",\"fronde\",\"frugale\",\"frutta\",\"fucilata\",\"fucsia\",\"fuggente\",\"fulmine\",\"fulvo\",\"fumante\",\"fumetto\",\"fumoso\",\"fune\",\"funzione\",\"fuoco\",\"furbo\",\"furgone\",\"furore\",\"fuso\",\"futile\",\"gabbiano\",\"gaffe\",\"galateo\",\"gallina\",\"galoppo\",\"gambero\",\"gamma\",\"garanzia\",\"garbo\",\"garofano\",\"garzone\",\"gasdotto\",\"gasolio\",\"gastrico\",\"gatto\",\"gaudio\",\"gazebo\",\"gazzella\",\"geco\",\"gelatina\",\"gelso\",\"gemello\",\"gemmato\",\"gene\",\"genitore\",\"gennaio\",\"genotipo\",\"gergo\",\"ghepardo\",\"ghiaccio\",\"ghisa\",\"giallo\",\"gilda\",\"ginepro\",\"giocare\",\"gioiello\",\"giorno\",\"giove\",\"girato\",\"girone\",\"gittata\",\"giudizio\",\"giurato\",\"giusto\",\"globulo\",\"glutine\",\"gnomo\",\"gobba\",\"golf\",\"gomito\",\"gommone\",\"gonfio\",\"gonna\",\"governo\",\"gracile\",\"grado\",\"grafico\",\"grammo\",\"grande\",\"grattare\",\"gravoso\",\"grazia\",\"greca\",\"gregge\",\"grifone\",\"grigio\",\"grinza\",\"grotta\",\"gruppo\",\"guadagno\",\"guaio\",\"guanto\",\"guardare\",\"gufo\",\"guidare\",\"ibernato\",\"icona\",\"identico\",\"idillio\",\"idolo\",\"idra\",\"idrico\",\"idrogeno\",\"igiene\",\"ignaro\",\"ignorato\",\"ilare\",\"illeso\",\"illogico\",\"illudere\",\"imballo\",\"imbevuto\",\"imbocco\",\"imbuto\",\"immane\",\"immerso\",\"immolato\",\"impacco\",\"impeto\",\"impiego\",\"importo\",\"impronta\",\"inalare\",\"inarcare\",\"inattivo\",\"incanto\",\"incendio\",\"inchino\",\"incisivo\",\"incluso\",\"incontro\",\"incrocio\",\"incubo\",\"indagine\",\"india\",\"indole\",\"inedito\",\"infatti\",\"infilare\",\"inflitto\",\"ingaggio\",\"ingegno\",\"inglese\",\"ingordo\",\"ingrosso\",\"innesco\",\"inodore\",\"inoltrare\",\"inondato\",\"insano\",\"insetto\",\"insieme\",\"insonnia\",\"insulina\",\"intasato\",\"intero\",\"intonaco\",\"intuito\",\"inumidire\",\"invalido\",\"invece\",\"invito\",\"iperbole\",\"ipnotico\",\"ipotesi\",\"ippica\",\"iride\",\"irlanda\",\"ironico\",\"irrigato\",\"irrorare\",\"isolato\",\"isotopo\",\"isterico\",\"istituto\",\"istrice\",\"italia\",\"iterare\",\"labbro\",\"labirinto\",\"lacca\",\"lacerato\",\"lacrima\",\"lacuna\",\"laddove\",\"lago\",\"lampo\",\"lancetta\",\"lanterna\",\"lardoso\",\"larga\",\"laringe\",\"lastra\",\"latenza\",\"latino\",\"lattuga\",\"lavagna\",\"lavoro\",\"legale\",\"leggero\",\"lembo\",\"lentezza\",\"lenza\",\"leone\",\"lepre\",\"lesivo\",\"lessato\",\"lesto\",\"letterale\",\"leva\",\"levigato\",\"libero\",\"lido\",\"lievito\",\"lilla\",\"limatura\",\"limitare\",\"limpido\",\"lineare\",\"lingua\",\"liquido\",\"lira\",\"lirica\",\"lisca\",\"lite\",\"litigio\",\"livrea\",\"locanda\",\"lode\",\"logica\",\"lombare\",\"londra\",\"longevo\",\"loquace\",\"lorenzo\",\"loto\",\"lotteria\",\"luce\",\"lucidato\",\"lumaca\",\"luminoso\",\"lungo\",\"lupo\",\"luppolo\",\"lusinga\",\"lusso\",\"lutto\",\"macabro\",\"macchina\",\"macero\",\"macinato\",\"madama\",\"magico\",\"maglia\",\"magnete\",\"magro\",\"maiolica\",\"malafede\",\"malgrado\",\"malinteso\",\"malsano\",\"malto\",\"malumore\",\"mana\",\"mancia\",\"mandorla\",\"mangiare\",\"manifesto\",\"mannaro\",\"manovra\",\"mansarda\",\"mantide\",\"manubrio\",\"mappa\",\"maratona\",\"marcire\",\"maretta\",\"marmo\",\"marsupio\",\"maschera\",\"massaia\",\"mastino\",\"materasso\",\"matricola\",\"mattone\",\"maturo\",\"mazurca\",\"meandro\",\"meccanico\",\"mecenate\",\"medesimo\",\"meditare\",\"mega\",\"melassa\",\"melis\",\"melodia\",\"meninge\",\"meno\",\"mensola\",\"mercurio\",\"merenda\",\"merlo\",\"meschino\",\"mese\",\"messere\",\"mestolo\",\"metallo\",\"metodo\",\"mettere\",\"miagolare\",\"mica\",\"micelio\",\"michele\",\"microbo\",\"midollo\",\"miele\",\"migliore\",\"milano\",\"milite\",\"mimosa\",\"minerale\",\"mini\",\"minore\",\"mirino\",\"mirtillo\",\"miscela\",\"missiva\",\"misto\",\"misurare\",\"mitezza\",\"mitigare\",\"mitra\",\"mittente\",\"mnemonico\",\"modello\",\"modifica\",\"modulo\",\"mogano\",\"mogio\",\"mole\",\"molosso\",\"monastero\",\"monco\",\"mondina\",\"monetario\",\"monile\",\"monotono\",\"monsone\",\"montato\",\"monviso\",\"mora\",\"mordere\",\"morsicato\",\"mostro\",\"motivato\",\"motosega\",\"motto\",\"movenza\",\"movimento\",\"mozzo\",\"mucca\",\"mucosa\",\"muffa\",\"mughetto\",\"mugnaio\",\"mulatto\",\"mulinello\",\"multiplo\",\"mummia\",\"munto\",\"muovere\",\"murale\",\"musa\",\"muscolo\",\"musica\",\"mutevole\",\"muto\",\"nababbo\",\"nafta\",\"nanometro\",\"narciso\",\"narice\",\"narrato\",\"nascere\",\"nastrare\",\"naturale\",\"nautica\",\"naviglio\",\"nebulosa\",\"necrosi\",\"negativo\",\"negozio\",\"nemmeno\",\"neofita\",\"neretto\",\"nervo\",\"nessuno\",\"nettuno\",\"neutrale\",\"neve\",\"nevrotico\",\"nicchia\",\"ninfa\",\"nitido\",\"nobile\",\"nocivo\",\"nodo\",\"nome\",\"nomina\",\"nordico\",\"normale\",\"norvegese\",\"nostrano\",\"notare\",\"notizia\",\"notturno\",\"novella\",\"nucleo\",\"nulla\",\"numero\",\"nuovo\",\"nutrire\",\"nuvola\",\"nuziale\",\"oasi\",\"obbedire\",\"obbligo\",\"obelisco\",\"oblio\",\"obolo\",\"obsoleto\",\"occasione\",\"occhio\",\"occidente\",\"occorrere\",\"occultare\",\"ocra\",\"oculato\",\"odierno\",\"odorare\",\"offerta\",\"offrire\",\"offuscato\",\"oggetto\",\"oggi\",\"ognuno\",\"olandese\",\"olfatto\",\"oliato\",\"oliva\",\"ologramma\",\"oltre\",\"omaggio\",\"ombelico\",\"ombra\",\"omega\",\"omissione\",\"ondoso\",\"onere\",\"onice\",\"onnivoro\",\"onorevole\",\"onta\",\"operato\",\"opinione\",\"opposto\",\"oracolo\",\"orafo\",\"ordine\",\"orecchino\",\"orefice\",\"orfano\",\"organico\",\"origine\",\"orizzonte\",\"orma\",\"ormeggio\",\"ornativo\",\"orologio\",\"orrendo\",\"orribile\",\"ortensia\",\"ortica\",\"orzata\",\"orzo\",\"osare\",\"oscurare\",\"osmosi\",\"ospedale\",\"ospite\",\"ossa\",\"ossidare\",\"ostacolo\",\"oste\",\"otite\",\"otre\",\"ottagono\",\"ottimo\",\"ottobre\",\"ovale\",\"ovest\",\"ovino\",\"oviparo\",\"ovocito\",\"ovunque\",\"ovviare\",\"ozio\",\"pacchetto\",\"pace\",\"pacifico\",\"padella\",\"padrone\",\"paese\",\"paga\",\"pagina\",\"palazzina\",\"palesare\",\"pallido\",\"palo\",\"palude\",\"pandoro\",\"pannello\",\"paolo\",\"paonazzo\",\"paprica\",\"parabola\",\"parcella\",\"parere\",\"pargolo\",\"pari\",\"parlato\",\"parola\",\"partire\",\"parvenza\",\"parziale\",\"passivo\",\"pasticca\",\"patacca\",\"patologia\",\"pattume\",\"pavone\",\"peccato\",\"pedalare\",\"pedonale\",\"peggio\",\"peloso\",\"penare\",\"pendice\",\"penisola\",\"pennuto\",\"penombra\",\"pensare\",\"pentola\",\"pepe\",\"pepita\",\"perbene\",\"percorso\",\"perdonato\",\"perforare\",\"pergamena\",\"periodo\",\"permesso\",\"perno\",\"perplesso\",\"persuaso\",\"pertugio\",\"pervaso\",\"pesatore\",\"pesista\",\"peso\",\"pestifero\",\"petalo\",\"pettine\",\"petulante\",\"pezzo\",\"piacere\",\"pianta\",\"piattino\",\"piccino\",\"picozza\",\"piega\",\"pietra\",\"piffero\",\"pigiama\",\"pigolio\",\"pigro\",\"pila\",\"pilifero\",\"pillola\",\"pilota\",\"pimpante\",\"pineta\",\"pinna\",\"pinolo\",\"pioggia\",\"piombo\",\"piramide\",\"piretico\",\"pirite\",\"pirolisi\",\"pitone\",\"pizzico\",\"placebo\",\"planare\",\"plasma\",\"platano\",\"plenario\",\"pochezza\",\"poderoso\",\"podismo\",\"poesia\",\"poggiare\",\"polenta\",\"poligono\",\"pollice\",\"polmonite\",\"polpetta\",\"polso\",\"poltrona\",\"polvere\",\"pomice\",\"pomodoro\",\"ponte\",\"popoloso\",\"porfido\",\"poroso\",\"porpora\",\"porre\",\"portata\",\"posa\",\"positivo\",\"possesso\",\"postulato\",\"potassio\",\"potere\",\"pranzo\",\"prassi\",\"pratica\",\"precluso\",\"predica\",\"prefisso\",\"pregiato\",\"prelievo\",\"premere\",\"prenotare\",\"preparato\",\"presenza\",\"pretesto\",\"prevalso\",\"prima\",\"principe\",\"privato\",\"problema\",\"procura\",\"produrre\",\"profumo\",\"progetto\",\"prolunga\",\"promessa\",\"pronome\",\"proposta\",\"proroga\",\"proteso\",\"prova\",\"prudente\",\"prugna\",\"prurito\",\"psiche\",\"pubblico\",\"pudica\",\"pugilato\",\"pugno\",\"pulce\",\"pulito\",\"pulsante\",\"puntare\",\"pupazzo\",\"pupilla\",\"puro\",\"quadro\",\"qualcosa\",\"quasi\",\"querela\",\"quota\",\"raccolto\",\"raddoppio\",\"radicale\",\"radunato\",\"raffica\",\"ragazzo\",\"ragione\",\"ragno\",\"ramarro\",\"ramingo\",\"ramo\",\"randagio\",\"rantolare\",\"rapato\",\"rapina\",\"rappreso\",\"rasatura\",\"raschiato\",\"rasente\",\"rassegna\",\"rastrello\",\"rata\",\"ravveduto\",\"reale\",\"recepire\",\"recinto\",\"recluta\",\"recondito\",\"recupero\",\"reddito\",\"redimere\",\"regalato\",\"registro\",\"regola\",\"regresso\",\"relazione\",\"remare\",\"remoto\",\"renna\",\"replica\",\"reprimere\",\"reputare\",\"resa\",\"residente\",\"responso\",\"restauro\",\"rete\",\"retina\",\"retorica\",\"rettifica\",\"revocato\",\"riassunto\",\"ribadire\",\"ribelle\",\"ribrezzo\",\"ricarica\",\"ricco\",\"ricevere\",\"riciclato\",\"ricordo\",\"ricreduto\",\"ridicolo\",\"ridurre\",\"rifasare\",\"riflesso\",\"riforma\",\"rifugio\",\"rigare\",\"rigettato\",\"righello\",\"rilassato\",\"rilevato\",\"rimanere\",\"rimbalzo\",\"rimedio\",\"rimorchio\",\"rinascita\",\"rincaro\",\"rinforzo\",\"rinnovo\",\"rinomato\",\"rinsavito\",\"rintocco\",\"rinuncia\",\"rinvenire\",\"riparato\",\"ripetuto\",\"ripieno\",\"riportare\",\"ripresa\",\"ripulire\",\"risata\",\"rischio\",\"riserva\",\"risibile\",\"riso\",\"rispetto\",\"ristoro\",\"risultato\",\"risvolto\",\"ritardo\",\"ritegno\",\"ritmico\",\"ritrovo\",\"riunione\",\"riva\",\"riverso\",\"rivincita\",\"rivolto\",\"rizoma\",\"roba\",\"robotico\",\"robusto\",\"roccia\",\"roco\",\"rodaggio\",\"rodere\",\"roditore\",\"rogito\",\"rollio\",\"romantico\",\"rompere\",\"ronzio\",\"rosolare\",\"rospo\",\"rotante\",\"rotondo\",\"rotula\",\"rovescio\",\"rubizzo\",\"rubrica\",\"ruga\",\"rullino\",\"rumine\",\"rumoroso\",\"ruolo\",\"rupe\",\"russare\",\"rustico\",\"sabato\",\"sabbiare\",\"sabotato\",\"sagoma\",\"salasso\",\"saldatura\",\"salgemma\",\"salivare\",\"salmone\",\"salone\",\"saltare\",\"saluto\",\"salvo\",\"sapere\",\"sapido\",\"saporito\",\"saraceno\",\"sarcasmo\",\"sarto\",\"sassoso\",\"satellite\",\"satira\",\"satollo\",\"saturno\",\"savana\",\"savio\",\"saziato\",\"sbadiglio\",\"sbalzo\",\"sbancato\",\"sbarra\",\"sbattere\",\"sbavare\",\"sbendare\",\"sbirciare\",\"sbloccato\",\"sbocciato\",\"sbrinare\",\"sbruffone\",\"sbuffare\",\"scabroso\",\"scadenza\",\"scala\",\"scambiare\",\"scandalo\",\"scapola\",\"scarso\",\"scatenare\",\"scavato\",\"scelto\",\"scenico\",\"scettro\",\"scheda\",\"schiena\",\"sciarpa\",\"scienza\",\"scindere\",\"scippo\",\"sciroppo\",\"scivolo\",\"sclerare\",\"scodella\",\"scolpito\",\"scomparto\",\"sconforto\",\"scoprire\",\"scorta\",\"scossone\",\"scozzese\",\"scriba\",\"scrollare\",\"scrutinio\",\"scuderia\",\"scultore\",\"scuola\",\"scuro\",\"scusare\",\"sdebitare\",\"sdoganare\",\"seccatura\",\"secondo\",\"sedano\",\"seggiola\",\"segnalato\",\"segregato\",\"seguito\",\"selciato\",\"selettivo\",\"sella\",\"selvaggio\",\"semaforo\",\"sembrare\",\"seme\",\"seminato\",\"sempre\",\"senso\",\"sentire\",\"sepolto\",\"sequenza\",\"serata\",\"serbato\",\"sereno\",\"serio\",\"serpente\",\"serraglio\",\"servire\",\"sestina\",\"setola\",\"settimana\",\"sfacelo\",\"sfaldare\",\"sfamato\",\"sfarzoso\",\"sfaticato\",\"sfera\",\"sfida\",\"sfilato\",\"sfinge\",\"sfocato\",\"sfoderare\",\"sfogo\",\"sfoltire\",\"sforzato\",\"sfratto\",\"sfruttato\",\"sfuggito\",\"sfumare\",\"sfuso\",\"sgabello\",\"sgarbato\",\"sgonfiare\",\"sgorbio\",\"sgrassato\",\"sguardo\",\"sibilo\",\"siccome\",\"sierra\",\"sigla\",\"signore\",\"silenzio\",\"sillaba\",\"simbolo\",\"simpatico\",\"simulato\",\"sinfonia\",\"singolo\",\"sinistro\",\"sino\",\"sintesi\",\"sinusoide\",\"sipario\",\"sisma\",\"sistole\",\"situato\",\"slitta\",\"slogatura\",\"sloveno\",\"smarrito\",\"smemorato\",\"smentito\",\"smeraldo\",\"smilzo\",\"smontare\",\"smottato\",\"smussato\",\"snellire\",\"snervato\",\"snodo\",\"sobbalzo\",\"sobrio\",\"soccorso\",\"sociale\",\"sodale\",\"soffitto\",\"sogno\",\"soldato\",\"solenne\",\"solido\",\"sollazzo\",\"solo\",\"solubile\",\"solvente\",\"somatico\",\"somma\",\"sonda\",\"sonetto\",\"sonnifero\",\"sopire\",\"soppeso\",\"sopra\",\"sorgere\",\"sorpasso\",\"sorriso\",\"sorso\",\"sorteggio\",\"sorvolato\",\"sospiro\",\"sosta\",\"sottile\",\"spada\",\"spalla\",\"spargere\",\"spatola\",\"spavento\",\"spazzola\",\"specie\",\"spedire\",\"spegnere\",\"spelatura\",\"speranza\",\"spessore\",\"spettrale\",\"spezzato\",\"spia\",\"spigoloso\",\"spillato\",\"spinoso\",\"spirale\",\"splendido\",\"sportivo\",\"sposo\",\"spranga\",\"sprecare\",\"spronato\",\"spruzzo\",\"spuntino\",\"squillo\",\"sradicare\",\"srotolato\",\"stabile\",\"stacco\",\"staffa\",\"stagnare\",\"stampato\",\"stantio\",\"starnuto\",\"stasera\",\"statuto\",\"stelo\",\"steppa\",\"sterzo\",\"stiletto\",\"stima\",\"stirpe\",\"stivale\",\"stizzoso\",\"stonato\",\"storico\",\"strappo\",\"stregato\",\"stridulo\",\"strozzare\",\"strutto\",\"stuccare\",\"stufo\",\"stupendo\",\"subentro\",\"succoso\",\"sudore\",\"suggerito\",\"sugo\",\"sultano\",\"suonare\",\"superbo\",\"supporto\",\"surgelato\",\"surrogato\",\"sussurro\",\"sutura\",\"svagare\",\"svedese\",\"sveglio\",\"svelare\",\"svenuto\",\"svezia\",\"sviluppo\",\"svista\",\"svizzera\",\"svolta\",\"svuotare\",\"tabacco\",\"tabulato\",\"tacciare\",\"taciturno\",\"tale\",\"talismano\",\"tampone\",\"tannino\",\"tara\",\"tardivo\",\"targato\",\"tariffa\",\"tarpare\",\"tartaruga\",\"tasto\",\"tattico\",\"taverna\",\"tavolata\",\"tazza\",\"teca\",\"tecnico\",\"telefono\",\"temerario\",\"tempo\",\"temuto\",\"tendone\",\"tenero\",\"tensione\",\"tentacolo\",\"teorema\",\"terme\",\"terrazzo\",\"terzetto\",\"tesi\",\"tesserato\",\"testato\",\"tetro\",\"tettoia\",\"tifare\",\"tigella\",\"timbro\",\"tinto\",\"tipico\",\"tipografo\",\"tiraggio\",\"tiro\",\"titanio\",\"titolo\",\"titubante\",\"tizio\",\"tizzone\",\"toccare\",\"tollerare\",\"tolto\",\"tombola\",\"tomo\",\"tonfo\",\"tonsilla\",\"topazio\",\"topologia\",\"toppa\",\"torba\",\"tornare\",\"torrone\",\"tortora\",\"toscano\",\"tossire\",\"tostatura\",\"totano\",\"trabocco\",\"trachea\",\"trafila\",\"tragedia\",\"tralcio\",\"tramonto\",\"transito\",\"trapano\",\"trarre\",\"trasloco\",\"trattato\",\"trave\",\"treccia\",\"tremolio\",\"trespolo\",\"tributo\",\"tricheco\",\"trifoglio\",\"trillo\",\"trincea\",\"trio\",\"tristezza\",\"triturato\",\"trivella\",\"tromba\",\"trono\",\"troppo\",\"trottola\",\"trovare\",\"truccato\",\"tubatura\",\"tuffato\",\"tulipano\",\"tumulto\",\"tunisia\",\"turbare\",\"turchino\",\"tuta\",\"tutela\",\"ubicato\",\"uccello\",\"uccisore\",\"udire\",\"uditivo\",\"uffa\",\"ufficio\",\"uguale\",\"ulisse\",\"ultimato\",\"umano\",\"umile\",\"umorismo\",\"uncinetto\",\"ungere\",\"ungherese\",\"unicorno\",\"unificato\",\"unisono\",\"unitario\",\"unte\",\"uovo\",\"upupa\",\"uragano\",\"urgenza\",\"urlo\",\"usanza\",\"usato\",\"uscito\",\"usignolo\",\"usuraio\",\"utensile\",\"utilizzo\",\"utopia\",\"vacante\",\"vaccinato\",\"vagabondo\",\"vagliato\",\"valanga\",\"valgo\",\"valico\",\"valletta\",\"valoroso\",\"valutare\",\"valvola\",\"vampata\",\"vangare\",\"vanitoso\",\"vano\",\"vantaggio\",\"vanvera\",\"vapore\",\"varano\",\"varcato\",\"variante\",\"vasca\",\"vedetta\",\"vedova\",\"veduto\",\"vegetale\",\"veicolo\",\"velcro\",\"velina\",\"velluto\",\"veloce\",\"venato\",\"vendemmia\",\"vento\",\"verace\",\"verbale\",\"vergogna\",\"verifica\",\"vero\",\"verruca\",\"verticale\",\"vescica\",\"vessillo\",\"vestale\",\"veterano\",\"vetrina\",\"vetusto\",\"viandante\",\"vibrante\",\"vicenda\",\"vichingo\",\"vicinanza\",\"vidimare\",\"vigilia\",\"vigneto\",\"vigore\",\"vile\",\"villano\",\"vimini\",\"vincitore\",\"viola\",\"vipera\",\"virgola\",\"virologo\",\"virulento\",\"viscoso\",\"visione\",\"vispo\",\"vissuto\",\"visura\",\"vita\",\"vitello\",\"vittima\",\"vivanda\",\"vivido\",\"viziare\",\"voce\",\"voga\",\"volatile\",\"volere\",\"volpe\",\"voragine\",\"vulcano\",\"zampogna\",\"zanna\",\"zappato\",\"zattera\",\"zavorra\",\"zefiro\",\"zelante\",\"zelo\",\"zenzero\",\"zerbino\",\"zibetto\",\"zinco\",\"zircone\",\"zitto\",\"zolla\",\"zotico\",\"zucchero\",\"zufolo\",\"zulu\",\"zuppa\"][\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"][\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]{\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_simplified\",\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"\":[\"chinese_traditional\"],\"abdikace\":[\"czech\"],\"abeceda\":[\"czech\"],\"adresa\":[\"czech\"],\"agrese\":[\"czech\"],\"akce\":[\"czech\"],\"aktovka\":[\"czech\"],\"alej\":[\"czech\"],\"alkohol\":[\"czech\"],\"amputace\":[\"czech\"],\"ananas\":[\"czech\"],\"andulka\":[\"czech\"],\"anekdota\":[\"czech\"],\"anketa\":[\"czech\"],\"antika\":[\"czech\"],\"anulovat\":[\"czech\"],\"archa\":[\"czech\"],\"arogance\":[\"czech\"],\"asfalt\":[\"czech\",\"turkish\"],\"asistent\":[\"czech\"],\"aspirace\":[\"czech\"],\"astma\":[\"czech\"],\"astronom\":[\"czech\"],\"atlas\":[\"czech\"],\"atletika\":[\"czech\"],\"atol\":[\"czech\"],\"autobus\":[\"czech\"],\"azyl\":[\"czech\"],\"babka\":[\"czech\"],\"bachor\":[\"czech\"],\"bacil\":[\"czech\"],\"baculka\":[\"czech\"],\"badatel\":[\"czech\"],\"bageta\":[\"czech\"],\"bagr\":[\"czech\"],\"bahno\":[\"czech\"],\"bakterie\":[\"czech\"],\"balada\":[\"czech\"],\"baletka\":[\"czech\"],\"balkon\":[\"czech\"],\"balonek\":[\"czech\"],\"balvan\":[\"czech\"],\"balza\":[\"czech\"],\"bambus\":[\"czech\"],\"bankomat\":[\"czech\"],\"barbar\":[\"czech\"],\"baret\":[\"czech\"],\"barman\":[\"czech\"],\"baroko\":[\"czech\"],\"barva\":[\"czech\"],\"baterka\":[\"czech\"],\"batoh\":[\"czech\"],\"bavlna\":[\"czech\"],\"bazalka\":[\"czech\"],\"bazilika\":[\"czech\"],\"bazuka\":[\"czech\"],\"bedna\":[\"czech\"],\"beran\":[\"czech\"],\"beseda\":[\"czech\"],\"bestie\":[\"czech\"],\"beton\":[\"czech\",\"turkish\"],\"bezinka\":[\"czech\"],\"bezmoc\":[\"czech\"],\"beztak\":[\"czech\"],\"bicykl\":[\"czech\"],\"bidlo\":[\"czech\"],\"biftek\":[\"czech\",\"turkish\"],\"bikiny\":[\"czech\"],\"bilance\":[\"czech\"],\"biograf\":[\"czech\"],\"biolog\":[\"czech\"],\"bitva\":[\"czech\"],\"bizon\":[\"czech\"],\"blahobyt\":[\"czech\"],\"blatouch\":[\"czech\"],\"blecha\":[\"czech\"],\"bledule\":[\"czech\"],\"blesk\":[\"czech\"],\"blikat\":[\"czech\"],\"blizna\":[\"czech\"],\"blokovat\":[\"czech\"],\"bloudit\":[\"czech\"],\"blud\":[\"czech\"],\"bobek\":[\"czech\"],\"bobr\":[\"czech\"],\"bodlina\":[\"czech\"],\"bodnout\":[\"czech\"],\"bohatost\":[\"czech\"],\"bojkot\":[\"czech\"],\"bojovat\":[\"czech\"],\"bokorys\":[\"czech\"],\"bolest\":[\"czech\"],\"borec\":[\"czech\"],\"borovice\":[\"czech\"],\"bota\":[\"czech\"],\"boubel\":[\"czech\"],\"bouchat\":[\"czech\"],\"bouda\":[\"czech\"],\"boule\":[\"czech\"],\"bourat\":[\"czech\"],\"boxer\":[\"czech\"],\"bradavka\":[\"czech\"],\"brambora\":[\"czech\"],\"branka\":[\"czech\"],\"bratr\":[\"czech\"],\"brepta\":[\"czech\"],\"briketa\":[\"czech\"],\"brko\":[\"czech\"],\"brloh\":[\"czech\"],\"bronz\":[\"czech\"],\"broskev\":[\"czech\"],\"brunetka\":[\"czech\"],\"brusinka\":[\"czech\"],\"brzda\":[\"czech\"],\"brzy\":[\"czech\"],\"bublina\":[\"czech\"],\"bubnovat\":[\"czech\"],\"buchta\":[\"czech\"],\"buditel\":[\"czech\"],\"budka\":[\"czech\"],\"budova\":[\"czech\"],\"bufet\":[\"czech\"],\"bujarost\":[\"czech\"],\"bukvice\":[\"czech\"],\"buldok\":[\"czech\"],\"bulva\":[\"czech\"],\"bunda\":[\"czech\"],\"bunkr\":[\"czech\"],\"burza\":[\"czech\"],\"butik\":[\"czech\",\"turkish\"],\"buvol\":[\"czech\"],\"buzola\":[\"czech\"],\"bydlet\":[\"czech\"],\"bylina\":[\"czech\"],\"bytovka\":[\"czech\"],\"bzukot\":[\"czech\"],\"capart\":[\"czech\"],\"carevna\":[\"czech\"],\"cedr\":[\"czech\"],\"cedule\":[\"czech\"],\"cejch\":[\"czech\"],\"cejn\":[\"czech\"],\"cela\":[\"czech\"],\"celer\":[\"czech\"],\"celkem\":[\"czech\"],\"celnice\":[\"czech\"],\"cenina\":[\"czech\"],\"cennost\":[\"czech\"],\"cenovka\":[\"czech\"],\"centrum\":[\"czech\"],\"cenzor\":[\"czech\"],\"cestopis\":[\"czech\"],\"cetka\":[\"czech\"],\"chalupa\":[\"czech\"],\"chapadlo\":[\"czech\"],\"charita\":[\"czech\"],\"chata\":[\"czech\"],\"chechtat\":[\"czech\"],\"chemie\":[\"czech\"],\"chichot\":[\"czech\"],\"chirurg\":[\"czech\"],\"chlad\":[\"czech\"],\"chleba\":[\"czech\"],\"chlubit\":[\"czech\"],\"chmel\":[\"czech\"],\"chmura\":[\"czech\"],\"chobot\":[\"czech\"],\"chochol\":[\"czech\"],\"chodba\":[\"czech\"],\"cholera\":[\"czech\"],\"chomout\":[\"czech\"],\"chopit\":[\"czech\"],\"choroba\":[\"czech\"],\"chov\":[\"czech\"],\"chrapot\":[\"czech\"],\"chrlit\":[\"czech\"],\"chrt\":[\"czech\"],\"chrup\":[\"czech\"],\"chtivost\":[\"czech\"],\"chudina\":[\"czech\"],\"chutnat\":[\"czech\"],\"chvat\":[\"czech\"],\"chvilka\":[\"czech\"],\"chvost\":[\"czech\"],\"chyba\":[\"czech\"],\"chystat\":[\"czech\"],\"chytit\":[\"czech\"],\"cibule\":[\"czech\"],\"cigareta\":[\"czech\"],\"cihelna\":[\"czech\"],\"cihla\":[\"czech\"],\"cinkot\":[\"czech\"],\"cirkus\":[\"czech\"],\"cisterna\":[\"czech\"],\"citace\":[\"czech\"],\"citrus\":[\"czech\"],\"cizinec\":[\"czech\"],\"cizost\":[\"czech\"],\"clona\":[\"czech\"],\"cokoliv\":[\"czech\"],\"couvat\":[\"czech\"],\"ctitel\":[\"czech\"],\"ctnost\":[\"czech\"],\"cudnost\":[\"czech\"],\"cuketa\":[\"czech\"],\"cukr\":[\"czech\"],\"cupot\":[\"czech\"],\"cvaknout\":[\"czech\"],\"cval\":[\"czech\"],\"cvik\":[\"czech\"],\"cvrkot\":[\"czech\"],\"cyklista\":[\"czech\"],\"daleko\":[\"czech\"],\"dareba\":[\"czech\"],\"datel\":[\"czech\"],\"datum\":[\"czech\"],\"dcera\":[\"czech\"],\"debata\":[\"czech\"],\"dechovka\":[\"czech\"],\"decibel\":[\"czech\"],\"deficit\":[\"czech\"],\"deflace\":[\"czech\"],\"dekl\":[\"czech\"],\"dekret\":[\"czech\"],\"demokrat\":[\"czech\"],\"deprese\":[\"czech\"],\"derby\":[\"czech\"],\"deska\":[\"czech\"],\"detektiv\":[\"czech\"],\"dikobraz\":[\"czech\"],\"diktovat\":[\"czech\"],\"dioda\":[\"czech\"],\"diplom\":[\"czech\"],\"disk\":[\"czech\",\"turkish\"],\"displej\":[\"czech\"],\"divadlo\":[\"czech\"],\"divoch\":[\"czech\"],\"dlaha\":[\"czech\"],\"dlouho\":[\"czech\"],\"dluhopis\":[\"czech\"],\"dnes\":[\"czech\"],\"dobro\":[\"czech\"],\"dobytek\":[\"czech\"],\"docent\":[\"czech\"],\"dochutit\":[\"czech\"],\"dodnes\":[\"czech\"],\"dohled\":[\"czech\"],\"dohoda\":[\"czech\"],\"dohra\":[\"czech\"],\"dojem\":[\"czech\"],\"dojnice\":[\"czech\"],\"doklad\":[\"czech\"],\"dokola\":[\"czech\"],\"doktor\":[\"czech\",\"turkish\"],\"dokument\":[\"czech\"],\"dolar\":[\"czech\"],\"doleva\":[\"czech\"],\"dolina\":[\"czech\"],\"doma\":[\"czech\"],\"dominant\":[\"czech\"],\"domluvit\":[\"czech\"],\"domov\":[\"czech\"],\"donutit\":[\"czech\"],\"dopad\":[\"czech\"],\"dopis\":[\"czech\"],\"doplnit\":[\"czech\"],\"doposud\":[\"czech\"],\"doprovod\":[\"czech\"],\"dopustit\":[\"czech\"],\"dorazit\":[\"czech\"],\"dorost\":[\"czech\"],\"dort\":[\"czech\"],\"dosah\":[\"czech\"],\"doslov\":[\"czech\"],\"dostatek\":[\"czech\"],\"dosud\":[\"czech\"],\"dosyta\":[\"czech\"],\"dotaz\":[\"czech\"],\"dotek\":[\"czech\"],\"dotknout\":[\"czech\"],\"doufat\":[\"czech\"],\"doutnat\":[\"czech\"],\"dovozce\":[\"czech\"],\"dozadu\":[\"czech\"],\"doznat\":[\"czech\"],\"dozorce\":[\"czech\"],\"drahota\":[\"czech\"],\"drak\":[\"czech\"],\"dramatik\":[\"czech\"],\"dravec\":[\"czech\"],\"draze\":[\"czech\"],\"drdol\":[\"czech\"],\"drobnost\":[\"czech\"],\"drogerie\":[\"czech\"],\"drozd\":[\"czech\"],\"drsnost\":[\"czech\"],\"drtit\":[\"czech\"],\"drzost\":[\"czech\"],\"duben\":[\"czech\"],\"duchovno\":[\"czech\"],\"dudek\":[\"czech\"],\"duha\":[\"czech\"],\"duhovka\":[\"czech\"],\"dusit\":[\"czech\"],\"dusno\":[\"czech\"],\"dutost\":[\"czech\"],\"dvojice\":[\"czech\"],\"dvorec\":[\"czech\"],\"dynamit\":[\"czech\"],\"ekolog\":[\"czech\"],\"ekonomie\":[\"czech\"],\"elektron\":[\"czech\"],\"elipsa\":[\"czech\"],\"email\":[\"czech\"],\"emise\":[\"czech\"],\"emoce\":[\"czech\"],\"empatie\":[\"czech\"],\"epizoda\":[\"czech\"],\"epocha\":[\"czech\"],\"epopej\":[\"czech\"],\"epos\":[\"czech\"],\"esej\":[\"czech\"],\"esence\":[\"czech\"],\"eskorta\":[\"czech\"],\"eskymo\":[\"czech\"],\"etiketa\":[\"czech\"],\"euforie\":[\"czech\"],\"evoluce\":[\"czech\"],\"exekuce\":[\"czech\"],\"exkurze\":[\"czech\"],\"expedice\":[\"czech\"],\"exploze\":[\"czech\"],\"export\":[\"czech\"],\"extrakt\":[\"czech\"],\"facka\":[\"czech\"],\"fajfka\":[\"czech\"],\"fakulta\":[\"czech\"],\"fanatik\":[\"czech\",\"turkish\"],\"fantazie\":[\"czech\"],\"farmacie\":[\"czech\"],\"favorit\":[\"czech\"],\"fazole\":[\"czech\"],\"federace\":[\"czech\"],\"fejeton\":[\"czech\"],\"fenka\":[\"czech\"],\"fialka\":[\"czech\"],\"figurant\":[\"czech\"],\"filozof\":[\"czech\"],\"filtr\":[\"czech\"],\"finance\":[\"czech\"],\"finta\":[\"czech\"],\"fixace\":[\"czech\"],\"fjord\":[\"czech\"],\"flanel\":[\"czech\"],\"flirt\":[\"czech\"],\"flotila\":[\"czech\"],\"fond\":[\"czech\"],\"fosfor\":[\"czech\"],\"fotbal\":[\"czech\"],\"fotka\":[\"czech\"],\"foton\":[\"czech\"],\"frakce\":[\"czech\"],\"freska\":[\"czech\"],\"fronta\":[\"czech\"],\"fukar\":[\"czech\"],\"funkce\":[\"czech\"],\"fyzika\":[\"czech\"],\"galeje\":[\"czech\"],\"garant\":[\"czech\"],\"genetika\":[\"czech\"],\"geolog\":[\"czech\"],\"gilotina\":[\"czech\"],\"glazura\":[\"czech\"],\"glejt\":[\"czech\"],\"golem\":[\"czech\"],\"golfista\":[\"czech\"],\"gotika\":[\"czech\"],\"graf\":[\"czech\"],\"gramofon\":[\"czech\"],\"granule\":[\"czech\"],\"grep\":[\"czech\"],\"gril\":[\"czech\"],\"grog\":[\"czech\"],\"groteska\":[\"czech\"],\"guma\":[\"czech\"],\"hadice\":[\"czech\"],\"hadr\":[\"czech\"],\"hala\":[\"czech\"],\"halenka\":[\"czech\"],\"hanba\":[\"czech\"],\"hanopis\":[\"czech\"],\"harfa\":[\"czech\"],\"harpuna\":[\"czech\"],\"havran\":[\"czech\"],\"hebkost\":[\"czech\"],\"hejkal\":[\"czech\"],\"hejno\":[\"czech\"],\"hejtman\":[\"czech\"],\"hektar\":[\"czech\",\"turkish\"],\"helma\":[\"czech\"],\"hematom\":[\"czech\"],\"herec\":[\"czech\"],\"herna\":[\"czech\"],\"heslo\":[\"czech\"],\"hezky\":[\"czech\"],\"historik\":[\"czech\"],\"hladovka\":[\"czech\"],\"hlasivky\":[\"czech\"],\"hlava\":[\"czech\"],\"hledat\":[\"czech\"],\"hlen\":[\"czech\"],\"hlodavec\":[\"czech\"],\"hloh\":[\"czech\"],\"hloupost\":[\"czech\"],\"hltat\":[\"czech\"],\"hlubina\":[\"czech\"],\"hluchota\":[\"czech\"],\"hmat\":[\"czech\"],\"hmota\":[\"czech\"],\"hmyz\":[\"czech\"],\"hnis\":[\"czech\"],\"hnojivo\":[\"czech\"],\"hnout\":[\"czech\"],\"hoblina\":[\"czech\"],\"hoboj\":[\"czech\"],\"hoch\":[\"czech\"],\"hodiny\":[\"czech\"],\"hodlat\":[\"czech\"],\"hodnota\":[\"czech\"],\"hodovat\":[\"czech\"],\"hojnost\":[\"czech\"],\"hokej\":[\"czech\"],\"holinka\":[\"czech\"],\"holka\":[\"czech\"],\"holub\":[\"czech\"],\"homole\":[\"czech\"],\"honitba\":[\"czech\"],\"honorace\":[\"czech\"],\"horal\":[\"czech\"],\"horda\":[\"czech\"],\"horizont\":[\"czech\"],\"horko\":[\"czech\"],\"horlivec\":[\"czech\"],\"hormon\":[\"czech\",\"turkish\"],\"hornina\":[\"czech\"],\"horoskop\":[\"czech\"],\"horstvo\":[\"czech\"],\"hospoda\":[\"czech\"],\"hostina\":[\"czech\"],\"hotovost\":[\"czech\"],\"houba\":[\"czech\"],\"houf\":[\"czech\"],\"houpat\":[\"czech\"],\"houska\":[\"czech\"],\"hovor\":[\"czech\"],\"hradba\":[\"czech\"],\"hranice\":[\"czech\"],\"hravost\":[\"czech\"],\"hrazda\":[\"czech\"],\"hrbolek\":[\"czech\"],\"hrdina\":[\"czech\"],\"hrdlo\":[\"czech\"],\"hrdost\":[\"czech\"],\"hrnek\":[\"czech\"],\"hrobka\":[\"czech\"],\"hromada\":[\"czech\"],\"hrot\":[\"czech\"],\"hrouda\":[\"czech\"],\"hrozen\":[\"czech\"],\"hrstka\":[\"czech\"],\"hrubost\":[\"czech\"],\"hryzat\":[\"czech\"],\"hubenost\":[\"czech\"],\"hubnout\":[\"czech\"],\"hudba\":[\"czech\"],\"hukot\":[\"czech\"],\"humr\":[\"czech\"],\"husita\":[\"czech\"],\"hustota\":[\"czech\"],\"hvozd\":[\"czech\"],\"hybnost\":[\"czech\"],\"hydrant\":[\"czech\"],\"hygiena\":[\"czech\"],\"hymna\":[\"czech\"],\"hysterik\":[\"czech\"],\"idylka\":[\"czech\"],\"ihned\":[\"czech\"],\"ikona\":[\"czech\"],\"iluze\":[\"czech\"],\"imunita\":[\"czech\"],\"infekce\":[\"czech\"],\"inflace\":[\"czech\"],\"inkaso\":[\"czech\"],\"inovace\":[\"czech\"],\"inspekce\":[\"czech\"],\"internet\":[\"czech\"],\"invalida\":[\"czech\"],\"investor\":[\"czech\"],\"inzerce\":[\"czech\"],\"ironie\":[\"czech\"],\"jablko\":[\"czech\"],\"jachta\":[\"czech\"],\"jahoda\":[\"czech\"],\"jakmile\":[\"czech\"],\"jakost\":[\"czech\"],\"jalovec\":[\"czech\"],\"jantar\":[\"czech\"],\"jarmark\":[\"czech\"],\"jaro\":[\"czech\"],\"jasan\":[\"czech\"],\"jasno\":[\"czech\"],\"jatka\":[\"czech\"],\"javor\":[\"czech\"],\"jazyk\":[\"czech\"],\"jedinec\":[\"czech\"],\"jedle\":[\"czech\"],\"jednatel\":[\"czech\"],\"jehlan\":[\"czech\"],\"jekot\":[\"czech\"],\"jelen\":[\"czech\"],\"jelito\":[\"czech\"],\"jemnost\":[\"czech\"],\"jenom\":[\"czech\"],\"jepice\":[\"czech\"],\"jeseter\":[\"czech\"],\"jevit\":[\"czech\"],\"jezdec\":[\"czech\"],\"jezero\":[\"czech\"],\"jinak\":[\"czech\"],\"jindy\":[\"czech\"],\"jinoch\":[\"czech\"],\"jiskra\":[\"czech\"],\"jistota\":[\"czech\"],\"jitrnice\":[\"czech\"],\"jizva\":[\"czech\"],\"jmenovat\":[\"czech\"],\"jogurt\":[\"czech\"],\"jurta\":[\"czech\"],\"kabaret\":[\"czech\"],\"kabel\":[\"czech\"],\"kabinet\":[\"czech\"],\"kachna\":[\"czech\"],\"kadet\":[\"czech\"],\"kadidlo\":[\"czech\"],\"kahan\":[\"czech\"],\"kajak\":[\"czech\"],\"kajuta\":[\"czech\"],\"kakao\":[\"czech\"],\"kaktus\":[\"czech\"],\"kalamita\":[\"czech\"],\"kalhoty\":[\"czech\"],\"kalibr\":[\"czech\"],\"kalnost\":[\"czech\"],\"kamera\":[\"czech\"],\"kamkoliv\":[\"czech\"],\"kamna\":[\"czech\"],\"kanibal\":[\"czech\"],\"kanoe\":[\"czech\"],\"kantor\":[\"czech\"],\"kapalina\":[\"czech\"],\"kapela\":[\"czech\"],\"kapitola\":[\"czech\"],\"kapka\":[\"czech\"],\"kaple\":[\"czech\"],\"kapota\":[\"czech\"],\"kapr\":[\"czech\"],\"kapusta\":[\"czech\"],\"kapybara\":[\"czech\"],\"karamel\":[\"czech\"],\"karotka\":[\"czech\"],\"karton\":[\"czech\"],\"kasa\":[\"czech\"],\"katalog\":[\"czech\"],\"katedra\":[\"czech\"],\"kauce\":[\"czech\"],\"kauza\":[\"czech\"],\"kavalec\":[\"czech\"],\"kazajka\":[\"czech\"],\"kazeta\":[\"czech\"],\"kazivost\":[\"czech\"],\"kdekoliv\":[\"czech\"],\"kdesi\":[\"czech\"],\"kedluben\":[\"czech\"],\"kemp\":[\"czech\"],\"keramika\":[\"czech\"],\"kino\":[\"czech\"],\"klacek\":[\"czech\"],\"kladivo\":[\"czech\"],\"klam\":[\"czech\"],\"klapot\":[\"czech\"],\"klasika\":[\"czech\"],\"klaun\":[\"czech\"],\"klec\":[\"czech\"],\"klenba\":[\"czech\"],\"klepat\":[\"czech\"],\"klesnout\":[\"czech\"],\"klid\":[\"czech\"],\"klima\":[\"czech\"],\"klisna\":[\"czech\"],\"klobouk\":[\"czech\"],\"klokan\":[\"czech\"],\"klopa\":[\"czech\"],\"kloub\":[\"czech\"],\"klubovna\":[\"czech\"],\"klusat\":[\"czech\"],\"kluzkost\":[\"czech\"],\"kmen\":[\"czech\"],\"kmitat\":[\"czech\"],\"kmotr\":[\"czech\"],\"kniha\":[\"czech\"],\"knot\":[\"czech\"],\"koalice\":[\"czech\"],\"koberec\":[\"czech\"],\"kobka\":[\"czech\"],\"kobliha\":[\"czech\"],\"kobyla\":[\"czech\"],\"kocour\":[\"czech\"],\"kohout\":[\"czech\"],\"kojenec\":[\"czech\"],\"kokos\":[\"czech\"],\"koktejl\":[\"czech\"],\"kolaps\":[\"czech\"],\"koleda\":[\"czech\"],\"kolize\":[\"czech\"],\"kolo\":[\"czech\"],\"komando\":[\"czech\"],\"kometa\":[\"czech\"],\"komik\":[\"czech\"],\"komnata\":[\"czech\"],\"komora\":[\"czech\"],\"kompas\":[\"czech\"],\"komunita\":[\"czech\"],\"konat\":[\"czech\"],\"koncept\":[\"czech\"],\"kondice\":[\"czech\"],\"konec\":[\"czech\"],\"konfese\":[\"czech\"],\"kongres\":[\"czech\"],\"konina\":[\"czech\"],\"konkurs\":[\"czech\"],\"kontakt\":[\"czech\"],\"konzerva\":[\"czech\"],\"kopanec\":[\"czech\"],\"kopie\":[\"czech\"],\"kopnout\":[\"czech\"],\"koprovka\":[\"czech\"],\"korbel\":[\"czech\"],\"korektor\":[\"czech\"],\"kormidlo\":[\"czech\"],\"koroptev\":[\"czech\"],\"korpus\":[\"czech\"],\"koruna\":[\"czech\"],\"koryto\":[\"czech\"],\"korzet\":[\"czech\"],\"kosatec\":[\"czech\"],\"kostka\":[\"czech\"],\"kotel\":[\"czech\"],\"kotleta\":[\"czech\"],\"kotoul\":[\"czech\"],\"koukat\":[\"czech\"],\"koupelna\":[\"czech\"],\"kousek\":[\"czech\"],\"kouzlo\":[\"czech\"],\"kovboj\":[\"czech\"],\"koza\":[\"czech\"],\"kozoroh\":[\"czech\"],\"krabice\":[\"czech\"],\"krach\":[\"czech\"],\"krajina\":[\"czech\"],\"kralovat\":[\"czech\"],\"krasopis\":[\"czech\"],\"kravata\":[\"czech\"],\"kredit\":[\"czech\"],\"krejcar\":[\"czech\"],\"kresba\":[\"czech\"],\"kreveta\":[\"czech\"],\"kriket\":[\"czech\"],\"kritik\":[\"czech\"],\"krize\":[\"czech\"],\"krkavec\":[\"czech\"],\"krmelec\":[\"czech\"],\"krmivo\":[\"czech\"],\"krocan\":[\"czech\"],\"krok\":[\"czech\"],\"kronika\":[\"czech\"],\"kropit\":[\"czech\"],\"kroupa\":[\"czech\"],\"krovka\":[\"czech\"],\"krtek\":[\"czech\"],\"kruhadlo\":[\"czech\"],\"krupice\":[\"czech\"],\"krutost\":[\"czech\"],\"krvinka\":[\"czech\"],\"krychle\":[\"czech\"],\"krypta\":[\"czech\"],\"krystal\":[\"czech\"],\"kryt\":[\"czech\"],\"kudlanka\":[\"czech\"],\"kufr\":[\"czech\"],\"kujnost\":[\"czech\"],\"kukla\":[\"czech\"],\"kulajda\":[\"czech\"],\"kulich\":[\"czech\"],\"kulka\":[\"czech\"],\"kulomet\":[\"czech\"],\"kultura\":[\"czech\"],\"kuna\":[\"czech\"],\"kupodivu\":[\"czech\"],\"kurt\":[\"czech\"],\"kurzor\":[\"czech\"],\"kutil\":[\"czech\"],\"kvalita\":[\"czech\"],\"kvasinka\":[\"czech\"],\"kvestor\":[\"czech\"],\"kynolog\":[\"czech\"],\"kyselina\":[\"czech\"],\"kytara\":[\"czech\"],\"kytice\":[\"czech\"],\"kytka\":[\"czech\"],\"kytovec\":[\"czech\"],\"kyvadlo\":[\"czech\"],\"labrador\":[\"czech\"],\"lachtan\":[\"czech\"],\"ladnost\":[\"czech\"],\"laik\":[\"czech\"],\"lakomec\":[\"czech\"],\"lamela\":[\"czech\"],\"lampa\":[\"czech\"],\"lanovka\":[\"czech\"],\"lasice\":[\"czech\"],\"laso\":[\"czech\"],\"lastura\":[\"czech\"],\"latinka\":[\"czech\"],\"lavina\":[\"czech\"],\"lebka\":[\"czech\"],\"leckdy\":[\"czech\"],\"leden\":[\"czech\"],\"lednice\":[\"czech\"],\"ledovka\":[\"czech\"],\"ledvina\":[\"czech\"],\"legenda\":[\"czech\"],\"legie\":[\"czech\"],\"legrace\":[\"czech\"],\"lehce\":[\"czech\"],\"lehkost\":[\"czech\"],\"lehnout\":[\"czech\"],\"lektvar\":[\"czech\"],\"lenochod\":[\"czech\"],\"lentilka\":[\"czech\"],\"lepenka\":[\"czech\"],\"lepidlo\":[\"czech\"],\"letadlo\":[\"czech\"],\"letec\":[\"czech\"],\"letmo\":[\"czech\"],\"letokruh\":[\"czech\"],\"levhart\":[\"czech\"],\"levitace\":[\"czech\"],\"levobok\":[\"czech\"],\"libra\":[\"czech\"],\"lichotka\":[\"czech\"],\"lidojed\":[\"czech\"],\"lidskost\":[\"czech\"],\"lihovina\":[\"czech\"],\"lijavec\":[\"czech\"],\"lilek\":[\"czech\"],\"limetka\":[\"czech\"],\"linie\":[\"czech\"],\"linka\":[\"czech\"],\"linoleum\":[\"czech\"],\"listopad\":[\"czech\"],\"litina\":[\"czech\"],\"litovat\":[\"czech\"],\"lobista\":[\"czech\"],\"lodivod\":[\"czech\"],\"logika\":[\"czech\"],\"logoped\":[\"czech\"],\"lokalita\":[\"czech\"],\"loket\":[\"czech\"],\"lomcovat\":[\"czech\"],\"lopata\":[\"czech\"],\"lopuch\":[\"czech\"],\"lord\":[\"czech\"],\"losos\":[\"czech\"],\"lotr\":[\"czech\"],\"loudal\":[\"czech\"],\"louh\":[\"czech\"],\"louka\":[\"czech\"],\"louskat\":[\"czech\"],\"lovec\":[\"czech\"],\"lstivost\":[\"czech\"],\"lucerna\":[\"czech\"],\"lucifer\":[\"czech\"],\"lump\":[\"czech\"],\"lusk\":[\"czech\"],\"lustrace\":[\"czech\"],\"lvice\":[\"czech\"],\"lyra\":[\"czech\"],\"lyrika\":[\"czech\"],\"lysina\":[\"czech\"],\"madam\":[\"czech\"],\"madlo\":[\"czech\"],\"magistr\":[\"czech\"],\"mahagon\":[\"czech\"],\"majetek\":[\"czech\"],\"majitel\":[\"czech\"],\"majorita\":[\"czech\"],\"makak\":[\"czech\"],\"makovice\":[\"czech\"],\"makrela\":[\"czech\"],\"malba\":[\"czech\"],\"malina\":[\"czech\"],\"malovat\":[\"czech\"],\"malvice\":[\"czech\"],\"maminka\":[\"czech\"],\"mandle\":[\"czech\"],\"manko\":[\"czech\"],\"marnost\":[\"czech\"],\"masakr\":[\"czech\"],\"maskot\":[\"czech\"],\"masopust\":[\"czech\"],\"matice\":[\"czech\"],\"matrika\":[\"czech\"],\"maturita\":[\"czech\"],\"mazanec\":[\"czech\"],\"mazivo\":[\"czech\"],\"mazlit\":[\"czech\"],\"mazurka\":[\"czech\"],\"mdloba\":[\"czech\"],\"mechanik\":[\"czech\"],\"meditace\":[\"czech\"],\"medovina\":[\"czech\"],\"melasa\":[\"czech\"],\"meloun\":[\"czech\"],\"mentolka\":[\"czech\"],\"metla\":[\"czech\"],\"metoda\":[\"czech\"],\"metr\":[\"czech\"],\"mezera\":[\"czech\"],\"migrace\":[\"czech\"],\"mihnout\":[\"czech\"],\"mihule\":[\"czech\"],\"mikina\":[\"czech\"],\"mikrofon\":[\"czech\",\"turkish\"],\"milenec\":[\"czech\"],\"milimetr\":[\"czech\"],\"milost\":[\"czech\"],\"mimika\":[\"czech\"],\"mincovna\":[\"czech\"],\"minibar\":[\"czech\"],\"minomet\":[\"czech\"],\"minulost\":[\"czech\"],\"miska\":[\"czech\"],\"mistr\":[\"czech\"],\"mixovat\":[\"czech\"],\"mladost\":[\"czech\"],\"mlha\":[\"czech\"],\"mlhovina\":[\"czech\"],\"mlok\":[\"czech\"],\"mlsat\":[\"czech\"],\"mluvit\":[\"czech\"],\"mnich\":[\"czech\"],\"mnohem\":[\"czech\"],\"mobil\":[\"czech\"],\"mocnost\":[\"czech\"],\"modelka\":[\"czech\"],\"modlitba\":[\"czech\"],\"mohyla\":[\"czech\"],\"mokro\":[\"czech\"],\"molekula\":[\"czech\"],\"momentka\":[\"czech\"],\"monarcha\":[\"czech\"],\"monokl\":[\"czech\"],\"monstrum\":[\"czech\"],\"montovat\":[\"czech\"],\"monzun\":[\"czech\"],\"mosaz\":[\"czech\"],\"moskyt\":[\"czech\"],\"most\":[\"czech\"],\"motivace\":[\"czech\"],\"motorka\":[\"czech\"],\"motyka\":[\"czech\"],\"moucha\":[\"czech\"],\"moudrost\":[\"czech\"],\"mozaika\":[\"czech\"],\"mozek\":[\"czech\"],\"mozol\":[\"czech\"],\"mramor\":[\"czech\"],\"mravenec\":[\"czech\"],\"mrkev\":[\"czech\"],\"mrtvola\":[\"czech\"],\"mrzet\":[\"czech\"],\"mrzutost\":[\"czech\"],\"mstitel\":[\"czech\"],\"mudrc\":[\"czech\"],\"muflon\":[\"czech\"],\"mulat\":[\"czech\"],\"mumie\":[\"czech\"],\"munice\":[\"czech\"],\"muset\":[\"czech\"],\"mutace\":[\"czech\"],\"muzeum\":[\"czech\"],\"muzikant\":[\"czech\"],\"myslivec\":[\"czech\"],\"mzda\":[\"czech\"],\"nabourat\":[\"czech\"],\"nachytat\":[\"czech\"],\"nadace\":[\"czech\"],\"nadbytek\":[\"czech\"],\"nadhoz\":[\"czech\"],\"nadobro\":[\"czech\"],\"nadpis\":[\"czech\"],\"nahlas\":[\"czech\"],\"nahnat\":[\"czech\"],\"nahodile\":[\"czech\"],\"nahradit\":[\"czech\"],\"naivita\":[\"czech\"],\"najednou\":[\"czech\"],\"najisto\":[\"czech\"],\"najmout\":[\"czech\"],\"naklonit\":[\"czech\"],\"nakonec\":[\"czech\"],\"nakrmit\":[\"czech\"],\"nalevo\":[\"czech\"],\"namazat\":[\"czech\"],\"namluvit\":[\"czech\"],\"nanometr\":[\"czech\"],\"naoko\":[\"czech\"],\"naopak\":[\"czech\"],\"naostro\":[\"czech\"],\"napadat\":[\"czech\"],\"napevno\":[\"czech\"],\"naplnit\":[\"czech\"],\"napnout\":[\"czech\"],\"naposled\":[\"czech\"],\"naprosto\":[\"czech\"],\"narodit\":[\"czech\"],\"naruby\":[\"czech\"],\"narychlo\":[\"czech\"],\"nasadit\":[\"czech\"],\"nasekat\":[\"czech\"],\"naslepo\":[\"czech\"],\"nastat\":[\"czech\"],\"natolik\":[\"czech\"],\"navenek\":[\"czech\"],\"navrch\":[\"czech\"],\"navzdory\":[\"czech\"],\"nazvat\":[\"czech\"],\"nebe\":[\"czech\"],\"nechat\":[\"czech\"],\"necky\":[\"czech\"],\"nedaleko\":[\"czech\"],\"nedbat\":[\"czech\"],\"neduh\":[\"czech\"],\"negace\":[\"czech\"],\"nehet\":[\"czech\"],\"nehoda\":[\"czech\"],\"nejen\":[\"czech\"],\"nejprve\":[\"czech\"],\"neklid\":[\"czech\"],\"nelibost\":[\"czech\"],\"nemilost\":[\"czech\"],\"nemoc\":[\"czech\"],\"neochota\":[\"czech\"],\"neonka\":[\"czech\"],\"nepokoj\":[\"czech\"],\"nerost\":[\"czech\"],\"nerv\":[\"czech\"],\"nesmysl\":[\"czech\"],\"nesoulad\":[\"czech\"],\"netvor\":[\"czech\"],\"neuron\":[\"czech\"],\"nevina\":[\"czech\"],\"nezvykle\":[\"czech\"],\"nicota\":[\"czech\"],\"nijak\":[\"czech\"],\"nikam\":[\"czech\"],\"nikdy\":[\"czech\"],\"nikl\":[\"czech\"],\"nikterak\":[\"czech\"],\"nitro\":[\"czech\"],\"nocleh\":[\"czech\"],\"nohavice\":[\"czech\"],\"nominace\":[\"czech\"],\"nora\":[\"czech\"],\"norek\":[\"czech\"],\"nositel\":[\"czech\"],\"nosnost\":[\"czech\"],\"nouze\":[\"czech\"],\"noviny\":[\"czech\"],\"novota\":[\"czech\"],\"nozdra\":[\"czech\"],\"nuda\":[\"czech\"],\"nudle\":[\"czech\"],\"nuget\":[\"czech\"],\"nutit\":[\"czech\"],\"nutnost\":[\"czech\"],\"nutrie\":[\"czech\"],\"nymfa\":[\"czech\"],\"obal\":[\"czech\"],\"obarvit\":[\"czech\"],\"obava\":[\"czech\"],\"obdiv\":[\"czech\"],\"obec\":[\"czech\"],\"obehnat\":[\"czech\"],\"obejmout\":[\"czech\"],\"obezita\":[\"czech\"],\"obhajoba\":[\"czech\"],\"obilnice\":[\"czech\"],\"objasnit\":[\"czech\"],\"objekt\":[\"czech\"],\"obklopit\":[\"czech\"],\"oblast\":[\"czech\"],\"oblek\":[\"czech\"],\"obliba\":[\"czech\"],\"obloha\":[\"czech\"],\"obluda\":[\"czech\"],\"obnos\":[\"czech\"],\"obohatit\":[\"czech\"],\"obojek\":[\"czech\"],\"obout\":[\"czech\"],\"obrazec\":[\"czech\"],\"obrna\":[\"czech\"],\"obruba\":[\"czech\"],\"obrys\":[\"czech\"],\"obsah\":[\"czech\"],\"obsluha\":[\"czech\"],\"obstarat\":[\"czech\"],\"obuv\":[\"czech\"],\"obvaz\":[\"czech\"],\"obvinit\":[\"czech\"],\"obvod\":[\"czech\"],\"obvykle\":[\"czech\"],\"obyvatel\":[\"czech\"],\"obzor\":[\"czech\"],\"ocas\":[\"czech\"],\"ocel\":[\"czech\"],\"ocenit\":[\"czech\"],\"ochladit\":[\"czech\"],\"ochota\":[\"czech\"],\"ochrana\":[\"czech\"],\"ocitnout\":[\"czech\"],\"odboj\":[\"czech\"],\"odbyt\":[\"czech\"],\"odchod\":[\"czech\"],\"odcizit\":[\"czech\"],\"odebrat\":[\"czech\"],\"odeslat\":[\"czech\"],\"odevzdat\":[\"czech\"],\"odezva\":[\"czech\"],\"odhadce\":[\"czech\"],\"odhodit\":[\"czech\"],\"odjet\":[\"czech\"],\"odjinud\":[\"czech\"],\"odkaz\":[\"czech\"],\"odkoupit\":[\"czech\"],\"odliv\":[\"czech\"],\"odluka\":[\"czech\"],\"odmlka\":[\"czech\"],\"odolnost\":[\"czech\"],\"odpad\":[\"czech\"],\"odpis\":[\"czech\"],\"odplout\":[\"czech\"],\"odpor\":[\"czech\"],\"odpustit\":[\"czech\"],\"odpykat\":[\"czech\"],\"odrazka\":[\"czech\"],\"odsoudit\":[\"czech\"],\"odstup\":[\"czech\"],\"odsun\":[\"czech\"],\"odtok\":[\"czech\"],\"odtud\":[\"czech\"],\"odvaha\":[\"czech\"],\"odveta\":[\"czech\"],\"odvolat\":[\"czech\"],\"odvracet\":[\"czech\"],\"odznak\":[\"czech\"],\"ofina\":[\"czech\"],\"ofsajd\":[\"czech\"],\"ohlas\":[\"czech\"],\"ohnisko\":[\"czech\"],\"ohrada\":[\"czech\"],\"ohrozit\":[\"czech\"],\"ohryzek\":[\"czech\"],\"okap\":[\"czech\"],\"okenice\":[\"czech\"],\"oklika\":[\"czech\"],\"okno\":[\"czech\"],\"okouzlit\":[\"czech\"],\"okovy\":[\"czech\"],\"okrasa\":[\"czech\"],\"okres\":[\"czech\"],\"okrsek\":[\"czech\"],\"okruh\":[\"czech\"],\"okupant\":[\"czech\"],\"okurka\":[\"czech\"],\"okusit\":[\"czech\"],\"olejnina\":[\"czech\"],\"olizovat\":[\"czech\"],\"omak\":[\"czech\"],\"omeleta\":[\"czech\"],\"omezit\":[\"czech\"],\"omladina\":[\"czech\"],\"omlouvat\":[\"czech\"],\"omluva\":[\"czech\"],\"omyl\":[\"czech\"],\"onehdy\":[\"czech\"],\"opakovat\":[\"czech\"],\"opasek\":[\"czech\"],\"operace\":[\"czech\"],\"opice\":[\"czech\"],\"opilost\":[\"czech\"],\"opisovat\":[\"czech\"],\"opora\":[\"czech\"],\"opozice\":[\"czech\"],\"opravdu\":[\"czech\"],\"oproti\":[\"czech\"],\"orbital\":[\"czech\"],\"orchestr\":[\"czech\"],\"orgie\":[\"czech\"],\"orlice\":[\"czech\"],\"orloj\":[\"czech\"],\"ortel\":[\"czech\"],\"osada\":[\"czech\"],\"oschnout\":[\"czech\"],\"osika\":[\"czech\"],\"osivo\":[\"czech\"],\"oslava\":[\"czech\"],\"oslepit\":[\"czech\"],\"oslnit\":[\"czech\"],\"oslovit\":[\"czech\"],\"osnova\":[\"czech\"],\"osoba\":[\"czech\"],\"osolit\":[\"czech\"],\"ospalec\":[\"czech\"],\"osten\":[\"czech\"],\"ostraha\":[\"czech\"],\"ostuda\":[\"czech\"],\"ostych\":[\"czech\"],\"osvojit\":[\"czech\"],\"oteplit\":[\"czech\"],\"otisk\":[\"czech\"],\"otop\":[\"czech\"],\"otrhat\":[\"czech\"],\"otrlost\":[\"czech\"],\"otrok\":[\"czech\"],\"otruby\":[\"czech\"],\"otvor\":[\"czech\"],\"ovanout\":[\"czech\"],\"ovar\":[\"czech\"],\"oves\":[\"czech\"],\"ovlivnit\":[\"czech\"],\"ovoce\":[\"czech\"],\"oxid\":[\"czech\"],\"ozdoba\":[\"czech\"],\"pachatel\":[\"czech\"],\"pacient\":[\"czech\"],\"padouch\":[\"czech\"],\"pahorek\":[\"czech\"],\"pakt\":[\"czech\"],\"palanda\":[\"czech\"],\"palec\":[\"czech\"],\"palivo\":[\"czech\"],\"paluba\":[\"czech\"],\"pamflet\":[\"czech\"],\"pamlsek\":[\"czech\"],\"panenka\":[\"czech\"],\"panika\":[\"czech\"],\"panna\":[\"czech\"],\"panovat\":[\"czech\"],\"panstvo\":[\"czech\"],\"pantofle\":[\"czech\"],\"paprika\":[\"czech\"],\"parketa\":[\"czech\"],\"parodie\":[\"czech\"],\"parta\":[\"czech\"],\"paruka\":[\"czech\"],\"paryba\":[\"czech\"],\"paseka\":[\"czech\"],\"pasivita\":[\"czech\"],\"pastelka\":[\"czech\"],\"patent\":[\"czech\"],\"patrona\":[\"czech\"],\"pavouk\":[\"czech\"],\"pazneht\":[\"czech\"],\"pazourek\":[\"czech\"],\"pecka\":[\"czech\"],\"pedagog\":[\"czech\"],\"pejsek\":[\"czech\"],\"peklo\":[\"czech\"],\"peloton\":[\"czech\"],\"penalta\":[\"czech\"],\"pendrek\":[\"czech\"],\"penze\":[\"czech\"],\"periskop\":[\"czech\"],\"pero\":[\"czech\"],\"pestrost\":[\"czech\"],\"petarda\":[\"czech\"],\"petice\":[\"czech\"],\"petrolej\":[\"czech\"],\"pevnina\":[\"czech\"],\"pexeso\":[\"czech\"],\"pianista\":[\"czech\"],\"piha\":[\"czech\"],\"pijavice\":[\"czech\"],\"pikle\":[\"czech\"],\"piknik\":[\"czech\",\"turkish\"],\"pilina\":[\"czech\"],\"pilnost\":[\"czech\"],\"pilulka\":[\"czech\"],\"pinzeta\":[\"czech\"],\"pipeta\":[\"czech\"],\"pisatel\":[\"czech\"],\"pistole\":[\"czech\"],\"pitevna\":[\"czech\"],\"pivnice\":[\"czech\"],\"pivovar\":[\"czech\"],\"placenta\":[\"czech\"],\"plakat\":[\"czech\"],\"plamen\":[\"czech\"],\"planeta\":[\"czech\"],\"plastika\":[\"czech\"],\"platit\":[\"czech\"],\"plavidlo\":[\"czech\"],\"plaz\":[\"czech\"],\"plech\":[\"czech\"],\"plemeno\":[\"czech\"],\"plenta\":[\"czech\"],\"ples\":[\"czech\"],\"pletivo\":[\"czech\"],\"plevel\":[\"czech\"],\"plivat\":[\"czech\"],\"plnit\":[\"czech\"],\"plno\":[\"czech\"],\"plocha\":[\"czech\"],\"plodina\":[\"czech\"],\"plomba\":[\"czech\"],\"plout\":[\"czech\"],\"pluk\":[\"czech\"],\"plyn\":[\"czech\"],\"pobavit\":[\"czech\"],\"pobyt\":[\"czech\"],\"pochod\":[\"czech\"],\"pocit\":[\"czech\"],\"poctivec\":[\"czech\"],\"podat\":[\"czech\"],\"podcenit\":[\"czech\"],\"podepsat\":[\"czech\"],\"podhled\":[\"czech\"],\"podivit\":[\"czech\"],\"podklad\":[\"czech\"],\"podmanit\":[\"czech\"],\"podnik\":[\"czech\"],\"podoba\":[\"czech\"],\"podpora\":[\"czech\"],\"podraz\":[\"czech\"],\"podstata\":[\"czech\"],\"podvod\":[\"czech\"],\"podzim\":[\"czech\"],\"poezie\":[\"czech\"],\"pohanka\":[\"czech\"],\"pohnutka\":[\"czech\"],\"pohovor\":[\"czech\"],\"pohroma\":[\"czech\"],\"pohyb\":[\"czech\"],\"pointa\":[\"czech\"],\"pojistka\":[\"czech\"],\"pojmout\":[\"czech\"],\"pokazit\":[\"czech\"],\"pokles\":[\"czech\"],\"pokoj\":[\"czech\"],\"pokrok\":[\"czech\"],\"pokuta\":[\"czech\"],\"pokyn\":[\"czech\"],\"poledne\":[\"czech\"],\"polibek\":[\"czech\"],\"polknout\":[\"czech\"],\"poloha\":[\"czech\"],\"polynom\":[\"czech\"],\"pomalu\":[\"czech\"],\"pominout\":[\"czech\"],\"pomlka\":[\"czech\"],\"pomoc\":[\"czech\"],\"pomsta\":[\"czech\"],\"pomyslet\":[\"czech\"],\"ponechat\":[\"czech\"],\"ponorka\":[\"czech\"],\"ponurost\":[\"czech\"],\"popadat\":[\"czech\"],\"popel\":[\"czech\"],\"popisek\":[\"czech\"],\"poplach\":[\"czech\"],\"poprosit\":[\"czech\"],\"popsat\":[\"czech\"],\"popud\":[\"czech\"],\"poradce\":[\"czech\"],\"porce\":[\"czech\"],\"porod\":[\"czech\"],\"porucha\":[\"czech\"],\"poryv\":[\"czech\"],\"posadit\":[\"czech\"],\"posed\":[\"czech\"],\"posila\":[\"czech\"],\"poskok\":[\"czech\"],\"poslanec\":[\"czech\"],\"posoudit\":[\"czech\"],\"pospolu\":[\"czech\"],\"postava\":[\"czech\"],\"posudek\":[\"czech\"],\"posyp\":[\"czech\"],\"potah\":[\"czech\"],\"potkan\":[\"czech\"],\"potlesk\":[\"czech\"],\"potomek\":[\"czech\"],\"potrava\":[\"czech\"],\"potupa\":[\"czech\"],\"potvora\":[\"czech\"],\"poukaz\":[\"czech\"],\"pouto\":[\"czech\"],\"pouzdro\":[\"czech\"],\"povaha\":[\"czech\"],\"povidla\":[\"czech\"],\"povlak\":[\"czech\"],\"povoz\":[\"czech\"],\"povrch\":[\"czech\"],\"povstat\":[\"czech\"],\"povyk\":[\"czech\"],\"povzdech\":[\"czech\"],\"pozdrav\":[\"czech\"],\"pozemek\":[\"czech\"],\"poznatek\":[\"czech\"],\"pozor\":[\"czech\"],\"pozvat\":[\"czech\"],\"pracovat\":[\"czech\"],\"prahory\":[\"czech\"],\"praktika\":[\"czech\"],\"prales\":[\"czech\"],\"praotec\":[\"czech\"],\"praporek\":[\"czech\"],\"prase\":[\"czech\"],\"pravda\":[\"czech\"],\"princip\":[\"czech\"],\"prkno\":[\"czech\"],\"probudit\":[\"czech\"],\"procento\":[\"czech\"],\"prodej\":[\"czech\"],\"profese\":[\"czech\"],\"prohra\":[\"czech\"],\"projekt\":[\"czech\"],\"prolomit\":[\"czech\"],\"promile\":[\"czech\"],\"pronikat\":[\"czech\"],\"propad\":[\"czech\"],\"prorok\":[\"czech\"],\"prosba\":[\"czech\"],\"proton\":[\"czech\"],\"proutek\":[\"czech\"],\"provaz\":[\"czech\"],\"prskavka\":[\"czech\"],\"prsten\":[\"czech\"],\"prudkost\":[\"czech\"],\"prut\":[\"czech\"],\"prvek\":[\"czech\"],\"prvohory\":[\"czech\"],\"psanec\":[\"czech\"],\"psovod\":[\"czech\"],\"pstruh\":[\"czech\"],\"ptactvo\":[\"czech\"],\"puberta\":[\"czech\"],\"puch\":[\"czech\"],\"pudl\":[\"czech\"],\"pukavec\":[\"czech\"],\"puklina\":[\"czech\"],\"pukrle\":[\"czech\"],\"pult\":[\"czech\"],\"pumpa\":[\"czech\"],\"punc\":[\"czech\"],\"pupen\":[\"czech\"],\"pusa\":[\"czech\"],\"pusinka\":[\"czech\"],\"pustina\":[\"czech\"],\"putovat\":[\"czech\"],\"putyka\":[\"czech\"],\"pyramida\":[\"czech\"],\"pysk\":[\"czech\"],\"pytel\":[\"czech\"],\"racek\":[\"czech\"],\"rachot\":[\"czech\"],\"radiace\":[\"czech\"],\"radnice\":[\"czech\"],\"radon\":[\"czech\"],\"raft\":[\"czech\"],\"ragby\":[\"czech\"],\"raketa\":[\"czech\"],\"rakovina\":[\"czech\"],\"rameno\":[\"czech\"],\"rampouch\":[\"czech\"],\"rande\":[\"czech\"],\"rarach\":[\"czech\"],\"rarita\":[\"czech\"],\"rasovna\":[\"czech\"],\"rastr\":[\"czech\"],\"ratolest\":[\"czech\"],\"razance\":[\"czech\"],\"razidlo\":[\"czech\"],\"reagovat\":[\"czech\"],\"reakce\":[\"czech\"],\"recept\":[\"czech\"],\"redaktor\":[\"czech\"],\"referent\":[\"czech\"],\"reflex\":[\"czech\"],\"rejnok\":[\"czech\"],\"reklama\":[\"czech\"],\"rekord\":[\"czech\"],\"rekrut\":[\"czech\"],\"rektor\":[\"czech\"],\"reputace\":[\"czech\"],\"revize\":[\"czech\",\"turkish\"],\"revma\":[\"czech\"],\"revolver\":[\"czech\"],\"rezerva\":[\"czech\"],\"riskovat\":[\"czech\"],\"riziko\":[\"czech\"],\"robotika\":[\"czech\"],\"rodokmen\":[\"czech\"],\"rohovka\":[\"czech\"],\"rokle\":[\"czech\"],\"rokoko\":[\"czech\"],\"romaneto\":[\"czech\"],\"ropovod\":[\"czech\"],\"ropucha\":[\"czech\"],\"rorejs\":[\"czech\"],\"rosol\":[\"czech\"],\"rostlina\":[\"czech\"],\"rotmistr\":[\"czech\"],\"rotoped\":[\"czech\"],\"rotunda\":[\"czech\"],\"roubenka\":[\"czech\"],\"roucho\":[\"czech\"],\"roup\":[\"czech\"],\"roura\":[\"czech\"],\"rovina\":[\"czech\"],\"rovnice\":[\"czech\"],\"rozbor\":[\"czech\"],\"rozchod\":[\"czech\"],\"rozdat\":[\"czech\"],\"rozeznat\":[\"czech\"],\"rozhodce\":[\"czech\"],\"rozinka\":[\"czech\"],\"rozjezd\":[\"czech\"],\"rozkaz\":[\"czech\"],\"rozloha\":[\"czech\"],\"rozmar\":[\"czech\"],\"rozpad\":[\"czech\"],\"rozruch\":[\"czech\"],\"rozsah\":[\"czech\"],\"roztok\":[\"czech\"],\"rozum\":[\"czech\"],\"rozvod\":[\"czech\"],\"rubrika\":[\"czech\"],\"ruchadlo\":[\"czech\"],\"rukavice\":[\"czech\"],\"rukopis\":[\"czech\"],\"ryba\":[\"czech\"],\"rybolov\":[\"czech\"],\"rychlost\":[\"czech\"],\"rydlo\":[\"czech\"],\"rypadlo\":[\"czech\"],\"rytina\":[\"czech\"],\"ryzost\":[\"czech\"],\"sadista\":[\"czech\"],\"sahat\":[\"czech\"],\"sako\":[\"czech\"],\"samec\":[\"czech\"],\"samizdat\":[\"czech\"],\"samota\":[\"czech\"],\"sanitka\":[\"czech\"],\"sardinka\":[\"czech\"],\"sasanka\":[\"czech\"],\"satelit\":[\"czech\"],\"sazba\":[\"czech\"],\"sazenice\":[\"czech\"],\"sbor\":[\"czech\"],\"schovat\":[\"czech\"],\"sebranka\":[\"czech\"],\"secese\":[\"czech\"],\"sedadlo\":[\"czech\"],\"sediment\":[\"czech\"],\"sedlo\":[\"czech\"],\"sehnat\":[\"czech\"],\"sejmout\":[\"czech\"],\"sekera\":[\"czech\"],\"sekta\":[\"czech\"],\"sekunda\":[\"czech\"],\"sekvoje\":[\"czech\"],\"semeno\":[\"czech\"],\"seno\":[\"czech\"],\"servis\":[\"czech\",\"turkish\"],\"sesadit\":[\"czech\"],\"seshora\":[\"czech\"],\"seskok\":[\"czech\"],\"seslat\":[\"czech\"],\"sestra\":[\"czech\"],\"sesuv\":[\"czech\"],\"sesypat\":[\"czech\"],\"setba\":[\"czech\"],\"setina\":[\"czech\"],\"setkat\":[\"czech\"],\"setnout\":[\"czech\"],\"setrvat\":[\"czech\"],\"sever\":[\"czech\"],\"seznam\":[\"czech\"],\"shoda\":[\"czech\"],\"shrnout\":[\"czech\"],\"sifon\":[\"czech\"],\"silnice\":[\"czech\"],\"sirka\":[\"czech\"],\"sirotek\":[\"czech\"],\"sirup\":[\"czech\"],\"situace\":[\"czech\"],\"skafandr\":[\"czech\"],\"skalisko\":[\"czech\"],\"skanzen\":[\"czech\"],\"skaut\":[\"czech\"],\"skeptik\":[\"czech\"],\"skica\":[\"czech\"],\"skladba\":[\"czech\"],\"sklenice\":[\"czech\"],\"sklo\":[\"czech\"],\"skluz\":[\"czech\"],\"skoba\":[\"czech\"],\"skokan\":[\"czech\"],\"skoro\":[\"czech\"],\"skripta\":[\"czech\"],\"skrz\":[\"czech\"],\"skupina\":[\"czech\"],\"skvost\":[\"czech\"],\"skvrna\":[\"czech\"],\"slabika\":[\"czech\"],\"sladidlo\":[\"czech\"],\"slanina\":[\"czech\"],\"slast\":[\"czech\"],\"slavnost\":[\"czech\"],\"sledovat\":[\"czech\"],\"slepec\":[\"czech\"],\"sleva\":[\"czech\"],\"slezina\":[\"czech\"],\"slib\":[\"czech\"],\"slina\":[\"czech\"],\"sliznice\":[\"czech\"],\"slon\":[\"czech\"],\"sloupek\":[\"czech\"],\"slovo\":[\"czech\"],\"sluch\":[\"czech\"],\"sluha\":[\"czech\"],\"slunce\":[\"czech\"],\"slupka\":[\"czech\"],\"slza\":[\"czech\"],\"smaragd\":[\"czech\"],\"smetana\":[\"czech\"],\"smilstvo\":[\"czech\"],\"smlouva\":[\"czech\"],\"smog\":[\"czech\"],\"smrad\":[\"czech\"],\"smrk\":[\"czech\"],\"smrtka\":[\"czech\"],\"smutek\":[\"czech\"],\"smysl\":[\"czech\"],\"snad\":[\"czech\"],\"snaha\":[\"czech\"],\"snob\":[\"czech\"],\"sobota\":[\"czech\"],\"socha\":[\"czech\"],\"sodovka\":[\"czech\"],\"sokol\":[\"czech\"],\"sopka\":[\"czech\"],\"sotva\":[\"czech\"],\"souboj\":[\"czech\"],\"soucit\":[\"czech\"],\"soudce\":[\"czech\"],\"souhlas\":[\"czech\"],\"soulad\":[\"czech\"],\"soumrak\":[\"czech\"],\"souprava\":[\"czech\"],\"soused\":[\"czech\"],\"soutok\":[\"czech\"],\"souviset\":[\"czech\"],\"spalovna\":[\"czech\"],\"spasitel\":[\"czech\"],\"spis\":[\"czech\"],\"splav\":[\"czech\"],\"spodek\":[\"czech\"],\"spojenec\":[\"czech\"],\"spolu\":[\"czech\"],\"sponzor\":[\"czech\"],\"spornost\":[\"czech\"],\"spousta\":[\"czech\"],\"sprcha\":[\"czech\"],\"spustit\":[\"czech\"],\"sranda\":[\"czech\"],\"sraz\":[\"czech\"],\"srdce\":[\"czech\"],\"srna\":[\"czech\"],\"srnec\":[\"czech\"],\"srovnat\":[\"czech\"],\"srpen\":[\"czech\"],\"srst\":[\"czech\"],\"srub\":[\"czech\"],\"stanice\":[\"czech\"],\"starosta\":[\"czech\"],\"statika\":[\"czech\"],\"stavba\":[\"czech\"],\"stehno\":[\"czech\"],\"stezka\":[\"czech\"],\"stodola\":[\"czech\"],\"stolek\":[\"czech\"],\"stopa\":[\"czech\"],\"storno\":[\"czech\"],\"stoupat\":[\"czech\"],\"strach\":[\"czech\"],\"stres\":[\"czech\"],\"strhnout\":[\"czech\"],\"strom\":[\"czech\"],\"struna\":[\"czech\"],\"studna\":[\"czech\"],\"stupnice\":[\"czech\"],\"stvol\":[\"czech\"],\"styk\":[\"czech\"],\"subjekt\":[\"czech\"],\"subtropy\":[\"czech\"],\"suchar\":[\"czech\"],\"sudost\":[\"czech\"],\"sukno\":[\"czech\"],\"sundat\":[\"czech\"],\"sunout\":[\"czech\"],\"surikata\":[\"czech\"],\"surovina\":[\"czech\"],\"svah\":[\"czech\"],\"svalstvo\":[\"czech\"],\"svetr\":[\"czech\"],\"svatba\":[\"czech\"],\"svazek\":[\"czech\"],\"svisle\":[\"czech\"],\"svitek\":[\"czech\"],\"svoboda\":[\"czech\"],\"svodidlo\":[\"czech\"],\"svorka\":[\"czech\"],\"svrab\":[\"czech\"],\"sykavka\":[\"czech\"],\"sykot\":[\"czech\"],\"synek\":[\"czech\"],\"synovec\":[\"czech\"],\"sypat\":[\"czech\"],\"sypkost\":[\"czech\"],\"syrovost\":[\"czech\"],\"sysel\":[\"czech\"],\"sytost\":[\"czech\"],\"tabletka\":[\"czech\"],\"tabule\":[\"czech\"],\"tahoun\":[\"czech\"],\"tajemno\":[\"czech\"],\"tajfun\":[\"czech\"],\"tajga\":[\"czech\"],\"tajit\":[\"czech\"],\"tajnost\":[\"czech\"],\"taktika\":[\"czech\"],\"tamhle\":[\"czech\"],\"tampon\":[\"czech\",\"turkish\"],\"tancovat\":[\"czech\"],\"tanec\":[\"czech\"],\"tanker\":[\"czech\"],\"tapeta\":[\"czech\"],\"tavenina\":[\"czech\"],\"tazatel\":[\"czech\"],\"technika\":[\"czech\"],\"tehdy\":[\"czech\"],\"tekutina\":[\"czech\"],\"telefon\":[\"czech\"],\"temnota\":[\"czech\"],\"tendence\":[\"czech\"],\"tenista\":[\"czech\"],\"tenor\":[\"czech\"],\"teplota\":[\"czech\"],\"tepna\":[\"czech\"],\"teprve\":[\"czech\"],\"terapie\":[\"czech\"],\"termoska\":[\"czech\"],\"textil\":[\"czech\"],\"ticho\":[\"czech\"],\"tiskopis\":[\"czech\"],\"titulek\":[\"czech\"],\"tkadlec\":[\"czech\"],\"tkanina\":[\"czech\"],\"tlapka\":[\"czech\"],\"tleskat\":[\"czech\"],\"tlukot\":[\"czech\"],\"tlupa\":[\"czech\"],\"tmel\":[\"czech\"],\"toaleta\":[\"czech\"],\"topinka\":[\"czech\"],\"topol\":[\"czech\"],\"torzo\":[\"czech\"],\"touha\":[\"czech\"],\"toulec\":[\"czech\"],\"tradice\":[\"czech\"],\"traktor\":[\"czech\"],\"tramp\":[\"czech\"],\"trasa\":[\"czech\"],\"traverza\":[\"czech\"],\"trefit\":[\"czech\"],\"trest\":[\"czech\"],\"trezor\":[\"czech\"],\"trhavina\":[\"czech\"],\"trhlina\":[\"czech\"],\"trochu\":[\"czech\"],\"trojice\":[\"czech\"],\"troska\":[\"czech\"],\"trouba\":[\"czech\"],\"trpce\":[\"czech\"],\"trpitel\":[\"czech\"],\"trpkost\":[\"czech\"],\"trubec\":[\"czech\"],\"truchlit\":[\"czech\"],\"truhlice\":[\"czech\"],\"trus\":[\"czech\"],\"trvat\":[\"czech\"],\"tudy\":[\"czech\"],\"tuhnout\":[\"czech\"],\"tuhost\":[\"czech\"],\"tundra\":[\"czech\"],\"turista\":[\"czech\"],\"turnaj\":[\"czech\"],\"tuzemsko\":[\"czech\"],\"tvaroh\":[\"czech\"],\"tvorba\":[\"czech\"],\"tvrdost\":[\"czech\"],\"tvrz\":[\"czech\"],\"tygr\":[\"czech\"],\"tykev\":[\"czech\"],\"ubohost\":[\"czech\"],\"uboze\":[\"czech\"],\"ubrat\":[\"czech\"],\"ubrousek\":[\"czech\"],\"ubrus\":[\"czech\"],\"ubytovna\":[\"czech\"],\"ucho\":[\"czech\"],\"uctivost\":[\"czech\"],\"udivit\":[\"czech\"],\"uhradit\":[\"czech\"],\"ujednat\":[\"czech\"],\"ujistit\":[\"czech\"],\"ujmout\":[\"czech\"],\"ukazatel\":[\"czech\"],\"uklidnit\":[\"czech\"],\"uklonit\":[\"czech\"],\"ukotvit\":[\"czech\"],\"ukrojit\":[\"czech\"],\"ulice\":[\"czech\"],\"ulita\":[\"czech\"],\"ulovit\":[\"czech\"],\"umyvadlo\":[\"czech\"],\"unavit\":[\"czech\"],\"uniforma\":[\"czech\"],\"uniknout\":[\"czech\"],\"upadnout\":[\"czech\"],\"uplatnit\":[\"czech\"],\"uplynout\":[\"czech\"],\"upoutat\":[\"czech\"],\"upravit\":[\"czech\"],\"uran\":[\"czech\"],\"urazit\":[\"czech\"],\"usednout\":[\"czech\"],\"usilovat\":[\"czech\"],\"usmrtit\":[\"czech\"],\"usnadnit\":[\"czech\"],\"usnout\":[\"czech\"],\"usoudit\":[\"czech\"],\"ustlat\":[\"czech\"],\"ustrnout\":[\"czech\"],\"utahovat\":[\"czech\"],\"utkat\":[\"czech\"],\"utlumit\":[\"czech\"],\"utonout\":[\"czech\"],\"utopenec\":[\"czech\"],\"utrousit\":[\"czech\"],\"uvalit\":[\"czech\"],\"uvolnit\":[\"czech\"],\"uvozovka\":[\"czech\"],\"uzdravit\":[\"czech\"],\"uzel\":[\"czech\"],\"uzenina\":[\"czech\"],\"uzlina\":[\"czech\"],\"uznat\":[\"czech\"],\"vagon\":[\"czech\",\"turkish\"],\"valcha\":[\"czech\"],\"valoun\":[\"czech\"],\"vana\":[\"czech\"],\"vandal\":[\"czech\"],\"vanilka\":[\"czech\"],\"varan\":[\"czech\"],\"varhany\":[\"czech\"],\"varovat\":[\"czech\"],\"vcelku\":[\"czech\"],\"vchod\":[\"czech\"],\"vdova\":[\"czech\"],\"vedro\":[\"czech\"],\"vegetace\":[\"czech\"],\"vejce\":[\"czech\"],\"velbloud\":[\"czech\"],\"veletrh\":[\"czech\"],\"velitel\":[\"czech\"],\"velmoc\":[\"czech\"],\"velryba\":[\"czech\"],\"venkov\":[\"czech\"],\"veranda\":[\"czech\"],\"verze\":[\"czech\"],\"veselka\":[\"czech\"],\"veskrze\":[\"czech\"],\"vesnice\":[\"czech\"],\"vespodu\":[\"czech\"],\"vesta\":[\"czech\"],\"veterina\":[\"czech\"],\"veverka\":[\"czech\"],\"vibrace\":[\"czech\"],\"vichr\":[\"czech\"],\"videohra\":[\"czech\"],\"vidina\":[\"czech\"],\"vidle\":[\"czech\"],\"vila\":[\"czech\"],\"vinice\":[\"czech\"],\"viset\":[\"czech\"],\"vitalita\":[\"czech\"],\"vize\":[\"czech\"],\"vizitka\":[\"czech\"],\"vjezd\":[\"czech\"],\"vklad\":[\"czech\"],\"vkus\":[\"czech\"],\"vlajka\":[\"czech\"],\"vlak\":[\"czech\"],\"vlasec\":[\"czech\"],\"vlevo\":[\"czech\"],\"vlhkost\":[\"czech\"],\"vliv\":[\"czech\"],\"vlnovka\":[\"czech\"],\"vloupat\":[\"czech\"],\"vnucovat\":[\"czech\"],\"vnuk\":[\"czech\"],\"voda\":[\"czech\"],\"vodivost\":[\"czech\"],\"vodoznak\":[\"czech\"],\"vodstvo\":[\"czech\"],\"vojensky\":[\"czech\"],\"vojna\":[\"czech\"],\"vojsko\":[\"czech\"],\"volant\":[\"czech\"],\"volba\":[\"czech\"],\"volit\":[\"czech\"],\"volno\":[\"czech\"],\"voskovka\":[\"czech\"],\"vozidlo\":[\"czech\"],\"vozovna\":[\"czech\"],\"vpravo\":[\"czech\"],\"vrabec\":[\"czech\"],\"vracet\":[\"czech\"],\"vrah\":[\"czech\"],\"vrata\":[\"czech\"],\"vrba\":[\"czech\"],\"vrcholek\":[\"czech\"],\"vrhat\":[\"czech\"],\"vrstva\":[\"czech\"],\"vrtule\":[\"czech\"],\"vsadit\":[\"czech\"],\"vstoupit\":[\"czech\"],\"vstup\":[\"czech\"],\"vtip\":[\"czech\"],\"vybavit\":[\"czech\"],\"vybrat\":[\"czech\"],\"vychovat\":[\"czech\"],\"vydat\":[\"czech\"],\"vydra\":[\"czech\"],\"vyfotit\":[\"czech\"],\"vyhledat\":[\"czech\"],\"vyhnout\":[\"czech\"],\"vyhodit\":[\"czech\"],\"vyhradit\":[\"czech\"],\"vyhubit\":[\"czech\"],\"vyjasnit\":[\"czech\"],\"vyjet\":[\"czech\"],\"vyjmout\":[\"czech\"],\"vyklopit\":[\"czech\"],\"vykonat\":[\"czech\"],\"vylekat\":[\"czech\"],\"vymazat\":[\"czech\"],\"vymezit\":[\"czech\"],\"vymizet\":[\"czech\"],\"vymyslet\":[\"czech\"],\"vynechat\":[\"czech\"],\"vynikat\":[\"czech\"],\"vynutit\":[\"czech\"],\"vypadat\":[\"czech\"],\"vyplatit\":[\"czech\"],\"vypravit\":[\"czech\"],\"vypustit\":[\"czech\"],\"vyrazit\":[\"czech\"],\"vyrovnat\":[\"czech\"],\"vyrvat\":[\"czech\"],\"vyslovit\":[\"czech\"],\"vysoko\":[\"czech\"],\"vystavit\":[\"czech\"],\"vysunout\":[\"czech\"],\"vysypat\":[\"czech\"],\"vytasit\":[\"czech\"],\"vytesat\":[\"czech\"],\"vytratit\":[\"czech\"],\"vyvinout\":[\"czech\"],\"vyvolat\":[\"czech\"],\"vyvrhel\":[\"czech\"],\"vyzdobit\":[\"czech\"],\"vyznat\":[\"czech\"],\"vzadu\":[\"czech\"],\"vzbudit\":[\"czech\"],\"vzchopit\":[\"czech\"],\"vzdor\":[\"czech\"],\"vzduch\":[\"czech\"],\"vzdychat\":[\"czech\"],\"vzestup\":[\"czech\"],\"vzhledem\":[\"czech\"],\"vzkaz\":[\"czech\"],\"vzlykat\":[\"czech\"],\"vznik\":[\"czech\"],\"vzorek\":[\"czech\"],\"vzpoura\":[\"czech\"],\"vztah\":[\"czech\"],\"vztek\":[\"czech\"],\"xylofon\":[\"czech\"],\"zabrat\":[\"czech\"],\"zabydlet\":[\"czech\"],\"zachovat\":[\"czech\"],\"zadarmo\":[\"czech\"],\"zadusit\":[\"czech\"],\"zafoukat\":[\"czech\"],\"zahltit\":[\"czech\"],\"zahodit\":[\"czech\"],\"zahrada\":[\"czech\"],\"zahynout\":[\"czech\"],\"zajatec\":[\"czech\"],\"zajet\":[\"czech\"],\"zajistit\":[\"czech\"],\"zaklepat\":[\"czech\"],\"zakoupit\":[\"czech\"],\"zalepit\":[\"czech\"],\"zamezit\":[\"czech\"],\"zamotat\":[\"czech\"],\"zamyslet\":[\"czech\"],\"zanechat\":[\"czech\"],\"zanikat\":[\"czech\"],\"zaplatit\":[\"czech\"],\"zapojit\":[\"czech\"],\"zapsat\":[\"czech\"],\"zarazit\":[\"czech\"],\"zastavit\":[\"czech\"],\"zasunout\":[\"czech\"],\"zatajit\":[\"czech\"],\"zatemnit\":[\"czech\"],\"zatknout\":[\"czech\"],\"zaujmout\":[\"czech\"],\"zavalit\":[\"czech\"],\"zavelet\":[\"czech\"],\"zavinit\":[\"czech\"],\"zavolat\":[\"czech\"],\"zavrtat\":[\"czech\"],\"zazvonit\":[\"czech\"],\"zbavit\":[\"czech\"],\"zbrusu\":[\"czech\"],\"zbudovat\":[\"czech\"],\"zbytek\":[\"czech\"],\"zdaleka\":[\"czech\"],\"zdarma\":[\"czech\"],\"zdatnost\":[\"czech\"],\"zdivo\":[\"czech\"],\"zdobit\":[\"czech\"],\"zdroj\":[\"czech\"],\"zdvih\":[\"czech\"],\"zdymadlo\":[\"czech\"],\"zelenina\":[\"czech\"],\"zeman\":[\"czech\"],\"zemina\":[\"czech\"],\"zeptat\":[\"czech\"],\"zezadu\":[\"czech\"],\"zezdola\":[\"czech\"],\"zhatit\":[\"czech\"],\"zhltnout\":[\"czech\"],\"zhluboka\":[\"czech\"],\"zhotovit\":[\"czech\"],\"zhruba\":[\"czech\"],\"zima\":[\"czech\"],\"zimnice\":[\"czech\"],\"zjemnit\":[\"czech\"],\"zklamat\":[\"czech\"],\"zkoumat\":[\"czech\"],\"zkratka\":[\"czech\"],\"zkumavka\":[\"czech\"],\"zlato\":[\"czech\"],\"zlehka\":[\"czech\"],\"zloba\":[\"czech\"],\"zlom\":[\"czech\"],\"zlost\":[\"czech\"],\"zlozvyk\":[\"czech\"],\"zmapovat\":[\"czech\"],\"zmar\":[\"czech\"],\"zmatek\":[\"czech\"],\"zmije\":[\"czech\"],\"zmizet\":[\"czech\"],\"zmocnit\":[\"czech\"],\"zmodrat\":[\"czech\"],\"zmrzlina\":[\"czech\"],\"zmutovat\":[\"czech\"],\"znak\":[\"czech\"],\"znalost\":[\"czech\"],\"znamenat\":[\"czech\"],\"znovu\":[\"czech\"],\"zobrazit\":[\"czech\"],\"zotavit\":[\"czech\"],\"zoubek\":[\"czech\"],\"zoufale\":[\"czech\"],\"zplodit\":[\"czech\"],\"zpomalit\":[\"czech\"],\"zprava\":[\"czech\"],\"zprostit\":[\"czech\"],\"zprudka\":[\"czech\"],\"zprvu\":[\"czech\"],\"zrada\":[\"czech\"],\"zranit\":[\"czech\"],\"zrcadlo\":[\"czech\"],\"zrnitost\":[\"czech\"],\"zrno\":[\"czech\"],\"zrovna\":[\"czech\"],\"zrychlit\":[\"czech\"],\"zrzavost\":[\"czech\"],\"zticha\":[\"czech\"],\"ztratit\":[\"czech\"],\"zubovina\":[\"czech\"],\"zubr\":[\"czech\"],\"zvednout\":[\"czech\"],\"zvenku\":[\"czech\"],\"zvesela\":[\"czech\"],\"zvon\":[\"czech\"],\"zvrat\":[\"czech\"],\"zvukovod\":[\"czech\"],\"zvyk\":[\"czech\"],\"abandon\":[\"english\",\"french\"],\"ability\":[\"english\"],\"able\":[\"english\"],\"about\":[\"english\"],\"above\":[\"english\"],\"absent\":[\"english\"],\"absorb\":[\"english\"],\"abstract\":[\"english\"],\"absurd\":[\"english\"],\"abuse\":[\"english\"],\"access\":[\"english\"],\"accident\":[\"english\"],\"account\":[\"english\"],\"accuse\":[\"english\"],\"achieve\":[\"english\"],\"acid\":[\"english\"],\"acoustic\":[\"english\"],\"acquire\":[\"english\"],\"across\":[\"english\"],\"act\":[\"english\"],\"action\":[\"english\"],\"actor\":[\"english\"],\"actress\":[\"english\"],\"actual\":[\"english\"],\"adapt\":[\"english\"],\"add\":[\"english\"],\"addict\":[\"english\"],\"address\":[\"english\"],\"adjust\":[\"english\"],\"admit\":[\"english\"],\"adult\":[\"english\"],\"advance\":[\"english\"],\"advice\":[\"english\"],\"aerobic\":[\"english\"],\"affair\":[\"english\"],\"afford\":[\"english\"],\"afraid\":[\"english\"],\"again\":[\"english\"],\"age\":[\"english\"],\"agent\":[\"english\"],\"agree\":[\"english\"],\"ahead\":[\"english\"],\"aim\":[\"english\"],\"air\":[\"english\"],\"airport\":[\"english\"],\"aisle\":[\"english\"],\"alarm\":[\"english\"],\"album\":[\"english\"],\"alcohol\":[\"english\"],\"alert\":[\"english\"],\"alien\":[\"english\"],\"all\":[\"english\"],\"alley\":[\"english\"],\"allow\":[\"english\"],\"almost\":[\"english\"],\"alone\":[\"english\"],\"alpha\":[\"english\"],\"already\":[\"english\"],\"also\":[\"english\"],\"alter\":[\"english\"],\"always\":[\"english\"],\"amateur\":[\"english\",\"french\"],\"amazing\":[\"english\"],\"among\":[\"english\"],\"amount\":[\"english\"],\"amused\":[\"english\"],\"analyst\":[\"english\"],\"anchor\":[\"english\"],\"ancient\":[\"english\"],\"anger\":[\"english\"],\"angle\":[\"english\",\"french\"],\"angry\":[\"english\"],\"animal\":[\"english\",\"french\"],\"ankle\":[\"english\"],\"announce\":[\"english\"],\"annual\":[\"english\"],\"another\":[\"english\"],\"answer\":[\"english\"],\"antenna\":[\"english\"],\"antique\":[\"english\"],\"anxiety\":[\"english\"],\"any\":[\"english\"],\"apart\":[\"english\"],\"apology\":[\"english\"],\"appear\":[\"english\"],\"apple\":[\"english\"],\"approve\":[\"english\"],\"april\":[\"english\"],\"arch\":[\"english\"],\"arctic\":[\"english\"],\"area\":[\"english\"],\"arena\":[\"english\",\"turkish\"],\"argue\":[\"english\"],\"arm\":[\"english\"],\"armed\":[\"english\"],\"armor\":[\"english\"],\"army\":[\"english\"],\"around\":[\"english\"],\"arrange\":[\"english\"],\"arrest\":[\"english\"],\"arrive\":[\"english\"],\"arrow\":[\"english\"],\"art\":[\"english\"],\"artefact\":[\"english\"],\"artist\":[\"english\",\"turkish\"],\"artwork\":[\"english\"],\"ask\":[\"english\"],\"aspect\":[\"english\",\"french\"],\"assault\":[\"english\"],\"asset\":[\"english\"],\"assist\":[\"english\"],\"assume\":[\"english\"],\"asthma\":[\"english\"],\"athlete\":[\"english\"],\"atom\":[\"english\",\"turkish\"],\"attack\":[\"english\"],\"attend\":[\"english\"],\"attitude\":[\"english\"],\"attract\":[\"english\"],\"auction\":[\"english\"],\"audit\":[\"english\"],\"august\":[\"english\"],\"aunt\":[\"english\"],\"author\":[\"english\"],\"auto\":[\"english\"],\"autumn\":[\"english\"],\"average\":[\"english\"],\"avocado\":[\"english\"],\"avoid\":[\"english\"],\"awake\":[\"english\"],\"aware\":[\"english\"],\"away\":[\"english\"],\"awesome\":[\"english\"],\"awful\":[\"english\"],\"awkward\":[\"english\"],\"axis\":[\"english\"],\"baby\":[\"english\"],\"bachelor\":[\"english\"],\"bacon\":[\"english\"],\"badge\":[\"english\",\"french\"],\"bag\":[\"english\"],\"balance\":[\"english\"],\"balcony\":[\"english\"],\"ball\":[\"english\"],\"bamboo\":[\"english\"],\"banana\":[\"english\"],\"banner\":[\"english\"],\"bar\":[\"english\"],\"barely\":[\"english\"],\"bargain\":[\"english\"],\"barrel\":[\"english\"],\"base\":[\"english\"],\"basic\":[\"english\"],\"basket\":[\"english\"],\"battle\":[\"english\"],\"beach\":[\"english\"],\"bean\":[\"english\"],\"beauty\":[\"english\"],\"because\":[\"english\"],\"become\":[\"english\"],\"beef\":[\"english\"],\"before\":[\"english\"],\"begin\":[\"english\"],\"behave\":[\"english\"],\"behind\":[\"english\"],\"believe\":[\"english\"],\"below\":[\"english\"],\"belt\":[\"english\"],\"bench\":[\"english\"],\"benefit\":[\"english\"],\"best\":[\"english\"],\"betray\":[\"english\"],\"better\":[\"english\"],\"between\":[\"english\"],\"beyond\":[\"english\"],\"bicycle\":[\"english\",\"french\"],\"bid\":[\"english\"],\"bike\":[\"english\"],\"bind\":[\"english\"],\"biology\":[\"english\"],\"bird\":[\"english\"],\"birth\":[\"english\"],\"bitter\":[\"english\"],\"black\":[\"english\"],\"blade\":[\"english\"],\"blame\":[\"english\"],\"blanket\":[\"english\"],\"blast\":[\"english\"],\"bleak\":[\"english\"],\"bless\":[\"english\"],\"blind\":[\"english\"],\"blood\":[\"english\"],\"blossom\":[\"english\"],\"blouse\":[\"english\"],\"blue\":[\"english\"],\"blur\":[\"english\"],\"blush\":[\"english\"],\"board\":[\"english\"],\"boat\":[\"english\"],\"body\":[\"english\"],\"boil\":[\"english\"],\"bomb\":[\"english\"],\"bone\":[\"english\"],\"bonus\":[\"english\",\"french\"],\"book\":[\"english\"],\"boost\":[\"english\"],\"border\":[\"english\"],\"boring\":[\"english\"],\"borrow\":[\"english\"],\"boss\":[\"english\"],\"bottom\":[\"english\"],\"bounce\":[\"english\"],\"box\":[\"english\"],\"boy\":[\"english\"],\"bracket\":[\"english\"],\"brain\":[\"english\"],\"brand\":[\"english\"],\"brass\":[\"english\"],\"brave\":[\"english\",\"french\"],\"bread\":[\"english\"],\"breeze\":[\"english\"],\"brick\":[\"english\"],\"bridge\":[\"english\"],\"brief\":[\"english\"],\"bright\":[\"english\"],\"bring\":[\"english\"],\"brisk\":[\"english\"],\"broccoli\":[\"english\"],\"broken\":[\"english\"],\"bronze\":[\"english\"],\"broom\":[\"english\"],\"brother\":[\"english\"],\"brown\":[\"english\"],\"brush\":[\"english\"],\"bubble\":[\"english\"],\"buddy\":[\"english\"],\"budget\":[\"english\"],\"buffalo\":[\"english\"],\"build\":[\"english\"],\"bulb\":[\"english\"],\"bulk\":[\"english\"],\"bullet\":[\"english\"],\"bundle\":[\"english\"],\"bunker\":[\"english\"],\"burden\":[\"english\"],\"burger\":[\"english\"],\"burst\":[\"english\"],\"bus\":[\"english\"],\"business\":[\"english\"],\"busy\":[\"english\"],\"butter\":[\"english\"],\"buyer\":[\"english\"],\"buzz\":[\"english\"],\"cabbage\":[\"english\"],\"cabin\":[\"english\"],\"cable\":[\"english\"],\"cactus\":[\"english\"],\"cage\":[\"english\"],\"cake\":[\"english\"],\"call\":[\"english\"],\"calm\":[\"english\"],\"camera\":[\"english\"],\"camp\":[\"english\"],\"can\":[\"english\"],\"canal\":[\"english\",\"french\"],\"cancel\":[\"english\"],\"candy\":[\"english\"],\"cannon\":[\"english\"],\"canoe\":[\"english\"],\"canvas\":[\"english\"],\"canyon\":[\"english\"],\"capable\":[\"english\",\"french\"],\"capital\":[\"english\"],\"captain\":[\"english\"],\"car\":[\"english\"],\"carbon\":[\"english\"],\"card\":[\"english\"],\"cargo\":[\"english\"],\"carpet\":[\"english\"],\"carry\":[\"english\"],\"cart\":[\"english\"],\"case\":[\"english\"],\"cash\":[\"english\"],\"casino\":[\"english\"],\"castle\":[\"english\"],\"casual\":[\"english\"],\"cat\":[\"english\"],\"catalog\":[\"english\"],\"catch\":[\"english\"],\"category\":[\"english\"],\"cattle\":[\"english\"],\"caught\":[\"english\"],\"cause\":[\"english\"],\"caution\":[\"english\",\"french\"],\"cave\":[\"english\"],\"ceiling\":[\"english\"],\"celery\":[\"english\"],\"cement\":[\"english\"],\"census\":[\"english\"],\"century\":[\"english\"],\"cereal\":[\"english\"],\"certain\":[\"english\"],\"chair\":[\"english\"],\"chalk\":[\"english\"],\"champion\":[\"english\"],\"change\":[\"english\"],\"chaos\":[\"english\"],\"chapter\":[\"english\"],\"charge\":[\"english\"],\"chase\":[\"english\"],\"chat\":[\"english\"],\"cheap\":[\"english\"],\"check\":[\"english\"],\"cheese\":[\"english\"],\"chef\":[\"english\"],\"cherry\":[\"english\"],\"chest\":[\"english\"],\"chicken\":[\"english\"],\"chief\":[\"english\"],\"child\":[\"english\"],\"chimney\":[\"english\"],\"choice\":[\"english\"],\"choose\":[\"english\"],\"chronic\":[\"english\"],\"chuckle\":[\"english\"],\"chunk\":[\"english\"],\"churn\":[\"english\"],\"cigar\":[\"english\"],\"cinnamon\":[\"english\"],\"circle\":[\"english\"],\"citizen\":[\"english\"],\"city\":[\"english\"],\"civil\":[\"english\",\"french\"],\"claim\":[\"english\"],\"clap\":[\"english\"],\"clarify\":[\"english\"],\"claw\":[\"english\"],\"clay\":[\"english\"],\"clean\":[\"english\"],\"clerk\":[\"english\"],\"clever\":[\"english\"],\"click\":[\"english\"],\"client\":[\"english\",\"french\"],\"cliff\":[\"english\"],\"climb\":[\"english\"],\"clinic\":[\"english\"],\"clip\":[\"english\"],\"clock\":[\"english\"],\"clog\":[\"english\"],\"close\":[\"english\"],\"cloth\":[\"english\"],\"cloud\":[\"english\"],\"clown\":[\"english\"],\"club\":[\"english\"],\"clump\":[\"english\"],\"cluster\":[\"english\"],\"clutch\":[\"english\"],\"coach\":[\"english\"],\"coast\":[\"english\"],\"coconut\":[\"english\"],\"code\":[\"english\"],\"coffee\":[\"english\"],\"coil\":[\"english\"],\"coin\":[\"english\"],\"collect\":[\"english\"],\"color\":[\"english\"],\"column\":[\"english\"],\"combine\":[\"english\"],\"come\":[\"english\"],\"comfort\":[\"english\"],\"comic\":[\"english\"],\"common\":[\"english\"],\"company\":[\"english\"],\"concert\":[\"english\",\"french\"],\"conduct\":[\"english\"],\"confirm\":[\"english\"],\"congress\":[\"english\"],\"connect\":[\"english\"],\"consider\":[\"english\"],\"control\":[\"english\"],\"convince\":[\"english\"],\"cook\":[\"english\"],\"cool\":[\"english\"],\"copper\":[\"english\"],\"copy\":[\"english\"],\"coral\":[\"english\"],\"core\":[\"english\"],\"corn\":[\"english\"],\"correct\":[\"english\",\"french\"],\"cost\":[\"english\"],\"cotton\":[\"english\"],\"couch\":[\"english\"],\"country\":[\"english\"],\"couple\":[\"english\"],\"course\":[\"english\"],\"cousin\":[\"english\"],\"cover\":[\"english\"],\"coyote\":[\"english\",\"french\"],\"crack\":[\"english\"],\"cradle\":[\"english\"],\"craft\":[\"english\"],\"cram\":[\"english\"],\"crane\":[\"english\"],\"crash\":[\"english\"],\"crater\":[\"english\"],\"crawl\":[\"english\"],\"crazy\":[\"english\"],\"cream\":[\"english\"],\"credit\":[\"english\"],\"creek\":[\"english\"],\"crew\":[\"english\"],\"cricket\":[\"english\"],\"crime\":[\"english\"],\"crisp\":[\"english\"],\"critic\":[\"english\"],\"crop\":[\"english\"],\"cross\":[\"english\"],\"crouch\":[\"english\"],\"crowd\":[\"english\"],\"crucial\":[\"english\",\"french\"],\"cruel\":[\"english\",\"french\"],\"cruise\":[\"english\"],\"crumble\":[\"english\"],\"crunch\":[\"english\"],\"crush\":[\"english\"],\"cry\":[\"english\"],\"crystal\":[\"english\"],\"cube\":[\"english\"],\"culture\":[\"english\"],\"cup\":[\"english\"],\"cupboard\":[\"english\"],\"curious\":[\"english\"],\"current\":[\"english\"],\"curtain\":[\"english\"],\"curve\":[\"english\"],\"cushion\":[\"english\"],\"custom\":[\"english\"],\"cute\":[\"english\"],\"cycle\":[\"english\",\"french\"],\"dad\":[\"english\"],\"damage\":[\"english\"],\"damp\":[\"english\"],\"dance\":[\"english\"],\"danger\":[\"english\",\"french\"],\"daring\":[\"english\"],\"dash\":[\"english\"],\"daughter\":[\"english\"],\"dawn\":[\"english\"],\"day\":[\"english\"],\"deal\":[\"english\"],\"debate\":[\"english\"],\"debris\":[\"english\"],\"decade\":[\"english\"],\"december\":[\"english\"],\"decide\":[\"english\"],\"decline\":[\"english\"],\"decorate\":[\"english\"],\"decrease\":[\"english\"],\"deer\":[\"english\"],\"defense\":[\"english\"],\"define\":[\"english\"],\"defy\":[\"english\"],\"degree\":[\"english\"],\"delay\":[\"english\"],\"deliver\":[\"english\"],\"demand\":[\"english\"],\"demise\":[\"english\"],\"denial\":[\"english\"],\"dentist\":[\"english\"],\"deny\":[\"english\"],\"depart\":[\"english\"],\"depend\":[\"english\"],\"deposit\":[\"english\"],\"depth\":[\"english\"],\"deputy\":[\"english\"],\"derive\":[\"english\"],\"describe\":[\"english\"],\"desert\":[\"english\"],\"design\":[\"english\"],\"desk\":[\"english\"],\"despair\":[\"english\"],\"destroy\":[\"english\"],\"detail\":[\"english\"],\"detect\":[\"english\"],\"develop\":[\"english\"],\"device\":[\"english\"],\"devote\":[\"english\"],\"diagram\":[\"english\"],\"dial\":[\"english\"],\"diamond\":[\"english\"],\"diary\":[\"english\"],\"dice\":[\"english\"],\"diesel\":[\"english\"],\"diet\":[\"english\"],\"differ\":[\"english\"],\"digital\":[\"english\",\"french\"],\"dignity\":[\"english\"],\"dilemma\":[\"english\"],\"dinner\":[\"english\"],\"dinosaur\":[\"english\"],\"direct\":[\"english\"],\"dirt\":[\"english\"],\"disagree\":[\"english\"],\"discover\":[\"english\"],\"disease\":[\"english\"],\"dish\":[\"english\"],\"dismiss\":[\"english\"],\"disorder\":[\"english\"],\"display\":[\"english\"],\"distance\":[\"english\",\"french\"],\"divert\":[\"english\"],\"divide\":[\"english\"],\"divorce\":[\"english\"],\"dizzy\":[\"english\"],\"doctor\":[\"english\"],\"document\":[\"english\"],\"dog\":[\"english\"],\"doll\":[\"english\"],\"dolphin\":[\"english\"],\"domain\":[\"english\"],\"donate\":[\"english\"],\"donkey\":[\"english\"],\"donor\":[\"english\"],\"door\":[\"english\"],\"dose\":[\"english\"],\"double\":[\"english\",\"french\"],\"dove\":[\"english\"],\"draft\":[\"english\"],\"dragon\":[\"english\",\"french\"],\"drama\":[\"english\"],\"drastic\":[\"english\"],\"draw\":[\"english\"],\"dream\":[\"english\"],\"dress\":[\"english\"],\"drift\":[\"english\"],\"drill\":[\"english\"],\"drink\":[\"english\"],\"drip\":[\"english\"],\"drive\":[\"english\"],\"drop\":[\"english\"],\"drum\":[\"english\"],\"dry\":[\"english\"],\"duck\":[\"english\"],\"dumb\":[\"english\"],\"dune\":[\"english\"],\"during\":[\"english\"],\"dust\":[\"english\"],\"dutch\":[\"english\"],\"duty\":[\"english\"],\"dwarf\":[\"english\"],\"dynamic\":[\"english\"],\"eager\":[\"english\"],\"eagle\":[\"english\"],\"early\":[\"english\"],\"earn\":[\"english\"],\"earth\":[\"english\"],\"easily\":[\"english\"],\"east\":[\"english\"],\"easy\":[\"english\"],\"echo\":[\"english\"],\"ecology\":[\"english\"],\"economy\":[\"english\"],\"edge\":[\"english\"],\"edit\":[\"english\"],\"educate\":[\"english\"],\"effort\":[\"english\",\"french\"],\"egg\":[\"english\"],\"eight\":[\"english\"],\"either\":[\"english\"],\"elbow\":[\"english\"],\"elder\":[\"english\"],\"electric\":[\"english\"],\"elegant\":[\"english\"],\"element\":[\"english\"],\"elephant\":[\"english\"],\"elevator\":[\"english\"],\"elite\":[\"english\"],\"else\":[\"english\"],\"embark\":[\"english\"],\"embody\":[\"english\"],\"embrace\":[\"english\"],\"emerge\":[\"english\"],\"emotion\":[\"english\"],\"employ\":[\"english\"],\"empower\":[\"english\"],\"empty\":[\"english\"],\"enable\":[\"english\"],\"enact\":[\"english\"],\"end\":[\"english\"],\"endless\":[\"english\"],\"endorse\":[\"english\"],\"enemy\":[\"english\"],\"energy\":[\"english\"],\"enforce\":[\"english\"],\"engage\":[\"english\"],\"engine\":[\"english\"],\"enhance\":[\"english\"],\"enjoy\":[\"english\"],\"enlist\":[\"english\"],\"enough\":[\"english\"],\"enrich\":[\"english\"],\"enroll\":[\"english\"],\"ensure\":[\"english\"],\"enter\":[\"english\"],\"entire\":[\"english\"],\"entry\":[\"english\"],\"envelope\":[\"english\"],\"episode\":[\"english\"],\"equal\":[\"english\"],\"equip\":[\"english\"],\"era\":[\"english\"],\"erase\":[\"english\"],\"erode\":[\"english\"],\"erosion\":[\"english\"],\"error\":[\"english\"],\"erupt\":[\"english\"],\"escape\":[\"english\"],\"essay\":[\"english\"],\"essence\":[\"english\",\"french\"],\"estate\":[\"english\"],\"eternal\":[\"english\"],\"ethics\":[\"english\"],\"evidence\":[\"english\"],\"evil\":[\"english\"],\"evoke\":[\"english\"],\"evolve\":[\"english\"],\"exact\":[\"english\",\"french\"],\"example\":[\"english\"],\"excess\":[\"english\"],\"exchange\":[\"english\"],\"excite\":[\"english\"],\"exclude\":[\"english\"],\"excuse\":[\"english\",\"french\"],\"execute\":[\"english\"],\"exercise\":[\"english\"],\"exhaust\":[\"english\"],\"exhibit\":[\"english\"],\"exile\":[\"english\"],\"exist\":[\"english\"],\"exit\":[\"english\"],\"exotic\":[\"english\"],\"expand\":[\"english\"],\"expect\":[\"english\"],\"expire\":[\"english\"],\"explain\":[\"english\"],\"expose\":[\"english\"],\"express\":[\"english\"],\"extend\":[\"english\"],\"extra\":[\"english\"],\"eye\":[\"english\"],\"eyebrow\":[\"english\"],\"fabric\":[\"english\"],\"face\":[\"english\"],\"faculty\":[\"english\"],\"fade\":[\"english\"],\"faint\":[\"english\"],\"faith\":[\"english\"],\"fall\":[\"english\"],\"false\":[\"english\"],\"fame\":[\"english\"],\"family\":[\"english\"],\"famous\":[\"english\"],\"fan\":[\"english\"],\"fancy\":[\"english\"],\"fantasy\":[\"english\"],\"farm\":[\"english\"],\"fashion\":[\"english\"],\"fat\":[\"english\"],\"fatal\":[\"english\",\"french\"],\"father\":[\"english\"],\"fatigue\":[\"english\",\"french\"],\"fault\":[\"english\"],\"favorite\":[\"english\"],\"feature\":[\"english\"],\"february\":[\"english\"],\"federal\":[\"english\",\"turkish\"],\"fee\":[\"english\"],\"feed\":[\"english\"],\"feel\":[\"english\"],\"female\":[\"english\"],\"fence\":[\"english\"],\"festival\":[\"english\",\"french\",\"turkish\"],\"fetch\":[\"english\"],\"fever\":[\"english\"],\"few\":[\"english\"],\"fiber\":[\"english\"],\"fiction\":[\"english\"],\"field\":[\"english\"],\"figure\":[\"english\",\"french\"],\"file\":[\"english\"],\"film\":[\"english\"],\"filter\":[\"english\"],\"final\":[\"english\"],\"find\":[\"english\"],\"fine\":[\"english\"],\"finger\":[\"english\"],\"finish\":[\"english\"],\"fire\":[\"english\"],\"firm\":[\"english\"],\"first\":[\"english\"],\"fiscal\":[\"english\"],\"fish\":[\"english\"],\"fit\":[\"english\"],\"fitness\":[\"english\"],\"fix\":[\"english\"],\"flag\":[\"english\"],\"flame\":[\"english\"],\"flash\":[\"english\"],\"flat\":[\"english\"],\"flavor\":[\"english\"],\"flee\":[\"english\"],\"flight\":[\"english\"],\"flip\":[\"english\"],\"float\":[\"english\"],\"flock\":[\"english\"],\"floor\":[\"english\"],\"flower\":[\"english\"],\"fluid\":[\"english\"],\"flush\":[\"english\"],\"fly\":[\"english\"],\"foam\":[\"english\"],\"focus\":[\"english\"],\"fog\":[\"english\"],\"foil\":[\"english\"],\"fold\":[\"english\"],\"follow\":[\"english\"],\"food\":[\"english\"],\"foot\":[\"english\"],\"force\":[\"english\"],\"forest\":[\"english\"],\"forget\":[\"english\"],\"fork\":[\"english\"],\"fortune\":[\"english\",\"french\"],\"forum\":[\"english\"],\"forward\":[\"english\"],\"fossil\":[\"english\"],\"foster\":[\"english\"],\"found\":[\"english\"],\"fox\":[\"english\"],\"fragile\":[\"english\",\"french\"],\"frame\":[\"english\"],\"frequent\":[\"english\"],\"fresh\":[\"english\"],\"friend\":[\"english\"],\"fringe\":[\"english\"],\"frog\":[\"english\"],\"front\":[\"english\"],\"frost\":[\"english\"],\"frown\":[\"english\"],\"frozen\":[\"english\"],\"fruit\":[\"english\",\"french\"],\"fuel\":[\"english\"],\"fun\":[\"english\"],\"funny\":[\"english\"],\"furnace\":[\"english\"],\"fury\":[\"english\"],\"future\":[\"english\"],\"gadget\":[\"english\"],\"gain\":[\"english\"],\"galaxy\":[\"english\"],\"gallery\":[\"english\"],\"game\":[\"english\"],\"gap\":[\"english\"],\"garage\":[\"english\"],\"garbage\":[\"english\"],\"garden\":[\"english\"],\"garlic\":[\"english\"],\"garment\":[\"english\"],\"gas\":[\"english\"],\"gasp\":[\"english\"],\"gate\":[\"english\"],\"gather\":[\"english\"],\"gauge\":[\"english\"],\"gaze\":[\"english\"],\"general\":[\"english\"],\"genius\":[\"english\"],\"genre\":[\"english\"],\"gentle\":[\"english\"],\"genuine\":[\"english\"],\"gesture\":[\"english\"],\"ghost\":[\"english\"],\"giant\":[\"english\"],\"gift\":[\"english\"],\"giggle\":[\"english\"],\"ginger\":[\"english\"],\"giraffe\":[\"english\"],\"girl\":[\"english\"],\"give\":[\"english\"],\"glad\":[\"english\"],\"glance\":[\"english\"],\"glare\":[\"english\"],\"glass\":[\"english\"],\"glide\":[\"english\"],\"glimpse\":[\"english\"],\"globe\":[\"english\",\"french\"],\"gloom\":[\"english\"],\"glory\":[\"english\"],\"glove\":[\"english\"],\"glow\":[\"english\"],\"glue\":[\"english\"],\"goat\":[\"english\"],\"goddess\":[\"english\"],\"gold\":[\"english\"],\"good\":[\"english\"],\"goose\":[\"english\"],\"gorilla\":[\"english\"],\"gospel\":[\"english\"],\"gossip\":[\"english\"],\"govern\":[\"english\"],\"gown\":[\"english\"],\"grab\":[\"english\"],\"grace\":[\"english\"],\"grain\":[\"english\"],\"grant\":[\"english\"],\"grape\":[\"english\"],\"grass\":[\"english\"],\"gravity\":[\"english\"],\"great\":[\"english\"],\"green\":[\"english\"],\"grid\":[\"english\"],\"grief\":[\"english\"],\"grit\":[\"english\"],\"grocery\":[\"english\"],\"group\":[\"english\"],\"grow\":[\"english\"],\"grunt\":[\"english\"],\"guard\":[\"english\"],\"guess\":[\"english\"],\"guide\":[\"english\",\"french\"],\"guilt\":[\"english\"],\"guitar\":[\"english\"],\"gun\":[\"english\"],\"gym\":[\"english\"],\"habit\":[\"english\"],\"hair\":[\"english\"],\"half\":[\"english\"],\"hammer\":[\"english\"],\"hamster\":[\"english\"],\"hand\":[\"english\"],\"happy\":[\"english\"],\"harbor\":[\"english\"],\"hard\":[\"english\"],\"harsh\":[\"english\"],\"harvest\":[\"english\"],\"hat\":[\"english\"],\"have\":[\"english\"],\"hawk\":[\"english\"],\"hazard\":[\"english\"],\"head\":[\"english\"],\"health\":[\"english\"],\"heart\":[\"english\"],\"heavy\":[\"english\"],\"hedgehog\":[\"english\"],\"height\":[\"english\"],\"hello\":[\"english\"],\"helmet\":[\"english\"],\"help\":[\"english\"],\"hen\":[\"english\"],\"hero\":[\"english\"],\"hidden\":[\"english\"],\"high\":[\"english\"],\"hill\":[\"english\"],\"hint\":[\"english\"],\"hip\":[\"english\"],\"hire\":[\"english\"],\"history\":[\"english\"],\"hobby\":[\"english\"],\"hockey\":[\"english\"],\"hold\":[\"english\"],\"hole\":[\"english\"],\"holiday\":[\"english\"],\"hollow\":[\"english\"],\"home\":[\"english\"],\"honey\":[\"english\"],\"hood\":[\"english\"],\"hope\":[\"english\"],\"horn\":[\"english\"],\"horror\":[\"english\"],\"horse\":[\"english\"],\"hospital\":[\"english\"],\"host\":[\"english\"],\"hotel\":[\"english\"],\"hour\":[\"english\"],\"hover\":[\"english\"],\"hub\":[\"english\"],\"huge\":[\"english\"],\"human\":[\"english\"],\"humble\":[\"english\",\"french\"],\"humor\":[\"english\"],\"hundred\":[\"english\"],\"hungry\":[\"english\"],\"hunt\":[\"english\"],\"hurdle\":[\"english\"],\"hurry\":[\"english\"],\"hurt\":[\"english\"],\"husband\":[\"english\"],\"hybrid\":[\"english\"],\"ice\":[\"english\"],\"icon\":[\"english\"],\"idea\":[\"english\"],\"identify\":[\"english\"],\"idle\":[\"english\"],\"ignore\":[\"english\"],\"ill\":[\"english\"],\"illegal\":[\"english\"],\"illness\":[\"english\"],\"image\":[\"english\",\"french\"],\"imitate\":[\"english\"],\"immense\":[\"english\",\"french\"],\"immune\":[\"english\"],\"impact\":[\"english\",\"french\"],\"impose\":[\"english\"],\"improve\":[\"english\"],\"impulse\":[\"english\"],\"inch\":[\"english\"],\"include\":[\"english\"],\"income\":[\"english\"],\"increase\":[\"english\"],\"index\":[\"english\"],\"indicate\":[\"english\"],\"indoor\":[\"english\"],\"industry\":[\"english\"],\"infant\":[\"english\"],\"inflict\":[\"english\"],\"inform\":[\"english\"],\"inhale\":[\"english\"],\"inherit\":[\"english\"],\"initial\":[\"english\"],\"inject\":[\"english\"],\"injury\":[\"english\"],\"inmate\":[\"english\"],\"inner\":[\"english\"],\"innocent\":[\"english\",\"french\"],\"input\":[\"english\"],\"inquiry\":[\"english\"],\"insane\":[\"english\"],\"insect\":[\"english\"],\"inside\":[\"english\"],\"inspire\":[\"english\"],\"install\":[\"english\"],\"intact\":[\"english\",\"french\"],\"interest\":[\"english\"],\"into\":[\"english\"],\"invest\":[\"english\"],\"invite\":[\"english\"],\"involve\":[\"english\"],\"iron\":[\"english\"],\"island\":[\"english\"],\"isolate\":[\"english\"],\"issue\":[\"english\"],\"item\":[\"english\"],\"ivory\":[\"english\"],\"jacket\":[\"english\"],\"jaguar\":[\"english\",\"french\"],\"jar\":[\"english\"],\"jazz\":[\"english\"],\"jealous\":[\"english\"],\"jeans\":[\"english\"],\"jelly\":[\"english\"],\"jewel\":[\"english\"],\"job\":[\"english\"],\"join\":[\"english\"],\"joke\":[\"english\"],\"journey\":[\"english\"],\"joy\":[\"english\"],\"judge\":[\"english\"],\"juice\":[\"english\"],\"jump\":[\"english\"],\"jungle\":[\"english\"],\"junior\":[\"english\",\"french\"],\"junk\":[\"english\"],\"just\":[\"english\"],\"kangaroo\":[\"english\"],\"keen\":[\"english\"],\"keep\":[\"english\"],\"ketchup\":[\"english\"],\"key\":[\"english\"],\"kick\":[\"english\"],\"kid\":[\"english\"],\"kidney\":[\"english\"],\"kind\":[\"english\"],\"kingdom\":[\"english\"],\"kiss\":[\"english\"],\"kit\":[\"english\"],\"kitchen\":[\"english\"],\"kite\":[\"english\"],\"kitten\":[\"english\"],\"kiwi\":[\"english\"],\"knee\":[\"english\"],\"knife\":[\"english\"],\"knock\":[\"english\"],\"know\":[\"english\"],\"lab\":[\"english\"],\"label\":[\"english\",\"french\"],\"labor\":[\"english\"],\"ladder\":[\"english\"],\"lady\":[\"english\"],\"lake\":[\"english\"],\"lamp\":[\"english\"],\"language\":[\"english\"],\"laptop\":[\"english\"],\"large\":[\"english\"],\"later\":[\"english\"],\"latin\":[\"english\"],\"laugh\":[\"english\"],\"laundry\":[\"english\"],\"lava\":[\"english\"],\"law\":[\"english\"],\"lawn\":[\"english\"],\"lawsuit\":[\"english\"],\"layer\":[\"english\"],\"lazy\":[\"english\"],\"leader\":[\"english\"],\"leaf\":[\"english\"],\"learn\":[\"english\"],\"leave\":[\"english\"],\"lecture\":[\"english\",\"french\"],\"left\":[\"english\"],\"leg\":[\"english\"],\"legal\":[\"english\"],\"legend\":[\"english\"],\"leisure\":[\"english\"],\"lemon\":[\"english\"],\"lend\":[\"english\"],\"length\":[\"english\"],\"lens\":[\"english\"],\"leopard\":[\"english\"],\"lesson\":[\"english\"],\"letter\":[\"english\"],\"level\":[\"english\"],\"liar\":[\"english\"],\"liberty\":[\"english\"],\"library\":[\"english\"],\"license\":[\"english\"],\"life\":[\"english\"],\"lift\":[\"english\"],\"light\":[\"english\"],\"like\":[\"english\"],\"limb\":[\"english\"],\"limit\":[\"english\"],\"link\":[\"english\"],\"lion\":[\"english\"],\"liquid\":[\"english\"],\"list\":[\"english\"],\"little\":[\"english\"],\"live\":[\"english\"],\"lizard\":[\"english\"],\"load\":[\"english\"],\"loan\":[\"english\"],\"lobster\":[\"english\"],\"local\":[\"english\"],\"lock\":[\"english\"],\"logic\":[\"english\"],\"lonely\":[\"english\"],\"long\":[\"english\"],\"loop\":[\"english\"],\"lottery\":[\"english\"],\"loud\":[\"english\"],\"lounge\":[\"english\"],\"love\":[\"english\"],\"loyal\":[\"english\",\"french\"],\"lucky\":[\"english\"],\"luggage\":[\"english\"],\"lumber\":[\"english\"],\"lunar\":[\"english\"],\"lunch\":[\"english\"],\"luxury\":[\"english\"],\"lyrics\":[\"english\"],\"machine\":[\"english\",\"french\"],\"mad\":[\"english\"],\"magic\":[\"english\"],\"magnet\":[\"english\"],\"maid\":[\"english\"],\"mail\":[\"english\"],\"main\":[\"english\"],\"major\":[\"english\"],\"make\":[\"english\"],\"mammal\":[\"english\"],\"man\":[\"english\"],\"manage\":[\"english\"],\"mandate\":[\"english\"],\"mango\":[\"english\"],\"mansion\":[\"english\"],\"manual\":[\"english\"],\"maple\":[\"english\"],\"marble\":[\"english\"],\"march\":[\"english\"],\"margin\":[\"english\"],\"marine\":[\"english\"],\"market\":[\"english\",\"turkish\"],\"marriage\":[\"english\"],\"mask\":[\"english\"],\"mass\":[\"english\"],\"master\":[\"english\"],\"match\":[\"english\"],\"material\":[\"english\"],\"math\":[\"english\"],\"matrix\":[\"english\"],\"matter\":[\"english\"],\"maximum\":[\"english\"],\"maze\":[\"english\"],\"meadow\":[\"english\"],\"mean\":[\"english\"],\"measure\":[\"english\"],\"meat\":[\"english\"],\"mechanic\":[\"english\"],\"medal\":[\"english\"],\"media\":[\"english\"],\"melody\":[\"english\"],\"melt\":[\"english\"],\"member\":[\"english\"],\"memory\":[\"english\"],\"mention\":[\"english\"],\"menu\":[\"english\"],\"mercy\":[\"english\"],\"merge\":[\"english\"],\"merit\":[\"english\"],\"merry\":[\"english\"],\"mesh\":[\"english\"],\"message\":[\"english\"],\"metal\":[\"english\"],\"method\":[\"english\"],\"middle\":[\"english\"],\"midnight\":[\"english\"],\"milk\":[\"english\"],\"million\":[\"english\",\"french\"],\"mimic\":[\"english\"],\"mind\":[\"english\"],\"minimum\":[\"english\"],\"minor\":[\"english\"],\"minute\":[\"english\",\"french\"],\"miracle\":[\"english\",\"french\"],\"mirror\":[\"english\"],\"misery\":[\"english\"],\"miss\":[\"english\"],\"mistake\":[\"english\"],\"mix\":[\"english\"],\"mixed\":[\"english\"],\"mixture\":[\"english\"],\"mobile\":[\"english\",\"french\"],\"model\":[\"english\",\"turkish\"],\"modify\":[\"english\"],\"mom\":[\"english\"],\"moment\":[\"english\"],\"monitor\":[\"english\"],\"monkey\":[\"english\"],\"monster\":[\"english\"],\"month\":[\"english\"],\"moon\":[\"english\"],\"moral\":[\"english\"],\"more\":[\"english\"],\"morning\":[\"english\"],\"mosquito\":[\"english\"],\"mother\":[\"english\"],\"motion\":[\"english\"],\"motor\":[\"english\",\"turkish\"],\"mountain\":[\"english\"],\"mouse\":[\"english\"],\"move\":[\"english\"],\"movie\":[\"english\"],\"much\":[\"english\"],\"muffin\":[\"english\"],\"mule\":[\"english\"],\"multiply\":[\"english\"],\"muscle\":[\"english\",\"french\"],\"museum\":[\"english\"],\"mushroom\":[\"english\"],\"music\":[\"english\"],\"must\":[\"english\"],\"mutual\":[\"english\"],\"myself\":[\"english\"],\"mystery\":[\"english\"],\"myth\":[\"english\"],\"naive\":[\"english\"],\"name\":[\"english\"],\"napkin\":[\"english\"],\"narrow\":[\"english\"],\"nasty\":[\"english\"],\"nation\":[\"english\",\"french\"],\"nature\":[\"english\",\"french\"],\"near\":[\"english\"],\"neck\":[\"english\"],\"need\":[\"english\"],\"negative\":[\"english\"],\"neglect\":[\"english\"],\"neither\":[\"english\"],\"nephew\":[\"english\"],\"nerve\":[\"english\"],\"nest\":[\"english\"],\"net\":[\"english\"],\"network\":[\"english\"],\"neutral\":[\"english\"],\"never\":[\"english\"],\"news\":[\"english\"],\"next\":[\"english\"],\"nice\":[\"english\"],\"night\":[\"english\"],\"noble\":[\"english\",\"french\"],\"noise\":[\"english\"],\"nominee\":[\"english\"],\"noodle\":[\"english\"],\"normal\":[\"english\",\"turkish\"],\"north\":[\"english\"],\"nose\":[\"english\"],\"notable\":[\"english\",\"french\"],\"note\":[\"english\"],\"nothing\":[\"english\"],\"notice\":[\"english\"],\"novel\":[\"english\"],\"now\":[\"english\"],\"nuclear\":[\"english\"],\"number\":[\"english\"],\"nurse\":[\"english\"],\"nut\":[\"english\"],\"oak\":[\"english\"],\"obey\":[\"english\"],\"object\":[\"english\"],\"oblige\":[\"english\"],\"obscure\":[\"english\"],\"observe\":[\"english\"],\"obtain\":[\"english\"],\"obvious\":[\"english\"],\"occur\":[\"english\"],\"ocean\":[\"english\"],\"october\":[\"english\"],\"odor\":[\"english\"],\"off\":[\"english\"],\"offer\":[\"english\"],\"office\":[\"english\"],\"often\":[\"english\"],\"oil\":[\"english\"],\"okay\":[\"english\"],\"old\":[\"english\"],\"olive\":[\"english\"],\"olympic\":[\"english\"],\"omit\":[\"english\"],\"once\":[\"english\"],\"one\":[\"english\"],\"onion\":[\"english\"],\"online\":[\"english\"],\"only\":[\"english\"],\"open\":[\"english\"],\"opera\":[\"english\",\"turkish\"],\"opinion\":[\"english\",\"french\"],\"oppose\":[\"english\"],\"option\":[\"english\"],\"orange\":[\"english\",\"french\"],\"orbit\":[\"english\"],\"orchard\":[\"english\"],\"order\":[\"english\"],\"ordinary\":[\"english\"],\"organ\":[\"english\"],\"orient\":[\"english\"],\"original\":[\"english\"],\"orphan\":[\"english\"],\"ostrich\":[\"english\"],\"other\":[\"english\"],\"outdoor\":[\"english\"],\"outer\":[\"english\"],\"output\":[\"english\"],\"outside\":[\"english\"],\"oval\":[\"english\"],\"oven\":[\"english\"],\"over\":[\"english\"],\"own\":[\"english\"],\"owner\":[\"english\"],\"oxygen\":[\"english\"],\"oyster\":[\"english\"],\"ozone\":[\"english\",\"french\"],\"pact\":[\"english\"],\"paddle\":[\"english\"],\"page\":[\"english\"],\"pair\":[\"english\"],\"palace\":[\"english\",\"french\"],\"palm\":[\"english\"],\"panda\":[\"english\",\"french\",\"turkish\"],\"panel\":[\"english\",\"turkish\"],\"panic\":[\"english\"],\"panther\":[\"english\"],\"paper\":[\"english\"],\"parade\":[\"english\"],\"parent\":[\"english\"],\"park\":[\"english\"],\"parrot\":[\"english\"],\"party\":[\"english\"],\"pass\":[\"english\"],\"patch\":[\"english\"],\"path\":[\"english\"],\"patient\":[\"english\"],\"patrol\":[\"english\"],\"pattern\":[\"english\"],\"pause\":[\"english\"],\"pave\":[\"english\"],\"payment\":[\"english\"],\"peace\":[\"english\"],\"peanut\":[\"english\"],\"pear\":[\"english\"],\"peasant\":[\"english\"],\"pelican\":[\"english\"],\"pen\":[\"english\"],\"penalty\":[\"english\"],\"pencil\":[\"english\"],\"people\":[\"english\"],\"pepper\":[\"english\"],\"perfect\":[\"english\"],\"permit\":[\"english\"],\"person\":[\"english\"],\"pet\":[\"english\"],\"phone\":[\"english\"],\"photo\":[\"english\"],\"phrase\":[\"english\",\"french\"],\"physical\":[\"english\"],\"piano\":[\"english\",\"french\"],\"picnic\":[\"english\"],\"picture\":[\"english\"],\"piece\":[\"english\"],\"pig\":[\"english\"],\"pigeon\":[\"english\"],\"pill\":[\"english\"],\"pilot\":[\"english\",\"turkish\"],\"pink\":[\"english\"],\"pioneer\":[\"english\"],\"pipe\":[\"english\"],\"pistol\":[\"english\"],\"pitch\":[\"english\"],\"pizza\":[\"english\",\"french\"],\"place\":[\"english\"],\"planet\":[\"english\"],\"plastic\":[\"english\"],\"plate\":[\"english\"],\"play\":[\"english\"],\"please\":[\"english\"],\"pledge\":[\"english\"],\"pluck\":[\"english\"],\"plug\":[\"english\"],\"plunge\":[\"english\"],\"poem\":[\"english\"],\"poet\":[\"english\"],\"point\":[\"english\"],\"polar\":[\"english\"],\"pole\":[\"english\"],\"police\":[\"english\"],\"pond\":[\"english\"],\"pony\":[\"english\"],\"pool\":[\"english\"],\"popular\":[\"english\"],\"portion\":[\"english\"],\"position\":[\"english\",\"french\"],\"possible\":[\"english\"],\"post\":[\"english\"],\"potato\":[\"english\"],\"pottery\":[\"english\"],\"poverty\":[\"english\"],\"powder\":[\"english\"],\"power\":[\"english\"],\"practice\":[\"english\"],\"praise\":[\"english\"],\"predict\":[\"english\"],\"prefer\":[\"english\"],\"prepare\":[\"english\"],\"present\":[\"english\"],\"pretty\":[\"english\"],\"prevent\":[\"english\"],\"price\":[\"english\"],\"pride\":[\"english\"],\"primary\":[\"english\"],\"print\":[\"english\"],\"priority\":[\"english\"],\"prison\":[\"english\",\"french\"],\"private\":[\"english\"],\"prize\":[\"english\"],\"problem\":[\"english\",\"turkish\"],\"process\":[\"english\"],\"produce\":[\"english\"],\"profit\":[\"english\"],\"program\":[\"english\",\"turkish\"],\"project\":[\"english\"],\"promote\":[\"english\"],\"proof\":[\"english\"],\"property\":[\"english\"],\"prosper\":[\"english\"],\"protect\":[\"english\"],\"proud\":[\"english\"],\"provide\":[\"english\"],\"public\":[\"english\",\"french\"],\"pudding\":[\"english\"],\"pull\":[\"english\"],\"pulp\":[\"english\"],\"pulse\":[\"english\"],\"pumpkin\":[\"english\"],\"punch\":[\"english\"],\"pupil\":[\"english\"],\"puppy\":[\"english\"],\"purchase\":[\"english\"],\"purity\":[\"english\"],\"purpose\":[\"english\"],\"purse\":[\"english\"],\"push\":[\"english\"],\"put\":[\"english\"],\"puzzle\":[\"english\",\"french\"],\"pyramid\":[\"english\"],\"quality\":[\"english\"],\"quantum\":[\"english\"],\"quarter\":[\"english\"],\"question\":[\"english\",\"french\"],\"quick\":[\"english\"],\"quit\":[\"english\"],\"quiz\":[\"english\"],\"quote\":[\"english\"],\"rabbit\":[\"english\"],\"raccoon\":[\"english\"],\"race\":[\"english\"],\"rack\":[\"english\"],\"radar\":[\"english\",\"turkish\"],\"radio\":[\"english\"],\"rail\":[\"english\"],\"rain\":[\"english\"],\"raise\":[\"english\"],\"rally\":[\"english\"],\"ramp\":[\"english\"],\"ranch\":[\"english\"],\"random\":[\"english\"],\"range\":[\"english\"],\"rapid\":[\"english\"],\"rare\":[\"english\"],\"rate\":[\"english\"],\"rather\":[\"english\"],\"raven\":[\"english\"],\"raw\":[\"english\"],\"razor\":[\"english\"],\"ready\":[\"english\"],\"real\":[\"english\"],\"reason\":[\"english\"],\"rebel\":[\"english\"],\"rebuild\":[\"english\"],\"recall\":[\"english\"],\"receive\":[\"english\"],\"recipe\":[\"english\"],\"record\":[\"english\"],\"recycle\":[\"english\"],\"reduce\":[\"english\"],\"reflect\":[\"english\"],\"reform\":[\"english\",\"turkish\"],\"refuse\":[\"english\"],\"region\":[\"english\"],\"regret\":[\"english\"],\"regular\":[\"english\"],\"reject\":[\"english\"],\"relax\":[\"english\"],\"release\":[\"english\"],\"relief\":[\"english\",\"french\"],\"rely\":[\"english\"],\"remain\":[\"english\"],\"remember\":[\"english\"],\"remind\":[\"english\"],\"remove\":[\"english\"],\"render\":[\"english\"],\"renew\":[\"english\"],\"rent\":[\"english\"],\"reopen\":[\"english\"],\"repair\":[\"english\"],\"repeat\":[\"english\"],\"replace\":[\"english\"],\"report\":[\"english\"],\"require\":[\"english\"],\"rescue\":[\"english\"],\"resemble\":[\"english\"],\"resist\":[\"english\"],\"resource\":[\"english\"],\"response\":[\"english\"],\"result\":[\"english\"],\"retire\":[\"english\"],\"retreat\":[\"english\"],\"return\":[\"english\"],\"reunion\":[\"english\"],\"reveal\":[\"english\"],\"review\":[\"english\"],\"reward\":[\"english\"],\"rhythm\":[\"english\"],\"rib\":[\"english\"],\"ribbon\":[\"english\"],\"rice\":[\"english\"],\"rich\":[\"english\"],\"ride\":[\"english\"],\"ridge\":[\"english\"],\"rifle\":[\"english\"],\"right\":[\"english\"],\"rigid\":[\"english\"],\"ring\":[\"english\"],\"riot\":[\"english\"],\"ripple\":[\"english\"],\"risk\":[\"english\"],\"ritual\":[\"english\"],\"rival\":[\"english\",\"french\"],\"river\":[\"english\"],\"road\":[\"english\"],\"roast\":[\"english\"],\"robot\":[\"english\",\"turkish\"],\"robust\":[\"english\"],\"rocket\":[\"english\"],\"romance\":[\"english\",\"french\"],\"roof\":[\"english\"],\"rookie\":[\"english\"],\"room\":[\"english\"],\"rose\":[\"english\"],\"rotate\":[\"english\"],\"rough\":[\"english\"],\"round\":[\"english\"],\"route\":[\"english\"],\"royal\":[\"english\"],\"rubber\":[\"english\"],\"rude\":[\"english\"],\"rug\":[\"english\"],\"rule\":[\"english\"],\"run\":[\"english\"],\"runway\":[\"english\"],\"rural\":[\"english\"],\"sad\":[\"english\"],\"saddle\":[\"english\"],\"sadness\":[\"english\"],\"safe\":[\"english\"],\"sail\":[\"english\"],\"salad\":[\"english\"],\"salmon\":[\"english\"],\"salon\":[\"english\",\"french\",\"turkish\"],\"salt\":[\"english\"],\"salute\":[\"english\"],\"same\":[\"english\"],\"sample\":[\"english\"],\"sand\":[\"english\"],\"satisfy\":[\"english\"],\"satoshi\":[\"english\"],\"sauce\":[\"english\"],\"sausage\":[\"english\"],\"save\":[\"english\"],\"say\":[\"english\"],\"scale\":[\"english\"],\"scan\":[\"english\"],\"scare\":[\"english\"],\"scatter\":[\"english\"],\"scene\":[\"english\"],\"scheme\":[\"english\"],\"school\":[\"english\"],\"science\":[\"english\",\"french\"],\"scissors\":[\"english\"],\"scorpion\":[\"english\"],\"scout\":[\"english\"],\"scrap\":[\"english\"],\"screen\":[\"english\"],\"script\":[\"english\"],\"scrub\":[\"english\"],\"sea\":[\"english\"],\"search\":[\"english\"],\"season\":[\"english\"],\"seat\":[\"english\"],\"second\":[\"english\"],\"secret\":[\"english\"],\"section\":[\"english\"],\"security\":[\"english\"],\"seed\":[\"english\"],\"seek\":[\"english\"],\"segment\":[\"english\"],\"select\":[\"english\"],\"sell\":[\"english\"],\"seminar\":[\"english\"],\"senior\":[\"english\"],\"sense\":[\"english\"],\"sentence\":[\"english\",\"french\"],\"series\":[\"english\"],\"service\":[\"english\",\"french\"],\"session\":[\"english\"],\"settle\":[\"english\"],\"setup\":[\"english\"],\"seven\":[\"english\"],\"shadow\":[\"english\"],\"shaft\":[\"english\"],\"shallow\":[\"english\"],\"share\":[\"english\"],\"shed\":[\"english\"],\"shell\":[\"english\"],\"sheriff\":[\"english\"],\"shield\":[\"english\"],\"shift\":[\"english\"],\"shine\":[\"english\"],\"ship\":[\"english\"],\"shiver\":[\"english\"],\"shock\":[\"english\"],\"shoe\":[\"english\"],\"shoot\":[\"english\"],\"shop\":[\"english\"],\"short\":[\"english\"],\"shoulder\":[\"english\"],\"shove\":[\"english\"],\"shrimp\":[\"english\"],\"shrug\":[\"english\"],\"shuffle\":[\"english\"],\"shy\":[\"english\"],\"sibling\":[\"english\"],\"sick\":[\"english\"],\"side\":[\"english\"],\"siege\":[\"english\"],\"sight\":[\"english\"],\"sign\":[\"english\"],\"silent\":[\"english\"],\"silk\":[\"english\"],\"silly\":[\"english\"],\"silver\":[\"english\"],\"similar\":[\"english\"],\"simple\":[\"english\",\"french\"],\"since\":[\"english\"],\"sing\":[\"english\"],\"siren\":[\"english\"],\"sister\":[\"english\"],\"situate\":[\"english\"],\"six\":[\"english\"],\"size\":[\"english\"],\"skate\":[\"english\"],\"sketch\":[\"english\"],\"ski\":[\"english\"],\"skill\":[\"english\"],\"skin\":[\"english\"],\"skirt\":[\"english\"],\"skull\":[\"english\"],\"slab\":[\"english\"],\"slam\":[\"english\"],\"sleep\":[\"english\"],\"slender\":[\"english\"],\"slice\":[\"english\"],\"slide\":[\"english\"],\"slight\":[\"english\"],\"slim\":[\"english\"],\"slogan\":[\"english\",\"turkish\"],\"slot\":[\"english\"],\"slow\":[\"english\"],\"slush\":[\"english\"],\"small\":[\"english\"],\"smart\":[\"english\"],\"smile\":[\"english\"],\"smoke\":[\"english\"],\"smooth\":[\"english\"],\"snack\":[\"english\"],\"snake\":[\"english\"],\"snap\":[\"english\"],\"sniff\":[\"english\"],\"snow\":[\"english\"],\"soap\":[\"english\"],\"soccer\":[\"english\"],\"social\":[\"english\",\"french\"],\"sock\":[\"english\"],\"soda\":[\"english\"],\"soft\":[\"english\"],\"solar\":[\"english\"],\"soldier\":[\"english\"],\"solid\":[\"english\"],\"solution\":[\"english\"],\"solve\":[\"english\"],\"someone\":[\"english\"],\"song\":[\"english\"],\"soon\":[\"english\"],\"sorry\":[\"english\"],\"sort\":[\"english\"],\"soul\":[\"english\"],\"sound\":[\"english\"],\"soup\":[\"english\"],\"source\":[\"english\",\"french\"],\"south\":[\"english\"],\"space\":[\"english\"],\"spare\":[\"english\"],\"spatial\":[\"english\",\"french\"],\"spawn\":[\"english\"],\"speak\":[\"english\"],\"special\":[\"english\"],\"speed\":[\"english\"],\"spell\":[\"english\"],\"spend\":[\"english\"],\"sphere\":[\"english\"],\"spice\":[\"english\"],\"spider\":[\"english\"],\"spike\":[\"english\"],\"spin\":[\"english\"],\"spirit\":[\"english\"],\"split\":[\"english\"],\"spoil\":[\"english\"],\"sponsor\":[\"english\",\"turkish\"],\"spoon\":[\"english\"],\"sport\":[\"english\"],\"spot\":[\"english\"],\"spray\":[\"english\"],\"spread\":[\"english\"],\"spring\":[\"english\"],\"spy\":[\"english\"],\"square\":[\"english\"],\"squeeze\":[\"english\"],\"squirrel\":[\"english\"],\"stable\":[\"english\",\"french\"],\"stadium\":[\"english\"],\"staff\":[\"english\"],\"stage\":[\"english\"],\"stairs\":[\"english\"],\"stamp\":[\"english\"],\"stand\":[\"english\"],\"start\":[\"english\"],\"state\":[\"english\"],\"stay\":[\"english\"],\"steak\":[\"english\"],\"steel\":[\"english\"],\"stem\":[\"english\"],\"step\":[\"english\"],\"stereo\":[\"english\"],\"stick\":[\"english\"],\"still\":[\"english\"],\"sting\":[\"english\"],\"stock\":[\"english\"],\"stomach\":[\"english\"],\"stone\":[\"english\"],\"stool\":[\"english\"],\"story\":[\"english\"],\"stove\":[\"english\"],\"strategy\":[\"english\"],\"street\":[\"english\"],\"strike\":[\"english\"],\"strong\":[\"english\"],\"struggle\":[\"english\"],\"student\":[\"english\"],\"stuff\":[\"english\"],\"stumble\":[\"english\"],\"style\":[\"english\"],\"subject\":[\"english\"],\"submit\":[\"english\"],\"subway\":[\"english\"],\"success\":[\"english\"],\"such\":[\"english\"],\"sudden\":[\"english\"],\"suffer\":[\"english\"],\"sugar\":[\"english\"],\"suggest\":[\"english\"],\"suit\":[\"english\"],\"summer\":[\"english\"],\"sun\":[\"english\"],\"sunny\":[\"english\"],\"sunset\":[\"english\"],\"super\":[\"english\"],\"supply\":[\"english\"],\"supreme\":[\"english\"],\"sure\":[\"english\"],\"surface\":[\"english\",\"french\"],\"surge\":[\"english\"],\"surprise\":[\"english\",\"french\"],\"surround\":[\"english\"],\"survey\":[\"english\"],\"suspect\":[\"english\",\"french\"],\"sustain\":[\"english\"],\"swallow\":[\"english\"],\"swamp\":[\"english\"],\"swap\":[\"english\"],\"swarm\":[\"english\"],\"swear\":[\"english\"],\"sweet\":[\"english\"],\"swift\":[\"english\"],\"swim\":[\"english\"],\"swing\":[\"english\"],\"switch\":[\"english\"],\"sword\":[\"english\"],\"symbol\":[\"english\"],\"symptom\":[\"english\"],\"syrup\":[\"english\"],\"system\":[\"english\"],\"table\":[\"english\"],\"tackle\":[\"english\"],\"tag\":[\"english\"],\"tail\":[\"english\"],\"talent\":[\"english\",\"french\"],\"talk\":[\"english\"],\"tank\":[\"english\"],\"tape\":[\"english\"],\"target\":[\"english\"],\"task\":[\"english\"],\"taste\":[\"english\"],\"tattoo\":[\"english\"],\"taxi\":[\"english\"],\"teach\":[\"english\"],\"team\":[\"english\"],\"tell\":[\"english\"],\"ten\":[\"english\"],\"tenant\":[\"english\"],\"tennis\":[\"english\"],\"tent\":[\"english\"],\"term\":[\"english\"],\"test\":[\"english\"],\"text\":[\"english\"],\"thank\":[\"english\"],\"that\":[\"english\"],\"theme\":[\"english\"],\"then\":[\"english\"],\"theory\":[\"english\"],\"there\":[\"english\"],\"they\":[\"english\"],\"thing\":[\"english\"],\"this\":[\"english\"],\"thought\":[\"english\"],\"three\":[\"english\"],\"thrive\":[\"english\"],\"throw\":[\"english\"],\"thumb\":[\"english\"],\"thunder\":[\"english\"],\"ticket\":[\"english\"],\"tide\":[\"english\"],\"tiger\":[\"english\"],\"tilt\":[\"english\"],\"timber\":[\"english\"],\"time\":[\"english\"],\"tiny\":[\"english\"],\"tip\":[\"english\"],\"tired\":[\"english\"],\"tissue\":[\"english\"],\"title\":[\"english\"],\"toast\":[\"english\"],\"tobacco\":[\"english\"],\"today\":[\"english\"],\"toddler\":[\"english\"],\"toe\":[\"english\"],\"together\":[\"english\"],\"toilet\":[\"english\"],\"token\":[\"english\"],\"tomato\":[\"english\"],\"tomorrow\":[\"english\"],\"tone\":[\"english\"],\"tongue\":[\"english\"],\"tonight\":[\"english\"],\"tool\":[\"english\"],\"tooth\":[\"english\"],\"top\":[\"english\"],\"topic\":[\"english\"],\"topple\":[\"english\"],\"torch\":[\"english\"],\"tornado\":[\"english\"],\"tortoise\":[\"english\"],\"toss\":[\"english\"],\"total\":[\"english\"],\"tourist\":[\"english\"],\"toward\":[\"english\"],\"tower\":[\"english\"],\"town\":[\"english\"],\"toy\":[\"english\"],\"track\":[\"english\"],\"trade\":[\"english\"],\"traffic\":[\"english\"],\"tragic\":[\"english\"],\"train\":[\"english\",\"french\"],\"transfer\":[\"english\",\"turkish\"],\"trap\":[\"english\"],\"trash\":[\"english\"],\"travel\":[\"english\"],\"tray\":[\"english\"],\"treat\":[\"english\"],\"tree\":[\"english\"],\"trend\":[\"english\"],\"trial\":[\"english\"],\"tribe\":[\"english\"],\"trick\":[\"english\"],\"trigger\":[\"english\"],\"trim\":[\"english\"],\"trip\":[\"english\"],\"trophy\":[\"english\"],\"trouble\":[\"english\"],\"truck\":[\"english\"],\"true\":[\"english\"],\"truly\":[\"english\"],\"trumpet\":[\"english\"],\"trust\":[\"english\"],\"truth\":[\"english\"],\"try\":[\"english\"],\"tube\":[\"english\"],\"tuition\":[\"english\"],\"tumble\":[\"english\"],\"tuna\":[\"english\"],\"tunnel\":[\"english\",\"french\"],\"turkey\":[\"english\"],\"turn\":[\"english\"],\"turtle\":[\"english\"],\"twelve\":[\"english\"],\"twenty\":[\"english\"],\"twice\":[\"english\"],\"twin\":[\"english\"],\"twist\":[\"english\"],\"two\":[\"english\"],\"type\":[\"english\"],\"typical\":[\"english\"],\"ugly\":[\"english\"],\"umbrella\":[\"english\"],\"unable\":[\"english\"],\"unaware\":[\"english\"],\"uncle\":[\"english\"],\"uncover\":[\"english\"],\"under\":[\"english\"],\"undo\":[\"english\"],\"unfair\":[\"english\"],\"unfold\":[\"english\"],\"unhappy\":[\"english\"],\"uniform\":[\"english\"],\"unique\":[\"english\",\"french\"],\"unit\":[\"english\"],\"universe\":[\"english\"],\"unknown\":[\"english\"],\"unlock\":[\"english\"],\"until\":[\"english\"],\"unusual\":[\"english\"],\"unveil\":[\"english\"],\"update\":[\"english\"],\"upgrade\":[\"english\"],\"uphold\":[\"english\"],\"upon\":[\"english\"],\"upper\":[\"english\"],\"upset\":[\"english\"],\"urban\":[\"english\"],\"urge\":[\"english\"],\"usage\":[\"english\",\"french\"],\"use\":[\"english\"],\"used\":[\"english\"],\"useful\":[\"english\"],\"useless\":[\"english\"],\"usual\":[\"english\"],\"utility\":[\"english\"],\"vacant\":[\"english\"],\"vacuum\":[\"english\"],\"vague\":[\"english\",\"french\"],\"valid\":[\"english\"],\"valley\":[\"english\"],\"valve\":[\"english\",\"french\"],\"van\":[\"english\"],\"vanish\":[\"english\"],\"vapor\":[\"english\"],\"various\":[\"english\"],\"vast\":[\"english\"],\"vault\":[\"english\"],\"vehicle\":[\"english\"],\"velvet\":[\"english\"],\"vendor\":[\"english\"],\"venture\":[\"english\"],\"venue\":[\"english\"],\"verb\":[\"english\"],\"verify\":[\"english\"],\"version\":[\"english\"],\"very\":[\"english\"],\"vessel\":[\"english\"],\"veteran\":[\"english\"],\"viable\":[\"english\"],\"vibrant\":[\"english\"],\"vicious\":[\"english\"],\"victory\":[\"english\"],\"video\":[\"english\"],\"view\":[\"english\"],\"village\":[\"english\",\"french\"],\"vintage\":[\"english\"],\"violin\":[\"english\"],\"virtual\":[\"english\"],\"virus\":[\"english\",\"french\"],\"visa\":[\"english\"],\"visit\":[\"english\"],\"visual\":[\"english\"],\"vital\":[\"english\",\"french\"],\"vivid\":[\"english\"],\"vocal\":[\"english\"],\"voice\":[\"english\"],\"void\":[\"english\"],\"volcano\":[\"english\"],\"volume\":[\"english\",\"french\"],\"vote\":[\"english\"],\"voyage\":[\"english\",\"french\"],\"wage\":[\"english\"],\"wagon\":[\"english\",\"french\"],\"wait\":[\"english\"],\"walk\":[\"english\"],\"wall\":[\"english\"],\"walnut\":[\"english\"],\"want\":[\"english\"],\"warfare\":[\"english\"],\"warm\":[\"english\"],\"warrior\":[\"english\"],\"wash\":[\"english\"],\"wasp\":[\"english\"],\"waste\":[\"english\"],\"water\":[\"english\"],\"wave\":[\"english\"],\"way\":[\"english\"],\"wealth\":[\"english\"],\"weapon\":[\"english\"],\"wear\":[\"english\"],\"weasel\":[\"english\"],\"weather\":[\"english\"],\"web\":[\"english\"],\"wedding\":[\"english\"],\"weekend\":[\"english\"],\"weird\":[\"english\"],\"welcome\":[\"english\"],\"west\":[\"english\"],\"wet\":[\"english\"],\"whale\":[\"english\"],\"what\":[\"english\"],\"wheat\":[\"english\"],\"wheel\":[\"english\"],\"when\":[\"english\"],\"where\":[\"english\"],\"whip\":[\"english\"],\"whisper\":[\"english\"],\"wide\":[\"english\"],\"width\":[\"english\"],\"wife\":[\"english\"],\"wild\":[\"english\"],\"will\":[\"english\"],\"win\":[\"english\"],\"window\":[\"english\"],\"wine\":[\"english\"],\"wing\":[\"english\"],\"wink\":[\"english\"],\"winner\":[\"english\"],\"winter\":[\"english\"],\"wire\":[\"english\"],\"wisdom\":[\"english\"],\"wise\":[\"english\"],\"wish\":[\"english\"],\"witness\":[\"english\"],\"wolf\":[\"english\"],\"woman\":[\"english\"],\"wonder\":[\"english\"],\"wood\":[\"english\"],\"wool\":[\"english\"],\"word\":[\"english\"],\"work\":[\"english\"],\"world\":[\"english\"],\"worry\":[\"english\"],\"worth\":[\"english\"],\"wrap\":[\"english\"],\"wreck\":[\"english\"],\"wrestle\":[\"english\"],\"wrist\":[\"english\"],\"write\":[\"english\"],\"wrong\":[\"english\"],\"yard\":[\"english\"],\"year\":[\"english\"],\"yellow\":[\"english\"],\"you\":[\"english\"],\"young\":[\"english\"],\"youth\":[\"english\"],\"zebra\":[\"english\"],\"zero\":[\"english\"],\"zone\":[\"english\"],\"zoo\":[\"english\"],\"abaisser\":[\"french\"],\"abdiquer\":[\"french\"],\"abeille\":[\"french\"],\"abolir\":[\"french\"],\"aborder\":[\"french\"],\"aboutir\":[\"french\"],\"aboyer\":[\"french\"],\"abrasif\":[\"french\"],\"abreuver\":[\"french\"],\"abriter\":[\"french\"],\"abroger\":[\"french\"],\"abrupt\":[\"french\"],\"absence\":[\"french\"],\"absolu\":[\"french\"],\"absurde\":[\"french\"],\"abusif\":[\"french\"],\"abyssal\":[\"french\"],\"academie\":[\"french\"],\"acajou\":[\"french\"],\"acarien\":[\"french\"],\"accabler\":[\"french\"],\"accepter\":[\"french\"],\"acclamer\":[\"french\"],\"accolade\":[\"french\"],\"accroche\":[\"french\"],\"accuser\":[\"french\"],\"acerbe\":[\"french\"],\"achat\":[\"french\"],\"acheter\":[\"french\"],\"aciduler\":[\"french\"],\"acier\":[\"french\"],\"acompte\":[\"french\"],\"acquerir\":[\"french\"],\"acronyme\":[\"french\"],\"acteur\":[\"french\"],\"actif\":[\"french\"],\"actuel\":[\"french\"],\"adepte\":[\"french\"],\"adequat\":[\"french\"],\"adhesif\":[\"french\"],\"adjectif\":[\"french\"],\"adjuger\":[\"french\"],\"admettre\":[\"french\"],\"admirer\":[\"french\"],\"adopter\":[\"french\"],\"adorer\":[\"french\"],\"adoucir\":[\"french\"],\"adresse\":[\"french\"],\"adroit\":[\"french\"],\"adulte\":[\"french\"],\"adverbe\":[\"french\"],\"aerer\":[\"french\"],\"aeronef\":[\"french\"],\"affaire\":[\"french\"],\"affecter\":[\"french\"],\"affiche\":[\"french\"],\"affreux\":[\"french\"],\"affubler\":[\"french\"],\"agacer\":[\"french\"],\"agencer\":[\"french\"],\"agile\":[\"french\"],\"agiter\":[\"french\"],\"agrafer\":[\"french\"],\"agreable\":[\"french\"],\"agrume\":[\"french\"],\"aider\":[\"french\"],\"aiguille\":[\"french\"],\"ailier\":[\"french\"],\"aimable\":[\"french\"],\"aisance\":[\"french\"],\"ajouter\":[\"french\"],\"ajuster\":[\"french\"],\"alarmer\":[\"french\"],\"alchimie\":[\"french\"],\"alerte\":[\"french\"],\"algebre\":[\"french\"],\"algue\":[\"french\"],\"aliener\":[\"french\"],\"aliment\":[\"french\"],\"alleger\":[\"french\"],\"alliage\":[\"french\"],\"allouer\":[\"french\"],\"allumer\":[\"french\"],\"alourdir\":[\"french\"],\"alpaga\":[\"french\"],\"altesse\":[\"french\"],\"alveole\":[\"french\"],\"ambigu\":[\"french\"],\"ambre\":[\"french\"],\"amenager\":[\"french\"],\"amertume\":[\"french\"],\"amidon\":[\"french\"],\"amiral\":[\"french\"],\"amorcer\":[\"french\"],\"amour\":[\"french\"],\"amovible\":[\"french\"],\"amphibie\":[\"french\"],\"ampleur\":[\"french\"],\"amusant\":[\"french\"],\"analyse\":[\"french\"],\"anaphore\":[\"french\"],\"anarchie\":[\"french\"],\"anatomie\":[\"french\"],\"ancien\":[\"french\"],\"aneantir\":[\"french\"],\"angoisse\":[\"french\"],\"anguleux\":[\"french\"],\"annexer\":[\"french\"],\"annonce\":[\"french\"],\"annuel\":[\"french\"],\"anodin\":[\"french\"],\"anomalie\":[\"french\"],\"anonyme\":[\"french\"],\"anormal\":[\"french\"],\"antenne\":[\"french\"],\"antidote\":[\"french\"],\"anxieux\":[\"french\"],\"apaiser\":[\"french\"],\"aperitif\":[\"french\"],\"aplanir\":[\"french\"],\"apologie\":[\"french\"],\"appareil\":[\"french\"],\"appeler\":[\"french\"],\"apporter\":[\"french\"],\"appuyer\":[\"french\"],\"aquarium\":[\"french\"],\"aqueduc\":[\"french\"],\"arbitre\":[\"french\"],\"arbuste\":[\"french\"],\"ardeur\":[\"french\"],\"ardoise\":[\"french\"],\"argent\":[\"french\"],\"arlequin\":[\"french\"],\"armature\":[\"french\"],\"armement\":[\"french\"],\"armoire\":[\"french\"],\"armure\":[\"french\"],\"arpenter\":[\"french\"],\"arracher\":[\"french\"],\"arriver\":[\"french\"],\"arroser\":[\"french\"],\"arsenic\":[\"french\"],\"arteriel\":[\"french\"],\"article\":[\"french\"],\"asphalte\":[\"french\"],\"aspirer\":[\"french\"],\"assaut\":[\"french\"],\"asservir\":[\"french\"],\"assiette\":[\"french\"],\"associer\":[\"french\"],\"assurer\":[\"french\"],\"asticot\":[\"french\"],\"astre\":[\"french\"],\"astuce\":[\"french\"],\"atelier\":[\"french\"],\"atome\":[\"french\"],\"atrium\":[\"french\"],\"atroce\":[\"french\"],\"attaque\":[\"french\"],\"attentif\":[\"french\"],\"attirer\":[\"french\"],\"attraper\":[\"french\"],\"aubaine\":[\"french\"],\"auberge\":[\"french\"],\"audace\":[\"french\"],\"audible\":[\"french\"],\"augurer\":[\"french\"],\"aurore\":[\"french\"],\"automne\":[\"french\"],\"autruche\":[\"french\"],\"avaler\":[\"french\"],\"avancer\":[\"french\"],\"avarice\":[\"french\"],\"avenir\":[\"french\"],\"averse\":[\"french\"],\"aveugle\":[\"french\"],\"aviateur\":[\"french\"],\"avide\":[\"french\"],\"avion\":[\"french\"],\"aviser\":[\"french\"],\"avoine\":[\"french\"],\"avouer\":[\"french\"],\"avril\":[\"french\"],\"axial\":[\"french\"],\"axiome\":[\"french\"],\"bafouer\":[\"french\"],\"bagage\":[\"french\"],\"baguette\":[\"french\"],\"baignade\":[\"french\"],\"balancer\":[\"french\"],\"balcon\":[\"french\"],\"baleine\":[\"french\"],\"balisage\":[\"french\"],\"bambin\":[\"french\"],\"bancaire\":[\"french\"],\"bandage\":[\"french\"],\"banlieue\":[\"french\"],\"banniere\":[\"french\"],\"banquier\":[\"french\"],\"barbier\":[\"french\"],\"baril\":[\"french\"],\"baron\":[\"french\"],\"barque\":[\"french\"],\"barrage\":[\"french\"],\"bassin\":[\"french\"],\"bastion\":[\"french\"],\"bataille\":[\"french\"],\"bateau\":[\"french\"],\"batterie\":[\"french\"],\"baudrier\":[\"french\"],\"bavarder\":[\"french\"],\"belette\":[\"french\"],\"belier\":[\"french\"],\"belote\":[\"french\"],\"benefice\":[\"french\"],\"berceau\":[\"french\"],\"berger\":[\"french\"],\"berline\":[\"french\"],\"bermuda\":[\"french\",\"turkish\"],\"besace\":[\"french\"],\"besogne\":[\"french\"],\"betail\":[\"french\"],\"beurre\":[\"french\"],\"biberon\":[\"french\"],\"bidule\":[\"french\"],\"bijou\":[\"french\"],\"bilan\":[\"french\"],\"bilingue\":[\"french\"],\"billard\":[\"french\"],\"binaire\":[\"french\"],\"biologie\":[\"french\"],\"biopsie\":[\"french\"],\"biotype\":[\"french\"],\"biscuit\":[\"french\"],\"bison\":[\"french\"],\"bistouri\":[\"french\"],\"bitume\":[\"french\"],\"bizarre\":[\"french\"],\"blafard\":[\"french\"],\"blague\":[\"french\"],\"blanchir\":[\"french\"],\"blessant\":[\"french\"],\"blinder\":[\"french\"],\"blond\":[\"french\"],\"bloquer\":[\"french\"],\"blouson\":[\"french\"],\"bobard\":[\"french\"],\"bobine\":[\"french\"],\"boire\":[\"french\"],\"boiser\":[\"french\"],\"bolide\":[\"french\"],\"bonbon\":[\"french\"],\"bondir\":[\"french\"],\"bonheur\":[\"french\"],\"bonifier\":[\"french\"],\"bordure\":[\"french\"],\"borne\":[\"french\"],\"botte\":[\"french\"],\"boucle\":[\"french\"],\"boueux\":[\"french\"],\"bougie\":[\"french\"],\"boulon\":[\"french\"],\"bouquin\":[\"french\"],\"bourse\":[\"french\"],\"boussole\":[\"french\"],\"boutique\":[\"french\"],\"boxeur\":[\"french\"],\"branche\":[\"french\"],\"brasier\":[\"french\"],\"brebis\":[\"french\"],\"breche\":[\"french\"],\"breuvage\":[\"french\"],\"bricoler\":[\"french\"],\"brigade\":[\"french\"],\"brillant\":[\"french\"],\"brioche\":[\"french\"],\"brique\":[\"french\"],\"brochure\":[\"french\"],\"broder\":[\"french\"],\"bronzer\":[\"french\"],\"brousse\":[\"french\"],\"broyeur\":[\"french\"],\"brume\":[\"french\"],\"brusque\":[\"french\"],\"brutal\":[\"french\"],\"bruyant\":[\"french\"],\"buffle\":[\"french\"],\"buisson\":[\"french\"],\"bulletin\":[\"french\"],\"bureau\":[\"french\"],\"burin\":[\"french\"],\"bustier\":[\"french\"],\"butiner\":[\"french\"],\"butoir\":[\"french\"],\"buvable\":[\"french\"],\"buvette\":[\"french\"],\"cabanon\":[\"french\"],\"cabine\":[\"french\"],\"cachette\":[\"french\"],\"cadeau\":[\"french\"],\"cadre\":[\"french\"],\"cafeine\":[\"french\"],\"caillou\":[\"french\"],\"caisson\":[\"french\"],\"calculer\":[\"french\"],\"calepin\":[\"french\"],\"calibre\":[\"french\"],\"calmer\":[\"french\"],\"calomnie\":[\"french\"],\"calvaire\":[\"french\"],\"camarade\":[\"french\"],\"camera\":[\"french\"],\"camion\":[\"french\"],\"campagne\":[\"french\"],\"caneton\":[\"french\"],\"canon\":[\"french\"],\"cantine\":[\"french\"],\"canular\":[\"french\"],\"caporal\":[\"french\"],\"caprice\":[\"french\"],\"capsule\":[\"french\"],\"capter\":[\"french\"],\"capuche\":[\"french\"],\"carabine\":[\"french\"],\"carbone\":[\"french\"],\"caresser\":[\"french\"],\"caribou\":[\"french\"],\"carnage\":[\"french\"],\"carotte\":[\"french\"],\"carreau\":[\"french\"],\"carton\":[\"french\"],\"cascade\":[\"french\"],\"casier\":[\"french\"],\"casque\":[\"french\"],\"cassure\":[\"french\"],\"causer\":[\"french\"],\"cavalier\":[\"french\"],\"caverne\":[\"french\"],\"caviar\":[\"french\"],\"cedille\":[\"french\"],\"ceinture\":[\"french\"],\"celeste\":[\"french\"],\"cellule\":[\"french\"],\"cendrier\":[\"french\"],\"censurer\":[\"french\"],\"central\":[\"french\"],\"cercle\":[\"french\"],\"cerebral\":[\"french\"],\"cerise\":[\"french\"],\"cerner\":[\"french\"],\"cerveau\":[\"french\"],\"cesser\":[\"french\"],\"chagrin\":[\"french\"],\"chaise\":[\"french\"],\"chaleur\":[\"french\"],\"chambre\":[\"french\"],\"chance\":[\"french\"],\"chapitre\":[\"french\"],\"charbon\":[\"french\"],\"chasseur\":[\"french\"],\"chaton\":[\"french\"],\"chausson\":[\"french\"],\"chavirer\":[\"french\"],\"chemise\":[\"french\"],\"chenille\":[\"french\"],\"chequier\":[\"french\"],\"chercher\":[\"french\"],\"cheval\":[\"french\"],\"chien\":[\"french\"],\"chiffre\":[\"french\"],\"chignon\":[\"french\"],\"chimere\":[\"french\"],\"chiot\":[\"french\"],\"chlorure\":[\"french\"],\"chocolat\":[\"french\"],\"choisir\":[\"french\"],\"chose\":[\"french\"],\"chouette\":[\"french\"],\"chrome\":[\"french\"],\"chute\":[\"french\"],\"cigare\":[\"french\"],\"cigogne\":[\"french\"],\"cimenter\":[\"french\"],\"cinema\":[\"french\"],\"cintrer\":[\"french\"],\"circuler\":[\"french\"],\"cirer\":[\"french\"],\"cirque\":[\"french\"],\"citerne\":[\"french\"],\"citoyen\":[\"french\"],\"citron\":[\"french\"],\"clairon\":[\"french\"],\"clameur\":[\"french\"],\"claquer\":[\"french\"],\"classe\":[\"french\"],\"clavier\":[\"french\"],\"cligner\":[\"french\"],\"climat\":[\"french\"],\"clivage\":[\"french\"],\"cloche\":[\"french\"],\"clonage\":[\"french\"],\"cloporte\":[\"french\"],\"cobalt\":[\"french\"],\"cobra\":[\"french\"],\"cocasse\":[\"french\"],\"cocotier\":[\"french\"],\"coder\":[\"french\"],\"codifier\":[\"french\"],\"coffre\":[\"french\"],\"cogner\":[\"french\"],\"cohesion\":[\"french\"],\"coiffer\":[\"french\"],\"coincer\":[\"french\"],\"colere\":[\"french\"],\"colibri\":[\"french\"],\"colline\":[\"french\"],\"colmater\":[\"french\"],\"colonel\":[\"french\"],\"combat\":[\"french\"],\"comedie\":[\"french\"],\"commande\":[\"french\"],\"compact\":[\"french\"],\"conduire\":[\"french\"],\"confier\":[\"french\"],\"congeler\":[\"french\"],\"connoter\":[\"french\"],\"consonne\":[\"french\"],\"contact\":[\"french\"],\"convexe\":[\"french\"],\"copain\":[\"french\"],\"copie\":[\"french\"],\"corail\":[\"french\"],\"corbeau\":[\"french\"],\"cordage\":[\"french\"],\"corniche\":[\"french\"],\"corpus\":[\"french\"],\"cortege\":[\"french\"],\"cosmique\":[\"french\"],\"costume\":[\"french\"],\"coton\":[\"french\"],\"coude\":[\"french\"],\"coupure\":[\"french\"],\"courage\":[\"french\"],\"couteau\":[\"french\"],\"couvrir\":[\"french\"],\"crabe\":[\"french\"],\"crainte\":[\"french\"],\"cravate\":[\"french\"],\"crayon\":[\"french\"],\"creature\":[\"french\"],\"crediter\":[\"french\"],\"cremeux\":[\"french\"],\"creuser\":[\"french\"],\"crevette\":[\"french\"],\"cribler\":[\"french\"],\"crier\":[\"french\"],\"cristal\":[\"french\"],\"critere\":[\"french\"],\"croire\":[\"french\"],\"croquer\":[\"french\"],\"crotale\":[\"french\"],\"crypter\":[\"french\"],\"cubique\":[\"french\"],\"cueillir\":[\"french\"],\"cuillere\":[\"french\"],\"cuisine\":[\"french\"],\"cuivre\":[\"french\"],\"culminer\":[\"french\"],\"cultiver\":[\"french\"],\"cumuler\":[\"french\"],\"cupide\":[\"french\"],\"curatif\":[\"french\"],\"curseur\":[\"french\"],\"cyanure\":[\"french\"],\"cylindre\":[\"french\"],\"cynique\":[\"french\"],\"daigner\":[\"french\"],\"damier\":[\"french\"],\"danseur\":[\"french\"],\"dauphin\":[\"french\"],\"debattre\":[\"french\"],\"debiter\":[\"french\"],\"deborder\":[\"french\"],\"debrider\":[\"french\"],\"debutant\":[\"french\"],\"decaler\":[\"french\"],\"decembre\":[\"french\"],\"dechirer\":[\"french\"],\"decider\":[\"french\"],\"declarer\":[\"french\"],\"decorer\":[\"french\"],\"decrire\":[\"french\"],\"decupler\":[\"french\"],\"dedale\":[\"french\"],\"deductif\":[\"french\"],\"deesse\":[\"french\"],\"defensif\":[\"french\"],\"defiler\":[\"french\"],\"defrayer\":[\"french\"],\"degager\":[\"french\"],\"degivrer\":[\"french\"],\"deglutir\":[\"french\"],\"degrafer\":[\"french\"],\"dejeuner\":[\"french\"],\"delice\":[\"french\"],\"deloger\":[\"french\"],\"demander\":[\"french\"],\"demeurer\":[\"french\"],\"demolir\":[\"french\"],\"denicher\":[\"french\"],\"denouer\":[\"french\"],\"dentelle\":[\"french\"],\"denuder\":[\"french\"],\"depart\":[\"french\"],\"depenser\":[\"french\"],\"dephaser\":[\"french\"],\"deplacer\":[\"french\"],\"deposer\":[\"french\"],\"deranger\":[\"french\"],\"derober\":[\"french\"],\"desastre\":[\"french\"],\"descente\":[\"french\"],\"desert\":[\"french\"],\"designer\":[\"french\"],\"desobeir\":[\"french\"],\"dessiner\":[\"french\"],\"destrier\":[\"french\"],\"detacher\":[\"french\"],\"detester\":[\"french\"],\"detourer\":[\"french\"],\"detresse\":[\"french\"],\"devancer\":[\"french\"],\"devenir\":[\"french\"],\"deviner\":[\"french\"],\"devoir\":[\"french\"],\"diable\":[\"french\"],\"dialogue\":[\"french\"],\"diamant\":[\"french\"],\"dicter\":[\"french\"],\"differer\":[\"french\"],\"digerer\":[\"french\"],\"digne\":[\"french\"],\"diluer\":[\"french\"],\"dimanche\":[\"french\"],\"diminuer\":[\"french\"],\"dioxyde\":[\"french\"],\"directif\":[\"french\"],\"diriger\":[\"french\"],\"discuter\":[\"french\"],\"disposer\":[\"french\"],\"dissiper\":[\"french\"],\"divertir\":[\"french\"],\"diviser\":[\"french\"],\"docile\":[\"french\"],\"docteur\":[\"french\"],\"dogme\":[\"french\"],\"doigt\":[\"french\"],\"domaine\":[\"french\"],\"domicile\":[\"french\"],\"dompter\":[\"french\"],\"donateur\":[\"french\"],\"donjon\":[\"french\"],\"donner\":[\"french\"],\"dopamine\":[\"french\"],\"dortoir\":[\"french\"],\"dorure\":[\"french\"],\"dosage\":[\"french\"],\"doseur\":[\"french\"],\"dossier\":[\"french\"],\"dotation\":[\"french\"],\"douanier\":[\"french\"],\"douceur\":[\"french\"],\"douter\":[\"french\"],\"doyen\":[\"french\"],\"draper\":[\"french\"],\"dresser\":[\"french\"],\"dribbler\":[\"french\"],\"droiture\":[\"french\"],\"duperie\":[\"french\"],\"duplexe\":[\"french\"],\"durable\":[\"french\"],\"durcir\":[\"french\"],\"dynastie\":[\"french\"],\"eblouir\":[\"french\"],\"ecarter\":[\"french\"],\"echarpe\":[\"french\"],\"echelle\":[\"french\"],\"eclairer\":[\"french\"],\"eclipse\":[\"french\"],\"eclore\":[\"french\"],\"ecluse\":[\"french\"],\"ecole\":[\"french\"],\"economie\":[\"french\"],\"ecorce\":[\"french\"],\"ecouter\":[\"french\"],\"ecraser\":[\"french\"],\"ecremer\":[\"french\"],\"ecrivain\":[\"french\"],\"ecrou\":[\"french\"],\"ecume\":[\"french\"],\"ecureuil\":[\"french\"],\"edifier\":[\"french\"],\"eduquer\":[\"french\"],\"effacer\":[\"french\"],\"effectif\":[\"french\"],\"effigie\":[\"french\"],\"effrayer\":[\"french\"],\"effusion\":[\"french\"],\"egaliser\":[\"french\"],\"egarer\":[\"french\"],\"ejecter\":[\"french\"],\"elaborer\":[\"french\"],\"elargir\":[\"french\"],\"electron\":[\"french\"],\"elegant\":[\"french\"],\"elephant\":[\"french\"],\"eleve\":[\"french\"],\"eligible\":[\"french\"],\"elitisme\":[\"french\"],\"eloge\":[\"french\"],\"elucider\":[\"french\"],\"eluder\":[\"french\"],\"emballer\":[\"french\"],\"embellir\":[\"french\"],\"embryon\":[\"french\"],\"emeraude\":[\"french\"],\"emission\":[\"french\"],\"emmener\":[\"french\"],\"emotion\":[\"french\"],\"emouvoir\":[\"french\"],\"empereur\":[\"french\"],\"employer\":[\"french\"],\"emporter\":[\"french\"],\"emprise\":[\"french\"],\"emulsion\":[\"french\"],\"encadrer\":[\"french\"],\"enchere\":[\"french\"],\"enclave\":[\"french\"],\"encoche\":[\"french\"],\"endiguer\":[\"french\"],\"endosser\":[\"french\"],\"endroit\":[\"french\"],\"enduire\":[\"french\"],\"energie\":[\"french\"],\"enfance\":[\"french\"],\"enfermer\":[\"french\"],\"enfouir\":[\"french\"],\"engager\":[\"french\"],\"engin\":[\"french\",\"turkish\"],\"englober\":[\"french\"],\"enigme\":[\"french\"],\"enjamber\":[\"french\"],\"enjeu\":[\"french\"],\"enlever\":[\"french\"],\"ennemi\":[\"french\"],\"ennuyeux\":[\"french\"],\"enrichir\":[\"french\"],\"enrobage\":[\"french\"],\"enseigne\":[\"french\"],\"entasser\":[\"french\"],\"entendre\":[\"french\"],\"entier\":[\"french\"],\"entourer\":[\"french\"],\"entraver\":[\"french\"],\"enumerer\":[\"french\"],\"envahir\":[\"french\"],\"enviable\":[\"french\"],\"envoyer\":[\"french\"],\"enzyme\":[\"french\"],\"eolien\":[\"french\"],\"epaissir\":[\"french\"],\"epargne\":[\"french\"],\"epatant\":[\"french\"],\"epaule\":[\"french\"],\"epicerie\":[\"french\"],\"epidemie\":[\"french\"],\"epier\":[\"french\"],\"epilogue\":[\"french\"],\"epine\":[\"french\"],\"episode\":[\"french\"],\"epitaphe\":[\"french\"],\"epoque\":[\"french\"],\"epreuve\":[\"french\"],\"eprouver\":[\"french\"],\"epuisant\":[\"french\"],\"equerre\":[\"french\"],\"equipe\":[\"french\"],\"eriger\":[\"french\"],\"erosion\":[\"french\"],\"erreur\":[\"french\"],\"eruption\":[\"french\"],\"escalier\":[\"french\"],\"espadon\":[\"french\"],\"espece\":[\"french\"],\"espiegle\":[\"french\"],\"espoir\":[\"french\"],\"esprit\":[\"french\"],\"esquiver\":[\"french\"],\"essayer\":[\"french\"],\"essieu\":[\"french\"],\"essorer\":[\"french\"],\"estime\":[\"french\"],\"estomac\":[\"french\"],\"estrade\":[\"french\"],\"etagere\":[\"french\"],\"etaler\":[\"french\"],\"etanche\":[\"french\"],\"etatique\":[\"french\"],\"eteindre\":[\"french\"],\"etendoir\":[\"french\"],\"eternel\":[\"french\"],\"ethanol\":[\"french\"],\"ethique\":[\"french\"],\"ethnie\":[\"french\"],\"etirer\":[\"french\"],\"etoffer\":[\"french\"],\"etoile\":[\"french\"],\"etonnant\":[\"french\"],\"etourdir\":[\"french\"],\"etrange\":[\"french\"],\"etroit\":[\"french\"],\"etude\":[\"french\"],\"euphorie\":[\"french\"],\"evaluer\":[\"french\"],\"evasion\":[\"french\"],\"eventail\":[\"french\"],\"evidence\":[\"french\"],\"eviter\":[\"french\"],\"evolutif\":[\"french\"],\"evoquer\":[\"french\"],\"exagerer\":[\"french\"],\"exaucer\":[\"french\"],\"exceller\":[\"french\"],\"excitant\":[\"french\"],\"exclusif\":[\"french\"],\"executer\":[\"french\"],\"exemple\":[\"french\"],\"exercer\":[\"french\"],\"exhaler\":[\"french\"],\"exhorter\":[\"french\"],\"exigence\":[\"french\"],\"exiler\":[\"french\"],\"exister\":[\"french\"],\"exotique\":[\"french\"],\"expedier\":[\"french\"],\"explorer\":[\"french\"],\"exposer\":[\"french\"],\"exprimer\":[\"french\"],\"exquis\":[\"french\"],\"extensif\":[\"french\"],\"extraire\":[\"french\"],\"exulter\":[\"french\"],\"fable\":[\"french\"],\"fabuleux\":[\"french\"],\"facette\":[\"french\"],\"facile\":[\"french\"],\"facture\":[\"french\"],\"faiblir\":[\"french\"],\"falaise\":[\"french\"],\"fameux\":[\"french\"],\"famille\":[\"french\"],\"farceur\":[\"french\"],\"farfelu\":[\"french\"],\"farine\":[\"french\"],\"farouche\":[\"french\"],\"fasciner\":[\"french\"],\"faucon\":[\"french\"],\"fautif\":[\"french\"],\"faveur\":[\"french\"],\"favori\":[\"french\",\"turkish\"],\"febrile\":[\"french\"],\"feconder\":[\"french\"],\"federer\":[\"french\"],\"felin\":[\"french\"],\"femme\":[\"french\"],\"femur\":[\"french\"],\"fendoir\":[\"french\"],\"feodal\":[\"french\"],\"fermer\":[\"french\"],\"feroce\":[\"french\"],\"ferveur\":[\"french\"],\"feuille\":[\"french\"],\"feutre\":[\"french\"],\"fevrier\":[\"french\"],\"fiasco\":[\"french\"],\"ficeler\":[\"french\"],\"fictif\":[\"french\"],\"fidele\":[\"french\"],\"filature\":[\"french\"],\"filetage\":[\"french\"],\"filiere\":[\"french\"],\"filleul\":[\"french\"],\"filmer\":[\"french\"],\"filou\":[\"french\"],\"filtrer\":[\"french\"],\"financer\":[\"french\"],\"finir\":[\"french\"],\"fiole\":[\"french\"],\"firme\":[\"french\"],\"fissure\":[\"french\"],\"fixer\":[\"french\"],\"flairer\":[\"french\"],\"flamme\":[\"french\"],\"flasque\":[\"french\"],\"flatteur\":[\"french\"],\"fleau\":[\"french\"],\"fleche\":[\"french\"],\"fleur\":[\"french\"],\"flexion\":[\"french\"],\"flocon\":[\"french\"],\"flore\":[\"french\"],\"fluctuer\":[\"french\"],\"fluide\":[\"french\"],\"fluvial\":[\"french\"],\"folie\":[\"french\"],\"fonderie\":[\"french\"],\"fongible\":[\"french\"],\"fontaine\":[\"french\"],\"forcer\":[\"french\"],\"forgeron\":[\"french\"],\"formuler\":[\"french\"],\"fossile\":[\"french\"],\"foudre\":[\"french\"],\"fougere\":[\"french\"],\"fouiller\":[\"french\"],\"foulure\":[\"french\"],\"fourmi\":[\"french\"],\"fraise\":[\"french\"],\"franchir\":[\"french\"],\"frapper\":[\"french\"],\"frayeur\":[\"french\"],\"fregate\":[\"french\"],\"freiner\":[\"french\"],\"frelon\":[\"french\"],\"fremir\":[\"french\"],\"frenesie\":[\"french\"],\"frere\":[\"french\"],\"friable\":[\"french\"],\"friction\":[\"french\"],\"frisson\":[\"french\"],\"frivole\":[\"french\"],\"froid\":[\"french\"],\"fromage\":[\"french\"],\"frontal\":[\"french\"],\"frotter\":[\"french\"],\"fugitif\":[\"french\"],\"fuite\":[\"french\"],\"fureur\":[\"french\"],\"furieux\":[\"french\"],\"furtif\":[\"french\"],\"fusion\":[\"french\"],\"futur\":[\"french\"],\"gagner\":[\"french\"],\"galaxie\":[\"french\"],\"galerie\":[\"french\"],\"gambader\":[\"french\"],\"garantir\":[\"french\"],\"gardien\":[\"french\"],\"garnir\":[\"french\"],\"garrigue\":[\"french\"],\"gazelle\":[\"french\"],\"gazon\":[\"french\"],\"geant\":[\"french\"],\"gelatine\":[\"french\"],\"gelule\":[\"french\"],\"gendarme\":[\"french\"],\"general\":[\"french\"],\"genie\":[\"french\"],\"genou\":[\"french\"],\"gentil\":[\"french\"],\"geologie\":[\"french\"],\"geometre\":[\"french\"],\"geranium\":[\"french\"],\"germe\":[\"french\"],\"gestuel\":[\"french\"],\"geyser\":[\"french\"],\"gibier\":[\"french\"],\"gicler\":[\"french\"],\"girafe\":[\"french\"],\"givre\":[\"french\"],\"glace\":[\"french\"],\"glaive\":[\"french\"],\"glisser\":[\"french\"],\"gloire\":[\"french\"],\"glorieux\":[\"french\"],\"golfeur\":[\"french\"],\"gomme\":[\"french\"],\"gonfler\":[\"french\"],\"gorge\":[\"french\"],\"gorille\":[\"french\"],\"goudron\":[\"french\"],\"gouffre\":[\"french\"],\"goulot\":[\"french\"],\"goupille\":[\"french\"],\"gourmand\":[\"french\"],\"goutte\":[\"french\"],\"graduel\":[\"french\"],\"graffiti\":[\"french\"],\"graine\":[\"french\"],\"grand\":[\"french\"],\"grappin\":[\"french\"],\"gratuit\":[\"french\"],\"gravir\":[\"french\"],\"grenat\":[\"french\"],\"griffure\":[\"french\"],\"griller\":[\"french\"],\"grimper\":[\"french\"],\"grogner\":[\"french\"],\"gronder\":[\"french\"],\"grotte\":[\"french\"],\"groupe\":[\"french\"],\"gruger\":[\"french\"],\"grutier\":[\"french\"],\"gruyere\":[\"french\"],\"guepard\":[\"french\"],\"guerrier\":[\"french\"],\"guimauve\":[\"french\"],\"guitare\":[\"french\"],\"gustatif\":[\"french\"],\"gymnaste\":[\"french\"],\"gyrostat\":[\"french\"],\"habitude\":[\"french\"],\"hachoir\":[\"french\"],\"halte\":[\"french\"],\"hameau\":[\"french\"],\"hangar\":[\"french\",\"turkish\"],\"hanneton\":[\"french\"],\"haricot\":[\"french\"],\"harmonie\":[\"french\"],\"harpon\":[\"french\"],\"hasard\":[\"french\"],\"helium\":[\"french\"],\"hematome\":[\"french\"],\"herbe\":[\"french\"],\"herisson\":[\"french\"],\"hermine\":[\"french\"],\"heron\":[\"french\"],\"hesiter\":[\"french\"],\"heureux\":[\"french\"],\"hiberner\":[\"french\"],\"hibou\":[\"french\"],\"hilarant\":[\"french\"],\"histoire\":[\"french\"],\"hiver\":[\"french\"],\"homard\":[\"french\"],\"hommage\":[\"french\"],\"homogene\":[\"french\"],\"honneur\":[\"french\"],\"honorer\":[\"french\"],\"honteux\":[\"french\"],\"horde\":[\"french\"],\"horizon\":[\"french\"],\"horloge\":[\"french\"],\"hormone\":[\"french\"],\"horrible\":[\"french\"],\"houleux\":[\"french\"],\"housse\":[\"french\"],\"hublot\":[\"french\"],\"huileux\":[\"french\"],\"humain\":[\"french\"],\"humide\":[\"french\"],\"humour\":[\"french\"],\"hurler\":[\"french\"],\"hydromel\":[\"french\"],\"hygiene\":[\"french\"],\"hymne\":[\"french\"],\"hypnose\":[\"french\"],\"idylle\":[\"french\"],\"ignorer\":[\"french\"],\"iguane\":[\"french\"],\"illicite\":[\"french\"],\"illusion\":[\"french\"],\"imbiber\":[\"french\"],\"imiter\":[\"french\"],\"immobile\":[\"french\"],\"immuable\":[\"french\"],\"imperial\":[\"french\"],\"implorer\":[\"french\"],\"imposer\":[\"french\"],\"imprimer\":[\"french\"],\"imputer\":[\"french\"],\"incarner\":[\"french\"],\"incendie\":[\"french\"],\"incident\":[\"french\"],\"incliner\":[\"french\"],\"incolore\":[\"french\"],\"indexer\":[\"french\"],\"indice\":[\"french\"],\"inductif\":[\"french\"],\"inedit\":[\"french\"],\"ineptie\":[\"french\"],\"inexact\":[\"french\"],\"infini\":[\"french\"],\"infliger\":[\"french\"],\"informer\":[\"french\"],\"infusion\":[\"french\"],\"ingerer\":[\"french\"],\"inhaler\":[\"french\"],\"inhiber\":[\"french\"],\"injecter\":[\"french\"],\"injure\":[\"french\"],\"inoculer\":[\"french\"],\"inonder\":[\"french\"],\"inscrire\":[\"french\"],\"insecte\":[\"french\"],\"insigne\":[\"french\"],\"insolite\":[\"french\"],\"inspirer\":[\"french\"],\"instinct\":[\"french\"],\"insulter\":[\"french\"],\"intense\":[\"french\"],\"intime\":[\"french\"],\"intrigue\":[\"french\"],\"intuitif\":[\"french\"],\"inutile\":[\"french\"],\"invasion\":[\"french\"],\"inventer\":[\"french\"],\"inviter\":[\"french\"],\"invoquer\":[\"french\"],\"ironique\":[\"french\"],\"irradier\":[\"french\"],\"irreel\":[\"french\"],\"irriter\":[\"french\"],\"isoler\":[\"french\"],\"ivoire\":[\"french\"],\"ivresse\":[\"french\"],\"jaillir\":[\"french\"],\"jambe\":[\"french\"],\"janvier\":[\"french\"],\"jardin\":[\"french\"],\"jauger\":[\"french\"],\"jaune\":[\"french\"],\"javelot\":[\"french\"],\"jetable\":[\"french\"],\"jeton\":[\"french\"],\"jeudi\":[\"french\"],\"jeunesse\":[\"french\"],\"joindre\":[\"french\"],\"joncher\":[\"french\"],\"jongler\":[\"french\"],\"joueur\":[\"french\"],\"jouissif\":[\"french\"],\"journal\":[\"french\"],\"jovial\":[\"french\"],\"joyau\":[\"french\"],\"joyeux\":[\"french\"],\"jubiler\":[\"french\"],\"jugement\":[\"french\"],\"jupon\":[\"french\"],\"juriste\":[\"french\"],\"justice\":[\"french\"],\"juteux\":[\"french\"],\"juvenile\":[\"french\"],\"kayak\":[\"french\"],\"kimono\":[\"french\"],\"kiosque\":[\"french\"],\"labial\":[\"french\"],\"labourer\":[\"french\"],\"lacerer\":[\"french\"],\"lactose\":[\"french\"],\"lagune\":[\"french\"],\"laine\":[\"french\"],\"laisser\":[\"french\"],\"laitier\":[\"french\"],\"lambeau\":[\"french\"],\"lamelle\":[\"french\"],\"lampe\":[\"french\"],\"lanceur\":[\"french\"],\"langage\":[\"french\"],\"lanterne\":[\"french\"],\"lapin\":[\"french\"],\"largeur\":[\"french\"],\"larme\":[\"french\"],\"laurier\":[\"french\"],\"lavabo\":[\"french\"],\"lavoir\":[\"french\"],\"legal\":[\"french\"],\"leger\":[\"french\"],\"legume\":[\"french\"],\"lessive\":[\"french\"],\"lettre\":[\"french\"],\"levier\":[\"french\"],\"lexique\":[\"french\"],\"lezard\":[\"french\"],\"liasse\":[\"french\"],\"liberer\":[\"french\"],\"libre\":[\"french\"],\"licence\":[\"french\"],\"licorne\":[\"french\"],\"liege\":[\"french\"],\"lievre\":[\"french\"],\"ligature\":[\"french\"],\"ligoter\":[\"french\"],\"ligue\":[\"french\"],\"limer\":[\"french\"],\"limite\":[\"french\"],\"limonade\":[\"french\"],\"limpide\":[\"french\"],\"lineaire\":[\"french\"],\"lingot\":[\"french\"],\"lionceau\":[\"french\"],\"liquide\":[\"french\"],\"lisiere\":[\"french\"],\"lister\":[\"french\"],\"lithium\":[\"french\"],\"litige\":[\"french\"],\"littoral\":[\"french\"],\"livreur\":[\"french\"],\"logique\":[\"french\"],\"lointain\":[\"french\"],\"loisir\":[\"french\"],\"lombric\":[\"french\"],\"loterie\":[\"french\"],\"louer\":[\"french\"],\"lourd\":[\"french\"],\"loutre\":[\"french\"],\"louve\":[\"french\"],\"lubie\":[\"french\"],\"lucide\":[\"french\"],\"lucratif\":[\"french\"],\"lueur\":[\"french\"],\"lugubre\":[\"french\"],\"luisant\":[\"french\"],\"lumiere\":[\"french\"],\"lunaire\":[\"french\"],\"lundi\":[\"french\"],\"luron\":[\"french\"],\"lutter\":[\"french\"],\"luxueux\":[\"french\"],\"magasin\":[\"french\"],\"magenta\":[\"french\"],\"magique\":[\"french\"],\"maigre\":[\"french\"],\"maillon\":[\"french\"],\"maintien\":[\"french\"],\"mairie\":[\"french\"],\"maison\":[\"french\"],\"majorer\":[\"french\"],\"malaxer\":[\"french\"],\"malefice\":[\"french\"],\"malheur\":[\"french\"],\"malice\":[\"french\"],\"mallette\":[\"french\"],\"mammouth\":[\"french\"],\"mandater\":[\"french\"],\"maniable\":[\"french\"],\"manquant\":[\"french\"],\"manteau\":[\"french\"],\"manuel\":[\"french\"],\"marathon\":[\"french\"],\"marbre\":[\"french\"],\"marchand\":[\"french\"],\"mardi\":[\"french\"],\"maritime\":[\"french\"],\"marqueur\":[\"french\"],\"marron\":[\"french\"],\"marteler\":[\"french\"],\"mascotte\":[\"french\"],\"massif\":[\"french\"],\"materiel\":[\"french\"],\"matiere\":[\"french\"],\"matraque\":[\"french\"],\"maudire\":[\"french\"],\"maussade\":[\"french\"],\"mauve\":[\"french\"],\"maximal\":[\"french\"],\"mechant\":[\"french\"],\"meconnu\":[\"french\"],\"medaille\":[\"french\"],\"medecin\":[\"french\"],\"mediter\":[\"french\"],\"meduse\":[\"french\"],\"meilleur\":[\"french\"],\"melange\":[\"french\"],\"melodie\":[\"french\"],\"membre\":[\"french\"],\"memoire\":[\"french\"],\"menacer\":[\"french\"],\"mener\":[\"french\"],\"menhir\":[\"french\"],\"mensonge\":[\"french\"],\"mentor\":[\"french\"],\"mercredi\":[\"french\"],\"merite\":[\"french\"],\"merle\":[\"french\"],\"messager\":[\"french\"],\"mesure\":[\"french\"],\"metal\":[\"french\"],\"meteore\":[\"french\"],\"methode\":[\"french\"],\"metier\":[\"french\"],\"meuble\":[\"french\"],\"miauler\":[\"french\"],\"microbe\":[\"french\"],\"miette\":[\"french\"],\"mignon\":[\"french\"],\"migrer\":[\"french\"],\"milieu\":[\"french\"],\"mimique\":[\"french\"],\"mince\":[\"french\"],\"mineral\":[\"french\"],\"minimal\":[\"french\"],\"minorer\":[\"french\"],\"miroiter\":[\"french\"],\"missile\":[\"french\"],\"mixte\":[\"french\"],\"moderne\":[\"french\"],\"moelleux\":[\"french\"],\"mondial\":[\"french\"],\"moniteur\":[\"french\"],\"monnaie\":[\"french\"],\"monotone\":[\"french\"],\"monstre\":[\"french\"],\"montagne\":[\"french\"],\"monument\":[\"french\"],\"moqueur\":[\"french\"],\"morceau\":[\"french\"],\"morsure\":[\"french\"],\"mortier\":[\"french\"],\"moteur\":[\"french\"],\"motif\":[\"french\"],\"mouche\":[\"french\"],\"moufle\":[\"french\"],\"moulin\":[\"french\"],\"mousson\":[\"french\"],\"mouton\":[\"french\"],\"mouvant\":[\"french\"],\"multiple\":[\"french\"],\"munition\":[\"french\"],\"muraille\":[\"french\"],\"murene\":[\"french\"],\"murmure\":[\"french\"],\"museum\":[\"french\"],\"musicien\":[\"french\"],\"mutation\":[\"french\"],\"muter\":[\"french\"],\"mutuel\":[\"french\"],\"myriade\":[\"french\"],\"myrtille\":[\"french\"],\"mystere\":[\"french\"],\"mythique\":[\"french\"],\"nageur\":[\"french\"],\"nappe\":[\"french\"],\"narquois\":[\"french\"],\"narrer\":[\"french\"],\"natation\":[\"french\"],\"naufrage\":[\"french\"],\"nautique\":[\"french\"],\"navire\":[\"french\"],\"nebuleux\":[\"french\"],\"nectar\":[\"french\"],\"nefaste\":[\"french\"],\"negation\":[\"french\"],\"negliger\":[\"french\"],\"negocier\":[\"french\"],\"neige\":[\"french\"],\"nerveux\":[\"french\"],\"nettoyer\":[\"french\"],\"neurone\":[\"french\"],\"neutron\":[\"french\"],\"neveu\":[\"french\"],\"niche\":[\"french\"],\"nickel\":[\"french\"],\"nitrate\":[\"french\"],\"niveau\":[\"french\"],\"nocif\":[\"french\"],\"nocturne\":[\"french\"],\"noirceur\":[\"french\"],\"noisette\":[\"french\"],\"nomade\":[\"french\"],\"nombreux\":[\"french\"],\"nommer\":[\"french\"],\"normatif\":[\"french\"],\"notifier\":[\"french\"],\"notoire\":[\"french\"],\"nourrir\":[\"french\"],\"nouveau\":[\"french\"],\"novateur\":[\"french\"],\"novembre\":[\"french\"],\"novice\":[\"french\"],\"nuage\":[\"french\"],\"nuancer\":[\"french\"],\"nuire\":[\"french\"],\"nuisible\":[\"french\"],\"numero\":[\"french\"],\"nuptial\":[\"french\"],\"nuque\":[\"french\"],\"nutritif\":[\"french\"],\"obeir\":[\"french\"],\"objectif\":[\"french\"],\"obliger\":[\"french\"],\"obscur\":[\"french\"],\"observer\":[\"french\"],\"obstacle\":[\"french\"],\"obtenir\":[\"french\"],\"obturer\":[\"french\"],\"occasion\":[\"french\"],\"occuper\":[\"french\"],\"ocean\":[\"french\"],\"octobre\":[\"french\"],\"octroyer\":[\"french\"],\"octupler\":[\"french\"],\"oculaire\":[\"french\"],\"odeur\":[\"french\"],\"odorant\":[\"french\"],\"offenser\":[\"french\"],\"officier\":[\"french\"],\"offrir\":[\"french\"],\"ogive\":[\"french\"],\"oiseau\":[\"french\"],\"oisillon\":[\"french\"],\"olfactif\":[\"french\"],\"olivier\":[\"french\"],\"ombrage\":[\"french\"],\"omettre\":[\"french\"],\"onctueux\":[\"french\"],\"onduler\":[\"french\"],\"onereux\":[\"french\"],\"onirique\":[\"french\"],\"opale\":[\"french\"],\"opaque\":[\"french\"],\"operer\":[\"french\"],\"opportun\":[\"french\"],\"opprimer\":[\"french\"],\"opter\":[\"french\"],\"optique\":[\"french\"],\"orageux\":[\"french\"],\"orbite\":[\"french\"],\"ordonner\":[\"french\"],\"oreille\":[\"french\"],\"organe\":[\"french\"],\"orgueil\":[\"french\"],\"orifice\":[\"french\"],\"ornement\":[\"french\"],\"orque\":[\"french\"],\"ortie\":[\"french\"],\"osciller\":[\"french\"],\"osmose\":[\"french\"],\"ossature\":[\"french\"],\"otarie\":[\"french\"],\"ouragan\":[\"french\"],\"ourson\":[\"french\"],\"outil\":[\"french\"],\"outrager\":[\"french\"],\"ouvrage\":[\"french\"],\"ovation\":[\"french\"],\"oxyde\":[\"french\"],\"oxygene\":[\"french\"],\"paisible\":[\"french\"],\"palmares\":[\"french\"],\"palourde\":[\"french\"],\"palper\":[\"french\"],\"panache\":[\"french\"],\"pangolin\":[\"french\"],\"paniquer\":[\"french\"],\"panneau\":[\"french\"],\"panorama\":[\"french\"],\"pantalon\":[\"french\"],\"papaye\":[\"french\"],\"papier\":[\"french\"],\"papoter\":[\"french\"],\"papyrus\":[\"french\"],\"paradoxe\":[\"french\"],\"parcelle\":[\"french\"],\"paresse\":[\"french\"],\"parfumer\":[\"french\"],\"parler\":[\"french\"],\"parole\":[\"french\"],\"parrain\":[\"french\"],\"parsemer\":[\"french\"],\"partager\":[\"french\"],\"parure\":[\"french\"],\"parvenir\":[\"french\"],\"passion\":[\"french\"],\"pasteque\":[\"french\"],\"paternel\":[\"french\"],\"patience\":[\"french\"],\"patron\":[\"french\",\"turkish\"],\"pavillon\":[\"french\"],\"pavoiser\":[\"french\"],\"payer\":[\"french\"],\"paysage\":[\"french\"],\"peigne\":[\"french\"],\"peintre\":[\"french\"],\"pelage\":[\"french\"],\"pelican\":[\"french\"],\"pelle\":[\"french\"],\"pelouse\":[\"french\"],\"peluche\":[\"french\"],\"pendule\":[\"french\"],\"penetrer\":[\"french\"],\"penible\":[\"french\"],\"pensif\":[\"french\"],\"penurie\":[\"french\"],\"pepite\":[\"french\"],\"peplum\":[\"french\"],\"perdrix\":[\"french\"],\"perforer\":[\"french\"],\"periode\":[\"french\"],\"permuter\":[\"french\"],\"perplexe\":[\"french\"],\"persil\":[\"french\"],\"perte\":[\"french\"],\"peser\":[\"french\"],\"petale\":[\"french\"],\"petit\":[\"french\"],\"petrir\":[\"french\"],\"peuple\":[\"french\"],\"pharaon\":[\"french\"],\"phobie\":[\"french\"],\"phoque\":[\"french\"],\"photon\":[\"french\"],\"physique\":[\"french\"],\"pictural\":[\"french\"],\"piece\":[\"french\"],\"pierre\":[\"french\"],\"pieuvre\":[\"french\"],\"pilote\":[\"french\"],\"pinceau\":[\"french\"],\"pipette\":[\"french\"],\"piquer\":[\"french\"],\"pirogue\":[\"french\"],\"piscine\":[\"french\"],\"piston\":[\"french\"],\"pivoter\":[\"french\"],\"pixel\":[\"french\"],\"placard\":[\"french\"],\"plafond\":[\"french\"],\"plaisir\":[\"french\"],\"planer\":[\"french\"],\"plaque\":[\"french\"],\"plastron\":[\"french\"],\"plateau\":[\"french\"],\"pleurer\":[\"french\"],\"plexus\":[\"french\"],\"pliage\":[\"french\"],\"plomb\":[\"french\"],\"plonger\":[\"french\"],\"pluie\":[\"french\"],\"plumage\":[\"french\"],\"pochette\":[\"french\"],\"poesie\":[\"french\"],\"poete\":[\"french\"],\"pointe\":[\"french\"],\"poirier\":[\"french\"],\"poisson\":[\"french\"],\"poivre\":[\"french\"],\"polaire\":[\"french\"],\"policier\":[\"french\"],\"pollen\":[\"french\"],\"polygone\":[\"french\"],\"pommade\":[\"french\"],\"pompier\":[\"french\"],\"ponctuel\":[\"french\"],\"ponderer\":[\"french\"],\"poney\":[\"french\"],\"portique\":[\"french\"],\"posseder\":[\"french\"],\"posture\":[\"french\"],\"potager\":[\"french\"],\"poteau\":[\"french\"],\"potion\":[\"french\"],\"pouce\":[\"french\"],\"poulain\":[\"french\"],\"poumon\":[\"french\"],\"pourpre\":[\"french\"],\"poussin\":[\"french\"],\"pouvoir\":[\"french\"],\"prairie\":[\"french\"],\"pratique\":[\"french\"],\"precieux\":[\"french\"],\"predire\":[\"french\"],\"prefixe\":[\"french\"],\"prelude\":[\"french\"],\"prenom\":[\"french\"],\"presence\":[\"french\"],\"pretexte\":[\"french\"],\"prevoir\":[\"french\"],\"primitif\":[\"french\"],\"prince\":[\"french\"],\"priver\":[\"french\"],\"probleme\":[\"french\"],\"proceder\":[\"french\"],\"prodige\":[\"french\"],\"profond\":[\"french\"],\"progres\":[\"french\"],\"proie\":[\"french\"],\"projeter\":[\"french\"],\"prologue\":[\"french\"],\"promener\":[\"french\"],\"propre\":[\"french\"],\"prospere\":[\"french\"],\"proteger\":[\"french\"],\"prouesse\":[\"french\"],\"proverbe\":[\"french\"],\"prudence\":[\"french\"],\"pruneau\":[\"french\"],\"psychose\":[\"french\"],\"puceron\":[\"french\"],\"puiser\":[\"french\"],\"pulpe\":[\"french\"],\"pulsar\":[\"french\"],\"punaise\":[\"french\"],\"punitif\":[\"french\"],\"pupitre\":[\"french\"],\"purifier\":[\"french\"],\"pyramide\":[\"french\"],\"quasar\":[\"french\"],\"querelle\":[\"french\"],\"quietude\":[\"french\"],\"quitter\":[\"french\"],\"quotient\":[\"french\"],\"racine\":[\"french\"],\"raconter\":[\"french\"],\"radieux\":[\"french\"],\"ragondin\":[\"french\"],\"raideur\":[\"french\"],\"raisin\":[\"french\"],\"ralentir\":[\"french\"],\"rallonge\":[\"french\"],\"ramasser\":[\"french\"],\"rapide\":[\"french\"],\"rasage\":[\"french\"],\"ratisser\":[\"french\"],\"ravager\":[\"french\"],\"ravin\":[\"french\"],\"rayonner\":[\"french\"],\"reactif\":[\"french\"],\"reagir\":[\"french\"],\"realiser\":[\"french\"],\"reanimer\":[\"french\"],\"recevoir\":[\"french\"],\"reciter\":[\"french\"],\"reclamer\":[\"french\"],\"recolter\":[\"french\"],\"recruter\":[\"french\"],\"reculer\":[\"french\"],\"recycler\":[\"french\"],\"rediger\":[\"french\"],\"redouter\":[\"french\"],\"refaire\":[\"french\"],\"reflexe\":[\"french\"],\"reformer\":[\"french\"],\"refrain\":[\"french\"],\"refuge\":[\"french\"],\"regalien\":[\"french\"],\"region\":[\"french\"],\"reglage\":[\"french\"],\"regulier\":[\"french\"],\"reiterer\":[\"french\"],\"rejeter\":[\"french\"],\"rejouer\":[\"french\"],\"relatif\":[\"french\"],\"relever\":[\"french\"],\"remarque\":[\"french\"],\"remede\":[\"french\"],\"remise\":[\"french\"],\"remonter\":[\"french\"],\"remplir\":[\"french\"],\"remuer\":[\"french\"],\"renard\":[\"french\"],\"renfort\":[\"french\"],\"renifler\":[\"french\"],\"renoncer\":[\"french\"],\"rentrer\":[\"french\"],\"renvoi\":[\"french\"],\"replier\":[\"french\"],\"reporter\":[\"french\"],\"reprise\":[\"french\"],\"reptile\":[\"french\"],\"requin\":[\"french\"],\"reserve\":[\"french\"],\"resineux\":[\"french\"],\"resoudre\":[\"french\"],\"respect\":[\"french\"],\"rester\":[\"french\"],\"resultat\":[\"french\"],\"retablir\":[\"french\"],\"retenir\":[\"french\"],\"reticule\":[\"french\"],\"retomber\":[\"french\"],\"retracer\":[\"french\"],\"reunion\":[\"french\"],\"reussir\":[\"french\"],\"revanche\":[\"french\"],\"revivre\":[\"french\"],\"revolte\":[\"french\"],\"revulsif\":[\"french\"],\"richesse\":[\"french\"],\"rideau\":[\"french\"],\"rieur\":[\"french\"],\"rigide\":[\"french\"],\"rigoler\":[\"french\"],\"rincer\":[\"french\"],\"riposter\":[\"french\"],\"risible\":[\"french\"],\"risque\":[\"french\"],\"rituel\":[\"french\"],\"riviere\":[\"french\"],\"rocheux\":[\"french\"],\"rompre\":[\"french\"],\"ronce\":[\"french\"],\"rondin\":[\"french\"],\"roseau\":[\"french\"],\"rosier\":[\"french\"],\"rotatif\":[\"french\"],\"rotor\":[\"french\"],\"rotule\":[\"french\"],\"rouge\":[\"french\"],\"rouille\":[\"french\"],\"rouleau\":[\"french\"],\"routine\":[\"french\"],\"royaume\":[\"french\"],\"ruban\":[\"french\"],\"rubis\":[\"french\"],\"ruche\":[\"french\"],\"ruelle\":[\"french\"],\"rugueux\":[\"french\"],\"ruiner\":[\"french\"],\"ruisseau\":[\"french\"],\"ruser\":[\"french\"],\"rustique\":[\"french\"],\"rythme\":[\"french\"],\"sabler\":[\"french\"],\"saboter\":[\"french\"],\"sabre\":[\"french\"],\"sacoche\":[\"french\"],\"safari\":[\"french\"],\"sagesse\":[\"french\"],\"saisir\":[\"french\"],\"salade\":[\"french\"],\"salive\":[\"french\"],\"saluer\":[\"french\"],\"samedi\":[\"french\"],\"sanction\":[\"french\"],\"sanglier\":[\"french\"],\"sarcasme\":[\"french\"],\"sardine\":[\"french\"],\"saturer\":[\"french\"],\"saugrenu\":[\"french\"],\"saumon\":[\"french\"],\"sauter\":[\"french\"],\"sauvage\":[\"french\"],\"savant\":[\"french\"],\"savonner\":[\"french\"],\"scalpel\":[\"french\"],\"scandale\":[\"french\"],\"scelerat\":[\"french\"],\"scenario\":[\"french\"],\"sceptre\":[\"french\"],\"schema\":[\"french\"],\"scinder\":[\"french\"],\"score\":[\"french\"],\"scrutin\":[\"french\"],\"sculpter\":[\"french\"],\"seance\":[\"french\"],\"secable\":[\"french\"],\"secher\":[\"french\"],\"secouer\":[\"french\"],\"secreter\":[\"french\"],\"sedatif\":[\"french\"],\"seduire\":[\"french\"],\"seigneur\":[\"french\"],\"sejour\":[\"french\"],\"selectif\":[\"french\"],\"semaine\":[\"french\"],\"sembler\":[\"french\"],\"semence\":[\"french\"],\"seminal\":[\"french\"],\"senateur\":[\"french\"],\"sensible\":[\"french\"],\"separer\":[\"french\"],\"sequence\":[\"french\"],\"serein\":[\"french\"],\"sergent\":[\"french\"],\"serieux\":[\"french\"],\"serrure\":[\"french\"],\"serum\":[\"french\"],\"sesame\":[\"french\"],\"sevir\":[\"french\"],\"sevrage\":[\"french\"],\"sextuple\":[\"french\"],\"sideral\":[\"french\"],\"siecle\":[\"french\"],\"sieger\":[\"french\"],\"siffler\":[\"french\"],\"sigle\":[\"french\"],\"signal\":[\"french\"],\"silence\":[\"french\"],\"silicium\":[\"french\"],\"sincere\":[\"french\"],\"sinistre\":[\"french\"],\"siphon\":[\"french\"],\"sirop\":[\"french\"],\"sismique\":[\"french\"],\"situer\":[\"french\"],\"skier\":[\"french\"],\"socle\":[\"french\"],\"sodium\":[\"french\"],\"soigneux\":[\"french\"],\"soldat\":[\"french\"],\"soleil\":[\"french\"],\"solitude\":[\"french\"],\"soluble\":[\"french\"],\"sombre\":[\"french\"],\"sommeil\":[\"french\"],\"somnoler\":[\"french\"],\"sonde\":[\"french\"],\"songeur\":[\"french\"],\"sonnette\":[\"french\"],\"sonore\":[\"french\"],\"sorcier\":[\"french\"],\"sortir\":[\"french\"],\"sosie\":[\"french\"],\"sottise\":[\"french\"],\"soucieux\":[\"french\"],\"soudure\":[\"french\"],\"souffle\":[\"french\"],\"soulever\":[\"french\"],\"soupape\":[\"french\"],\"soutirer\":[\"french\"],\"souvenir\":[\"french\"],\"spacieux\":[\"french\"],\"special\":[\"french\"],\"sphere\":[\"french\"],\"spiral\":[\"french\",\"turkish\"],\"station\":[\"french\"],\"sternum\":[\"french\"],\"stimulus\":[\"french\"],\"stipuler\":[\"french\"],\"strict\":[\"french\"],\"studieux\":[\"french\"],\"stupeur\":[\"french\"],\"styliste\":[\"french\"],\"sublime\":[\"french\"],\"substrat\":[\"french\"],\"subtil\":[\"french\"],\"subvenir\":[\"french\"],\"succes\":[\"french\"],\"sucre\":[\"french\"],\"suffixe\":[\"french\"],\"suggerer\":[\"french\"],\"suiveur\":[\"french\"],\"sulfate\":[\"french\"],\"superbe\":[\"french\"],\"supplier\":[\"french\"],\"suricate\":[\"french\"],\"surmener\":[\"french\"],\"sursaut\":[\"french\"],\"survie\":[\"french\"],\"syllabe\":[\"french\"],\"symbole\":[\"french\"],\"symetrie\":[\"french\"],\"synapse\":[\"french\"],\"syntaxe\":[\"french\"],\"systeme\":[\"french\"],\"tabac\":[\"french\"],\"tablier\":[\"french\"],\"tactile\":[\"french\"],\"tailler\":[\"french\"],\"talisman\":[\"french\"],\"talonner\":[\"french\"],\"tambour\":[\"french\"],\"tamiser\":[\"french\"],\"tangible\":[\"french\"],\"tapis\":[\"french\"],\"taquiner\":[\"french\"],\"tarder\":[\"french\"],\"tarif\":[\"french\"],\"tartine\":[\"french\"],\"tasse\":[\"french\"],\"tatami\":[\"french\"],\"tatouage\":[\"french\"],\"taupe\":[\"french\"],\"taureau\":[\"french\"],\"taxer\":[\"french\"],\"temoin\":[\"french\"],\"temporel\":[\"french\"],\"tenaille\":[\"french\"],\"tendre\":[\"french\"],\"teneur\":[\"french\"],\"tenir\":[\"french\"],\"tension\":[\"french\"],\"terminer\":[\"french\"],\"terne\":[\"french\"],\"terrible\":[\"french\"],\"tetine\":[\"french\"],\"texte\":[\"french\"],\"theme\":[\"french\"],\"theorie\":[\"french\"],\"therapie\":[\"french\"],\"thorax\":[\"french\"],\"tibia\":[\"french\"],\"tiede\":[\"french\"],\"timide\":[\"french\"],\"tirelire\":[\"french\"],\"tiroir\":[\"french\"],\"tissu\":[\"french\"],\"titane\":[\"french\"],\"titre\":[\"french\"],\"tituber\":[\"french\"],\"toboggan\":[\"french\"],\"tolerant\":[\"french\"],\"tomate\":[\"french\"],\"tonique\":[\"french\"],\"tonneau\":[\"french\"],\"toponyme\":[\"french\"],\"torche\":[\"french\"],\"tordre\":[\"french\"],\"tornade\":[\"french\"],\"torpille\":[\"french\"],\"torrent\":[\"french\"],\"torse\":[\"french\"],\"tortue\":[\"french\"],\"totem\":[\"french\"],\"toucher\":[\"french\"],\"tournage\":[\"french\"],\"tousser\":[\"french\"],\"toxine\":[\"french\"],\"traction\":[\"french\"],\"trafic\":[\"french\"],\"tragique\":[\"french\"],\"trahir\":[\"french\"],\"trancher\":[\"french\"],\"travail\":[\"french\"],\"trefle\":[\"french\"],\"tremper\":[\"french\"],\"tresor\":[\"french\"],\"treuil\":[\"french\"],\"triage\":[\"french\"],\"tribunal\":[\"french\"],\"tricoter\":[\"french\"],\"trilogie\":[\"french\"],\"triomphe\":[\"french\"],\"tripler\":[\"french\"],\"triturer\":[\"french\"],\"trivial\":[\"french\"],\"trombone\":[\"french\"],\"tronc\":[\"french\"],\"tropical\":[\"french\"],\"troupeau\":[\"french\"],\"tuile\":[\"french\"],\"tulipe\":[\"french\"],\"tumulte\":[\"french\"],\"turbine\":[\"french\"],\"tuteur\":[\"french\"],\"tutoyer\":[\"french\"],\"tuyau\":[\"french\"],\"tympan\":[\"french\"],\"typhon\":[\"french\"],\"typique\":[\"french\"],\"tyran\":[\"french\"],\"ubuesque\":[\"french\"],\"ultime\":[\"french\"],\"ultrason\":[\"french\"],\"unanime\":[\"french\"],\"unifier\":[\"french\"],\"union\":[\"french\"],\"unitaire\":[\"french\"],\"univers\":[\"french\"],\"uranium\":[\"french\"],\"urbain\":[\"french\"],\"urticant\":[\"french\"],\"usine\":[\"french\"],\"usuel\":[\"french\"],\"usure\":[\"french\"],\"utile\":[\"french\"],\"utopie\":[\"french\"],\"vacarme\":[\"french\"],\"vaccin\":[\"french\"],\"vagabond\":[\"french\"],\"vaillant\":[\"french\"],\"vaincre\":[\"french\"],\"vaisseau\":[\"french\"],\"valable\":[\"french\"],\"valise\":[\"french\"],\"vallon\":[\"french\"],\"vampire\":[\"french\"],\"vanille\":[\"french\"],\"vapeur\":[\"french\"],\"varier\":[\"french\"],\"vaseux\":[\"french\"],\"vassal\":[\"french\"],\"vaste\":[\"french\"],\"vecteur\":[\"french\"],\"vedette\":[\"french\"],\"vegetal\":[\"french\"],\"vehicule\":[\"french\"],\"veinard\":[\"french\"],\"veloce\":[\"french\"],\"vendredi\":[\"french\"],\"venerer\":[\"french\"],\"venger\":[\"french\"],\"venimeux\":[\"french\"],\"ventouse\":[\"french\"],\"verdure\":[\"french\"],\"verin\":[\"french\"],\"vernir\":[\"french\"],\"verrou\":[\"french\"],\"verser\":[\"french\"],\"vertu\":[\"french\"],\"veston\":[\"french\"],\"veteran\":[\"french\"],\"vetuste\":[\"french\"],\"vexant\":[\"french\"],\"vexer\":[\"french\"],\"viaduc\":[\"french\"],\"viande\":[\"french\"],\"victoire\":[\"french\"],\"vidange\":[\"french\"],\"video\":[\"french\"],\"vignette\":[\"french\"],\"vigueur\":[\"french\"],\"vilain\":[\"french\"],\"vinaigre\":[\"french\"],\"violon\":[\"french\"],\"vipere\":[\"french\"],\"virement\":[\"french\"],\"virtuose\":[\"french\"],\"visage\":[\"french\"],\"viseur\":[\"french\"],\"vision\":[\"french\"],\"visqueux\":[\"french\"],\"visuel\":[\"french\"],\"vitesse\":[\"french\"],\"viticole\":[\"french\"],\"vitrine\":[\"french\"],\"vivace\":[\"french\"],\"vivipare\":[\"french\"],\"vocation\":[\"french\"],\"voguer\":[\"french\"],\"voile\":[\"french\"],\"voisin\":[\"french\"],\"voiture\":[\"french\"],\"volaille\":[\"french\"],\"volcan\":[\"french\"],\"voltiger\":[\"french\"],\"vorace\":[\"french\"],\"vortex\":[\"french\"],\"voter\":[\"french\"],\"vouloir\":[\"french\"],\"voyelle\":[\"french\"],\"xenon\":[\"french\"],\"yacht\":[\"french\"],\"zebre\":[\"french\"],\"zenith\":[\"french\"],\"zeste\":[\"french\"],\"zoologie\":[\"french\"],\"abaco\":[\"italian\"],\"abbaglio\":[\"italian\"],\"abbinato\":[\"italian\"],\"abete\":[\"italian\"],\"abisso\":[\"italian\"],\"abolire\":[\"italian\"],\"abrasivo\":[\"italian\"],\"abrogato\":[\"italian\"],\"accadere\":[\"italian\"],\"accenno\":[\"italian\"],\"accusato\":[\"italian\"],\"acetone\":[\"italian\"],\"achille\":[\"italian\"],\"acido\":[\"italian\"],\"acqua\":[\"italian\"],\"acre\":[\"italian\"],\"acrilico\":[\"italian\"],\"acrobata\":[\"italian\"],\"acuto\":[\"italian\"],\"adagio\":[\"italian\"],\"addebito\":[\"italian\"],\"addome\":[\"italian\"],\"adeguato\":[\"italian\"],\"aderire\":[\"italian\"],\"adipe\":[\"italian\"],\"adottare\":[\"italian\"],\"adulare\":[\"italian\"],\"affabile\":[\"italian\"],\"affetto\":[\"italian\"],\"affisso\":[\"italian\"],\"affranto\":[\"italian\"],\"aforisma\":[\"italian\"],\"afoso\":[\"italian\"],\"africano\":[\"italian\"],\"agave\":[\"italian\"],\"agente\":[\"italian\"],\"agevole\":[\"italian\"],\"aggancio\":[\"italian\"],\"agire\":[\"italian\"],\"agitare\":[\"italian\"],\"agonismo\":[\"italian\"],\"agricolo\":[\"italian\"],\"agrumeto\":[\"italian\"],\"aguzzo\":[\"italian\"],\"alabarda\":[\"italian\"],\"alato\":[\"italian\"],\"albatro\":[\"italian\"],\"alberato\":[\"italian\"],\"albo\":[\"italian\"],\"albume\":[\"italian\"],\"alce\":[\"italian\"],\"alcolico\":[\"italian\"],\"alettone\":[\"italian\"],\"alfa\":[\"italian\"],\"algebra\":[\"italian\"],\"aliante\":[\"italian\"],\"alibi\":[\"italian\"],\"alimento\":[\"italian\"],\"allagato\":[\"italian\"],\"allegro\":[\"italian\"],\"allievo\":[\"italian\"],\"allodola\":[\"italian\"],\"allusivo\":[\"italian\"],\"almeno\":[\"italian\"],\"alogeno\":[\"italian\"],\"alpaca\":[\"italian\"],\"alpestre\":[\"italian\"],\"altalena\":[\"italian\"],\"alterno\":[\"italian\"],\"alticcio\":[\"italian\"],\"altrove\":[\"italian\"],\"alunno\":[\"italian\"],\"alveolo\":[\"italian\"],\"alzare\":[\"italian\"],\"amalgama\":[\"italian\"],\"amanita\":[\"italian\"],\"amarena\":[\"italian\"],\"ambito\":[\"italian\"],\"ambrato\":[\"italian\"],\"ameba\":[\"italian\"],\"america\":[\"italian\"],\"ametista\":[\"italian\"],\"amico\":[\"italian\"],\"ammasso\":[\"italian\"],\"ammenda\":[\"italian\"],\"ammirare\":[\"italian\"],\"ammonito\":[\"italian\"],\"amore\":[\"italian\"],\"ampio\":[\"italian\"],\"ampliare\":[\"italian\"],\"amuleto\":[\"italian\"],\"anacardo\":[\"italian\"],\"anagrafe\":[\"italian\"],\"analista\":[\"italian\"],\"anarchia\":[\"italian\"],\"anatra\":[\"italian\"],\"anca\":[\"italian\"],\"ancella\":[\"italian\"],\"ancora\":[\"italian\"],\"andare\":[\"italian\"],\"andrea\":[\"italian\"],\"anello\":[\"italian\"],\"angelo\":[\"italian\"],\"angolare\":[\"italian\"],\"angusto\":[\"italian\"],\"anima\":[\"italian\"],\"annegare\":[\"italian\"],\"annidato\":[\"italian\"],\"anno\":[\"italian\"],\"annuncio\":[\"italian\"],\"anonimo\":[\"italian\"],\"anticipo\":[\"italian\"],\"anzi\":[\"italian\"],\"apatico\":[\"italian\"],\"apertura\":[\"italian\"],\"apode\":[\"italian\"],\"apparire\":[\"italian\"],\"appetito\":[\"italian\"],\"appoggio\":[\"italian\"],\"approdo\":[\"italian\"],\"appunto\":[\"italian\"],\"aprile\":[\"italian\"],\"arabica\":[\"italian\"],\"arachide\":[\"italian\"],\"aragosta\":[\"italian\"],\"araldica\":[\"italian\"],\"arancio\":[\"italian\"],\"aratura\":[\"italian\"],\"arazzo\":[\"italian\"],\"arbitro\":[\"italian\"],\"archivio\":[\"italian\"],\"ardito\":[\"italian\"],\"arenile\":[\"italian\"],\"argento\":[\"italian\"],\"argine\":[\"italian\"],\"arguto\":[\"italian\"],\"aria\":[\"italian\"],\"armonia\":[\"italian\"],\"arnese\":[\"italian\"],\"arredato\":[\"italian\"],\"arringa\":[\"italian\"],\"arrosto\":[\"italian\"],\"arsenico\":[\"italian\"],\"arso\":[\"italian\"],\"artefice\":[\"italian\"],\"arzillo\":[\"italian\"],\"asciutto\":[\"italian\"],\"ascolto\":[\"italian\"],\"asepsi\":[\"italian\"],\"asettico\":[\"italian\"],\"asfalto\":[\"italian\"],\"asino\":[\"italian\"],\"asola\":[\"italian\"],\"aspirato\":[\"italian\"],\"aspro\":[\"italian\"],\"assaggio\":[\"italian\"],\"asse\":[\"italian\"],\"assoluto\":[\"italian\"],\"assurdo\":[\"italian\"],\"asta\":[\"italian\"],\"astenuto\":[\"italian\"],\"astice\":[\"italian\"],\"astratto\":[\"italian\"],\"atavico\":[\"italian\"],\"ateismo\":[\"italian\"],\"atomico\":[\"italian\"],\"atono\":[\"italian\"],\"attesa\":[\"italian\"],\"attivare\":[\"italian\"],\"attorno\":[\"italian\"],\"attrito\":[\"italian\"],\"attuale\":[\"italian\"],\"ausilio\":[\"italian\"],\"austria\":[\"italian\"],\"autista\":[\"italian\"],\"autonomo\":[\"italian\"],\"autunno\":[\"italian\"],\"avanzato\":[\"italian\"],\"avere\":[\"italian\"],\"avvenire\":[\"italian\"],\"avviso\":[\"italian\"],\"avvolgere\":[\"italian\"],\"azione\":[\"italian\"],\"azoto\":[\"italian\"],\"azzimo\":[\"italian\"],\"azzurro\":[\"italian\"],\"babele\":[\"italian\"],\"baccano\":[\"italian\"],\"bacino\":[\"italian\"],\"baco\":[\"italian\"],\"badessa\":[\"italian\"],\"badilata\":[\"italian\"],\"bagnato\":[\"italian\"],\"baita\":[\"italian\"],\"balcone\":[\"italian\"],\"baldo\":[\"italian\"],\"balena\":[\"italian\"],\"ballata\":[\"italian\"],\"balzano\":[\"italian\"],\"bambino\":[\"italian\"],\"bandire\":[\"italian\"],\"baraonda\":[\"italian\"],\"barbaro\":[\"italian\"],\"barca\":[\"italian\"],\"baritono\":[\"italian\"],\"barlume\":[\"italian\"],\"barocco\":[\"italian\"],\"basilico\":[\"italian\"],\"basso\":[\"italian\"],\"batosta\":[\"italian\"],\"battuto\":[\"italian\"],\"baule\":[\"italian\"],\"bava\":[\"italian\"],\"bavosa\":[\"italian\"],\"becco\":[\"italian\"],\"beffa\":[\"italian\"],\"belgio\":[\"italian\"],\"belva\":[\"italian\"],\"benda\":[\"italian\"],\"benevole\":[\"italian\"],\"benigno\":[\"italian\"],\"benzina\":[\"italian\"],\"bere\":[\"italian\"],\"berlina\":[\"italian\"],\"beta\":[\"italian\"],\"bibita\":[\"italian\"],\"bici\":[\"italian\"],\"bidone\":[\"italian\"],\"bifido\":[\"italian\"],\"biga\":[\"italian\"],\"bilancia\":[\"italian\"],\"bimbo\":[\"italian\"],\"binocolo\":[\"italian\"],\"biologo\":[\"italian\"],\"bipede\":[\"italian\"],\"bipolare\":[\"italian\"],\"birbante\":[\"italian\"],\"birra\":[\"italian\"],\"biscotto\":[\"italian\"],\"bisesto\":[\"italian\"],\"bisnonno\":[\"italian\"],\"bisonte\":[\"italian\"],\"bisturi\":[\"italian\"],\"bizzarro\":[\"italian\"],\"blando\":[\"italian\"],\"blatta\":[\"italian\"],\"bollito\":[\"italian\"],\"bonifico\":[\"italian\"],\"bordo\":[\"italian\"],\"bosco\":[\"italian\"],\"botanico\":[\"italian\"],\"bottino\":[\"italian\"],\"bozzolo\":[\"italian\"],\"braccio\":[\"italian\"],\"bradipo\":[\"italian\"],\"brama\":[\"italian\"],\"branca\":[\"italian\"],\"bravura\":[\"italian\"],\"bretella\":[\"italian\"],\"brevetto\":[\"italian\"],\"brezza\":[\"italian\"],\"briglia\":[\"italian\"],\"brillante\":[\"italian\"],\"brindare\":[\"italian\"],\"broccolo\":[\"italian\"],\"brodo\":[\"italian\"],\"bronzina\":[\"italian\"],\"brullo\":[\"italian\"],\"bruno\":[\"italian\"],\"bubbone\":[\"italian\"],\"buca\":[\"italian\"],\"budino\":[\"italian\"],\"buffone\":[\"italian\"],\"buio\":[\"italian\"],\"bulbo\":[\"italian\"],\"buono\":[\"italian\"],\"burlone\":[\"italian\"],\"burrasca\":[\"italian\"],\"bussola\":[\"italian\"],\"busta\":[\"italian\"],\"cadetto\":[\"italian\"],\"caduco\":[\"italian\"],\"calamaro\":[\"italian\"],\"calcolo\":[\"italian\"],\"calesse\":[\"italian\"],\"calibro\":[\"italian\"],\"calmo\":[\"italian\"],\"caloria\":[\"italian\"],\"cambusa\":[\"italian\"],\"camerata\":[\"italian\"],\"camicia\":[\"italian\"],\"cammino\":[\"italian\"],\"camola\":[\"italian\"],\"campale\":[\"italian\"],\"canapa\":[\"italian\"],\"candela\":[\"italian\"],\"cane\":[\"italian\"],\"canino\":[\"italian\"],\"canotto\":[\"italian\"],\"cantina\":[\"italian\"],\"capace\":[\"italian\"],\"capello\":[\"italian\"],\"capitolo\":[\"italian\"],\"capogiro\":[\"italian\"],\"cappero\":[\"italian\"],\"capra\":[\"italian\"],\"capsula\":[\"italian\"],\"carapace\":[\"italian\"],\"carcassa\":[\"italian\"],\"cardo\":[\"italian\"],\"carisma\":[\"italian\"],\"carovana\":[\"italian\"],\"carretto\":[\"italian\"],\"cartolina\":[\"italian\"],\"casaccio\":[\"italian\"],\"cascata\":[\"italian\"],\"caserma\":[\"italian\"],\"caso\":[\"italian\"],\"cassone\":[\"italian\"],\"castello\":[\"italian\"],\"casuale\":[\"italian\"],\"catasta\":[\"italian\"],\"catena\":[\"italian\"],\"catrame\":[\"italian\"],\"cauto\":[\"italian\"],\"cavillo\":[\"italian\"],\"cedibile\":[\"italian\"],\"cedrata\":[\"italian\"],\"cefalo\":[\"italian\"],\"celebre\":[\"italian\"],\"cellulare\":[\"italian\"],\"cena\":[\"italian\"],\"cenone\":[\"italian\"],\"centesimo\":[\"italian\"],\"ceramica\":[\"italian\"],\"cercare\":[\"italian\"],\"certo\":[\"italian\"],\"cerume\":[\"italian\"],\"cervello\":[\"italian\"],\"cesoia\":[\"italian\"],\"cespo\":[\"italian\"],\"ceto\":[\"italian\"],\"chela\":[\"italian\"],\"chiaro\":[\"italian\"],\"chicca\":[\"italian\"],\"chiedere\":[\"italian\"],\"chimera\":[\"italian\"],\"china\":[\"italian\"],\"chirurgo\":[\"italian\"],\"chitarra\":[\"italian\"],\"ciao\":[\"italian\"],\"ciclismo\":[\"italian\"],\"cifrare\":[\"italian\"],\"cigno\":[\"italian\"],\"cilindro\":[\"italian\"],\"ciottolo\":[\"italian\"],\"circa\":[\"italian\"],\"cirrosi\":[\"italian\"],\"citrico\":[\"italian\"],\"cittadino\":[\"italian\"],\"ciuffo\":[\"italian\"],\"civetta\":[\"italian\"],\"civile\":[\"italian\"],\"classico\":[\"italian\"],\"clinica\":[\"italian\"],\"cloro\":[\"italian\"],\"cocco\":[\"italian\"],\"codardo\":[\"italian\"],\"codice\":[\"italian\"],\"coerente\":[\"italian\"],\"cognome\":[\"italian\"],\"collare\":[\"italian\"],\"colmato\":[\"italian\"],\"colore\":[\"italian\"],\"colposo\":[\"italian\"],\"coltivato\":[\"italian\"],\"colza\":[\"italian\"],\"coma\":[\"italian\"],\"cometa\":[\"italian\"],\"commando\":[\"italian\"],\"comodo\":[\"italian\"],\"computer\":[\"italian\"],\"comune\":[\"italian\"],\"conciso\":[\"italian\"],\"condurre\":[\"italian\"],\"conferma\":[\"italian\"],\"congelare\":[\"italian\"],\"coniuge\":[\"italian\"],\"connesso\":[\"italian\"],\"conoscere\":[\"italian\"],\"consumo\":[\"italian\"],\"continuo\":[\"italian\"],\"convegno\":[\"italian\"],\"coperto\":[\"italian\"],\"copione\":[\"italian\"],\"coppia\":[\"italian\"],\"copricapo\":[\"italian\"],\"corazza\":[\"italian\"],\"cordata\":[\"italian\"],\"coricato\":[\"italian\"],\"cornice\":[\"italian\"],\"corolla\":[\"italian\"],\"corpo\":[\"italian\"],\"corredo\":[\"italian\"],\"corsia\":[\"italian\"],\"cortese\":[\"italian\"],\"cosmico\":[\"italian\"],\"costante\":[\"italian\"],\"cottura\":[\"italian\"],\"covato\":[\"italian\"],\"cratere\":[\"italian\"],\"cravatta\":[\"italian\"],\"creato\":[\"italian\"],\"credere\":[\"italian\"],\"cremoso\":[\"italian\"],\"crescita\":[\"italian\"],\"creta\":[\"italian\"],\"criceto\":[\"italian\"],\"crinale\":[\"italian\"],\"crisi\":[\"italian\"],\"critico\":[\"italian\"],\"croce\":[\"italian\"],\"cronaca\":[\"italian\"],\"crostata\":[\"italian\"],\"cruciale\":[\"italian\"],\"crusca\":[\"italian\"],\"cucire\":[\"italian\"],\"cuculo\":[\"italian\"],\"cugino\":[\"italian\"],\"cullato\":[\"italian\"],\"cupola\":[\"italian\"],\"curatore\":[\"italian\"],\"cursore\":[\"italian\"],\"curvo\":[\"italian\"],\"cuscino\":[\"italian\"],\"custode\":[\"italian\"],\"dado\":[\"italian\"],\"daino\":[\"italian\"],\"dalmata\":[\"italian\"],\"damerino\":[\"italian\"],\"daniela\":[\"italian\"],\"dannoso\":[\"italian\"],\"danzare\":[\"italian\"],\"datato\":[\"italian\"],\"davanti\":[\"italian\"],\"davvero\":[\"italian\"],\"debutto\":[\"italian\"],\"decennio\":[\"italian\"],\"deciso\":[\"italian\"],\"declino\":[\"italian\"],\"decollo\":[\"italian\"],\"decreto\":[\"italian\"],\"dedicato\":[\"italian\"],\"definito\":[\"italian\"],\"deforme\":[\"italian\"],\"degno\":[\"italian\"],\"delegare\":[\"italian\"],\"delfino\":[\"italian\"],\"delirio\":[\"italian\"],\"delta\":[\"italian\"],\"demenza\":[\"italian\"],\"denotato\":[\"italian\"],\"dentro\":[\"italian\"],\"deposito\":[\"italian\"],\"derapata\":[\"italian\"],\"derivare\":[\"italian\"],\"deroga\":[\"italian\"],\"descritto\":[\"italian\"],\"deserto\":[\"italian\"],\"desiderio\":[\"italian\"],\"desumere\":[\"italian\"],\"detersivo\":[\"italian\"],\"devoto\":[\"italian\"],\"diametro\":[\"italian\"],\"dicembre\":[\"italian\"],\"diedro\":[\"italian\"],\"difeso\":[\"italian\"],\"diffuso\":[\"italian\"],\"digerire\":[\"italian\"],\"digitale\":[\"italian\"],\"diluvio\":[\"italian\"],\"dinamico\":[\"italian\"],\"dinnanzi\":[\"italian\"],\"dipinto\":[\"italian\"],\"diploma\":[\"italian\"],\"dipolo\":[\"italian\"],\"diradare\":[\"italian\"],\"dire\":[\"italian\"],\"dirotto\":[\"italian\"],\"dirupo\":[\"italian\"],\"disagio\":[\"italian\"],\"discreto\":[\"italian\"],\"disfare\":[\"italian\"],\"disgelo\":[\"italian\"],\"disposto\":[\"italian\"],\"distanza\":[\"italian\"],\"disumano\":[\"italian\"],\"dito\":[\"italian\"],\"divano\":[\"italian\"],\"divelto\":[\"italian\"],\"dividere\":[\"italian\"],\"divorato\":[\"italian\"],\"doblone\":[\"italian\"],\"docente\":[\"italian\"],\"doganale\":[\"italian\"],\"dogma\":[\"italian\"],\"dolce\":[\"italian\"],\"domato\":[\"italian\"],\"domenica\":[\"italian\"],\"dominare\":[\"italian\"],\"dondolo\":[\"italian\"],\"dono\":[\"italian\"],\"dormire\":[\"italian\"],\"dote\":[\"italian\"],\"dottore\":[\"italian\"],\"dovuto\":[\"italian\"],\"dozzina\":[\"italian\"],\"drago\":[\"italian\"],\"druido\":[\"italian\"],\"dubbio\":[\"italian\"],\"dubitare\":[\"italian\"],\"ducale\":[\"italian\"],\"duna\":[\"italian\"],\"duomo\":[\"italian\"],\"duplice\":[\"italian\"],\"duraturo\":[\"italian\"],\"ebano\":[\"italian\"],\"eccesso\":[\"italian\"],\"ecco\":[\"italian\"],\"eclissi\":[\"italian\"],\"economia\":[\"italian\"],\"edera\":[\"italian\"],\"edicola\":[\"italian\"],\"edile\":[\"italian\"],\"editoria\":[\"italian\"],\"educare\":[\"italian\"],\"egemonia\":[\"italian\"],\"egli\":[\"italian\"],\"egoismo\":[\"italian\"],\"egregio\":[\"italian\"],\"elaborato\":[\"italian\"],\"elargire\":[\"italian\"],\"elegante\":[\"italian\"],\"elencato\":[\"italian\"],\"eletto\":[\"italian\"],\"elevare\":[\"italian\"],\"elfico\":[\"italian\"],\"elica\":[\"italian\"],\"elmo\":[\"italian\"],\"elsa\":[\"italian\"],\"eluso\":[\"italian\"],\"emanato\":[\"italian\"],\"emblema\":[\"italian\"],\"emesso\":[\"italian\"],\"emiro\":[\"italian\"],\"emotivo\":[\"italian\"],\"emozione\":[\"italian\"],\"empirico\":[\"italian\"],\"emulo\":[\"italian\"],\"endemico\":[\"italian\"],\"enduro\":[\"italian\"],\"energia\":[\"italian\"],\"enfasi\":[\"italian\"],\"enoteca\":[\"italian\"],\"entrare\":[\"italian\"],\"enzima\":[\"italian\"],\"epatite\":[\"italian\"],\"epilogo\":[\"italian\"],\"episodio\":[\"italian\"],\"epocale\":[\"italian\"],\"eppure\":[\"italian\"],\"equatore\":[\"italian\"],\"erario\":[\"italian\"],\"erba\":[\"italian\"],\"erboso\":[\"italian\"],\"erede\":[\"italian\"],\"eremita\":[\"italian\"],\"erigere\":[\"italian\"],\"ermetico\":[\"italian\"],\"eroe\":[\"italian\"],\"erosivo\":[\"italian\"],\"errante\":[\"italian\"],\"esagono\":[\"italian\"],\"esame\":[\"italian\"],\"esanime\":[\"italian\"],\"esaudire\":[\"italian\"],\"esca\":[\"italian\"],\"esempio\":[\"italian\"],\"esercito\":[\"italian\"],\"esibito\":[\"italian\"],\"esigente\":[\"italian\"],\"esistere\":[\"italian\"],\"esito\":[\"italian\"],\"esofago\":[\"italian\"],\"esortato\":[\"italian\"],\"esoso\":[\"italian\"],\"espanso\":[\"italian\"],\"espresso\":[\"italian\"],\"essenza\":[\"italian\"],\"esso\":[\"italian\"],\"esteso\":[\"italian\"],\"estimare\":[\"italian\"],\"estonia\":[\"italian\"],\"estroso\":[\"italian\"],\"esultare\":[\"italian\"],\"etilico\":[\"italian\"],\"etnico\":[\"italian\"],\"etrusco\":[\"italian\"],\"etto\":[\"italian\"],\"euclideo\":[\"italian\"],\"europa\":[\"italian\"],\"evaso\":[\"italian\"],\"evidenza\":[\"italian\"],\"evitato\":[\"italian\"],\"evoluto\":[\"italian\"],\"evviva\":[\"italian\"],\"fabbrica\":[\"italian\"],\"faccenda\":[\"italian\"],\"fachiro\":[\"italian\"],\"falco\":[\"italian\"],\"famiglia\":[\"italian\"],\"fanale\":[\"italian\"],\"fanfara\":[\"italian\"],\"fango\":[\"italian\"],\"fantasma\":[\"italian\"],\"fare\":[\"italian\"],\"farfalla\":[\"italian\"],\"farinoso\":[\"italian\"],\"farmaco\":[\"italian\"],\"fascia\":[\"italian\"],\"fastoso\":[\"italian\"],\"fasullo\":[\"italian\"],\"faticare\":[\"italian\"],\"fato\":[\"italian\"],\"favoloso\":[\"italian\"],\"febbre\":[\"italian\"],\"fecola\":[\"italian\"],\"fede\":[\"italian\"],\"fegato\":[\"italian\"],\"felpa\":[\"italian\"],\"feltro\":[\"italian\"],\"femmina\":[\"italian\"],\"fendere\":[\"italian\"],\"fenomeno\":[\"italian\"],\"fermento\":[\"italian\"],\"ferro\":[\"italian\"],\"fertile\":[\"italian\"],\"fessura\":[\"italian\"],\"festivo\":[\"italian\"],\"fetta\":[\"italian\"],\"feudo\":[\"italian\"],\"fiaba\":[\"italian\"],\"fiducia\":[\"italian\"],\"fifa\":[\"italian\"],\"figurato\":[\"italian\"],\"filo\":[\"italian\",\"turkish\"],\"finanza\":[\"italian\"],\"finestra\":[\"italian\"],\"finire\":[\"italian\"],\"fiore\":[\"italian\"],\"fiscale\":[\"italian\"],\"fisico\":[\"italian\"],\"fiume\":[\"italian\"],\"flacone\":[\"italian\"],\"flamenco\":[\"italian\"],\"flebo\":[\"italian\"],\"flemma\":[\"italian\"],\"florido\":[\"italian\"],\"fluente\":[\"italian\"],\"fluoro\":[\"italian\"],\"fobico\":[\"italian\"],\"focaccia\":[\"italian\"],\"focoso\":[\"italian\"],\"foderato\":[\"italian\"],\"foglio\":[\"italian\"],\"folata\":[\"italian\"],\"folclore\":[\"italian\"],\"folgore\":[\"italian\"],\"fondente\":[\"italian\"],\"fonetico\":[\"italian\"],\"fonia\":[\"italian\"],\"fontana\":[\"italian\"],\"forbito\":[\"italian\"],\"forchetta\":[\"italian\"],\"foresta\":[\"italian\"],\"formica\":[\"italian\"],\"fornaio\":[\"italian\"],\"foro\":[\"italian\"],\"fortezza\":[\"italian\"],\"forzare\":[\"italian\"],\"fosfato\":[\"italian\"],\"fosso\":[\"italian\"],\"fracasso\":[\"italian\"],\"frana\":[\"italian\"],\"frassino\":[\"italian\"],\"fratello\":[\"italian\"],\"freccetta\":[\"italian\"],\"frenata\":[\"italian\"],\"fresco\":[\"italian\"],\"frigo\":[\"italian\"],\"frollino\":[\"italian\"],\"fronde\":[\"italian\"],\"frugale\":[\"italian\"],\"frutta\":[\"italian\"],\"fucilata\":[\"italian\"],\"fucsia\":[\"italian\"],\"fuggente\":[\"italian\"],\"fulmine\":[\"italian\"],\"fulvo\":[\"italian\"],\"fumante\":[\"italian\"],\"fumetto\":[\"italian\"],\"fumoso\":[\"italian\"],\"fune\":[\"italian\"],\"funzione\":[\"italian\"],\"fuoco\":[\"italian\"],\"furbo\":[\"italian\"],\"furgone\":[\"italian\"],\"furore\":[\"italian\"],\"fuso\":[\"italian\"],\"futile\":[\"italian\"],\"gabbiano\":[\"italian\"],\"gaffe\":[\"italian\"],\"galateo\":[\"italian\"],\"gallina\":[\"italian\"],\"galoppo\":[\"italian\"],\"gambero\":[\"italian\"],\"gamma\":[\"italian\"],\"garanzia\":[\"italian\"],\"garbo\":[\"italian\"],\"garofano\":[\"italian\"],\"garzone\":[\"italian\"],\"gasdotto\":[\"italian\"],\"gasolio\":[\"italian\"],\"gastrico\":[\"italian\"],\"gatto\":[\"italian\"],\"gaudio\":[\"italian\"],\"gazebo\":[\"italian\"],\"gazzella\":[\"italian\"],\"geco\":[\"italian\"],\"gelatina\":[\"italian\"],\"gelso\":[\"italian\"],\"gemello\":[\"italian\"],\"gemmato\":[\"italian\"],\"gene\":[\"italian\"],\"genitore\":[\"italian\"],\"gennaio\":[\"italian\"],\"genotipo\":[\"italian\"],\"gergo\":[\"italian\"],\"ghepardo\":[\"italian\"],\"ghiaccio\":[\"italian\"],\"ghisa\":[\"italian\"],\"giallo\":[\"italian\"],\"gilda\":[\"italian\"],\"ginepro\":[\"italian\"],\"giocare\":[\"italian\"],\"gioiello\":[\"italian\"],\"giorno\":[\"italian\"],\"giove\":[\"italian\"],\"girato\":[\"italian\"],\"girone\":[\"italian\"],\"gittata\":[\"italian\"],\"giudizio\":[\"italian\"],\"giurato\":[\"italian\"],\"giusto\":[\"italian\"],\"globulo\":[\"italian\"],\"glutine\":[\"italian\"],\"gnomo\":[\"italian\"],\"gobba\":[\"italian\"],\"golf\":[\"italian\"],\"gomito\":[\"italian\"],\"gommone\":[\"italian\"],\"gonfio\":[\"italian\"],\"gonna\":[\"italian\"],\"governo\":[\"italian\"],\"gracile\":[\"italian\"],\"grado\":[\"italian\"],\"grafico\":[\"italian\"],\"grammo\":[\"italian\"],\"grande\":[\"italian\"],\"grattare\":[\"italian\"],\"gravoso\":[\"italian\"],\"grazia\":[\"italian\"],\"greca\":[\"italian\"],\"gregge\":[\"italian\"],\"grifone\":[\"italian\"],\"grigio\":[\"italian\"],\"grinza\":[\"italian\"],\"grotta\":[\"italian\"],\"gruppo\":[\"italian\"],\"guadagno\":[\"italian\"],\"guaio\":[\"italian\"],\"guanto\":[\"italian\"],\"guardare\":[\"italian\"],\"gufo\":[\"italian\"],\"guidare\":[\"italian\"],\"ibernato\":[\"italian\"],\"icona\":[\"italian\"],\"identico\":[\"italian\"],\"idillio\":[\"italian\"],\"idolo\":[\"italian\"],\"idra\":[\"italian\"],\"idrico\":[\"italian\"],\"idrogeno\":[\"italian\"],\"igiene\":[\"italian\"],\"ignaro\":[\"italian\"],\"ignorato\":[\"italian\"],\"ilare\":[\"italian\"],\"illeso\":[\"italian\"],\"illogico\":[\"italian\"],\"illudere\":[\"italian\"],\"imballo\":[\"italian\"],\"imbevuto\":[\"italian\"],\"imbocco\":[\"italian\"],\"imbuto\":[\"italian\"],\"immane\":[\"italian\"],\"immerso\":[\"italian\"],\"immolato\":[\"italian\"],\"impacco\":[\"italian\"],\"impeto\":[\"italian\"],\"impiego\":[\"italian\"],\"importo\":[\"italian\"],\"impronta\":[\"italian\"],\"inalare\":[\"italian\"],\"inarcare\":[\"italian\"],\"inattivo\":[\"italian\"],\"incanto\":[\"italian\"],\"incendio\":[\"italian\"],\"inchino\":[\"italian\"],\"incisivo\":[\"italian\"],\"incluso\":[\"italian\"],\"incontro\":[\"italian\"],\"incrocio\":[\"italian\"],\"incubo\":[\"italian\"],\"indagine\":[\"italian\"],\"india\":[\"italian\"],\"indole\":[\"italian\"],\"inedito\":[\"italian\"],\"infatti\":[\"italian\"],\"infilare\":[\"italian\"],\"inflitto\":[\"italian\"],\"ingaggio\":[\"italian\"],\"ingegno\":[\"italian\"],\"inglese\":[\"italian\"],\"ingordo\":[\"italian\"],\"ingrosso\":[\"italian\"],\"innesco\":[\"italian\"],\"inodore\":[\"italian\"],\"inoltrare\":[\"italian\"],\"inondato\":[\"italian\"],\"insano\":[\"italian\"],\"insetto\":[\"italian\"],\"insieme\":[\"italian\"],\"insonnia\":[\"italian\"],\"insulina\":[\"italian\"],\"intasato\":[\"italian\"],\"intero\":[\"italian\"],\"intonaco\":[\"italian\"],\"intuito\":[\"italian\"],\"inumidire\":[\"italian\"],\"invalido\":[\"italian\"],\"invece\":[\"italian\"],\"invito\":[\"italian\"],\"iperbole\":[\"italian\"],\"ipnotico\":[\"italian\"],\"ipotesi\":[\"italian\"],\"ippica\":[\"italian\"],\"iride\":[\"italian\"],\"irlanda\":[\"italian\"],\"ironico\":[\"italian\"],\"irrigato\":[\"italian\"],\"irrorare\":[\"italian\"],\"isolato\":[\"italian\"],\"isotopo\":[\"italian\"],\"isterico\":[\"italian\"],\"istituto\":[\"italian\"],\"istrice\":[\"italian\"],\"italia\":[\"italian\"],\"iterare\":[\"italian\"],\"labbro\":[\"italian\"],\"labirinto\":[\"italian\"],\"lacca\":[\"italian\"],\"lacerato\":[\"italian\"],\"lacrima\":[\"italian\"],\"lacuna\":[\"italian\"],\"laddove\":[\"italian\"],\"lago\":[\"italian\"],\"lampo\":[\"italian\"],\"lancetta\":[\"italian\"],\"lanterna\":[\"italian\"],\"lardoso\":[\"italian\"],\"larga\":[\"italian\"],\"laringe\":[\"italian\"],\"lastra\":[\"italian\"],\"latenza\":[\"italian\"],\"latino\":[\"italian\"],\"lattuga\":[\"italian\"],\"lavagna\":[\"italian\"],\"lavoro\":[\"italian\"],\"legale\":[\"italian\"],\"leggero\":[\"italian\"],\"lembo\":[\"italian\"],\"lentezza\":[\"italian\"],\"lenza\":[\"italian\"],\"leone\":[\"italian\"],\"lepre\":[\"italian\"],\"lesivo\":[\"italian\"],\"lessato\":[\"italian\"],\"lesto\":[\"italian\"],\"letterale\":[\"italian\"],\"leva\":[\"italian\"],\"levigato\":[\"italian\"],\"libero\":[\"italian\"],\"lido\":[\"italian\"],\"lievito\":[\"italian\"],\"lilla\":[\"italian\"],\"limatura\":[\"italian\"],\"limitare\":[\"italian\"],\"limpido\":[\"italian\"],\"lineare\":[\"italian\"],\"lingua\":[\"italian\"],\"liquido\":[\"italian\"],\"lira\":[\"italian\"],\"lirica\":[\"italian\"],\"lisca\":[\"italian\"],\"lite\":[\"italian\"],\"litigio\":[\"italian\"],\"livrea\":[\"italian\"],\"locanda\":[\"italian\"],\"lode\":[\"italian\"],\"logica\":[\"italian\"],\"lombare\":[\"italian\"],\"londra\":[\"italian\"],\"longevo\":[\"italian\"],\"loquace\":[\"italian\"],\"lorenzo\":[\"italian\"],\"loto\":[\"italian\"],\"lotteria\":[\"italian\"],\"luce\":[\"italian\"],\"lucidato\":[\"italian\"],\"lumaca\":[\"italian\"],\"luminoso\":[\"italian\"],\"lungo\":[\"italian\"],\"lupo\":[\"italian\"],\"luppolo\":[\"italian\"],\"lusinga\":[\"italian\"],\"lusso\":[\"italian\"],\"lutto\":[\"italian\"],\"macabro\":[\"italian\"],\"macchina\":[\"italian\"],\"macero\":[\"italian\"],\"macinato\":[\"italian\"],\"madama\":[\"italian\"],\"magico\":[\"italian\"],\"maglia\":[\"italian\"],\"magnete\":[\"italian\"],\"magro\":[\"italian\"],\"maiolica\":[\"italian\"],\"malafede\":[\"italian\"],\"malgrado\":[\"italian\"],\"malinteso\":[\"italian\"],\"malsano\":[\"italian\"],\"malto\":[\"italian\"],\"malumore\":[\"italian\"],\"mana\":[\"italian\"],\"mancia\":[\"italian\"],\"mandorla\":[\"italian\"],\"mangiare\":[\"italian\"],\"manifesto\":[\"italian\"],\"mannaro\":[\"italian\"],\"manovra\":[\"italian\"],\"mansarda\":[\"italian\"],\"mantide\":[\"italian\"],\"manubrio\":[\"italian\"],\"mappa\":[\"italian\"],\"maratona\":[\"italian\"],\"marcire\":[\"italian\"],\"maretta\":[\"italian\"],\"marmo\":[\"italian\"],\"marsupio\":[\"italian\"],\"maschera\":[\"italian\"],\"massaia\":[\"italian\"],\"mastino\":[\"italian\"],\"materasso\":[\"italian\"],\"matricola\":[\"italian\"],\"mattone\":[\"italian\"],\"maturo\":[\"italian\"],\"mazurca\":[\"italian\"],\"meandro\":[\"italian\"],\"meccanico\":[\"italian\"],\"mecenate\":[\"italian\"],\"medesimo\":[\"italian\"],\"meditare\":[\"italian\"],\"mega\":[\"italian\"],\"melassa\":[\"italian\"],\"melis\":[\"italian\"],\"melodia\":[\"italian\"],\"meninge\":[\"italian\"],\"meno\":[\"italian\"],\"mensola\":[\"italian\"],\"mercurio\":[\"italian\"],\"merenda\":[\"italian\"],\"merlo\":[\"italian\"],\"meschino\":[\"italian\"],\"mese\":[\"italian\"],\"messere\":[\"italian\"],\"mestolo\":[\"italian\"],\"metallo\":[\"italian\"],\"metodo\":[\"italian\"],\"mettere\":[\"italian\"],\"miagolare\":[\"italian\"],\"mica\":[\"italian\"],\"micelio\":[\"italian\"],\"michele\":[\"italian\"],\"microbo\":[\"italian\"],\"midollo\":[\"italian\"],\"miele\":[\"italian\"],\"migliore\":[\"italian\"],\"milano\":[\"italian\"],\"milite\":[\"italian\"],\"mimosa\":[\"italian\"],\"minerale\":[\"italian\"],\"mini\":[\"italian\"],\"minore\":[\"italian\"],\"mirino\":[\"italian\"],\"mirtillo\":[\"italian\"],\"miscela\":[\"italian\"],\"missiva\":[\"italian\"],\"misto\":[\"italian\"],\"misurare\":[\"italian\"],\"mitezza\":[\"italian\"],\"mitigare\":[\"italian\"],\"mitra\":[\"italian\"],\"mittente\":[\"italian\"],\"mnemonico\":[\"italian\"],\"modello\":[\"italian\"],\"modifica\":[\"italian\"],\"modulo\":[\"italian\"],\"mogano\":[\"italian\"],\"mogio\":[\"italian\"],\"mole\":[\"italian\"],\"molosso\":[\"italian\"],\"monastero\":[\"italian\"],\"monco\":[\"italian\"],\"mondina\":[\"italian\"],\"monetario\":[\"italian\"],\"monile\":[\"italian\"],\"monotono\":[\"italian\"],\"monsone\":[\"italian\"],\"montato\":[\"italian\"],\"monviso\":[\"italian\"],\"mora\":[\"italian\"],\"mordere\":[\"italian\"],\"morsicato\":[\"italian\"],\"mostro\":[\"italian\"],\"motivato\":[\"italian\"],\"motosega\":[\"italian\"],\"motto\":[\"italian\"],\"movenza\":[\"italian\"],\"movimento\":[\"italian\"],\"mozzo\":[\"italian\"],\"mucca\":[\"italian\"],\"mucosa\":[\"italian\"],\"muffa\":[\"italian\"],\"mughetto\":[\"italian\"],\"mugnaio\":[\"italian\"],\"mulatto\":[\"italian\"],\"mulinello\":[\"italian\"],\"multiplo\":[\"italian\"],\"mummia\":[\"italian\"],\"munto\":[\"italian\"],\"muovere\":[\"italian\"],\"murale\":[\"italian\"],\"musa\":[\"italian\"],\"muscolo\":[\"italian\"],\"musica\":[\"italian\"],\"mutevole\":[\"italian\"],\"muto\":[\"italian\"],\"nababbo\":[\"italian\"],\"nafta\":[\"italian\"],\"nanometro\":[\"italian\"],\"narciso\":[\"italian\"],\"narice\":[\"italian\"],\"narrato\":[\"italian\"],\"nascere\":[\"italian\"],\"nastrare\":[\"italian\"],\"naturale\":[\"italian\"],\"nautica\":[\"italian\"],\"naviglio\":[\"italian\"],\"nebulosa\":[\"italian\"],\"necrosi\":[\"italian\"],\"negativo\":[\"italian\"],\"negozio\":[\"italian\"],\"nemmeno\":[\"italian\"],\"neofita\":[\"italian\"],\"neretto\":[\"italian\"],\"nervo\":[\"italian\"],\"nessuno\":[\"italian\"],\"nettuno\":[\"italian\"],\"neutrale\":[\"italian\"],\"neve\":[\"italian\"],\"nevrotico\":[\"italian\"],\"nicchia\":[\"italian\"],\"ninfa\":[\"italian\"],\"nitido\":[\"italian\"],\"nobile\":[\"italian\"],\"nocivo\":[\"italian\"],\"nodo\":[\"italian\"],\"nome\":[\"italian\"],\"nomina\":[\"italian\"],\"nordico\":[\"italian\"],\"normale\":[\"italian\"],\"norvegese\":[\"italian\"],\"nostrano\":[\"italian\"],\"notare\":[\"italian\"],\"notizia\":[\"italian\"],\"notturno\":[\"italian\"],\"novella\":[\"italian\"],\"nucleo\":[\"italian\"],\"nulla\":[\"italian\"],\"numero\":[\"italian\"],\"nuovo\":[\"italian\"],\"nutrire\":[\"italian\"],\"nuvola\":[\"italian\"],\"nuziale\":[\"italian\"],\"oasi\":[\"italian\"],\"obbedire\":[\"italian\"],\"obbligo\":[\"italian\"],\"obelisco\":[\"italian\"],\"oblio\":[\"italian\"],\"obolo\":[\"italian\"],\"obsoleto\":[\"italian\"],\"occasione\":[\"italian\"],\"occhio\":[\"italian\"],\"occidente\":[\"italian\"],\"occorrere\":[\"italian\"],\"occultare\":[\"italian\"],\"ocra\":[\"italian\"],\"oculato\":[\"italian\"],\"odierno\":[\"italian\"],\"odorare\":[\"italian\"],\"offerta\":[\"italian\"],\"offrire\":[\"italian\"],\"offuscato\":[\"italian\"],\"oggetto\":[\"italian\"],\"oggi\":[\"italian\"],\"ognuno\":[\"italian\"],\"olandese\":[\"italian\"],\"olfatto\":[\"italian\"],\"oliato\":[\"italian\"],\"oliva\":[\"italian\"],\"ologramma\":[\"italian\"],\"oltre\":[\"italian\"],\"omaggio\":[\"italian\"],\"ombelico\":[\"italian\"],\"ombra\":[\"italian\"],\"omega\":[\"italian\"],\"omissione\":[\"italian\"],\"ondoso\":[\"italian\"],\"onere\":[\"italian\"],\"onice\":[\"italian\"],\"onnivoro\":[\"italian\"],\"onorevole\":[\"italian\"],\"onta\":[\"italian\"],\"operato\":[\"italian\"],\"opinione\":[\"italian\"],\"opposto\":[\"italian\"],\"oracolo\":[\"italian\"],\"orafo\":[\"italian\"],\"ordine\":[\"italian\"],\"orecchino\":[\"italian\"],\"orefice\":[\"italian\"],\"orfano\":[\"italian\"],\"organico\":[\"italian\"],\"origine\":[\"italian\"],\"orizzonte\":[\"italian\"],\"orma\":[\"italian\"],\"ormeggio\":[\"italian\"],\"ornativo\":[\"italian\"],\"orologio\":[\"italian\"],\"orrendo\":[\"italian\"],\"orribile\":[\"italian\"],\"ortensia\":[\"italian\"],\"ortica\":[\"italian\"],\"orzata\":[\"italian\"],\"orzo\":[\"italian\"],\"osare\":[\"italian\"],\"oscurare\":[\"italian\"],\"osmosi\":[\"italian\"],\"ospedale\":[\"italian\"],\"ospite\":[\"italian\"],\"ossa\":[\"italian\"],\"ossidare\":[\"italian\"],\"ostacolo\":[\"italian\"],\"oste\":[\"italian\"],\"otite\":[\"italian\"],\"otre\":[\"italian\"],\"ottagono\":[\"italian\"],\"ottimo\":[\"italian\"],\"ottobre\":[\"italian\"],\"ovale\":[\"italian\"],\"ovest\":[\"italian\"],\"ovino\":[\"italian\"],\"oviparo\":[\"italian\"],\"ovocito\":[\"italian\"],\"ovunque\":[\"italian\"],\"ovviare\":[\"italian\"],\"ozio\":[\"italian\"],\"pacchetto\":[\"italian\"],\"pace\":[\"italian\"],\"pacifico\":[\"italian\"],\"padella\":[\"italian\"],\"padrone\":[\"italian\"],\"paese\":[\"italian\"],\"paga\":[\"italian\"],\"pagina\":[\"italian\"],\"palazzina\":[\"italian\"],\"palesare\":[\"italian\"],\"pallido\":[\"italian\"],\"palo\":[\"italian\"],\"palude\":[\"italian\"],\"pandoro\":[\"italian\"],\"pannello\":[\"italian\"],\"paolo\":[\"italian\"],\"paonazzo\":[\"italian\"],\"paprica\":[\"italian\"],\"parabola\":[\"italian\"],\"parcella\":[\"italian\"],\"parere\":[\"italian\"],\"pargolo\":[\"italian\"],\"pari\":[\"italian\"],\"parlato\":[\"italian\"],\"parola\":[\"italian\"],\"partire\":[\"italian\"],\"parvenza\":[\"italian\"],\"parziale\":[\"italian\"],\"passivo\":[\"italian\"],\"pasticca\":[\"italian\"],\"patacca\":[\"italian\"],\"patologia\":[\"italian\"],\"pattume\":[\"italian\"],\"pavone\":[\"italian\"],\"peccato\":[\"italian\"],\"pedalare\":[\"italian\"],\"pedonale\":[\"italian\"],\"peggio\":[\"italian\"],\"peloso\":[\"italian\"],\"penare\":[\"italian\"],\"pendice\":[\"italian\"],\"penisola\":[\"italian\"],\"pennuto\":[\"italian\"],\"penombra\":[\"italian\"],\"pensare\":[\"italian\"],\"pentola\":[\"italian\"],\"pepe\":[\"italian\"],\"pepita\":[\"italian\"],\"perbene\":[\"italian\"],\"percorso\":[\"italian\"],\"perdonato\":[\"italian\"],\"perforare\":[\"italian\"],\"pergamena\":[\"italian\"],\"periodo\":[\"italian\"],\"permesso\":[\"italian\"],\"perno\":[\"italian\"],\"perplesso\":[\"italian\"],\"persuaso\":[\"italian\"],\"pertugio\":[\"italian\"],\"pervaso\":[\"italian\"],\"pesatore\":[\"italian\"],\"pesista\":[\"italian\"],\"peso\":[\"italian\"],\"pestifero\":[\"italian\"],\"petalo\":[\"italian\"],\"pettine\":[\"italian\"],\"petulante\":[\"italian\"],\"pezzo\":[\"italian\"],\"piacere\":[\"italian\"],\"pianta\":[\"italian\"],\"piattino\":[\"italian\"],\"piccino\":[\"italian\"],\"picozza\":[\"italian\"],\"piega\":[\"italian\"],\"pietra\":[\"italian\"],\"piffero\":[\"italian\"],\"pigiama\":[\"italian\"],\"pigolio\":[\"italian\"],\"pigro\":[\"italian\"],\"pila\":[\"italian\"],\"pilifero\":[\"italian\"],\"pillola\":[\"italian\"],\"pilota\":[\"italian\"],\"pimpante\":[\"italian\"],\"pineta\":[\"italian\"],\"pinna\":[\"italian\"],\"pinolo\":[\"italian\"],\"pioggia\":[\"italian\"],\"piombo\":[\"italian\"],\"piramide\":[\"italian\"],\"piretico\":[\"italian\"],\"pirite\":[\"italian\"],\"pirolisi\":[\"italian\"],\"pitone\":[\"italian\"],\"pizzico\":[\"italian\"],\"placebo\":[\"italian\"],\"planare\":[\"italian\"],\"plasma\":[\"italian\"],\"platano\":[\"italian\"],\"plenario\":[\"italian\"],\"pochezza\":[\"italian\"],\"poderoso\":[\"italian\"],\"podismo\":[\"italian\"],\"poesia\":[\"italian\"],\"poggiare\":[\"italian\"],\"polenta\":[\"italian\"],\"poligono\":[\"italian\"],\"pollice\":[\"italian\"],\"polmonite\":[\"italian\"],\"polpetta\":[\"italian\"],\"polso\":[\"italian\"],\"poltrona\":[\"italian\"],\"polvere\":[\"italian\"],\"pomice\":[\"italian\"],\"pomodoro\":[\"italian\"],\"ponte\":[\"italian\"],\"popoloso\":[\"italian\"],\"porfido\":[\"italian\"],\"poroso\":[\"italian\"],\"porpora\":[\"italian\"],\"porre\":[\"italian\"],\"portata\":[\"italian\"],\"posa\":[\"italian\",\"turkish\"],\"positivo\":[\"italian\"],\"possesso\":[\"italian\"],\"postulato\":[\"italian\"],\"potassio\":[\"italian\"],\"potere\":[\"italian\"],\"pranzo\":[\"italian\"],\"prassi\":[\"italian\"],\"pratica\":[\"italian\"],\"precluso\":[\"italian\"],\"predica\":[\"italian\"],\"prefisso\":[\"italian\"],\"pregiato\":[\"italian\"],\"prelievo\":[\"italian\"],\"premere\":[\"italian\"],\"prenotare\":[\"italian\"],\"preparato\":[\"italian\"],\"presenza\":[\"italian\"],\"pretesto\":[\"italian\"],\"prevalso\":[\"italian\"],\"prima\":[\"italian\"],\"principe\":[\"italian\"],\"privato\":[\"italian\"],\"problema\":[\"italian\"],\"procura\":[\"italian\"],\"produrre\":[\"italian\"],\"profumo\":[\"italian\"],\"progetto\":[\"italian\"],\"prolunga\":[\"italian\"],\"promessa\":[\"italian\"],\"pronome\":[\"italian\"],\"proposta\":[\"italian\"],\"proroga\":[\"italian\"],\"proteso\":[\"italian\"],\"prova\":[\"italian\",\"turkish\"],\"prudente\":[\"italian\"],\"prugna\":[\"italian\"],\"prurito\":[\"italian\"],\"psiche\":[\"italian\"],\"pubblico\":[\"italian\"],\"pudica\":[\"italian\"],\"pugilato\":[\"italian\"],\"pugno\":[\"italian\"],\"pulce\":[\"italian\"],\"pulito\":[\"italian\"],\"pulsante\":[\"italian\"],\"puntare\":[\"italian\"],\"pupazzo\":[\"italian\"],\"pupilla\":[\"italian\"],\"puro\":[\"italian\"],\"quadro\":[\"italian\"],\"qualcosa\":[\"italian\"],\"quasi\":[\"italian\"],\"querela\":[\"italian\"],\"quota\":[\"italian\"],\"raccolto\":[\"italian\"],\"raddoppio\":[\"italian\"],\"radicale\":[\"italian\"],\"radunato\":[\"italian\"],\"raffica\":[\"italian\"],\"ragazzo\":[\"italian\"],\"ragione\":[\"italian\"],\"ragno\":[\"italian\"],\"ramarro\":[\"italian\"],\"ramingo\":[\"italian\"],\"ramo\":[\"italian\"],\"randagio\":[\"italian\"],\"rantolare\":[\"italian\"],\"rapato\":[\"italian\"],\"rapina\":[\"italian\"],\"rappreso\":[\"italian\"],\"rasatura\":[\"italian\"],\"raschiato\":[\"italian\"],\"rasente\":[\"italian\"],\"rassegna\":[\"italian\"],\"rastrello\":[\"italian\"],\"rata\":[\"italian\"],\"ravveduto\":[\"italian\"],\"reale\":[\"italian\"],\"recepire\":[\"italian\"],\"recinto\":[\"italian\"],\"recluta\":[\"italian\"],\"recondito\":[\"italian\"],\"recupero\":[\"italian\"],\"reddito\":[\"italian\"],\"redimere\":[\"italian\"],\"regalato\":[\"italian\"],\"registro\":[\"italian\"],\"regola\":[\"italian\"],\"regresso\":[\"italian\"],\"relazione\":[\"italian\"],\"remare\":[\"italian\"],\"remoto\":[\"italian\"],\"renna\":[\"italian\"],\"replica\":[\"italian\"],\"reprimere\":[\"italian\"],\"reputare\":[\"italian\"],\"resa\":[\"italian\"],\"residente\":[\"italian\"],\"responso\":[\"italian\"],\"restauro\":[\"italian\"],\"rete\":[\"italian\"],\"retina\":[\"italian\"],\"retorica\":[\"italian\"],\"rettifica\":[\"italian\"],\"revocato\":[\"italian\"],\"riassunto\":[\"italian\"],\"ribadire\":[\"italian\"],\"ribelle\":[\"italian\"],\"ribrezzo\":[\"italian\"],\"ricarica\":[\"italian\"],\"ricco\":[\"italian\"],\"ricevere\":[\"italian\"],\"riciclato\":[\"italian\"],\"ricordo\":[\"italian\"],\"ricreduto\":[\"italian\"],\"ridicolo\":[\"italian\"],\"ridurre\":[\"italian\"],\"rifasare\":[\"italian\"],\"riflesso\":[\"italian\"],\"riforma\":[\"italian\"],\"rifugio\":[\"italian\"],\"rigare\":[\"italian\"],\"rigettato\":[\"italian\"],\"righello\":[\"italian\"],\"rilassato\":[\"italian\"],\"rilevato\":[\"italian\"],\"rimanere\":[\"italian\"],\"rimbalzo\":[\"italian\"],\"rimedio\":[\"italian\"],\"rimorchio\":[\"italian\"],\"rinascita\":[\"italian\"],\"rincaro\":[\"italian\"],\"rinforzo\":[\"italian\"],\"rinnovo\":[\"italian\"],\"rinomato\":[\"italian\"],\"rinsavito\":[\"italian\"],\"rintocco\":[\"italian\"],\"rinuncia\":[\"italian\"],\"rinvenire\":[\"italian\"],\"riparato\":[\"italian\"],\"ripetuto\":[\"italian\"],\"ripieno\":[\"italian\"],\"riportare\":[\"italian\"],\"ripresa\":[\"italian\"],\"ripulire\":[\"italian\"],\"risata\":[\"italian\"],\"rischio\":[\"italian\"],\"riserva\":[\"italian\"],\"risibile\":[\"italian\"],\"riso\":[\"italian\"],\"rispetto\":[\"italian\"],\"ristoro\":[\"italian\"],\"risultato\":[\"italian\"],\"risvolto\":[\"italian\"],\"ritardo\":[\"italian\"],\"ritegno\":[\"italian\"],\"ritmico\":[\"italian\"],\"ritrovo\":[\"italian\"],\"riunione\":[\"italian\"],\"riva\":[\"italian\"],\"riverso\":[\"italian\"],\"rivincita\":[\"italian\"],\"rivolto\":[\"italian\"],\"rizoma\":[\"italian\"],\"roba\":[\"italian\"],\"robotico\":[\"italian\"],\"robusto\":[\"italian\"],\"roccia\":[\"italian\"],\"roco\":[\"italian\"],\"rodaggio\":[\"italian\"],\"rodere\":[\"italian\"],\"roditore\":[\"italian\"],\"rogito\":[\"italian\"],\"rollio\":[\"italian\"],\"romantico\":[\"italian\"],\"rompere\":[\"italian\"],\"ronzio\":[\"italian\"],\"rosolare\":[\"italian\"],\"rospo\":[\"italian\"],\"rotante\":[\"italian\"],\"rotondo\":[\"italian\"],\"rotula\":[\"italian\"],\"rovescio\":[\"italian\"],\"rubizzo\":[\"italian\"],\"rubrica\":[\"italian\"],\"ruga\":[\"italian\"],\"rullino\":[\"italian\"],\"rumine\":[\"italian\"],\"rumoroso\":[\"italian\"],\"ruolo\":[\"italian\"],\"rupe\":[\"italian\"],\"russare\":[\"italian\"],\"rustico\":[\"italian\"],\"sabato\":[\"italian\"],\"sabbiare\":[\"italian\"],\"sabotato\":[\"italian\"],\"sagoma\":[\"italian\"],\"salasso\":[\"italian\"],\"saldatura\":[\"italian\"],\"salgemma\":[\"italian\"],\"salivare\":[\"italian\"],\"salmone\":[\"italian\"],\"salone\":[\"italian\"],\"saltare\":[\"italian\"],\"saluto\":[\"italian\"],\"salvo\":[\"italian\"],\"sapere\":[\"italian\"],\"sapido\":[\"italian\"],\"saporito\":[\"italian\"],\"saraceno\":[\"italian\"],\"sarcasmo\":[\"italian\"],\"sarto\":[\"italian\"],\"sassoso\":[\"italian\"],\"satellite\":[\"italian\"],\"satira\":[\"italian\"],\"satollo\":[\"italian\"],\"saturno\":[\"italian\"],\"savana\":[\"italian\"],\"savio\":[\"italian\"],\"saziato\":[\"italian\"],\"sbadiglio\":[\"italian\"],\"sbalzo\":[\"italian\"],\"sbancato\":[\"italian\"],\"sbarra\":[\"italian\"],\"sbattere\":[\"italian\"],\"sbavare\":[\"italian\"],\"sbendare\":[\"italian\"],\"sbirciare\":[\"italian\"],\"sbloccato\":[\"italian\"],\"sbocciato\":[\"italian\"],\"sbrinare\":[\"italian\"],\"sbruffone\":[\"italian\"],\"sbuffare\":[\"italian\"],\"scabroso\":[\"italian\"],\"scadenza\":[\"italian\"],\"scala\":[\"italian\"],\"scambiare\":[\"italian\"],\"scandalo\":[\"italian\"],\"scapola\":[\"italian\"],\"scarso\":[\"italian\"],\"scatenare\":[\"italian\"],\"scavato\":[\"italian\"],\"scelto\":[\"italian\"],\"scenico\":[\"italian\"],\"scettro\":[\"italian\"],\"scheda\":[\"italian\"],\"schiena\":[\"italian\"],\"sciarpa\":[\"italian\"],\"scienza\":[\"italian\"],\"scindere\":[\"italian\"],\"scippo\":[\"italian\"],\"sciroppo\":[\"italian\"],\"scivolo\":[\"italian\"],\"sclerare\":[\"italian\"],\"scodella\":[\"italian\"],\"scolpito\":[\"italian\"],\"scomparto\":[\"italian\"],\"sconforto\":[\"italian\"],\"scoprire\":[\"italian\"],\"scorta\":[\"italian\"],\"scossone\":[\"italian\"],\"scozzese\":[\"italian\"],\"scriba\":[\"italian\"],\"scrollare\":[\"italian\"],\"scrutinio\":[\"italian\"],\"scuderia\":[\"italian\"],\"scultore\":[\"italian\"],\"scuola\":[\"italian\"],\"scuro\":[\"italian\"],\"scusare\":[\"italian\"],\"sdebitare\":[\"italian\"],\"sdoganare\":[\"italian\"],\"seccatura\":[\"italian\"],\"secondo\":[\"italian\"],\"sedano\":[\"italian\"],\"seggiola\":[\"italian\"],\"segnalato\":[\"italian\"],\"segregato\":[\"italian\"],\"seguito\":[\"italian\"],\"selciato\":[\"italian\"],\"selettivo\":[\"italian\"],\"sella\":[\"italian\"],\"selvaggio\":[\"italian\"],\"semaforo\":[\"italian\"],\"sembrare\":[\"italian\"],\"seme\":[\"italian\"],\"seminato\":[\"italian\"],\"sempre\":[\"italian\"],\"senso\":[\"italian\"],\"sentire\":[\"italian\"],\"sepolto\":[\"italian\"],\"sequenza\":[\"italian\"],\"serata\":[\"italian\"],\"serbato\":[\"italian\"],\"sereno\":[\"italian\"],\"serio\":[\"italian\"],\"serpente\":[\"italian\"],\"serraglio\":[\"italian\"],\"servire\":[\"italian\"],\"sestina\":[\"italian\"],\"setola\":[\"italian\"],\"settimana\":[\"italian\"],\"sfacelo\":[\"italian\"],\"sfaldare\":[\"italian\"],\"sfamato\":[\"italian\"],\"sfarzoso\":[\"italian\"],\"sfaticato\":[\"italian\"],\"sfera\":[\"italian\"],\"sfida\":[\"italian\"],\"sfilato\":[\"italian\"],\"sfinge\":[\"italian\"],\"sfocato\":[\"italian\"],\"sfoderare\":[\"italian\"],\"sfogo\":[\"italian\"],\"sfoltire\":[\"italian\"],\"sforzato\":[\"italian\"],\"sfratto\":[\"italian\"],\"sfruttato\":[\"italian\"],\"sfuggito\":[\"italian\"],\"sfumare\":[\"italian\"],\"sfuso\":[\"italian\"],\"sgabello\":[\"italian\"],\"sgarbato\":[\"italian\"],\"sgonfiare\":[\"italian\"],\"sgorbio\":[\"italian\"],\"sgrassato\":[\"italian\"],\"sguardo\":[\"italian\"],\"sibilo\":[\"italian\"],\"siccome\":[\"italian\"],\"sierra\":[\"italian\"],\"sigla\":[\"italian\"],\"signore\":[\"italian\"],\"silenzio\":[\"italian\"],\"sillaba\":[\"italian\"],\"simbolo\":[\"italian\"],\"simpatico\":[\"italian\"],\"simulato\":[\"italian\"],\"sinfonia\":[\"italian\"],\"singolo\":[\"italian\"],\"sinistro\":[\"italian\"],\"sino\":[\"italian\"],\"sintesi\":[\"italian\"],\"sinusoide\":[\"italian\"],\"sipario\":[\"italian\"],\"sisma\":[\"italian\"],\"sistole\":[\"italian\"],\"situato\":[\"italian\"],\"slitta\":[\"italian\"],\"slogatura\":[\"italian\"],\"sloveno\":[\"italian\"],\"smarrito\":[\"italian\"],\"smemorato\":[\"italian\"],\"smentito\":[\"italian\"],\"smeraldo\":[\"italian\"],\"smilzo\":[\"italian\"],\"smontare\":[\"italian\"],\"smottato\":[\"italian\"],\"smussato\":[\"italian\"],\"snellire\":[\"italian\"],\"snervato\":[\"italian\"],\"snodo\":[\"italian\"],\"sobbalzo\":[\"italian\"],\"sobrio\":[\"italian\"],\"soccorso\":[\"italian\"],\"sociale\":[\"italian\"],\"sodale\":[\"italian\"],\"soffitto\":[\"italian\"],\"sogno\":[\"italian\"],\"soldato\":[\"italian\"],\"solenne\":[\"italian\"],\"solido\":[\"italian\"],\"sollazzo\":[\"italian\"],\"solo\":[\"italian\"],\"solubile\":[\"italian\"],\"solvente\":[\"italian\"],\"somatico\":[\"italian\"],\"somma\":[\"italian\"],\"sonda\":[\"italian\"],\"sonetto\":[\"italian\"],\"sonnifero\":[\"italian\"],\"sopire\":[\"italian\"],\"soppeso\":[\"italian\"],\"sopra\":[\"italian\"],\"sorgere\":[\"italian\"],\"sorpasso\":[\"italian\"],\"sorriso\":[\"italian\"],\"sorso\":[\"italian\"],\"sorteggio\":[\"italian\"],\"sorvolato\":[\"italian\"],\"sospiro\":[\"italian\"],\"sosta\":[\"italian\"],\"sottile\":[\"italian\"],\"spada\":[\"italian\"],\"spalla\":[\"italian\"],\"spargere\":[\"italian\"],\"spatola\":[\"italian\"],\"spavento\":[\"italian\"],\"spazzola\":[\"italian\"],\"specie\":[\"italian\"],\"spedire\":[\"italian\"],\"spegnere\":[\"italian\"],\"spelatura\":[\"italian\"],\"speranza\":[\"italian\"],\"spessore\":[\"italian\"],\"spettrale\":[\"italian\"],\"spezzato\":[\"italian\"],\"spia\":[\"italian\"],\"spigoloso\":[\"italian\"],\"spillato\":[\"italian\"],\"spinoso\":[\"italian\"],\"spirale\":[\"italian\"],\"splendido\":[\"italian\"],\"sportivo\":[\"italian\"],\"sposo\":[\"italian\"],\"spranga\":[\"italian\"],\"sprecare\":[\"italian\"],\"spronato\":[\"italian\"],\"spruzzo\":[\"italian\"],\"spuntino\":[\"italian\"],\"squillo\":[\"italian\"],\"sradicare\":[\"italian\"],\"srotolato\":[\"italian\"],\"stabile\":[\"italian\"],\"stacco\":[\"italian\"],\"staffa\":[\"italian\"],\"stagnare\":[\"italian\"],\"stampato\":[\"italian\"],\"stantio\":[\"italian\"],\"starnuto\":[\"italian\"],\"stasera\":[\"italian\"],\"statuto\":[\"italian\"],\"stelo\":[\"italian\"],\"steppa\":[\"italian\"],\"sterzo\":[\"italian\"],\"stiletto\":[\"italian\"],\"stima\":[\"italian\"],\"stirpe\":[\"italian\"],\"stivale\":[\"italian\"],\"stizzoso\":[\"italian\"],\"stonato\":[\"italian\"],\"storico\":[\"italian\"],\"strappo\":[\"italian\"],\"stregato\":[\"italian\"],\"stridulo\":[\"italian\"],\"strozzare\":[\"italian\"],\"strutto\":[\"italian\"],\"stuccare\":[\"italian\"],\"stufo\":[\"italian\"],\"stupendo\":[\"italian\"],\"subentro\":[\"italian\"],\"succoso\":[\"italian\"],\"sudore\":[\"italian\"],\"suggerito\":[\"italian\"],\"sugo\":[\"italian\"],\"sultano\":[\"italian\"],\"suonare\":[\"italian\"],\"superbo\":[\"italian\"],\"supporto\":[\"italian\"],\"surgelato\":[\"italian\"],\"surrogato\":[\"italian\"],\"sussurro\":[\"italian\"],\"sutura\":[\"italian\"],\"svagare\":[\"italian\"],\"svedese\":[\"italian\"],\"sveglio\":[\"italian\"],\"svelare\":[\"italian\"],\"svenuto\":[\"italian\"],\"svezia\":[\"italian\"],\"sviluppo\":[\"italian\"],\"svista\":[\"italian\"],\"svizzera\":[\"italian\"],\"svolta\":[\"italian\"],\"svuotare\":[\"italian\"],\"tabacco\":[\"italian\"],\"tabulato\":[\"italian\"],\"tacciare\":[\"italian\"],\"taciturno\":[\"italian\"],\"tale\":[\"italian\"],\"talismano\":[\"italian\"],\"tampone\":[\"italian\"],\"tannino\":[\"italian\"],\"tara\":[\"italian\"],\"tardivo\":[\"italian\"],\"targato\":[\"italian\"],\"tariffa\":[\"italian\"],\"tarpare\":[\"italian\"],\"tartaruga\":[\"italian\"],\"tasto\":[\"italian\"],\"tattico\":[\"italian\"],\"taverna\":[\"italian\"],\"tavolata\":[\"italian\"],\"tazza\":[\"italian\"],\"teca\":[\"italian\"],\"tecnico\":[\"italian\"],\"telefono\":[\"italian\"],\"temerario\":[\"italian\"],\"tempo\":[\"italian\",\"turkish\"],\"temuto\":[\"italian\"],\"tendone\":[\"italian\"],\"tenero\":[\"italian\"],\"tensione\":[\"italian\"],\"tentacolo\":[\"italian\"],\"teorema\":[\"italian\"],\"terme\":[\"italian\"],\"terrazzo\":[\"italian\"],\"terzetto\":[\"italian\"],\"tesi\":[\"italian\"],\"tesserato\":[\"italian\"],\"testato\":[\"italian\"],\"tetro\":[\"italian\"],\"tettoia\":[\"italian\"],\"tifare\":[\"italian\"],\"tigella\":[\"italian\"],\"timbro\":[\"italian\"],\"tinto\":[\"italian\"],\"tipico\":[\"italian\"],\"tipografo\":[\"italian\"],\"tiraggio\":[\"italian\"],\"tiro\":[\"italian\"],\"titanio\":[\"italian\"],\"titolo\":[\"italian\"],\"titubante\":[\"italian\"],\"tizio\":[\"italian\"],\"tizzone\":[\"italian\"],\"toccare\":[\"italian\"],\"tollerare\":[\"italian\"],\"tolto\":[\"italian\"],\"tombola\":[\"italian\"],\"tomo\":[\"italian\"],\"tonfo\":[\"italian\"],\"tonsilla\":[\"italian\"],\"topazio\":[\"italian\"],\"topologia\":[\"italian\"],\"toppa\":[\"italian\"],\"torba\":[\"italian\"],\"tornare\":[\"italian\"],\"torrone\":[\"italian\"],\"tortora\":[\"italian\"],\"toscano\":[\"italian\"],\"tossire\":[\"italian\"],\"tostatura\":[\"italian\"],\"totano\":[\"italian\"],\"trabocco\":[\"italian\"],\"trachea\":[\"italian\"],\"trafila\":[\"italian\"],\"tragedia\":[\"italian\"],\"tralcio\":[\"italian\"],\"tramonto\":[\"italian\"],\"transito\":[\"italian\"],\"trapano\":[\"italian\"],\"trarre\":[\"italian\"],\"trasloco\":[\"italian\"],\"trattato\":[\"italian\"],\"trave\":[\"italian\"],\"treccia\":[\"italian\"],\"tremolio\":[\"italian\"],\"trespolo\":[\"italian\"],\"tributo\":[\"italian\"],\"tricheco\":[\"italian\"],\"trifoglio\":[\"italian\"],\"trillo\":[\"italian\"],\"trincea\":[\"italian\"],\"trio\":[\"italian\"],\"tristezza\":[\"italian\"],\"triturato\":[\"italian\"],\"trivella\":[\"italian\"],\"tromba\":[\"italian\"],\"trono\":[\"italian\"],\"troppo\":[\"italian\"],\"trottola\":[\"italian\"],\"trovare\":[\"italian\"],\"truccato\":[\"italian\"],\"tubatura\":[\"italian\"],\"tuffato\":[\"italian\"],\"tulipano\":[\"italian\"],\"tumulto\":[\"italian\"],\"tunisia\":[\"italian\"],\"turbare\":[\"italian\"],\"turchino\":[\"italian\"],\"tuta\":[\"italian\"],\"tutela\":[\"italian\"],\"ubicato\":[\"italian\"],\"uccello\":[\"italian\"],\"uccisore\":[\"italian\"],\"udire\":[\"italian\"],\"uditivo\":[\"italian\"],\"uffa\":[\"italian\"],\"ufficio\":[\"italian\"],\"uguale\":[\"italian\"],\"ulisse\":[\"italian\"],\"ultimato\":[\"italian\"],\"umano\":[\"italian\"],\"umile\":[\"italian\"],\"umorismo\":[\"italian\"],\"uncinetto\":[\"italian\"],\"ungere\":[\"italian\"],\"ungherese\":[\"italian\"],\"unicorno\":[\"italian\"],\"unificato\":[\"italian\"],\"unisono\":[\"italian\"],\"unitario\":[\"italian\"],\"unte\":[\"italian\"],\"uovo\":[\"italian\"],\"upupa\":[\"italian\"],\"uragano\":[\"italian\"],\"urgenza\":[\"italian\"],\"urlo\":[\"italian\"],\"usanza\":[\"italian\"],\"usato\":[\"italian\"],\"uscito\":[\"italian\"],\"usignolo\":[\"italian\"],\"usuraio\":[\"italian\"],\"utensile\":[\"italian\"],\"utilizzo\":[\"italian\"],\"utopia\":[\"italian\"],\"vacante\":[\"italian\"],\"vaccinato\":[\"italian\"],\"vagabondo\":[\"italian\"],\"vagliato\":[\"italian\"],\"valanga\":[\"italian\"],\"valgo\":[\"italian\"],\"valico\":[\"italian\"],\"valletta\":[\"italian\"],\"valoroso\":[\"italian\"],\"valutare\":[\"italian\"],\"valvola\":[\"italian\"],\"vampata\":[\"italian\"],\"vangare\":[\"italian\"],\"vanitoso\":[\"italian\"],\"vano\":[\"italian\"],\"vantaggio\":[\"italian\"],\"vanvera\":[\"italian\"],\"vapore\":[\"italian\"],\"varano\":[\"italian\"],\"varcato\":[\"italian\"],\"variante\":[\"italian\"],\"vasca\":[\"italian\"],\"vedetta\":[\"italian\"],\"vedova\":[\"italian\"],\"veduto\":[\"italian\"],\"vegetale\":[\"italian\"],\"veicolo\":[\"italian\"],\"velcro\":[\"italian\"],\"velina\":[\"italian\"],\"velluto\":[\"italian\"],\"veloce\":[\"italian\"],\"venato\":[\"italian\"],\"vendemmia\":[\"italian\"],\"vento\":[\"italian\"],\"verace\":[\"italian\"],\"verbale\":[\"italian\"],\"vergogna\":[\"italian\"],\"verifica\":[\"italian\"],\"vero\":[\"italian\"],\"verruca\":[\"italian\"],\"verticale\":[\"italian\"],\"vescica\":[\"italian\"],\"vessillo\":[\"italian\"],\"vestale\":[\"italian\"],\"veterano\":[\"italian\"],\"vetrina\":[\"italian\"],\"vetusto\":[\"italian\"],\"viandante\":[\"italian\"],\"vibrante\":[\"italian\"],\"vicenda\":[\"italian\"],\"vichingo\":[\"italian\"],\"vicinanza\":[\"italian\"],\"vidimare\":[\"italian\"],\"vigilia\":[\"italian\"],\"vigneto\":[\"italian\"],\"vigore\":[\"italian\"],\"vile\":[\"italian\"],\"villano\":[\"italian\"],\"vimini\":[\"italian\"],\"vincitore\":[\"italian\"],\"viola\":[\"italian\"],\"vipera\":[\"italian\"],\"virgola\":[\"italian\"],\"virologo\":[\"italian\"],\"virulento\":[\"italian\"],\"viscoso\":[\"italian\"],\"visione\":[\"italian\"],\"vispo\":[\"italian\"],\"vissuto\":[\"italian\"],\"visura\":[\"italian\"],\"vita\":[\"italian\"],\"vitello\":[\"italian\"],\"vittima\":[\"italian\"],\"vivanda\":[\"italian\"],\"vivido\":[\"italian\"],\"viziare\":[\"italian\"],\"voce\":[\"italian\"],\"voga\":[\"italian\"],\"volatile\":[\"italian\"],\"volere\":[\"italian\"],\"volpe\":[\"italian\"],\"voragine\":[\"italian\"],\"vulcano\":[\"italian\"],\"zampogna\":[\"italian\"],\"zanna\":[\"italian\"],\"zappato\":[\"italian\"],\"zattera\":[\"italian\"],\"zavorra\":[\"italian\"],\"zefiro\":[\"italian\"],\"zelante\":[\"italian\"],\"zelo\":[\"italian\"],\"zenzero\":[\"italian\"],\"zerbino\":[\"italian\"],\"zibetto\":[\"italian\"],\"zinco\":[\"italian\"],\"zircone\":[\"italian\"],\"zitto\":[\"italian\"],\"zolla\":[\"italian\"],\"zotico\":[\"italian\"],\"zucchero\":[\"italian\"],\"zufolo\":[\"italian\"],\"zulu\":[\"italian\"],\"zuppa\":[\"italian\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"japanese\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"\":[\"korean\"],\"abacate\":[\"portuguese\"],\"abaixo\":[\"portuguese\"],\"abalar\":[\"portuguese\"],\"abater\":[\"portuguese\"],\"abduzir\":[\"portuguese\"],\"abelha\":[\"portuguese\"],\"aberto\":[\"portuguese\"],\"abismo\":[\"portuguese\"],\"abotoar\":[\"portuguese\"],\"abranger\":[\"portuguese\"],\"abreviar\":[\"portuguese\"],\"abrigar\":[\"portuguese\"],\"abrupto\":[\"portuguese\"],\"absinto\":[\"portuguese\"],\"absoluto\":[\"portuguese\"],\"absurdo\":[\"portuguese\"],\"abutre\":[\"portuguese\"],\"acabado\":[\"portuguese\"],\"acalmar\":[\"portuguese\"],\"acampar\":[\"portuguese\"],\"acanhar\":[\"portuguese\"],\"acaso\":[\"portuguese\"],\"aceitar\":[\"portuguese\"],\"acelerar\":[\"portuguese\"],\"acenar\":[\"portuguese\"],\"acervo\":[\"portuguese\"],\"acessar\":[\"portuguese\"],\"acetona\":[\"portuguese\"],\"achatar\":[\"portuguese\"],\"acidez\":[\"portuguese\"],\"acima\":[\"portuguese\"],\"acionado\":[\"portuguese\"],\"acirrar\":[\"portuguese\"],\"aclamar\":[\"portuguese\"],\"aclive\":[\"portuguese\"],\"acolhida\":[\"portuguese\"],\"acomodar\":[\"portuguese\"],\"acoplar\":[\"portuguese\"],\"acordar\":[\"portuguese\"],\"acumular\":[\"portuguese\"],\"acusador\":[\"portuguese\"],\"adaptar\":[\"portuguese\"],\"adega\":[\"portuguese\"],\"adentro\":[\"portuguese\"],\"adepto\":[\"portuguese\"],\"adequar\":[\"portuguese\"],\"aderente\":[\"portuguese\"],\"adesivo\":[\"portuguese\"],\"adeus\":[\"portuguese\"],\"adiante\":[\"portuguese\"],\"aditivo\":[\"portuguese\"],\"adjetivo\":[\"portuguese\"],\"adjunto\":[\"portuguese\"],\"admirar\":[\"portuguese\"],\"adorar\":[\"portuguese\"],\"adquirir\":[\"portuguese\"],\"adubo\":[\"portuguese\"],\"adverso\":[\"portuguese\"],\"advogado\":[\"portuguese\"],\"aeronave\":[\"portuguese\"],\"afastar\":[\"portuguese\"],\"aferir\":[\"portuguese\"],\"afetivo\":[\"portuguese\"],\"afinador\":[\"portuguese\"],\"afivelar\":[\"portuguese\"],\"aflito\":[\"portuguese\"],\"afluente\":[\"portuguese\"],\"afrontar\":[\"portuguese\"],\"agachar\":[\"portuguese\"],\"agarrar\":[\"portuguese\"],\"agasalho\":[\"portuguese\"],\"agenciar\":[\"portuguese\"],\"agilizar\":[\"portuguese\"],\"agiota\":[\"portuguese\"],\"agitado\":[\"portuguese\"],\"agora\":[\"portuguese\"],\"agradar\":[\"portuguese\"],\"agreste\":[\"portuguese\"],\"agrupar\":[\"portuguese\"],\"aguardar\":[\"portuguese\"],\"agulha\":[\"portuguese\"],\"ajoelhar\":[\"portuguese\"],\"ajudar\":[\"portuguese\"],\"ajustar\":[\"portuguese\"],\"alameda\":[\"portuguese\"],\"alarme\":[\"portuguese\"],\"alastrar\":[\"portuguese\"],\"alavanca\":[\"portuguese\"],\"albergue\":[\"portuguese\"],\"albino\":[\"portuguese\"],\"alcatra\":[\"portuguese\"],\"aldeia\":[\"portuguese\"],\"alecrim\":[\"portuguese\"],\"alegria\":[\"portuguese\"],\"alertar\":[\"portuguese\"],\"alface\":[\"portuguese\"],\"alfinete\":[\"portuguese\"],\"algum\":[\"portuguese\"],\"alheio\":[\"portuguese\"],\"aliar\":[\"portuguese\"],\"alicate\":[\"portuguese\"],\"alienar\":[\"portuguese\"],\"alinhar\":[\"portuguese\"],\"aliviar\":[\"portuguese\"],\"almofada\":[\"portuguese\"],\"alocar\":[\"portuguese\"],\"alpiste\":[\"portuguese\"],\"alterar\":[\"portuguese\"],\"altitude\":[\"portuguese\"],\"alucinar\":[\"portuguese\"],\"alugar\":[\"portuguese\"],\"aluno\":[\"portuguese\"],\"alusivo\":[\"portuguese\"],\"alvo\":[\"portuguese\"],\"amaciar\":[\"portuguese\"],\"amador\":[\"portuguese\"],\"amarelo\":[\"portuguese\"],\"amassar\":[\"portuguese\"],\"ambas\":[\"portuguese\"],\"ambiente\":[\"portuguese\"],\"ameixa\":[\"portuguese\"],\"amenizar\":[\"portuguese\"],\"amido\":[\"portuguese\"],\"amistoso\":[\"portuguese\"],\"amizade\":[\"portuguese\"],\"amolador\":[\"portuguese\"],\"amontoar\":[\"portuguese\"],\"amoroso\":[\"portuguese\"],\"amostra\":[\"portuguese\"],\"amparar\":[\"portuguese\"],\"ampliar\":[\"portuguese\"],\"ampola\":[\"portuguese\"],\"anagrama\":[\"portuguese\"],\"analisar\":[\"portuguese\"],\"anarquia\":[\"portuguese\"],\"anatomia\":[\"portuguese\"],\"andaime\":[\"portuguese\"],\"anel\":[\"portuguese\"],\"anexo\":[\"portuguese\"],\"angular\":[\"portuguese\"],\"animar\":[\"portuguese\"],\"anjo\":[\"portuguese\"],\"anomalia\":[\"portuguese\"],\"anotado\":[\"portuguese\"],\"ansioso\":[\"portuguese\"],\"anterior\":[\"portuguese\"],\"anuidade\":[\"portuguese\"],\"anunciar\":[\"portuguese\"],\"anzol\":[\"portuguese\"],\"apagador\":[\"portuguese\"],\"apalpar\":[\"portuguese\"],\"apanhado\":[\"portuguese\"],\"apego\":[\"portuguese\"],\"apelido\":[\"portuguese\"],\"apertada\":[\"portuguese\"],\"apesar\":[\"portuguese\"],\"apetite\":[\"portuguese\"],\"apito\":[\"portuguese\"],\"aplauso\":[\"portuguese\"],\"aplicada\":[\"portuguese\"],\"apoio\":[\"portuguese\"],\"apontar\":[\"portuguese\"],\"aposta\":[\"portuguese\"],\"aprendiz\":[\"portuguese\"],\"aprovar\":[\"portuguese\"],\"aquecer\":[\"portuguese\"],\"arame\":[\"portuguese\"],\"aranha\":[\"portuguese\"],\"arara\":[\"portuguese\"],\"arcada\":[\"portuguese\"],\"ardente\":[\"portuguese\"],\"areia\":[\"portuguese\"],\"arejar\":[\"portuguese\"],\"arenito\":[\"portuguese\"],\"aresta\":[\"portuguese\"],\"argiloso\":[\"portuguese\"],\"argola\":[\"portuguese\"],\"arma\":[\"portuguese\"],\"arquivo\":[\"portuguese\"],\"arraial\":[\"portuguese\"],\"arrebate\":[\"portuguese\"],\"arriscar\":[\"portuguese\"],\"arroba\":[\"portuguese\"],\"arrumar\":[\"portuguese\"],\"arsenal\":[\"portuguese\"],\"arterial\":[\"portuguese\"],\"artigo\":[\"portuguese\"],\"arvoredo\":[\"portuguese\"],\"asfaltar\":[\"portuguese\"],\"asilado\":[\"portuguese\"],\"aspirar\":[\"portuguese\"],\"assador\":[\"portuguese\"],\"assinar\":[\"portuguese\"],\"assoalho\":[\"portuguese\"],\"assunto\":[\"portuguese\"],\"astral\":[\"portuguese\"],\"atacado\":[\"portuguese\"],\"atadura\":[\"portuguese\"],\"atalho\":[\"portuguese\"],\"atarefar\":[\"portuguese\"],\"atear\":[\"portuguese\"],\"atender\":[\"portuguese\"],\"aterro\":[\"portuguese\"],\"ateu\":[\"portuguese\"],\"atingir\":[\"portuguese\"],\"atirador\":[\"portuguese\"],\"ativo\":[\"portuguese\"],\"atoleiro\":[\"portuguese\"],\"atracar\":[\"portuguese\"],\"atrevido\":[\"portuguese\"],\"atriz\":[\"portuguese\"],\"atual\":[\"portuguese\"],\"atum\":[\"portuguese\"],\"auditor\":[\"portuguese\"],\"aumentar\":[\"portuguese\"],\"aura\":[\"portuguese\"],\"aurora\":[\"portuguese\"],\"autismo\":[\"portuguese\"],\"autoria\":[\"portuguese\"],\"autuar\":[\"portuguese\"],\"avaliar\":[\"portuguese\"],\"avante\":[\"portuguese\"],\"avaria\":[\"portuguese\"],\"avental\":[\"portuguese\"],\"avesso\":[\"portuguese\"],\"aviador\":[\"portuguese\"],\"avisar\":[\"portuguese\"],\"avulso\":[\"portuguese\"],\"axila\":[\"portuguese\"],\"azarar\":[\"portuguese\"],\"azedo\":[\"portuguese\"],\"azeite\":[\"portuguese\"],\"azulejo\":[\"portuguese\"],\"babar\":[\"portuguese\"],\"babosa\":[\"portuguese\"],\"bacalhau\":[\"portuguese\"],\"bacharel\":[\"portuguese\"],\"bacia\":[\"portuguese\"],\"bagagem\":[\"portuguese\"],\"baiano\":[\"portuguese\"],\"bailar\":[\"portuguese\"],\"baioneta\":[\"portuguese\"],\"bairro\":[\"portuguese\"],\"baixista\":[\"portuguese\"],\"bajular\":[\"portuguese\"],\"baleia\":[\"portuguese\"],\"baliza\":[\"portuguese\"],\"balsa\":[\"portuguese\"],\"banal\":[\"portuguese\"],\"bandeira\":[\"portuguese\"],\"banho\":[\"portuguese\"],\"banir\":[\"portuguese\"],\"banquete\":[\"portuguese\"],\"barato\":[\"portuguese\"],\"barbado\":[\"portuguese\"],\"baronesa\":[\"portuguese\"],\"barraca\":[\"portuguese\"],\"barulho\":[\"portuguese\"],\"baseado\":[\"portuguese\"],\"bastante\":[\"portuguese\"],\"batata\":[\"portuguese\"],\"batedor\":[\"portuguese\"],\"batida\":[\"portuguese\"],\"batom\":[\"portuguese\"],\"batucar\":[\"portuguese\"],\"baunilha\":[\"portuguese\"],\"beber\":[\"portuguese\"],\"beijo\":[\"portuguese\"],\"beirada\":[\"portuguese\"],\"beisebol\":[\"portuguese\"],\"beldade\":[\"portuguese\"],\"beleza\":[\"portuguese\"],\"belga\":[\"portuguese\"],\"beliscar\":[\"portuguese\"],\"bendito\":[\"portuguese\"],\"bengala\":[\"portuguese\"],\"benzer\":[\"portuguese\",\"turkish\"],\"berimbau\":[\"portuguese\"],\"berlinda\":[\"portuguese\"],\"berro\":[\"portuguese\"],\"besouro\":[\"portuguese\"],\"bexiga\":[\"portuguese\"],\"bezerro\":[\"portuguese\"],\"bico\":[\"portuguese\"],\"bicudo\":[\"portuguese\"],\"bienal\":[\"portuguese\"],\"bifocal\":[\"portuguese\"],\"bifurcar\":[\"portuguese\"],\"bigorna\":[\"portuguese\"],\"bilhete\":[\"portuguese\"],\"bimestre\":[\"portuguese\"],\"bimotor\":[\"portuguese\"],\"biologia\":[\"portuguese\"],\"biombo\":[\"portuguese\"],\"biosfera\":[\"portuguese\"],\"bipolar\":[\"portuguese\"],\"birrento\":[\"portuguese\"],\"biscoito\":[\"portuguese\"],\"bisneto\":[\"portuguese\"],\"bispo\":[\"portuguese\"],\"bissexto\":[\"portuguese\"],\"bitola\":[\"portuguese\"],\"bizarro\":[\"portuguese\"],\"blindado\":[\"portuguese\"],\"bloco\":[\"portuguese\"],\"bloquear\":[\"portuguese\"],\"boato\":[\"portuguese\"],\"bobagem\":[\"portuguese\"],\"bocado\":[\"portuguese\"],\"bocejo\":[\"portuguese\"],\"bochecha\":[\"portuguese\"],\"boicotar\":[\"portuguese\"],\"bolada\":[\"portuguese\"],\"boletim\":[\"portuguese\"],\"bolha\":[\"portuguese\"],\"bolo\":[\"portuguese\"],\"bombeiro\":[\"portuguese\"],\"bonde\":[\"portuguese\"],\"boneco\":[\"portuguese\"],\"bonita\":[\"portuguese\"],\"borbulha\":[\"portuguese\"],\"borda\":[\"portuguese\"],\"boreal\":[\"portuguese\"],\"borracha\":[\"portuguese\"],\"bovino\":[\"portuguese\"],\"boxeador\":[\"portuguese\"],\"branco\":[\"portuguese\"],\"brasa\":[\"portuguese\"],\"braveza\":[\"portuguese\"],\"breu\":[\"portuguese\"],\"briga\":[\"portuguese\"],\"brilho\":[\"portuguese\"],\"brincar\":[\"portuguese\"],\"broa\":[\"portuguese\"],\"brochura\":[\"portuguese\"],\"bronzear\":[\"portuguese\"],\"broto\":[\"portuguese\"],\"bruxo\":[\"portuguese\"],\"bucha\":[\"portuguese\"],\"budismo\":[\"portuguese\"],\"bufar\":[\"portuguese\"],\"bule\":[\"portuguese\"],\"buraco\":[\"portuguese\"],\"busca\":[\"portuguese\"],\"busto\":[\"portuguese\"],\"buzina\":[\"portuguese\"],\"cabana\":[\"portuguese\"],\"cabelo\":[\"portuguese\"],\"cabide\":[\"portuguese\"],\"cabo\":[\"portuguese\"],\"cabrito\":[\"portuguese\"],\"cacau\":[\"portuguese\"],\"cacetada\":[\"portuguese\"],\"cachorro\":[\"portuguese\"],\"cacique\":[\"portuguese\"],\"cadastro\":[\"portuguese\"],\"cadeado\":[\"portuguese\"],\"cafezal\":[\"portuguese\"],\"caiaque\":[\"portuguese\"],\"caipira\":[\"portuguese\"],\"caixote\":[\"portuguese\"],\"cajado\":[\"portuguese\"],\"caju\":[\"portuguese\"],\"calafrio\":[\"portuguese\"],\"calcular\":[\"portuguese\"],\"caldeira\":[\"portuguese\"],\"calibrar\":[\"portuguese\"],\"calmante\":[\"portuguese\"],\"calota\":[\"portuguese\"],\"camada\":[\"portuguese\"],\"cambista\":[\"portuguese\"],\"camisa\":[\"portuguese\"],\"camomila\":[\"portuguese\"],\"campanha\":[\"portuguese\"],\"camuflar\":[\"portuguese\"],\"canavial\":[\"portuguese\"],\"cancelar\":[\"portuguese\"],\"caneta\":[\"portuguese\"],\"canguru\":[\"portuguese\"],\"canhoto\":[\"portuguese\"],\"canivete\":[\"portuguese\"],\"canoa\":[\"portuguese\"],\"cansado\":[\"portuguese\"],\"cantar\":[\"portuguese\"],\"canudo\":[\"portuguese\"],\"capacho\":[\"portuguese\"],\"capela\":[\"portuguese\"],\"capinar\":[\"portuguese\"],\"capotar\":[\"portuguese\"],\"capricho\":[\"portuguese\"],\"captador\":[\"portuguese\"],\"capuz\":[\"portuguese\"],\"caracol\":[\"portuguese\"],\"carbono\":[\"portuguese\"],\"cardeal\":[\"portuguese\"],\"careca\":[\"portuguese\"],\"carimbar\":[\"portuguese\"],\"carneiro\":[\"portuguese\"],\"carpete\":[\"portuguese\"],\"carreira\":[\"portuguese\"],\"cartaz\":[\"portuguese\"],\"carvalho\":[\"portuguese\"],\"casaco\":[\"portuguese\"],\"casca\":[\"portuguese\"],\"casebre\":[\"portuguese\"],\"castelo\":[\"portuguese\"],\"casulo\":[\"portuguese\"],\"catarata\":[\"portuguese\"],\"cativar\":[\"portuguese\"],\"caule\":[\"portuguese\"],\"causador\":[\"portuguese\"],\"cautelar\":[\"portuguese\"],\"cavalo\":[\"portuguese\"],\"caverna\":[\"portuguese\"],\"cebola\":[\"portuguese\"],\"cedilha\":[\"portuguese\"],\"cegonha\":[\"portuguese\"],\"celebrar\":[\"portuguese\"],\"celular\":[\"portuguese\"],\"cenoura\":[\"portuguese\"],\"censo\":[\"portuguese\"],\"centeio\":[\"portuguese\"],\"cercar\":[\"portuguese\"],\"cerrado\":[\"portuguese\"],\"certeiro\":[\"portuguese\"],\"cerveja\":[\"portuguese\"],\"cetim\":[\"portuguese\"],\"cevada\":[\"portuguese\"],\"chacota\":[\"portuguese\"],\"chaleira\":[\"portuguese\"],\"chamado\":[\"portuguese\"],\"chapada\":[\"portuguese\"],\"charme\":[\"portuguese\"],\"chatice\":[\"portuguese\"],\"chave\":[\"portuguese\"],\"chefe\":[\"portuguese\"],\"chegada\":[\"portuguese\"],\"cheiro\":[\"portuguese\"],\"cheque\":[\"portuguese\"],\"chicote\":[\"portuguese\"],\"chifre\":[\"portuguese\"],\"chinelo\":[\"portuguese\"],\"chocalho\":[\"portuguese\"],\"chover\":[\"portuguese\"],\"chumbo\":[\"portuguese\"],\"chutar\":[\"portuguese\"],\"chuva\":[\"portuguese\"],\"cicatriz\":[\"portuguese\"],\"ciclone\":[\"portuguese\"],\"cidade\":[\"portuguese\"],\"cidreira\":[\"portuguese\"],\"ciente\":[\"portuguese\"],\"cigana\":[\"portuguese\"],\"cimento\":[\"portuguese\"],\"cinto\":[\"portuguese\"],\"cinza\":[\"portuguese\"],\"ciranda\":[\"portuguese\"],\"circuito\":[\"portuguese\"],\"cirurgia\":[\"portuguese\"],\"citar\":[\"portuguese\"],\"clareza\":[\"portuguese\"],\"clero\":[\"portuguese\"],\"clicar\":[\"portuguese\"],\"clone\":[\"portuguese\"],\"clube\":[\"portuguese\"],\"coado\":[\"portuguese\"],\"coagir\":[\"portuguese\"],\"cobaia\":[\"portuguese\"],\"cobertor\":[\"portuguese\"],\"cobrar\":[\"portuguese\"],\"cocada\":[\"portuguese\"],\"coelho\":[\"portuguese\"],\"coentro\":[\"portuguese\"],\"coeso\":[\"portuguese\"],\"cogumelo\":[\"portuguese\"],\"coibir\":[\"portuguese\"],\"coifa\":[\"portuguese\"],\"coiote\":[\"portuguese\"],\"colar\":[\"portuguese\"],\"coleira\":[\"portuguese\"],\"colher\":[\"portuguese\"],\"colidir\":[\"portuguese\"],\"colmeia\":[\"portuguese\"],\"colono\":[\"portuguese\"],\"coluna\":[\"portuguese\"],\"comando\":[\"portuguese\"],\"combinar\":[\"portuguese\"],\"comentar\":[\"portuguese\"],\"comitiva\":[\"portuguese\"],\"comover\":[\"portuguese\"],\"complexo\":[\"portuguese\"],\"comum\":[\"portuguese\"],\"concha\":[\"portuguese\"],\"condor\":[\"portuguese\"],\"conectar\":[\"portuguese\"],\"confuso\":[\"portuguese\"],\"congelar\":[\"portuguese\"],\"conhecer\":[\"portuguese\"],\"conjugar\":[\"portuguese\"],\"consumir\":[\"portuguese\"],\"contrato\":[\"portuguese\"],\"convite\":[\"portuguese\"],\"cooperar\":[\"portuguese\"],\"copeiro\":[\"portuguese\"],\"copiador\":[\"portuguese\"],\"copo\":[\"portuguese\"],\"coquetel\":[\"portuguese\"],\"coragem\":[\"portuguese\"],\"cordial\":[\"portuguese\"],\"corneta\":[\"portuguese\"],\"coronha\":[\"portuguese\"],\"corporal\":[\"portuguese\"],\"correio\":[\"portuguese\"],\"cortejo\":[\"portuguese\"],\"coruja\":[\"portuguese\"],\"corvo\":[\"portuguese\"],\"cosseno\":[\"portuguese\"],\"costela\":[\"portuguese\"],\"cotonete\":[\"portuguese\"],\"couro\":[\"portuguese\"],\"couve\":[\"portuguese\"],\"covil\":[\"portuguese\"],\"cozinha\":[\"portuguese\"],\"cratera\":[\"portuguese\"],\"cravo\":[\"portuguese\"],\"creche\":[\"portuguese\"],\"credor\":[\"portuguese\"],\"creme\":[\"portuguese\"],\"crer\":[\"portuguese\"],\"crespo\":[\"portuguese\"],\"criada\":[\"portuguese\"],\"criminal\":[\"portuguese\"],\"crioulo\":[\"portuguese\"],\"crise\":[\"portuguese\"],\"criticar\":[\"portuguese\"],\"crosta\":[\"portuguese\"],\"crua\":[\"portuguese\"],\"cruzeiro\":[\"portuguese\"],\"cubano\":[\"portuguese\"],\"cueca\":[\"portuguese\"],\"cuidado\":[\"portuguese\"],\"cujo\":[\"portuguese\"],\"culatra\":[\"portuguese\"],\"culminar\":[\"portuguese\"],\"culpar\":[\"portuguese\"],\"cultura\":[\"portuguese\"],\"cumprir\":[\"portuguese\"],\"cunhado\":[\"portuguese\"],\"cupido\":[\"portuguese\"],\"curativo\":[\"portuguese\"],\"curral\":[\"portuguese\"],\"cursar\":[\"portuguese\"],\"curto\":[\"portuguese\"],\"cuspir\":[\"portuguese\"],\"custear\":[\"portuguese\"],\"cutelo\":[\"portuguese\"],\"damasco\":[\"portuguese\"],\"datar\":[\"portuguese\"],\"debater\":[\"portuguese\"],\"debitar\":[\"portuguese\"],\"deboche\":[\"portuguese\"],\"debulhar\":[\"portuguese\"],\"decalque\":[\"portuguese\"],\"decimal\":[\"portuguese\"],\"declive\":[\"portuguese\"],\"decote\":[\"portuguese\"],\"decretar\":[\"portuguese\"],\"dedal\":[\"portuguese\"],\"dedicado\":[\"portuguese\"],\"deduzir\":[\"portuguese\"],\"defesa\":[\"portuguese\"],\"defumar\":[\"portuguese\"],\"degelo\":[\"portuguese\"],\"degrau\":[\"portuguese\"],\"degustar\":[\"portuguese\"],\"deitado\":[\"portuguese\"],\"deixar\":[\"portuguese\"],\"delator\":[\"portuguese\"],\"delegado\":[\"portuguese\"],\"delinear\":[\"portuguese\"],\"delonga\":[\"portuguese\"],\"demanda\":[\"portuguese\"],\"demitir\":[\"portuguese\"],\"demolido\":[\"portuguese\"],\"dentista\":[\"portuguese\"],\"depenado\":[\"portuguese\"],\"depilar\":[\"portuguese\"],\"depois\":[\"portuguese\"],\"depressa\":[\"portuguese\"],\"depurar\":[\"portuguese\"],\"deriva\":[\"portuguese\"],\"derramar\":[\"portuguese\"],\"desafio\":[\"portuguese\"],\"desbotar\":[\"portuguese\"],\"descanso\":[\"portuguese\"],\"desenho\":[\"portuguese\"],\"desfiado\":[\"portuguese\"],\"desgaste\":[\"portuguese\"],\"desigual\":[\"portuguese\"],\"deslize\":[\"portuguese\"],\"desmamar\":[\"portuguese\"],\"desova\":[\"portuguese\"],\"despesa\":[\"portuguese\"],\"destaque\":[\"portuguese\"],\"desviar\":[\"portuguese\"],\"detalhar\":[\"portuguese\"],\"detentor\":[\"portuguese\"],\"detonar\":[\"portuguese\"],\"detrito\":[\"portuguese\"],\"deusa\":[\"portuguese\"],\"dever\":[\"portuguese\"],\"devido\":[\"portuguese\"],\"devotado\":[\"portuguese\"],\"dezena\":[\"portuguese\"],\"diagrama\":[\"portuguese\"],\"dialeto\":[\"portuguese\"],\"didata\":[\"portuguese\"],\"difuso\":[\"portuguese\"],\"digitar\":[\"portuguese\"],\"dilatado\":[\"portuguese\"],\"diluente\":[\"portuguese\"],\"diminuir\":[\"portuguese\"],\"dinastia\":[\"portuguese\"],\"dinheiro\":[\"portuguese\"],\"diocese\":[\"portuguese\"],\"direto\":[\"portuguese\"],\"discreta\":[\"portuguese\"],\"disfarce\":[\"portuguese\"],\"disparo\":[\"portuguese\"],\"disquete\":[\"portuguese\"],\"dissipar\":[\"portuguese\"],\"distante\":[\"portuguese\"],\"ditador\":[\"portuguese\"],\"diurno\":[\"portuguese\"],\"diverso\":[\"portuguese\"],\"divisor\":[\"portuguese\"],\"divulgar\":[\"portuguese\"],\"dizer\":[\"portuguese\"],\"dobrador\":[\"portuguese\"],\"dolorido\":[\"portuguese\"],\"domador\":[\"portuguese\"],\"dominado\":[\"portuguese\"],\"donativo\":[\"portuguese\"],\"donzela\":[\"portuguese\"],\"dormente\":[\"portuguese\"],\"dorsal\":[\"portuguese\"],\"dosagem\":[\"portuguese\"],\"dourado\":[\"portuguese\"],\"doutor\":[\"portuguese\"],\"drenagem\":[\"portuguese\"],\"drible\":[\"portuguese\"],\"drogaria\":[\"portuguese\"],\"duelar\":[\"portuguese\"],\"duende\":[\"portuguese\"],\"dueto\":[\"portuguese\"],\"duplo\":[\"portuguese\"],\"duquesa\":[\"portuguese\"],\"durante\":[\"portuguese\"],\"duvidoso\":[\"portuguese\"],\"eclodir\":[\"portuguese\"],\"ecoar\":[\"portuguese\"],\"ecologia\":[\"portuguese\"],\"edificar\":[\"portuguese\"],\"edital\":[\"portuguese\"],\"educado\":[\"portuguese\"],\"efeito\":[\"portuguese\"],\"efetivar\":[\"portuguese\"],\"ejetar\":[\"portuguese\"],\"elaborar\":[\"portuguese\"],\"eleger\":[\"portuguese\"],\"eleitor\":[\"portuguese\"],\"elenco\":[\"portuguese\"],\"elevador\":[\"portuguese\"],\"eliminar\":[\"portuguese\"],\"elogiar\":[\"portuguese\"],\"embargo\":[\"portuguese\"],\"embolado\":[\"portuguese\"],\"embrulho\":[\"portuguese\"],\"embutido\":[\"portuguese\"],\"emenda\":[\"portuguese\"],\"emergir\":[\"portuguese\"],\"emissor\":[\"portuguese\"],\"empatia\":[\"portuguese\"],\"empenho\":[\"portuguese\"],\"empinado\":[\"portuguese\"],\"empolgar\":[\"portuguese\"],\"emprego\":[\"portuguese\"],\"empurrar\":[\"portuguese\"],\"emulador\":[\"portuguese\"],\"encaixe\":[\"portuguese\"],\"encenado\":[\"portuguese\"],\"enchente\":[\"portuguese\"],\"encontro\":[\"portuguese\"],\"endeusar\":[\"portuguese\"],\"endossar\":[\"portuguese\"],\"enfaixar\":[\"portuguese\"],\"enfeite\":[\"portuguese\"],\"enfim\":[\"portuguese\"],\"engajado\":[\"portuguese\"],\"engenho\":[\"portuguese\"],\"englobar\":[\"portuguese\"],\"engomado\":[\"portuguese\"],\"engraxar\":[\"portuguese\"],\"enguia\":[\"portuguese\"],\"enjoar\":[\"portuguese\"],\"enlatar\":[\"portuguese\"],\"enquanto\":[\"portuguese\"],\"enraizar\":[\"portuguese\"],\"enrolado\":[\"portuguese\"],\"enrugar\":[\"portuguese\"],\"ensaio\":[\"portuguese\"],\"enseada\":[\"portuguese\"],\"ensino\":[\"portuguese\"],\"ensopado\":[\"portuguese\"],\"entanto\":[\"portuguese\"],\"enteado\":[\"portuguese\"],\"entidade\":[\"portuguese\"],\"entortar\":[\"portuguese\"],\"entrada\":[\"portuguese\"],\"entulho\":[\"portuguese\"],\"envergar\":[\"portuguese\"],\"enviado\":[\"portuguese\"],\"envolver\":[\"portuguese\"],\"enxame\":[\"portuguese\"],\"enxerto\":[\"portuguese\"],\"enxofre\":[\"portuguese\"],\"enxuto\":[\"portuguese\"],\"epiderme\":[\"portuguese\"],\"equipar\":[\"portuguese\"],\"ereto\":[\"portuguese\"],\"erguido\":[\"portuguese\"],\"errata\":[\"portuguese\"],\"erva\":[\"portuguese\"],\"ervilha\":[\"portuguese\"],\"esbanjar\":[\"portuguese\"],\"esbelto\":[\"portuguese\"],\"escama\":[\"portuguese\"],\"escola\":[\"portuguese\"],\"escrita\":[\"portuguese\"],\"escuta\":[\"portuguese\"],\"esfinge\":[\"portuguese\"],\"esfolar\":[\"portuguese\"],\"esfregar\":[\"portuguese\"],\"esfumado\":[\"portuguese\"],\"esgrima\":[\"portuguese\"],\"esmalte\":[\"portuguese\"],\"espanto\":[\"portuguese\"],\"espelho\":[\"portuguese\"],\"espiga\":[\"portuguese\"],\"esponja\":[\"portuguese\"],\"espreita\":[\"portuguese\"],\"espumar\":[\"portuguese\"],\"esquerda\":[\"portuguese\"],\"estaca\":[\"portuguese\"],\"esteira\":[\"portuguese\"],\"esticar\":[\"portuguese\"],\"estofado\":[\"portuguese\"],\"estrela\":[\"portuguese\"],\"estudo\":[\"portuguese\"],\"esvaziar\":[\"portuguese\"],\"etanol\":[\"portuguese\"],\"etiqueta\":[\"portuguese\"],\"euforia\":[\"portuguese\"],\"europeu\":[\"portuguese\"],\"evacuar\":[\"portuguese\"],\"evaporar\":[\"portuguese\"],\"evasivo\":[\"portuguese\"],\"eventual\":[\"portuguese\"],\"evidente\":[\"portuguese\"],\"evoluir\":[\"portuguese\"],\"exagero\":[\"portuguese\"],\"exalar\":[\"portuguese\"],\"examinar\":[\"portuguese\"],\"exato\":[\"portuguese\"],\"exausto\":[\"portuguese\"],\"excesso\":[\"portuguese\"],\"excitar\":[\"portuguese\"],\"exclamar\":[\"portuguese\"],\"executar\":[\"portuguese\"],\"exemplo\":[\"portuguese\"],\"exibir\":[\"portuguese\"],\"exigente\":[\"portuguese\"],\"exonerar\":[\"portuguese\"],\"expandir\":[\"portuguese\"],\"expelir\":[\"portuguese\"],\"expirar\":[\"portuguese\"],\"explanar\":[\"portuguese\"],\"exposto\":[\"portuguese\"],\"expresso\":[\"portuguese\"],\"expulsar\":[\"portuguese\"],\"externo\":[\"portuguese\"],\"extinto\":[\"portuguese\"],\"extrato\":[\"portuguese\"],\"fabricar\":[\"portuguese\"],\"fabuloso\":[\"portuguese\"],\"faceta\":[\"portuguese\"],\"facial\":[\"portuguese\"],\"fada\":[\"portuguese\"],\"fadiga\":[\"portuguese\"],\"faixa\":[\"portuguese\"],\"falar\":[\"portuguese\"],\"falta\":[\"portuguese\"],\"familiar\":[\"portuguese\"],\"fandango\":[\"portuguese\"],\"fanfarra\":[\"portuguese\"],\"fantoche\":[\"portuguese\"],\"fardado\":[\"portuguese\"],\"farelo\":[\"portuguese\"],\"farinha\":[\"portuguese\"],\"farofa\":[\"portuguese\"],\"farpa\":[\"portuguese\"],\"fartura\":[\"portuguese\"],\"fatia\":[\"portuguese\"],\"fator\":[\"portuguese\"],\"favorita\":[\"portuguese\"],\"faxina\":[\"portuguese\"],\"fazenda\":[\"portuguese\"],\"fechado\":[\"portuguese\"],\"feijoada\":[\"portuguese\"],\"feirante\":[\"portuguese\"],\"felino\":[\"portuguese\"],\"feminino\":[\"portuguese\"],\"fenda\":[\"portuguese\"],\"feno\":[\"portuguese\"],\"fera\":[\"portuguese\"],\"feriado\":[\"portuguese\"],\"ferrugem\":[\"portuguese\"],\"ferver\":[\"portuguese\"],\"festejar\":[\"portuguese\"],\"fetal\":[\"portuguese\"],\"feudal\":[\"portuguese\"],\"fiapo\":[\"portuguese\"],\"fibrose\":[\"portuguese\"],\"ficar\":[\"portuguese\"],\"ficheiro\":[\"portuguese\"],\"figurado\":[\"portuguese\"],\"fileira\":[\"portuguese\"],\"filho\":[\"portuguese\"],\"filme\":[\"portuguese\"],\"filtrar\":[\"portuguese\"],\"firmeza\":[\"portuguese\"],\"fisgada\":[\"portuguese\"],\"fissura\":[\"portuguese\"],\"fita\":[\"portuguese\"],\"fivela\":[\"portuguese\"],\"fixador\":[\"portuguese\"],\"fixo\":[\"portuguese\"],\"flacidez\":[\"portuguese\"],\"flamingo\":[\"portuguese\"],\"flanela\":[\"portuguese\"],\"flechada\":[\"portuguese\"],\"flora\":[\"portuguese\"],\"flutuar\":[\"portuguese\"],\"fluxo\":[\"portuguese\"],\"focal\":[\"portuguese\"],\"focinho\":[\"portuguese\"],\"fofocar\":[\"portuguese\"],\"fogo\":[\"portuguese\"],\"foguete\":[\"portuguese\"],\"foice\":[\"portuguese\"],\"folgado\":[\"portuguese\"],\"folheto\":[\"portuguese\"],\"forjar\":[\"portuguese\"],\"formiga\":[\"portuguese\"],\"forno\":[\"portuguese\"],\"forte\":[\"portuguese\"],\"fosco\":[\"portuguese\"],\"fossa\":[\"portuguese\"],\"fragata\":[\"portuguese\"],\"fralda\":[\"portuguese\"],\"frango\":[\"portuguese\"],\"frasco\":[\"portuguese\"],\"fraterno\":[\"portuguese\"],\"freira\":[\"portuguese\"],\"frente\":[\"portuguese\"],\"fretar\":[\"portuguese\"],\"frieza\":[\"portuguese\"],\"friso\":[\"portuguese\"],\"fritura\":[\"portuguese\"],\"fronha\":[\"portuguese\"],\"frustrar\":[\"portuguese\"],\"fruteira\":[\"portuguese\"],\"fugir\":[\"portuguese\"],\"fulano\":[\"portuguese\"],\"fuligem\":[\"portuguese\"],\"fundar\":[\"portuguese\"],\"fungo\":[\"portuguese\"],\"funil\":[\"portuguese\"],\"furador\":[\"portuguese\"],\"furioso\":[\"portuguese\"],\"futebol\":[\"portuguese\"],\"gabarito\":[\"portuguese\"],\"gabinete\":[\"portuguese\"],\"gado\":[\"portuguese\"],\"gaiato\":[\"portuguese\"],\"gaiola\":[\"portuguese\"],\"gaivota\":[\"portuguese\"],\"galega\":[\"portuguese\"],\"galho\":[\"portuguese\"],\"galinha\":[\"portuguese\"],\"galocha\":[\"portuguese\"],\"ganhar\":[\"portuguese\"],\"garagem\":[\"portuguese\"],\"garfo\":[\"portuguese\"],\"gargalo\":[\"portuguese\"],\"garimpo\":[\"portuguese\"],\"garoupa\":[\"portuguese\"],\"garrafa\":[\"portuguese\"],\"gasoduto\":[\"portuguese\"],\"gasto\":[\"portuguese\"],\"gata\":[\"portuguese\"],\"gatilho\":[\"portuguese\"],\"gaveta\":[\"portuguese\"],\"gazela\":[\"portuguese\"],\"gelado\":[\"portuguese\"],\"geleia\":[\"portuguese\"],\"gelo\":[\"portuguese\"],\"gemada\":[\"portuguese\"],\"gemer\":[\"portuguese\"],\"gemido\":[\"portuguese\"],\"generoso\":[\"portuguese\"],\"gengiva\":[\"portuguese\"],\"genial\":[\"portuguese\"],\"genoma\":[\"portuguese\"],\"genro\":[\"portuguese\"],\"geologia\":[\"portuguese\"],\"gerador\":[\"portuguese\"],\"germinar\":[\"portuguese\"],\"gesso\":[\"portuguese\"],\"gestor\":[\"portuguese\"],\"ginasta\":[\"portuguese\"],\"gincana\":[\"portuguese\"],\"gingado\":[\"portuguese\"],\"girafa\":[\"portuguese\"],\"girino\":[\"portuguese\"],\"glacial\":[\"portuguese\"],\"glicose\":[\"portuguese\"],\"global\":[\"portuguese\"],\"glorioso\":[\"portuguese\"],\"goela\":[\"portuguese\"],\"goiaba\":[\"portuguese\"],\"golfe\":[\"portuguese\"],\"golpear\":[\"portuguese\"],\"gordura\":[\"portuguese\"],\"gorjeta\":[\"portuguese\"],\"gorro\":[\"portuguese\"],\"gostoso\":[\"portuguese\"],\"goteira\":[\"portuguese\"],\"governar\":[\"portuguese\"],\"gracejo\":[\"portuguese\"],\"gradual\":[\"portuguese\"],\"grafite\":[\"portuguese\"],\"gralha\":[\"portuguese\"],\"grampo\":[\"portuguese\"],\"granada\":[\"portuguese\"],\"gratuito\":[\"portuguese\"],\"graveto\":[\"portuguese\"],\"graxa\":[\"portuguese\"],\"grego\":[\"portuguese\"],\"grelhar\":[\"portuguese\"],\"greve\":[\"portuguese\"],\"grilo\":[\"portuguese\"],\"grisalho\":[\"portuguese\"],\"gritaria\":[\"portuguese\"],\"grosso\":[\"portuguese\"],\"grotesco\":[\"portuguese\"],\"grudado\":[\"portuguese\"],\"grunhido\":[\"portuguese\"],\"gruta\":[\"portuguese\"],\"guache\":[\"portuguese\"],\"guarani\":[\"portuguese\"],\"guaxinim\":[\"portuguese\"],\"guerrear\":[\"portuguese\"],\"guiar\":[\"portuguese\"],\"guincho\":[\"portuguese\"],\"guisado\":[\"portuguese\"],\"gula\":[\"portuguese\"],\"guloso\":[\"portuguese\"],\"guru\":[\"portuguese\"],\"habitar\":[\"portuguese\"],\"harmonia\":[\"portuguese\"],\"haste\":[\"portuguese\"],\"haver\":[\"portuguese\"],\"hectare\":[\"portuguese\"],\"herdar\":[\"portuguese\"],\"heresia\":[\"portuguese\"],\"hesitar\":[\"portuguese\"],\"hiato\":[\"portuguese\"],\"hibernar\":[\"portuguese\"],\"hidratar\":[\"portuguese\"],\"hiena\":[\"portuguese\"],\"hino\":[\"portuguese\"],\"hipismo\":[\"portuguese\"],\"hipnose\":[\"portuguese\"],\"hipoteca\":[\"portuguese\"],\"hoje\":[\"portuguese\"],\"holofote\":[\"portuguese\"],\"homem\":[\"portuguese\"],\"honesto\":[\"portuguese\"],\"honrado\":[\"portuguese\"],\"hormonal\":[\"portuguese\"],\"hospedar\":[\"portuguese\"],\"humorado\":[\"portuguese\"],\"iate\":[\"portuguese\"],\"ideia\":[\"portuguese\"],\"idoso\":[\"portuguese\"],\"ignorado\":[\"portuguese\"],\"igreja\":[\"portuguese\"],\"iguana\":[\"portuguese\"],\"ileso\":[\"portuguese\"],\"ilha\":[\"portuguese\"],\"iludido\":[\"portuguese\"],\"iluminar\":[\"portuguese\"],\"ilustrar\":[\"portuguese\"],\"imagem\":[\"portuguese\"],\"imediato\":[\"portuguese\"],\"imenso\":[\"portuguese\"],\"imersivo\":[\"portuguese\"],\"iminente\":[\"portuguese\"],\"imitador\":[\"portuguese\"],\"imortal\":[\"portuguese\"],\"impacto\":[\"portuguese\"],\"impedir\":[\"portuguese\"],\"implante\":[\"portuguese\"],\"impor\":[\"portuguese\"],\"imprensa\":[\"portuguese\"],\"impune\":[\"portuguese\"],\"imunizar\":[\"portuguese\"],\"inalador\":[\"portuguese\"],\"inapto\":[\"portuguese\"],\"inativo\":[\"portuguese\"],\"incenso\":[\"portuguese\"],\"inchar\":[\"portuguese\"],\"incidir\":[\"portuguese\"],\"incluir\":[\"portuguese\"],\"incolor\":[\"portuguese\"],\"indeciso\":[\"portuguese\"],\"indireto\":[\"portuguese\"],\"indutor\":[\"portuguese\"],\"ineficaz\":[\"portuguese\"],\"inerente\":[\"portuguese\"],\"infantil\":[\"portuguese\"],\"infestar\":[\"portuguese\"],\"infinito\":[\"portuguese\"],\"inflamar\":[\"portuguese\"],\"informal\":[\"portuguese\"],\"infrator\":[\"portuguese\"],\"ingerir\":[\"portuguese\"],\"inibido\":[\"portuguese\"],\"inicial\":[\"portuguese\"],\"inimigo\":[\"portuguese\"],\"injetar\":[\"portuguese\"],\"inocente\":[\"portuguese\"],\"inodoro\":[\"portuguese\"],\"inovador\":[\"portuguese\"],\"inox\":[\"portuguese\"],\"inquieto\":[\"portuguese\"],\"inscrito\":[\"portuguese\"],\"inseto\":[\"portuguese\"],\"insistir\":[\"portuguese\"],\"inspetor\":[\"portuguese\"],\"instalar\":[\"portuguese\"],\"insulto\":[\"portuguese\"],\"intacto\":[\"portuguese\"],\"integral\":[\"portuguese\"],\"intimar\":[\"portuguese\"],\"intocado\":[\"portuguese\"],\"intriga\":[\"portuguese\"],\"invasor\":[\"portuguese\"],\"inverno\":[\"portuguese\"],\"invicto\":[\"portuguese\"],\"invocar\":[\"portuguese\"],\"iogurte\":[\"portuguese\"],\"iraniano\":[\"portuguese\"],\"ironizar\":[\"portuguese\"],\"irreal\":[\"portuguese\"],\"irritado\":[\"portuguese\"],\"isca\":[\"portuguese\"],\"isento\":[\"portuguese\"],\"isolado\":[\"portuguese\"],\"isqueiro\":[\"portuguese\"],\"italiano\":[\"portuguese\"],\"janeiro\":[\"portuguese\"],\"jangada\":[\"portuguese\"],\"janta\":[\"portuguese\"],\"jararaca\":[\"portuguese\"],\"jardim\":[\"portuguese\"],\"jarro\":[\"portuguese\"],\"jasmim\":[\"portuguese\"],\"jato\":[\"portuguese\"],\"javali\":[\"portuguese\"],\"jazida\":[\"portuguese\"],\"jejum\":[\"portuguese\"],\"joaninha\":[\"portuguese\"],\"joelhada\":[\"portuguese\"],\"jogador\":[\"portuguese\"],\"joia\":[\"portuguese\"],\"jornal\":[\"portuguese\"],\"jorrar\":[\"portuguese\"],\"jovem\":[\"portuguese\"],\"juba\":[\"portuguese\"],\"judeu\":[\"portuguese\"],\"judoca\":[\"portuguese\"],\"juiz\":[\"portuguese\"],\"julgador\":[\"portuguese\"],\"julho\":[\"portuguese\"],\"jurado\":[\"portuguese\"],\"jurista\":[\"portuguese\"],\"juro\":[\"portuguese\"],\"justa\":[\"portuguese\"],\"labareda\":[\"portuguese\"],\"laboral\":[\"portuguese\"],\"lacre\":[\"portuguese\"],\"lactante\":[\"portuguese\"],\"ladrilho\":[\"portuguese\"],\"lagarta\":[\"portuguese\"],\"lagoa\":[\"portuguese\"],\"laje\":[\"portuguese\"],\"lamber\":[\"portuguese\"],\"lamentar\":[\"portuguese\"],\"laminar\":[\"portuguese\"],\"lampejo\":[\"portuguese\"],\"lanche\":[\"portuguese\"],\"lapidar\":[\"portuguese\"],\"lapso\":[\"portuguese\"],\"laranja\":[\"portuguese\"],\"lareira\":[\"portuguese\"],\"largura\":[\"portuguese\"],\"lasanha\":[\"portuguese\"],\"lastro\":[\"portuguese\"],\"lateral\":[\"portuguese\"],\"latido\":[\"portuguese\"],\"lavanda\":[\"portuguese\"],\"lavoura\":[\"portuguese\"],\"lavrador\":[\"portuguese\"],\"laxante\":[\"portuguese\"],\"lazer\":[\"portuguese\"],\"lealdade\":[\"portuguese\"],\"lebre\":[\"portuguese\"],\"legado\":[\"portuguese\"],\"legendar\":[\"portuguese\"],\"legista\":[\"portuguese\"],\"leigo\":[\"portuguese\"],\"leiloar\":[\"portuguese\"],\"leitura\":[\"portuguese\"],\"lembrete\":[\"portuguese\"],\"leme\":[\"portuguese\"],\"lenhador\":[\"portuguese\"],\"lentilha\":[\"portuguese\"],\"leoa\":[\"portuguese\"],\"lesma\":[\"portuguese\"],\"leste\":[\"portuguese\"],\"letivo\":[\"portuguese\"],\"letreiro\":[\"portuguese\"],\"levar\":[\"portuguese\"],\"leveza\":[\"portuguese\"],\"levitar\":[\"portuguese\"],\"liberal\":[\"portuguese\"],\"libido\":[\"portuguese\"],\"liderar\":[\"portuguese\"],\"ligar\":[\"portuguese\"],\"ligeiro\":[\"portuguese\"],\"limitar\":[\"portuguese\"],\"limoeiro\":[\"portuguese\"],\"limpador\":[\"portuguese\"],\"linda\":[\"portuguese\"],\"linear\":[\"portuguese\"],\"linhagem\":[\"portuguese\"],\"liquidez\":[\"portuguese\"],\"listagem\":[\"portuguese\"],\"lisura\":[\"portuguese\"],\"litoral\":[\"portuguese\"],\"livro\":[\"portuguese\"],\"lixa\":[\"portuguese\"],\"lixeira\":[\"portuguese\"],\"locador\":[\"portuguese\"],\"locutor\":[\"portuguese\"],\"lojista\":[\"portuguese\"],\"lombo\":[\"portuguese\"],\"lona\":[\"portuguese\"],\"longe\":[\"portuguese\"],\"lontra\":[\"portuguese\"],\"lorde\":[\"portuguese\"],\"lotado\":[\"portuguese\"],\"loteria\":[\"portuguese\"],\"loucura\":[\"portuguese\"],\"lousa\":[\"portuguese\"],\"louvar\":[\"portuguese\"],\"luar\":[\"portuguese\"],\"lucidez\":[\"portuguese\"],\"lucro\":[\"portuguese\"],\"luneta\":[\"portuguese\"],\"lustre\":[\"portuguese\"],\"lutador\":[\"portuguese\"],\"luva\":[\"portuguese\"],\"macaco\":[\"portuguese\"],\"macete\":[\"portuguese\"],\"machado\":[\"portuguese\"],\"macio\":[\"portuguese\"],\"madeira\":[\"portuguese\"],\"madrinha\":[\"portuguese\"],\"magnata\":[\"portuguese\"],\"magreza\":[\"portuguese\"],\"maior\":[\"portuguese\"],\"mais\":[\"portuguese\"],\"malandro\":[\"portuguese\"],\"malha\":[\"portuguese\"],\"malote\":[\"portuguese\"],\"maluco\":[\"portuguese\"],\"mamilo\":[\"portuguese\"],\"mamoeiro\":[\"portuguese\"],\"mamute\":[\"portuguese\"],\"manada\":[\"portuguese\"],\"mancha\":[\"portuguese\"],\"mandato\":[\"portuguese\"],\"manequim\":[\"portuguese\"],\"manhoso\":[\"portuguese\"],\"manivela\":[\"portuguese\"],\"manobrar\":[\"portuguese\"],\"mansa\":[\"portuguese\"],\"manter\":[\"portuguese\"],\"manusear\":[\"portuguese\"],\"mapeado\":[\"portuguese\"],\"maquinar\":[\"portuguese\"],\"marcador\":[\"portuguese\"],\"maresia\":[\"portuguese\"],\"marfim\":[\"portuguese\"],\"margem\":[\"portuguese\"],\"marinho\":[\"portuguese\"],\"marmita\":[\"portuguese\"],\"maroto\":[\"portuguese\"],\"marquise\":[\"portuguese\"],\"marreco\":[\"portuguese\"],\"martelo\":[\"portuguese\"],\"marujo\":[\"portuguese\"],\"mascote\":[\"portuguese\"],\"masmorra\":[\"portuguese\"],\"massagem\":[\"portuguese\"],\"mastigar\":[\"portuguese\"],\"matagal\":[\"portuguese\"],\"materno\":[\"portuguese\"],\"matinal\":[\"portuguese\"],\"matutar\":[\"portuguese\"],\"maxilar\":[\"portuguese\"],\"medalha\":[\"portuguese\"],\"medida\":[\"portuguese\"],\"medusa\":[\"portuguese\"],\"megafone\":[\"portuguese\"],\"meiga\":[\"portuguese\"],\"melancia\":[\"portuguese\"],\"melhor\":[\"portuguese\"],\"membro\":[\"portuguese\"],\"memorial\":[\"portuguese\"],\"menino\":[\"portuguese\"],\"menos\":[\"portuguese\"],\"mensagem\":[\"portuguese\"],\"mental\":[\"portuguese\"],\"merecer\":[\"portuguese\"],\"mergulho\":[\"portuguese\"],\"mesada\":[\"portuguese\"],\"mesclar\":[\"portuguese\"],\"mesmo\":[\"portuguese\"],\"mesquita\":[\"portuguese\"],\"mestre\":[\"portuguese\"],\"metade\":[\"portuguese\"],\"meteoro\":[\"portuguese\"],\"metragem\":[\"portuguese\"],\"mexer\":[\"portuguese\"],\"mexicano\":[\"portuguese\"],\"micro\":[\"portuguese\"],\"migalha\":[\"portuguese\"],\"migrar\":[\"portuguese\"],\"milagre\":[\"portuguese\"],\"milenar\":[\"portuguese\"],\"milhar\":[\"portuguese\"],\"mimado\":[\"portuguese\"],\"minerar\":[\"portuguese\"],\"minhoca\":[\"portuguese\"],\"ministro\":[\"portuguese\"],\"minoria\":[\"portuguese\"],\"miolo\":[\"portuguese\"],\"mirante\":[\"portuguese\"],\"mirtilo\":[\"portuguese\"],\"misturar\":[\"portuguese\"],\"mocidade\":[\"portuguese\"],\"moderno\":[\"portuguese\"],\"modular\":[\"portuguese\"],\"moeda\":[\"portuguese\"],\"moer\":[\"portuguese\"],\"moinho\":[\"portuguese\"],\"moita\":[\"portuguese\"],\"moldura\":[\"portuguese\"],\"moleza\":[\"portuguese\"],\"molho\":[\"portuguese\"],\"molinete\":[\"portuguese\"],\"molusco\":[\"portuguese\"],\"montanha\":[\"portuguese\"],\"moqueca\":[\"portuguese\"],\"morango\":[\"portuguese\"],\"morcego\":[\"portuguese\"],\"mordomo\":[\"portuguese\"],\"morena\":[\"portuguese\"],\"mosaico\":[\"portuguese\"],\"mosquete\":[\"portuguese\"],\"mostarda\":[\"portuguese\"],\"motel\":[\"portuguese\"],\"motim\":[\"portuguese\"],\"moto\":[\"portuguese\"],\"motriz\":[\"portuguese\"],\"muda\":[\"portuguese\"],\"muito\":[\"portuguese\"],\"mulata\":[\"portuguese\"],\"mulher\":[\"portuguese\"],\"multar\":[\"portuguese\"],\"mundial\":[\"portuguese\"],\"munido\":[\"portuguese\"],\"muralha\":[\"portuguese\"],\"murcho\":[\"portuguese\"],\"muscular\":[\"portuguese\"],\"museu\":[\"portuguese\"],\"musical\":[\"portuguese\"],\"nacional\":[\"portuguese\"],\"nadador\":[\"portuguese\"],\"naja\":[\"portuguese\"],\"namoro\":[\"portuguese\"],\"narina\":[\"portuguese\"],\"narrado\":[\"portuguese\"],\"nascer\":[\"portuguese\"],\"nativa\":[\"portuguese\"],\"natureza\":[\"portuguese\"],\"navalha\":[\"portuguese\"],\"navegar\":[\"portuguese\"],\"navio\":[\"portuguese\"],\"neblina\":[\"portuguese\"],\"nebuloso\":[\"portuguese\"],\"negativa\":[\"portuguese\"],\"negociar\":[\"portuguese\"],\"negrito\":[\"portuguese\"],\"nervoso\":[\"portuguese\"],\"neta\":[\"portuguese\"],\"neural\":[\"portuguese\"],\"nevasca\":[\"portuguese\"],\"nevoeiro\":[\"portuguese\"],\"ninar\":[\"portuguese\"],\"ninho\":[\"portuguese\"],\"nitidez\":[\"portuguese\"],\"nivelar\":[\"portuguese\"],\"nobreza\":[\"portuguese\"],\"noite\":[\"portuguese\"],\"noiva\":[\"portuguese\"],\"nomear\":[\"portuguese\"],\"nominal\":[\"portuguese\"],\"nordeste\":[\"portuguese\"],\"nortear\":[\"portuguese\"],\"notar\":[\"portuguese\"],\"noticiar\":[\"portuguese\"],\"noturno\":[\"portuguese\"],\"novelo\":[\"portuguese\"],\"novilho\":[\"portuguese\"],\"novo\":[\"portuguese\"],\"nublado\":[\"portuguese\"],\"nudez\":[\"portuguese\"],\"numeral\":[\"portuguese\"],\"nupcial\":[\"portuguese\"],\"nutrir\":[\"portuguese\"],\"nuvem\":[\"portuguese\"],\"obcecado\":[\"portuguese\"],\"obedecer\":[\"portuguese\"],\"objetivo\":[\"portuguese\"],\"obrigado\":[\"portuguese\"],\"obscuro\":[\"portuguese\"],\"obstetra\":[\"portuguese\"],\"obter\":[\"portuguese\"],\"obturar\":[\"portuguese\"],\"ocidente\":[\"portuguese\"],\"ocioso\":[\"portuguese\"],\"ocorrer\":[\"portuguese\"],\"oculista\":[\"portuguese\"],\"ocupado\":[\"portuguese\"],\"ofegante\":[\"portuguese\"],\"ofensiva\":[\"portuguese\"],\"oferenda\":[\"portuguese\"],\"oficina\":[\"portuguese\"],\"ofuscado\":[\"portuguese\"],\"ogiva\":[\"portuguese\"],\"olaria\":[\"portuguese\"],\"oleoso\":[\"portuguese\"],\"olhar\":[\"portuguese\"],\"oliveira\":[\"portuguese\"],\"ombro\":[\"portuguese\"],\"omelete\":[\"portuguese\"],\"omisso\":[\"portuguese\"],\"omitir\":[\"portuguese\"],\"ondulado\":[\"portuguese\"],\"oneroso\":[\"portuguese\"],\"ontem\":[\"portuguese\"],\"opcional\":[\"portuguese\"],\"operador\":[\"portuguese\"],\"oponente\":[\"portuguese\"],\"oportuno\":[\"portuguese\"],\"oposto\":[\"portuguese\"],\"orar\":[\"portuguese\"],\"orbitar\":[\"portuguese\"],\"ordem\":[\"portuguese\"],\"ordinal\":[\"portuguese\"],\"orfanato\":[\"portuguese\"],\"orgasmo\":[\"portuguese\"],\"orgulho\":[\"portuguese\"],\"oriental\":[\"portuguese\"],\"origem\":[\"portuguese\"],\"oriundo\":[\"portuguese\"],\"orla\":[\"portuguese\"],\"ortodoxo\":[\"portuguese\"],\"orvalho\":[\"portuguese\"],\"oscilar\":[\"portuguese\"],\"ossada\":[\"portuguese\"],\"osso\":[\"portuguese\"],\"ostentar\":[\"portuguese\"],\"otimismo\":[\"portuguese\"],\"ousadia\":[\"portuguese\"],\"outono\":[\"portuguese\"],\"outubro\":[\"portuguese\"],\"ouvido\":[\"portuguese\"],\"ovelha\":[\"portuguese\"],\"ovular\":[\"portuguese\"],\"oxidar\":[\"portuguese\"],\"oxigenar\":[\"portuguese\"],\"pacato\":[\"portuguese\"],\"paciente\":[\"portuguese\"],\"pacote\":[\"portuguese\"],\"pactuar\":[\"portuguese\"],\"padaria\":[\"portuguese\"],\"padrinho\":[\"portuguese\"],\"pagar\":[\"portuguese\"],\"pagode\":[\"portuguese\"],\"painel\":[\"portuguese\"],\"pairar\":[\"portuguese\"],\"paisagem\":[\"portuguese\"],\"palavra\":[\"portuguese\"],\"palestra\":[\"portuguese\"],\"palheta\":[\"portuguese\"],\"palito\":[\"portuguese\"],\"palmada\":[\"portuguese\"],\"palpitar\":[\"portuguese\"],\"pancada\":[\"portuguese\"],\"panela\":[\"portuguese\"],\"panfleto\":[\"portuguese\"],\"panqueca\":[\"portuguese\"],\"pantanal\":[\"portuguese\"],\"papagaio\":[\"portuguese\"],\"papelada\":[\"portuguese\"],\"papiro\":[\"portuguese\"],\"parafina\":[\"portuguese\"],\"parcial\":[\"portuguese\"],\"pardal\":[\"portuguese\"],\"parede\":[\"portuguese\"],\"partida\":[\"portuguese\"],\"pasmo\":[\"portuguese\"],\"passado\":[\"portuguese\"],\"pastel\":[\"portuguese\"],\"patamar\":[\"portuguese\"],\"patente\":[\"portuguese\"],\"patinar\":[\"portuguese\"],\"patrono\":[\"portuguese\"],\"paulada\":[\"portuguese\"],\"pausar\":[\"portuguese\"],\"peculiar\":[\"portuguese\"],\"pedalar\":[\"portuguese\"],\"pedestre\":[\"portuguese\"],\"pediatra\":[\"portuguese\"],\"pedra\":[\"portuguese\"],\"pegada\":[\"portuguese\"],\"peitoral\":[\"portuguese\"],\"peixe\":[\"portuguese\"],\"pele\":[\"portuguese\"],\"pelicano\":[\"portuguese\"],\"penca\":[\"portuguese\"],\"pendurar\":[\"portuguese\"],\"peneira\":[\"portuguese\"],\"penhasco\":[\"portuguese\"],\"pensador\":[\"portuguese\"],\"pente\":[\"portuguese\"],\"perceber\":[\"portuguese\"],\"perfeito\":[\"portuguese\"],\"pergunta\":[\"portuguese\"],\"perito\":[\"portuguese\"],\"permitir\":[\"portuguese\"],\"perna\":[\"portuguese\"],\"perplexo\":[\"portuguese\"],\"persiana\":[\"portuguese\"],\"pertence\":[\"portuguese\"],\"peruca\":[\"portuguese\"],\"pescado\":[\"portuguese\"],\"pesquisa\":[\"portuguese\"],\"pessoa\":[\"portuguese\"],\"petiscar\":[\"portuguese\"],\"piada\":[\"portuguese\"],\"picado\":[\"portuguese\"],\"piedade\":[\"portuguese\"],\"pigmento\":[\"portuguese\"],\"pilastra\":[\"portuguese\"],\"pilhado\":[\"portuguese\"],\"pilotar\":[\"portuguese\"],\"pimenta\":[\"portuguese\"],\"pincel\":[\"portuguese\"],\"pinguim\":[\"portuguese\"],\"pinha\":[\"portuguese\"],\"pinote\":[\"portuguese\"],\"pintar\":[\"portuguese\"],\"pioneiro\":[\"portuguese\"],\"pipoca\":[\"portuguese\"],\"piquete\":[\"portuguese\"],\"piranha\":[\"portuguese\"],\"pires\":[\"portuguese\"],\"pirueta\":[\"portuguese\"],\"piscar\":[\"portuguese\"],\"pistola\":[\"portuguese\"],\"pitanga\":[\"portuguese\"],\"pivete\":[\"portuguese\"],\"planta\":[\"portuguese\"],\"plaqueta\":[\"portuguese\"],\"platina\":[\"portuguese\"],\"plebeu\":[\"portuguese\"],\"plumagem\":[\"portuguese\"],\"pluvial\":[\"portuguese\"],\"pneu\":[\"portuguese\"],\"poda\":[\"portuguese\"],\"poeira\":[\"portuguese\"],\"poetisa\":[\"portuguese\"],\"polegada\":[\"portuguese\"],\"policiar\":[\"portuguese\"],\"poluente\":[\"portuguese\"],\"polvilho\":[\"portuguese\"],\"pomar\":[\"portuguese\"],\"pomba\":[\"portuguese\"],\"ponderar\":[\"portuguese\"],\"pontaria\":[\"portuguese\"],\"populoso\":[\"portuguese\"],\"porta\":[\"portuguese\"],\"possuir\":[\"portuguese\"],\"postal\":[\"portuguese\"],\"pote\":[\"portuguese\"],\"poupar\":[\"portuguese\"],\"pouso\":[\"portuguese\"],\"povoar\":[\"portuguese\"],\"praia\":[\"portuguese\"],\"prancha\":[\"portuguese\"],\"prato\":[\"portuguese\"],\"praxe\":[\"portuguese\"],\"prece\":[\"portuguese\"],\"predador\":[\"portuguese\"],\"prefeito\":[\"portuguese\"],\"premiar\":[\"portuguese\"],\"prensar\":[\"portuguese\"],\"preparar\":[\"portuguese\"],\"presilha\":[\"portuguese\"],\"pretexto\":[\"portuguese\"],\"prevenir\":[\"portuguese\"],\"prezar\":[\"portuguese\"],\"primata\":[\"portuguese\"],\"princesa\":[\"portuguese\"],\"prisma\":[\"portuguese\"],\"privado\":[\"portuguese\"],\"processo\":[\"portuguese\"],\"produto\":[\"portuguese\"],\"profeta\":[\"portuguese\"],\"proibido\":[\"portuguese\"],\"projeto\":[\"portuguese\"],\"prometer\":[\"portuguese\"],\"propagar\":[\"portuguese\"],\"prosa\":[\"portuguese\"],\"protetor\":[\"portuguese\"],\"provador\":[\"portuguese\"],\"publicar\":[\"portuguese\"],\"pudim\":[\"portuguese\"],\"pular\":[\"portuguese\"],\"pulmonar\":[\"portuguese\"],\"pulseira\":[\"portuguese\"],\"punhal\":[\"portuguese\"],\"punir\":[\"portuguese\"],\"pupilo\":[\"portuguese\"],\"pureza\":[\"portuguese\"],\"puxador\":[\"portuguese\"],\"quadra\":[\"portuguese\"],\"quantia\":[\"portuguese\"],\"quarto\":[\"portuguese\"],\"quase\":[\"portuguese\"],\"quebrar\":[\"portuguese\"],\"queda\":[\"portuguese\"],\"queijo\":[\"portuguese\"],\"quente\":[\"portuguese\"],\"querido\":[\"portuguese\"],\"quimono\":[\"portuguese\"],\"quina\":[\"portuguese\"],\"quiosque\":[\"portuguese\"],\"rabanada\":[\"portuguese\"],\"rabisco\":[\"portuguese\"],\"rachar\":[\"portuguese\"],\"racionar\":[\"portuguese\"],\"radial\":[\"portuguese\"],\"raiar\":[\"portuguese\"],\"rainha\":[\"portuguese\"],\"raio\":[\"portuguese\"],\"raiva\":[\"portuguese\"],\"rajada\":[\"portuguese\"],\"ralado\":[\"portuguese\"],\"ramal\":[\"portuguese\"],\"ranger\":[\"portuguese\"],\"ranhura\":[\"portuguese\"],\"rapadura\":[\"portuguese\"],\"rapel\":[\"portuguese\"],\"rapidez\":[\"portuguese\"],\"raposa\":[\"portuguese\"],\"raquete\":[\"portuguese\"],\"raridade\":[\"portuguese\"],\"rasante\":[\"portuguese\"],\"rascunho\":[\"portuguese\"],\"rasgar\":[\"portuguese\"],\"raspador\":[\"portuguese\"],\"rasteira\":[\"portuguese\"],\"rasurar\":[\"portuguese\"],\"ratazana\":[\"portuguese\"],\"ratoeira\":[\"portuguese\"],\"realeza\":[\"portuguese\"],\"reanimar\":[\"portuguese\"],\"reaver\":[\"portuguese\"],\"rebaixar\":[\"portuguese\"],\"rebelde\":[\"portuguese\"],\"rebolar\":[\"portuguese\"],\"recado\":[\"portuguese\"],\"recente\":[\"portuguese\"],\"recheio\":[\"portuguese\"],\"recibo\":[\"portuguese\"],\"recordar\":[\"portuguese\"],\"recrutar\":[\"portuguese\"],\"recuar\":[\"portuguese\"],\"rede\":[\"portuguese\"],\"redimir\":[\"portuguese\"],\"redonda\":[\"portuguese\"],\"reduzida\":[\"portuguese\"],\"reenvio\":[\"portuguese\"],\"refinar\":[\"portuguese\"],\"refletir\":[\"portuguese\"],\"refogar\":[\"portuguese\"],\"refresco\":[\"portuguese\"],\"refugiar\":[\"portuguese\"],\"regalia\":[\"portuguese\"],\"regime\":[\"portuguese\"],\"regra\":[\"portuguese\"],\"reinado\":[\"portuguese\"],\"reitor\":[\"portuguese\"],\"rejeitar\":[\"portuguese\"],\"relativo\":[\"portuguese\"],\"remador\":[\"portuguese\"],\"remendo\":[\"portuguese\"],\"remorso\":[\"portuguese\"],\"renovado\":[\"portuguese\"],\"reparo\":[\"portuguese\"],\"repelir\":[\"portuguese\"],\"repleto\":[\"portuguese\"],\"repolho\":[\"portuguese\"],\"represa\":[\"portuguese\"],\"repudiar\":[\"portuguese\"],\"requerer\":[\"portuguese\"],\"resenha\":[\"portuguese\"],\"resfriar\":[\"portuguese\"],\"resgatar\":[\"portuguese\"],\"residir\":[\"portuguese\"],\"resolver\":[\"portuguese\"],\"respeito\":[\"portuguese\"],\"ressaca\":[\"portuguese\"],\"restante\":[\"portuguese\"],\"resumir\":[\"portuguese\"],\"retalho\":[\"portuguese\"],\"reter\":[\"portuguese\"],\"retirar\":[\"portuguese\"],\"retomada\":[\"portuguese\"],\"retratar\":[\"portuguese\"],\"revelar\":[\"portuguese\"],\"revisor\":[\"portuguese\"],\"revolta\":[\"portuguese\"],\"riacho\":[\"portuguese\"],\"rica\":[\"portuguese\"],\"rigidez\":[\"portuguese\"],\"rigoroso\":[\"portuguese\"],\"rimar\":[\"portuguese\"],\"ringue\":[\"portuguese\"],\"risada\":[\"portuguese\"],\"risco\":[\"portuguese\"],\"risonho\":[\"portuguese\"],\"robalo\":[\"portuguese\"],\"rochedo\":[\"portuguese\"],\"rodada\":[\"portuguese\"],\"rodeio\":[\"portuguese\"],\"rodovia\":[\"portuguese\"],\"roedor\":[\"portuguese\"],\"roleta\":[\"portuguese\"],\"romano\":[\"portuguese\"],\"roncar\":[\"portuguese\"],\"rosado\":[\"portuguese\"],\"roseira\":[\"portuguese\"],\"rosto\":[\"portuguese\"],\"rota\":[\"portuguese\",\"turkish\"],\"roteiro\":[\"portuguese\"],\"rotina\":[\"portuguese\"],\"rotular\":[\"portuguese\"],\"rouco\":[\"portuguese\"],\"roupa\":[\"portuguese\"],\"roxo\":[\"portuguese\"],\"rubro\":[\"portuguese\"],\"rugido\":[\"portuguese\"],\"rugoso\":[\"portuguese\"],\"ruivo\":[\"portuguese\"],\"rumo\":[\"portuguese\"],\"rupestre\":[\"portuguese\"],\"russo\":[\"portuguese\"],\"sabor\":[\"portuguese\"],\"saciar\":[\"portuguese\"],\"sacola\":[\"portuguese\"],\"sacudir\":[\"portuguese\"],\"sadio\":[\"portuguese\"],\"safira\":[\"portuguese\"],\"saga\":[\"portuguese\"],\"sagrada\":[\"portuguese\"],\"saibro\":[\"portuguese\"],\"salada\":[\"portuguese\"],\"saleiro\":[\"portuguese\"],\"salgado\":[\"portuguese\"],\"saliva\":[\"portuguese\"],\"salpicar\":[\"portuguese\"],\"salsicha\":[\"portuguese\"],\"saltar\":[\"portuguese\"],\"salvador\":[\"portuguese\"],\"sambar\":[\"portuguese\"],\"samurai\":[\"portuguese\"],\"sanar\":[\"portuguese\"],\"sanfona\":[\"portuguese\"],\"sangue\":[\"portuguese\"],\"sanidade\":[\"portuguese\"],\"sapato\":[\"portuguese\"],\"sarda\":[\"portuguese\"],\"sargento\":[\"portuguese\"],\"sarjeta\":[\"portuguese\"],\"saturar\":[\"portuguese\"],\"saudade\":[\"portuguese\"],\"saxofone\":[\"portuguese\"],\"sazonal\":[\"portuguese\"],\"secar\":[\"portuguese\"],\"secular\":[\"portuguese\"],\"seda\":[\"portuguese\",\"turkish\"],\"sedento\":[\"portuguese\"],\"sediado\":[\"portuguese\"],\"sedoso\":[\"portuguese\"],\"sedutor\":[\"portuguese\"],\"segmento\":[\"portuguese\"],\"segredo\":[\"portuguese\"],\"segundo\":[\"portuguese\"],\"seiva\":[\"portuguese\"],\"seleto\":[\"portuguese\"],\"selvagem\":[\"portuguese\"],\"semanal\":[\"portuguese\"],\"semente\":[\"portuguese\"],\"senador\":[\"portuguese\"],\"senhor\":[\"portuguese\"],\"sensual\":[\"portuguese\"],\"sentado\":[\"portuguese\"],\"separado\":[\"portuguese\"],\"sereia\":[\"portuguese\"],\"seringa\":[\"portuguese\"],\"serra\":[\"portuguese\"],\"servo\":[\"portuguese\"],\"setembro\":[\"portuguese\"],\"setor\":[\"portuguese\"],\"sigilo\":[\"portuguese\"],\"silhueta\":[\"portuguese\"],\"silicone\":[\"portuguese\"],\"simetria\":[\"portuguese\"],\"simpatia\":[\"portuguese\"],\"simular\":[\"portuguese\"],\"sinal\":[\"portuguese\"],\"sincero\":[\"portuguese\"],\"singular\":[\"portuguese\"],\"sinopse\":[\"portuguese\"],\"sintonia\":[\"portuguese\"],\"sirene\":[\"portuguese\"],\"siri\":[\"portuguese\"],\"situado\":[\"portuguese\"],\"soberano\":[\"portuguese\"],\"sobra\":[\"portuguese\"],\"socorro\":[\"portuguese\"],\"sogro\":[\"portuguese\"],\"soja\":[\"portuguese\"],\"solda\":[\"portuguese\"],\"soletrar\":[\"portuguese\"],\"solteiro\":[\"portuguese\"],\"sombrio\":[\"portuguese\"],\"sonata\":[\"portuguese\"],\"sondar\":[\"portuguese\"],\"sonegar\":[\"portuguese\"],\"sonhador\":[\"portuguese\"],\"sono\":[\"portuguese\"],\"soprano\":[\"portuguese\"],\"soquete\":[\"portuguese\"],\"sorrir\":[\"portuguese\"],\"sorteio\":[\"portuguese\"],\"sossego\":[\"portuguese\"],\"sotaque\":[\"portuguese\"],\"soterrar\":[\"portuguese\"],\"sovado\":[\"portuguese\"],\"sozinho\":[\"portuguese\"],\"suavizar\":[\"portuguese\"],\"subida\":[\"portuguese\"],\"submerso\":[\"portuguese\"],\"subsolo\":[\"portuguese\"],\"subtrair\":[\"portuguese\"],\"sucata\":[\"portuguese\"],\"sucesso\":[\"portuguese\"],\"suco\":[\"portuguese\"],\"sudeste\":[\"portuguese\"],\"sufixo\":[\"portuguese\"],\"sugador\":[\"portuguese\"],\"sugerir\":[\"portuguese\"],\"sujeito\":[\"portuguese\"],\"sulfato\":[\"portuguese\"],\"sumir\":[\"portuguese\"],\"suor\":[\"portuguese\"],\"superior\":[\"portuguese\"],\"suplicar\":[\"portuguese\"],\"suposto\":[\"portuguese\"],\"suprimir\":[\"portuguese\"],\"surdina\":[\"portuguese\"],\"surfista\":[\"portuguese\"],\"surpresa\":[\"portuguese\"],\"surreal\":[\"portuguese\"],\"surtir\":[\"portuguese\"],\"suspiro\":[\"portuguese\"],\"sustento\":[\"portuguese\"],\"tabela\":[\"portuguese\",\"turkish\"],\"tablete\":[\"portuguese\"],\"tabuada\":[\"portuguese\"],\"tacho\":[\"portuguese\"],\"tagarela\":[\"portuguese\"],\"talher\":[\"portuguese\"],\"talo\":[\"portuguese\"],\"talvez\":[\"portuguese\"],\"tamanho\":[\"portuguese\"],\"tamborim\":[\"portuguese\"],\"tampa\":[\"portuguese\"],\"tangente\":[\"portuguese\"],\"tanto\":[\"portuguese\"],\"tapar\":[\"portuguese\"],\"tapioca\":[\"portuguese\"],\"tardio\":[\"portuguese\"],\"tarefa\":[\"portuguese\"],\"tarja\":[\"portuguese\"],\"tarraxa\":[\"portuguese\"],\"tatuagem\":[\"portuguese\"],\"taurino\":[\"portuguese\"],\"taxativo\":[\"portuguese\"],\"taxista\":[\"portuguese\"],\"teatral\":[\"portuguese\"],\"tecer\":[\"portuguese\"],\"tecido\":[\"portuguese\"],\"teclado\":[\"portuguese\"],\"tedioso\":[\"portuguese\"],\"teia\":[\"portuguese\"],\"teimar\":[\"portuguese\"],\"telefone\":[\"portuguese\"],\"telhado\":[\"portuguese\"],\"tempero\":[\"portuguese\"],\"tenente\":[\"portuguese\"],\"tensor\":[\"portuguese\"],\"tentar\":[\"portuguese\"],\"termal\":[\"portuguese\"],\"terno\":[\"portuguese\"],\"terreno\":[\"portuguese\"],\"tese\":[\"portuguese\"],\"tesoura\":[\"portuguese\"],\"testado\":[\"portuguese\"],\"teto\":[\"portuguese\"],\"textura\":[\"portuguese\"],\"texugo\":[\"portuguese\"],\"tiara\":[\"portuguese\"],\"tigela\":[\"portuguese\"],\"tijolo\":[\"portuguese\"],\"timbrar\":[\"portuguese\"],\"timidez\":[\"portuguese\"],\"tingido\":[\"portuguese\"],\"tinteiro\":[\"portuguese\"],\"tiragem\":[\"portuguese\"],\"titular\":[\"portuguese\"],\"toalha\":[\"portuguese\"],\"tocha\":[\"portuguese\"],\"tolerar\":[\"portuguese\"],\"tolice\":[\"portuguese\"],\"tomada\":[\"portuguese\"],\"tomilho\":[\"portuguese\"],\"tonel\":[\"portuguese\"],\"tontura\":[\"portuguese\"],\"topete\":[\"portuguese\"],\"tora\":[\"portuguese\"],\"torcido\":[\"portuguese\"],\"torneio\":[\"portuguese\"],\"torque\":[\"portuguese\"],\"torrada\":[\"portuguese\"],\"torto\":[\"portuguese\"],\"tostar\":[\"portuguese\"],\"touca\":[\"portuguese\"],\"toupeira\":[\"portuguese\"],\"toxina\":[\"portuguese\"],\"trabalho\":[\"portuguese\"],\"tracejar\":[\"portuguese\"],\"tradutor\":[\"portuguese\"],\"trafegar\":[\"portuguese\"],\"trajeto\":[\"portuguese\"],\"trama\":[\"portuguese\"],\"trancar\":[\"portuguese\"],\"trapo\":[\"portuguese\"],\"traseiro\":[\"portuguese\"],\"tratador\":[\"portuguese\"],\"travar\":[\"portuguese\"],\"treino\":[\"portuguese\"],\"tremer\":[\"portuguese\"],\"trepidar\":[\"portuguese\"],\"trevo\":[\"portuguese\"],\"triagem\":[\"portuguese\"],\"tribo\":[\"portuguese\"],\"triciclo\":[\"portuguese\"],\"tridente\":[\"portuguese\"],\"trilogia\":[\"portuguese\"],\"trindade\":[\"portuguese\"],\"triplo\":[\"portuguese\"],\"triturar\":[\"portuguese\"],\"triunfal\":[\"portuguese\"],\"trocar\":[\"portuguese\"],\"trombeta\":[\"portuguese\"],\"trova\":[\"portuguese\"],\"trunfo\":[\"portuguese\"],\"truque\":[\"portuguese\"],\"tubular\":[\"portuguese\"],\"tucano\":[\"portuguese\"],\"tudo\":[\"portuguese\"],\"tulipa\":[\"portuguese\"],\"tupi\":[\"portuguese\"],\"turbo\":[\"portuguese\"],\"turma\":[\"portuguese\"],\"turquesa\":[\"portuguese\"],\"tutelar\":[\"portuguese\"],\"tutorial\":[\"portuguese\"],\"uivar\":[\"portuguese\"],\"umbigo\":[\"portuguese\"],\"unha\":[\"portuguese\"],\"unidade\":[\"portuguese\"],\"uniforme\":[\"portuguese\"],\"urologia\":[\"portuguese\"],\"urso\":[\"portuguese\"],\"urtiga\":[\"portuguese\"],\"urubu\":[\"portuguese\"],\"usado\":[\"portuguese\"],\"usina\":[\"portuguese\"],\"usufruir\":[\"portuguese\"],\"vacina\":[\"portuguese\"],\"vadiar\":[\"portuguese\"],\"vagaroso\":[\"portuguese\"],\"vaidoso\":[\"portuguese\"],\"vala\":[\"portuguese\"],\"valente\":[\"portuguese\"],\"validade\":[\"portuguese\"],\"valores\":[\"portuguese\"],\"vantagem\":[\"portuguese\"],\"vaqueiro\":[\"portuguese\"],\"varanda\":[\"portuguese\"],\"vareta\":[\"portuguese\"],\"varrer\":[\"portuguese\"],\"vascular\":[\"portuguese\"],\"vasilha\":[\"portuguese\"],\"vassoura\":[\"portuguese\"],\"vazar\":[\"portuguese\"],\"vazio\":[\"portuguese\"],\"veado\":[\"portuguese\"],\"vedar\":[\"portuguese\"],\"vegetar\":[\"portuguese\"],\"veicular\":[\"portuguese\"],\"veleiro\":[\"portuguese\"],\"velhice\":[\"portuguese\"],\"veludo\":[\"portuguese\"],\"vencedor\":[\"portuguese\"],\"vendaval\":[\"portuguese\"],\"venerar\":[\"portuguese\"],\"ventre\":[\"portuguese\"],\"verbal\":[\"portuguese\"],\"verdade\":[\"portuguese\"],\"vereador\":[\"portuguese\"],\"vergonha\":[\"portuguese\"],\"vermelho\":[\"portuguese\"],\"verniz\":[\"portuguese\"],\"versar\":[\"portuguese\"],\"vertente\":[\"portuguese\"],\"vespa\":[\"portuguese\"],\"vestido\":[\"portuguese\"],\"vetorial\":[\"portuguese\"],\"viaduto\":[\"portuguese\"],\"viagem\":[\"portuguese\"],\"viajar\":[\"portuguese\"],\"viatura\":[\"portuguese\"],\"vibrador\":[\"portuguese\"],\"videira\":[\"portuguese\"],\"vidraria\":[\"portuguese\"],\"viela\":[\"portuguese\"],\"viga\":[\"portuguese\"],\"vigente\":[\"portuguese\"],\"vigiar\":[\"portuguese\"],\"vigorar\":[\"portuguese\"],\"vilarejo\":[\"portuguese\"],\"vinco\":[\"portuguese\"],\"vinheta\":[\"portuguese\"],\"vinil\":[\"portuguese\"],\"violeta\":[\"portuguese\"],\"virada\":[\"portuguese\"],\"virtude\":[\"portuguese\"],\"visitar\":[\"portuguese\"],\"visto\":[\"portuguese\"],\"vitral\":[\"portuguese\"],\"viveiro\":[\"portuguese\"],\"vizinho\":[\"portuguese\"],\"voador\":[\"portuguese\"],\"voar\":[\"portuguese\"],\"vogal\":[\"portuguese\"],\"volante\":[\"portuguese\"],\"voleibol\":[\"portuguese\"],\"voltagem\":[\"portuguese\"],\"volumoso\":[\"portuguese\"],\"vontade\":[\"portuguese\"],\"vulto\":[\"portuguese\"],\"vuvuzela\":[\"portuguese\"],\"xadrez\":[\"portuguese\"],\"xarope\":[\"portuguese\"],\"xeque\":[\"portuguese\"],\"xeretar\":[\"portuguese\"],\"xerife\":[\"portuguese\"],\"xingar\":[\"portuguese\"],\"zangado\":[\"portuguese\"],\"zarpar\":[\"portuguese\"],\"zebu\":[\"portuguese\"],\"zelador\":[\"portuguese\"],\"zombar\":[\"portuguese\"],\"zoologia\":[\"portuguese\"],\"zumbido\":[\"portuguese\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"\":[\"russian\"],\"abaco\":[\"spanish\"],\"abdomen\":[\"spanish\"],\"abeja\":[\"spanish\"],\"abierto\":[\"spanish\"],\"abogado\":[\"spanish\"],\"abono\":[\"spanish\"],\"aborto\":[\"spanish\"],\"abrazo\":[\"spanish\"],\"abrir\":[\"spanish\"],\"abuelo\":[\"spanish\"],\"abuso\":[\"spanish\"],\"acabar\":[\"spanish\"],\"academia\":[\"spanish\"],\"acceso\":[\"spanish\"],\"accion\":[\"spanish\"],\"aceite\":[\"spanish\"],\"acelga\":[\"spanish\"],\"acento\":[\"spanish\"],\"aceptar\":[\"spanish\"],\"acido\":[\"spanish\"],\"aclarar\":[\"spanish\"],\"acne\":[\"spanish\"],\"acoger\":[\"spanish\"],\"acoso\":[\"spanish\"],\"activo\":[\"spanish\"],\"acto\":[\"spanish\"],\"actriz\":[\"spanish\"],\"actuar\":[\"spanish\"],\"acudir\":[\"spanish\"],\"acuerdo\":[\"spanish\"],\"acusar\":[\"spanish\"],\"adicto\":[\"spanish\"],\"admitir\":[\"spanish\"],\"adoptar\":[\"spanish\"],\"adorno\":[\"spanish\"],\"aduana\":[\"spanish\"],\"adulto\":[\"spanish\"],\"aereo\":[\"spanish\"],\"afectar\":[\"spanish\"],\"aficion\":[\"spanish\"],\"afinar\":[\"spanish\"],\"afirmar\":[\"spanish\"],\"agil\":[\"spanish\"],\"agitar\":[\"spanish\"],\"agonia\":[\"spanish\"],\"agosto\":[\"spanish\"],\"agotar\":[\"spanish\"],\"agregar\":[\"spanish\"],\"agrio\":[\"spanish\"],\"agua\":[\"spanish\"],\"agudo\":[\"spanish\"],\"aguila\":[\"spanish\"],\"aguja\":[\"spanish\"],\"ahogo\":[\"spanish\"],\"ahorro\":[\"spanish\"],\"aire\":[\"spanish\"],\"aislar\":[\"spanish\"],\"ajedrez\":[\"spanish\"],\"ajeno\":[\"spanish\"],\"ajuste\":[\"spanish\"],\"alacran\":[\"spanish\"],\"alambre\":[\"spanish\"],\"alarma\":[\"spanish\"],\"alba\":[\"spanish\"],\"album\":[\"spanish\"],\"alcalde\":[\"spanish\"],\"aldea\":[\"spanish\"],\"alegre\":[\"spanish\"],\"alejar\":[\"spanish\"],\"alerta\":[\"spanish\"],\"aleta\":[\"spanish\"],\"alfiler\":[\"spanish\"],\"alga\":[\"spanish\"],\"algodon\":[\"spanish\"],\"aliado\":[\"spanish\"],\"aliento\":[\"spanish\"],\"alivio\":[\"spanish\"],\"alma\":[\"spanish\"],\"almeja\":[\"spanish\"],\"almibar\":[\"spanish\"],\"altar\":[\"spanish\"],\"alteza\":[\"spanish\"],\"altivo\":[\"spanish\"],\"alto\":[\"spanish\"],\"altura\":[\"spanish\"],\"alumno\":[\"spanish\"],\"alzar\":[\"spanish\"],\"amable\":[\"spanish\"],\"amante\":[\"spanish\"],\"amapola\":[\"spanish\"],\"amargo\":[\"spanish\"],\"amasar\":[\"spanish\"],\"ambar\":[\"spanish\"],\"ambito\":[\"spanish\"],\"ameno\":[\"spanish\"],\"amigo\":[\"spanish\",\"turkish\"],\"amistad\":[\"spanish\"],\"amor\":[\"spanish\"],\"amparo\":[\"spanish\"],\"amplio\":[\"spanish\"],\"ancho\":[\"spanish\"],\"anciano\":[\"spanish\"],\"ancla\":[\"spanish\"],\"andar\":[\"spanish\"],\"anden\":[\"spanish\"],\"anemia\":[\"spanish\"],\"angulo\":[\"spanish\"],\"anillo\":[\"spanish\"],\"animo\":[\"spanish\"],\"anis\":[\"spanish\"],\"anotar\":[\"spanish\"],\"antena\":[\"spanish\"],\"antiguo\":[\"spanish\"],\"antojo\":[\"spanish\"],\"anual\":[\"spanish\"],\"anular\":[\"spanish\"],\"anuncio\":[\"spanish\"],\"anadir\":[\"spanish\"],\"anejo\":[\"spanish\"],\"ano\":[\"spanish\"],\"apagar\":[\"spanish\"],\"aparato\":[\"spanish\"],\"apetito\":[\"spanish\"],\"apio\":[\"spanish\"],\"aplicar\":[\"spanish\"],\"apodo\":[\"spanish\"],\"aporte\":[\"spanish\"],\"apoyo\":[\"spanish\"],\"aprender\":[\"spanish\"],\"aprobar\":[\"spanish\"],\"apuesta\":[\"spanish\"],\"apuro\":[\"spanish\"],\"arado\":[\"spanish\"],\"arana\":[\"spanish\"],\"arar\":[\"spanish\"],\"arbitro\":[\"spanish\"],\"arbol\":[\"spanish\"],\"arbusto\":[\"spanish\"],\"archivo\":[\"spanish\"],\"arco\":[\"spanish\"],\"arder\":[\"spanish\"],\"ardilla\":[\"spanish\"],\"arduo\":[\"spanish\"],\"area\":[\"spanish\"],\"arido\":[\"spanish\"],\"aries\":[\"spanish\"],\"armonia\":[\"spanish\"],\"arnes\":[\"spanish\"],\"aroma\":[\"spanish\",\"turkish\"],\"arpa\":[\"spanish\"],\"arpon\":[\"spanish\"],\"arreglo\":[\"spanish\"],\"arroz\":[\"spanish\"],\"arruga\":[\"spanish\"],\"arte\":[\"spanish\"],\"artista\":[\"spanish\"],\"asa\":[\"spanish\"],\"asado\":[\"spanish\"],\"asalto\":[\"spanish\"],\"ascenso\":[\"spanish\"],\"asegurar\":[\"spanish\"],\"aseo\":[\"spanish\"],\"asesor\":[\"spanish\"],\"asiento\":[\"spanish\"],\"asilo\":[\"spanish\"],\"asistir\":[\"spanish\"],\"asno\":[\"spanish\"],\"asombro\":[\"spanish\"],\"aspero\":[\"spanish\"],\"astilla\":[\"spanish\"],\"astro\":[\"spanish\"],\"astuto\":[\"spanish\"],\"asumir\":[\"spanish\"],\"asunto\":[\"spanish\"],\"atajo\":[\"spanish\"],\"ataque\":[\"spanish\"],\"atar\":[\"spanish\"],\"atento\":[\"spanish\"],\"ateo\":[\"spanish\"],\"atico\":[\"spanish\"],\"atleta\":[\"spanish\"],\"atomo\":[\"spanish\"],\"atraer\":[\"spanish\"],\"atroz\":[\"spanish\"],\"atun\":[\"spanish\"],\"audaz\":[\"spanish\"],\"audio\":[\"spanish\"],\"auge\":[\"spanish\"],\"aula\":[\"spanish\"],\"aumento\":[\"spanish\"],\"ausente\":[\"spanish\"],\"autor\":[\"spanish\"],\"aval\":[\"spanish\"],\"avance\":[\"spanish\"],\"avaro\":[\"spanish\"],\"ave\":[\"spanish\"],\"avellana\":[\"spanish\"],\"avena\":[\"spanish\"],\"avestruz\":[\"spanish\"],\"avion\":[\"spanish\"],\"aviso\":[\"spanish\"],\"ayer\":[\"spanish\"],\"ayuda\":[\"spanish\"],\"ayuno\":[\"spanish\"],\"azafran\":[\"spanish\"],\"azar\":[\"spanish\"],\"azote\":[\"spanish\"],\"azucar\":[\"spanish\"],\"azufre\":[\"spanish\"],\"azul\":[\"spanish\"],\"baba\":[\"spanish\"],\"babor\":[\"spanish\"],\"bache\":[\"spanish\"],\"bahia\":[\"spanish\"],\"baile\":[\"spanish\"],\"bajar\":[\"spanish\"],\"balanza\":[\"spanish\"],\"balcon\":[\"spanish\"],\"balde\":[\"spanish\"],\"bambu\":[\"spanish\"],\"banco\":[\"spanish\"],\"banda\":[\"spanish\"],\"bano\":[\"spanish\"],\"barba\":[\"spanish\"],\"barco\":[\"spanish\"],\"barniz\":[\"spanish\"],\"barro\":[\"spanish\"],\"bascula\":[\"spanish\"],\"baston\":[\"spanish\"],\"basura\":[\"spanish\"],\"batalla\":[\"spanish\"],\"bateria\":[\"spanish\"],\"batir\":[\"spanish\"],\"batuta\":[\"spanish\"],\"baul\":[\"spanish\"],\"bazar\":[\"spanish\"],\"bebe\":[\"spanish\"],\"bebida\":[\"spanish\"],\"bello\":[\"spanish\"],\"besar\":[\"spanish\"],\"beso\":[\"spanish\"],\"bestia\":[\"spanish\"],\"bicho\":[\"spanish\"],\"bien\":[\"spanish\"],\"bingo\":[\"spanish\"],\"blanco\":[\"spanish\"],\"bloque\":[\"spanish\"],\"blusa\":[\"spanish\"],\"boa\":[\"spanish\"],\"bobina\":[\"spanish\"],\"bobo\":[\"spanish\"],\"boca\":[\"spanish\"],\"bocina\":[\"spanish\"],\"boda\":[\"spanish\"],\"bodega\":[\"spanish\"],\"boina\":[\"spanish\"],\"bola\":[\"spanish\"],\"bolero\":[\"spanish\",\"turkish\"],\"bolsa\":[\"spanish\"],\"bomba\":[\"spanish\"],\"bondad\":[\"spanish\"],\"bonito\":[\"spanish\"],\"bono\":[\"spanish\"],\"bonsai\":[\"spanish\"],\"borde\":[\"spanish\"],\"borrar\":[\"spanish\"],\"bosque\":[\"spanish\"],\"bote\":[\"spanish\"],\"botin\":[\"spanish\"],\"boveda\":[\"spanish\"],\"bozal\":[\"spanish\"],\"bravo\":[\"spanish\"],\"brazo\":[\"spanish\"],\"brecha\":[\"spanish\"],\"breve\":[\"spanish\"],\"brillo\":[\"spanish\"],\"brinco\":[\"spanish\"],\"brisa\":[\"spanish\"],\"broca\":[\"spanish\"],\"broma\":[\"spanish\"],\"bronce\":[\"spanish\"],\"brote\":[\"spanish\"],\"bruja\":[\"spanish\"],\"brusco\":[\"spanish\"],\"bruto\":[\"spanish\"],\"buceo\":[\"spanish\"],\"bucle\":[\"spanish\"],\"bueno\":[\"spanish\"],\"buey\":[\"spanish\"],\"bufanda\":[\"spanish\"],\"bufon\":[\"spanish\"],\"buho\":[\"spanish\"],\"buitre\":[\"spanish\"],\"bulto\":[\"spanish\"],\"burbuja\":[\"spanish\"],\"burla\":[\"spanish\"],\"burro\":[\"spanish\"],\"buscar\":[\"spanish\"],\"butaca\":[\"spanish\"],\"buzon\":[\"spanish\"],\"caballo\":[\"spanish\"],\"cabeza\":[\"spanish\"],\"cabina\":[\"spanish\"],\"cabra\":[\"spanish\"],\"cacao\":[\"spanish\"],\"cadaver\":[\"spanish\"],\"cadena\":[\"spanish\"],\"caer\":[\"spanish\"],\"cafe\":[\"spanish\"],\"caida\":[\"spanish\"],\"caiman\":[\"spanish\"],\"caja\":[\"spanish\"],\"cajon\":[\"spanish\"],\"cal\":[\"spanish\"],\"calamar\":[\"spanish\"],\"calcio\":[\"spanish\"],\"caldo\":[\"spanish\"],\"calidad\":[\"spanish\"],\"calle\":[\"spanish\"],\"calma\":[\"spanish\"],\"calor\":[\"spanish\"],\"calvo\":[\"spanish\"],\"cama\":[\"spanish\"],\"cambio\":[\"spanish\"],\"camello\":[\"spanish\"],\"camino\":[\"spanish\"],\"campo\":[\"spanish\"],\"cancer\":[\"spanish\"],\"candil\":[\"spanish\"],\"canela\":[\"spanish\"],\"canguro\":[\"spanish\"],\"canica\":[\"spanish\"],\"canto\":[\"spanish\"],\"cana\":[\"spanish\"],\"canon\":[\"spanish\"],\"caoba\":[\"spanish\"],\"caos\":[\"spanish\"],\"capaz\":[\"spanish\"],\"capitan\":[\"spanish\"],\"capote\":[\"spanish\"],\"captar\":[\"spanish\"],\"capucha\":[\"spanish\"],\"cara\":[\"spanish\"],\"carbon\":[\"spanish\"],\"carcel\":[\"spanish\"],\"careta\":[\"spanish\"],\"carga\":[\"spanish\"],\"carino\":[\"spanish\"],\"carne\":[\"spanish\"],\"carpeta\":[\"spanish\"],\"carro\":[\"spanish\"],\"carta\":[\"spanish\"],\"casa\":[\"spanish\"],\"casco\":[\"spanish\"],\"casero\":[\"spanish\"],\"caspa\":[\"spanish\"],\"castor\":[\"spanish\"],\"catorce\":[\"spanish\"],\"catre\":[\"spanish\"],\"caudal\":[\"spanish\"],\"causa\":[\"spanish\"],\"cazo\":[\"spanish\"],\"cebolla\":[\"spanish\"],\"ceder\":[\"spanish\"],\"cedro\":[\"spanish\"],\"celda\":[\"spanish\"],\"celebre\":[\"spanish\"],\"celoso\":[\"spanish\"],\"celula\":[\"spanish\"],\"cemento\":[\"spanish\"],\"ceniza\":[\"spanish\"],\"centro\":[\"spanish\"],\"cerca\":[\"spanish\"],\"cerdo\":[\"spanish\"],\"cereza\":[\"spanish\"],\"cero\":[\"spanish\"],\"cerrar\":[\"spanish\"],\"certeza\":[\"spanish\"],\"cesped\":[\"spanish\"],\"cetro\":[\"spanish\"],\"chacal\":[\"spanish\"],\"chaleco\":[\"spanish\"],\"champu\":[\"spanish\"],\"chancla\":[\"spanish\"],\"chapa\":[\"spanish\"],\"charla\":[\"spanish\"],\"chico\":[\"spanish\"],\"chiste\":[\"spanish\"],\"chivo\":[\"spanish\"],\"choque\":[\"spanish\"],\"choza\":[\"spanish\"],\"chuleta\":[\"spanish\"],\"chupar\":[\"spanish\"],\"ciclon\":[\"spanish\"],\"ciego\":[\"spanish\"],\"cielo\":[\"spanish\"],\"cien\":[\"spanish\"],\"cierto\":[\"spanish\"],\"cifra\":[\"spanish\"],\"cigarro\":[\"spanish\"],\"cima\":[\"spanish\"],\"cinco\":[\"spanish\"],\"cine\":[\"spanish\"],\"cinta\":[\"spanish\"],\"cipres\":[\"spanish\"],\"circo\":[\"spanish\"],\"ciruela\":[\"spanish\"],\"cisne\":[\"spanish\"],\"cita\":[\"spanish\"],\"ciudad\":[\"spanish\"],\"clamor\":[\"spanish\"],\"clan\":[\"spanish\"],\"claro\":[\"spanish\"],\"clase\":[\"spanish\"],\"clave\":[\"spanish\"],\"cliente\":[\"spanish\"],\"clima\":[\"spanish\"],\"clinica\":[\"spanish\"],\"cobre\":[\"spanish\"],\"coccion\":[\"spanish\"],\"cochino\":[\"spanish\"],\"cocina\":[\"spanish\"],\"coco\":[\"spanish\"],\"codigo\":[\"spanish\"],\"codo\":[\"spanish\"],\"cofre\":[\"spanish\"],\"coger\":[\"spanish\"],\"cohete\":[\"spanish\"],\"cojin\":[\"spanish\"],\"cojo\":[\"spanish\"],\"cola\":[\"spanish\"],\"colcha\":[\"spanish\"],\"colegio\":[\"spanish\"],\"colgar\":[\"spanish\"],\"colina\":[\"spanish\"],\"collar\":[\"spanish\"],\"colmo\":[\"spanish\"],\"columna\":[\"spanish\"],\"combate\":[\"spanish\"],\"comer\":[\"spanish\"],\"comida\":[\"spanish\"],\"comodo\":[\"spanish\"],\"compra\":[\"spanish\"],\"conde\":[\"spanish\"],\"conejo\":[\"spanish\"],\"conga\":[\"spanish\"],\"conocer\":[\"spanish\"],\"consejo\":[\"spanish\"],\"contar\":[\"spanish\"],\"copa\":[\"spanish\"],\"copia\":[\"spanish\"],\"corazon\":[\"spanish\"],\"corbata\":[\"spanish\"],\"corcho\":[\"spanish\"],\"cordon\":[\"spanish\"],\"corona\":[\"spanish\"],\"correr\":[\"spanish\"],\"coser\":[\"spanish\"],\"cosmos\":[\"spanish\"],\"costa\":[\"spanish\"],\"craneo\":[\"spanish\"],\"crater\":[\"spanish\"],\"crear\":[\"spanish\"],\"crecer\":[\"spanish\"],\"creido\":[\"spanish\"],\"crema\":[\"spanish\"],\"cria\":[\"spanish\"],\"crimen\":[\"spanish\"],\"cripta\":[\"spanish\"],\"crisis\":[\"spanish\"],\"cromo\":[\"spanish\"],\"cronica\":[\"spanish\"],\"croqueta\":[\"spanish\"],\"crudo\":[\"spanish\"],\"cruz\":[\"spanish\"],\"cuadro\":[\"spanish\"],\"cuarto\":[\"spanish\"],\"cuatro\":[\"spanish\"],\"cubo\":[\"spanish\"],\"cubrir\":[\"spanish\"],\"cuchara\":[\"spanish\"],\"cuello\":[\"spanish\"],\"cuento\":[\"spanish\"],\"cuerda\":[\"spanish\"],\"cuesta\":[\"spanish\"],\"cueva\":[\"spanish\"],\"cuidar\":[\"spanish\"],\"culebra\":[\"spanish\"],\"culpa\":[\"spanish\"],\"culto\":[\"spanish\"],\"cumbre\":[\"spanish\"],\"cumplir\":[\"spanish\"],\"cuna\":[\"spanish\"],\"cuneta\":[\"spanish\"],\"cuota\":[\"spanish\"],\"cupon\":[\"spanish\"],\"cupula\":[\"spanish\"],\"curar\":[\"spanish\"],\"curioso\":[\"spanish\"],\"curso\":[\"spanish\"],\"curva\":[\"spanish\"],\"cutis\":[\"spanish\"],\"dama\":[\"spanish\"],\"danza\":[\"spanish\"],\"dar\":[\"spanish\"],\"dardo\":[\"spanish\"],\"datil\":[\"spanish\"],\"deber\":[\"spanish\"],\"debil\":[\"spanish\"],\"decada\":[\"spanish\"],\"decir\":[\"spanish\"],\"dedo\":[\"spanish\"],\"defensa\":[\"spanish\"],\"definir\":[\"spanish\"],\"dejar\":[\"spanish\"],\"delfin\":[\"spanish\"],\"delgado\":[\"spanish\"],\"delito\":[\"spanish\"],\"demora\":[\"spanish\"],\"denso\":[\"spanish\"],\"dental\":[\"spanish\"],\"deporte\":[\"spanish\"],\"derecho\":[\"spanish\"],\"derrota\":[\"spanish\"],\"desayuno\":[\"spanish\"],\"deseo\":[\"spanish\"],\"desfile\":[\"spanish\"],\"desnudo\":[\"spanish\"],\"destino\":[\"spanish\"],\"desvio\":[\"spanish\"],\"detalle\":[\"spanish\"],\"detener\":[\"spanish\"],\"deuda\":[\"spanish\"],\"dia\":[\"spanish\"],\"diablo\":[\"spanish\"],\"diadema\":[\"spanish\"],\"diamante\":[\"spanish\"],\"diana\":[\"spanish\"],\"diario\":[\"spanish\"],\"dibujo\":[\"spanish\"],\"dictar\":[\"spanish\"],\"diente\":[\"spanish\"],\"dieta\":[\"spanish\"],\"diez\":[\"spanish\"],\"dificil\":[\"spanish\"],\"digno\":[\"spanish\"],\"dilema\":[\"spanish\"],\"diluir\":[\"spanish\"],\"dinero\":[\"spanish\"],\"directo\":[\"spanish\"],\"dirigir\":[\"spanish\"],\"disco\":[\"spanish\"],\"diseno\":[\"spanish\"],\"disfraz\":[\"spanish\"],\"diva\":[\"spanish\"],\"divino\":[\"spanish\"],\"doble\":[\"spanish\"],\"doce\":[\"spanish\"],\"dolor\":[\"spanish\"],\"domingo\":[\"spanish\"],\"don\":[\"spanish\"],\"donar\":[\"spanish\"],\"dorado\":[\"spanish\"],\"dormir\":[\"spanish\"],\"dorso\":[\"spanish\"],\"dos\":[\"spanish\"],\"dosis\":[\"spanish\"],\"dragon\":[\"spanish\"],\"droga\":[\"spanish\"],\"ducha\":[\"spanish\"],\"duda\":[\"spanish\"],\"duelo\":[\"spanish\"],\"dueno\":[\"spanish\"],\"dulce\":[\"spanish\"],\"duo\":[\"spanish\"],\"duque\":[\"spanish\"],\"durar\":[\"spanish\"],\"dureza\":[\"spanish\"],\"duro\":[\"spanish\"],\"ebano\":[\"spanish\"],\"ebrio\":[\"spanish\"],\"echar\":[\"spanish\"],\"eco\":[\"spanish\"],\"ecuador\":[\"spanish\"],\"edad\":[\"spanish\"],\"edicion\":[\"spanish\"],\"edificio\":[\"spanish\"],\"editor\":[\"spanish\"],\"educar\":[\"spanish\"],\"efecto\":[\"spanish\"],\"eficaz\":[\"spanish\"],\"eje\":[\"spanish\"],\"ejemplo\":[\"spanish\"],\"elefante\":[\"spanish\"],\"elegir\":[\"spanish\"],\"elemento\":[\"spanish\"],\"elevar\":[\"spanish\"],\"elipse\":[\"spanish\"],\"elite\":[\"spanish\"],\"elixir\":[\"spanish\"],\"elogio\":[\"spanish\"],\"eludir\":[\"spanish\"],\"embudo\":[\"spanish\"],\"emitir\":[\"spanish\"],\"emocion\":[\"spanish\"],\"empate\":[\"spanish\"],\"empeno\":[\"spanish\"],\"empleo\":[\"spanish\"],\"empresa\":[\"spanish\"],\"enano\":[\"spanish\"],\"encargo\":[\"spanish\"],\"enchufe\":[\"spanish\"],\"encia\":[\"spanish\"],\"enemigo\":[\"spanish\"],\"enero\":[\"spanish\"],\"enfado\":[\"spanish\"],\"enfermo\":[\"spanish\"],\"engano\":[\"spanish\"],\"enigma\":[\"spanish\"],\"enlace\":[\"spanish\"],\"enorme\":[\"spanish\"],\"enredo\":[\"spanish\"],\"ensayo\":[\"spanish\"],\"ensenar\":[\"spanish\"],\"entero\":[\"spanish\"],\"entrar\":[\"spanish\"],\"envase\":[\"spanish\"],\"envio\":[\"spanish\"],\"epoca\":[\"spanish\"],\"equipo\":[\"spanish\"],\"erizo\":[\"spanish\"],\"escala\":[\"spanish\"],\"escena\":[\"spanish\"],\"escolar\":[\"spanish\"],\"escribir\":[\"spanish\"],\"escudo\":[\"spanish\"],\"esencia\":[\"spanish\"],\"esfera\":[\"spanish\"],\"esfuerzo\":[\"spanish\"],\"espada\":[\"spanish\"],\"espejo\":[\"spanish\"],\"espia\":[\"spanish\"],\"esposa\":[\"spanish\"],\"espuma\":[\"spanish\"],\"esqui\":[\"spanish\"],\"estar\":[\"spanish\"],\"este\":[\"spanish\"],\"estilo\":[\"spanish\"],\"estufa\":[\"spanish\"],\"etapa\":[\"spanish\"],\"eterno\":[\"spanish\"],\"etica\":[\"spanish\"],\"etnia\":[\"spanish\"],\"evadir\":[\"spanish\"],\"evaluar\":[\"spanish\"],\"evento\":[\"spanish\"],\"evitar\":[\"spanish\"],\"exacto\":[\"spanish\"],\"examen\":[\"spanish\"],\"exceso\":[\"spanish\"],\"excusa\":[\"spanish\"],\"exento\":[\"spanish\"],\"exigir\":[\"spanish\"],\"exilio\":[\"spanish\"],\"existir\":[\"spanish\"],\"exito\":[\"spanish\"],\"experto\":[\"spanish\"],\"explicar\":[\"spanish\"],\"exponer\":[\"spanish\"],\"extremo\":[\"spanish\"],\"fabrica\":[\"spanish\"],\"fabula\":[\"spanish\"],\"fachada\":[\"spanish\"],\"facil\":[\"spanish\"],\"factor\":[\"spanish\"],\"faena\":[\"spanish\"],\"faja\":[\"spanish\"],\"falda\":[\"spanish\"],\"fallo\":[\"spanish\"],\"falso\":[\"spanish\"],\"faltar\":[\"spanish\"],\"fama\":[\"spanish\"],\"familia\":[\"spanish\"],\"famoso\":[\"spanish\"],\"faraon\":[\"spanish\"],\"farmacia\":[\"spanish\"],\"farol\":[\"spanish\"],\"farsa\":[\"spanish\"],\"fase\":[\"spanish\"],\"fatiga\":[\"spanish\"],\"fauna\":[\"spanish\",\"turkish\"],\"favor\":[\"spanish\"],\"fax\":[\"spanish\"],\"febrero\":[\"spanish\"],\"fecha\":[\"spanish\"],\"feliz\":[\"spanish\"],\"feo\":[\"spanish\"],\"feria\":[\"spanish\"],\"feroz\":[\"spanish\"],\"fertil\":[\"spanish\"],\"fervor\":[\"spanish\"],\"festin\":[\"spanish\"],\"fiable\":[\"spanish\"],\"fianza\":[\"spanish\"],\"fiar\":[\"spanish\"],\"fibra\":[\"spanish\"],\"ficcion\":[\"spanish\"],\"ficha\":[\"spanish\"],\"fideo\":[\"spanish\"],\"fiebre\":[\"spanish\"],\"fiel\":[\"spanish\"],\"fiera\":[\"spanish\"],\"fiesta\":[\"spanish\"],\"figura\":[\"spanish\"],\"fijar\":[\"spanish\"],\"fijo\":[\"spanish\"],\"fila\":[\"spanish\"],\"filete\":[\"spanish\"],\"filial\":[\"spanish\"],\"filtro\":[\"spanish\"],\"fin\":[\"spanish\"],\"finca\":[\"spanish\"],\"fingir\":[\"spanish\"],\"finito\":[\"spanish\"],\"firma\":[\"spanish\"],\"flaco\":[\"spanish\"],\"flauta\":[\"spanish\"],\"flecha\":[\"spanish\"],\"flor\":[\"spanish\"],\"flota\":[\"spanish\"],\"fluir\":[\"spanish\"],\"flujo\":[\"spanish\"],\"fluor\":[\"spanish\"],\"fobia\":[\"spanish\"],\"foca\":[\"spanish\"],\"fogata\":[\"spanish\"],\"fogon\":[\"spanish\"],\"folio\":[\"spanish\"],\"folleto\":[\"spanish\"],\"fondo\":[\"spanish\"],\"forma\":[\"spanish\"],\"forro\":[\"spanish\"],\"fortuna\":[\"spanish\"],\"forzar\":[\"spanish\"],\"fosa\":[\"spanish\"],\"foto\":[\"spanish\"],\"fracaso\":[\"spanish\"],\"fragil\":[\"spanish\"],\"franja\":[\"spanish\"],\"frase\":[\"spanish\"],\"fraude\":[\"spanish\"],\"freir\":[\"spanish\"],\"freno\":[\"spanish\"],\"fresa\":[\"spanish\"],\"frio\":[\"spanish\"],\"frito\":[\"spanish\"],\"fruta\":[\"spanish\"],\"fuego\":[\"spanish\"],\"fuente\":[\"spanish\"],\"fuerza\":[\"spanish\"],\"fuga\":[\"spanish\"],\"fumar\":[\"spanish\"],\"funcion\":[\"spanish\"],\"funda\":[\"spanish\"],\"furgon\":[\"spanish\"],\"furia\":[\"spanish\"],\"fusil\":[\"spanish\"],\"futbol\":[\"spanish\"],\"futuro\":[\"spanish\"],\"gacela\":[\"spanish\"],\"gafas\":[\"spanish\"],\"gaita\":[\"spanish\"],\"gajo\":[\"spanish\"],\"gala\":[\"spanish\"],\"galeria\":[\"spanish\"],\"gallo\":[\"spanish\"],\"gamba\":[\"spanish\"],\"ganar\":[\"spanish\"],\"gancho\":[\"spanish\"],\"ganga\":[\"spanish\"],\"ganso\":[\"spanish\"],\"garaje\":[\"spanish\"],\"garza\":[\"spanish\"],\"gasolina\":[\"spanish\"],\"gastar\":[\"spanish\"],\"gato\":[\"spanish\"],\"gavilan\":[\"spanish\"],\"gemelo\":[\"spanish\"],\"gemir\":[\"spanish\"],\"gen\":[\"spanish\"],\"genero\":[\"spanish\"],\"genio\":[\"spanish\"],\"gente\":[\"spanish\"],\"geranio\":[\"spanish\"],\"gerente\":[\"spanish\"],\"germen\":[\"spanish\"],\"gesto\":[\"spanish\"],\"gigante\":[\"spanish\"],\"gimnasio\":[\"spanish\"],\"girar\":[\"spanish\"],\"giro\":[\"spanish\"],\"glaciar\":[\"spanish\"],\"globo\":[\"spanish\"],\"gloria\":[\"spanish\"],\"gol\":[\"spanish\"],\"golfo\":[\"spanish\"],\"goloso\":[\"spanish\"],\"golpe\":[\"spanish\"],\"goma\":[\"spanish\"],\"gordo\":[\"spanish\"],\"gorila\":[\"spanish\"],\"gorra\":[\"spanish\"],\"gota\":[\"spanish\"],\"goteo\":[\"spanish\"],\"gozar\":[\"spanish\"],\"grada\":[\"spanish\"],\"grafico\":[\"spanish\"],\"grano\":[\"spanish\"],\"grasa\":[\"spanish\"],\"gratis\":[\"spanish\"],\"grave\":[\"spanish\"],\"grieta\":[\"spanish\"],\"grillo\":[\"spanish\"],\"gripe\":[\"spanish\"],\"gris\":[\"spanish\"],\"grito\":[\"spanish\"],\"grosor\":[\"spanish\"],\"grua\":[\"spanish\"],\"grueso\":[\"spanish\"],\"grumo\":[\"spanish\"],\"grupo\":[\"spanish\"],\"guante\":[\"spanish\"],\"guapo\":[\"spanish\"],\"guardia\":[\"spanish\"],\"guerra\":[\"spanish\"],\"guia\":[\"spanish\"],\"guino\":[\"spanish\"],\"guion\":[\"spanish\"],\"guiso\":[\"spanish\"],\"guitarra\":[\"spanish\"],\"gusano\":[\"spanish\"],\"gustar\":[\"spanish\"],\"haber\":[\"spanish\",\"turkish\"],\"habil\":[\"spanish\"],\"hablar\":[\"spanish\"],\"hacer\":[\"spanish\"],\"hacha\":[\"spanish\"],\"hada\":[\"spanish\"],\"hallar\":[\"spanish\"],\"hamaca\":[\"spanish\"],\"harina\":[\"spanish\"],\"haz\":[\"spanish\"],\"hazana\":[\"spanish\"],\"hebilla\":[\"spanish\"],\"hebra\":[\"spanish\"],\"hecho\":[\"spanish\"],\"helado\":[\"spanish\"],\"helio\":[\"spanish\"],\"hembra\":[\"spanish\"],\"herir\":[\"spanish\"],\"hermano\":[\"spanish\"],\"heroe\":[\"spanish\"],\"hervir\":[\"spanish\"],\"hielo\":[\"spanish\"],\"hierro\":[\"spanish\"],\"higado\":[\"spanish\"],\"higiene\":[\"spanish\"],\"hijo\":[\"spanish\"],\"himno\":[\"spanish\"],\"historia\":[\"spanish\"],\"hocico\":[\"spanish\"],\"hogar\":[\"spanish\"],\"hoguera\":[\"spanish\"],\"hoja\":[\"spanish\"],\"hombre\":[\"spanish\"],\"hongo\":[\"spanish\"],\"honor\":[\"spanish\"],\"honra\":[\"spanish\"],\"hora\":[\"spanish\"],\"hormiga\":[\"spanish\"],\"horno\":[\"spanish\"],\"hostil\":[\"spanish\"],\"hoyo\":[\"spanish\"],\"hueco\":[\"spanish\"],\"huelga\":[\"spanish\"],\"huerta\":[\"spanish\"],\"hueso\":[\"spanish\"],\"huevo\":[\"spanish\"],\"huida\":[\"spanish\"],\"huir\":[\"spanish\"],\"humano\":[\"spanish\"],\"humedo\":[\"spanish\"],\"humilde\":[\"spanish\"],\"humo\":[\"spanish\"],\"hundir\":[\"spanish\"],\"huracan\":[\"spanish\"],\"hurto\":[\"spanish\"],\"icono\":[\"spanish\"],\"ideal\":[\"spanish\"],\"idioma\":[\"spanish\"],\"idolo\":[\"spanish\"],\"iglesia\":[\"spanish\"],\"iglu\":[\"spanish\"],\"igual\":[\"spanish\"],\"ilegal\":[\"spanish\"],\"ilusion\":[\"spanish\"],\"imagen\":[\"spanish\"],\"iman\":[\"spanish\"],\"imitar\":[\"spanish\"],\"impar\":[\"spanish\"],\"imperio\":[\"spanish\"],\"imponer\":[\"spanish\"],\"impulso\":[\"spanish\"],\"incapaz\":[\"spanish\"],\"indice\":[\"spanish\"],\"inerte\":[\"spanish\"],\"infiel\":[\"spanish\"],\"informe\":[\"spanish\"],\"ingenio\":[\"spanish\"],\"inicio\":[\"spanish\"],\"inmenso\":[\"spanish\"],\"inmune\":[\"spanish\"],\"innato\":[\"spanish\"],\"insecto\":[\"spanish\"],\"instante\":[\"spanish\"],\"interes\":[\"spanish\"],\"intimo\":[\"spanish\"],\"intuir\":[\"spanish\"],\"inutil\":[\"spanish\"],\"invierno\":[\"spanish\"],\"ira\":[\"spanish\"],\"iris\":[\"spanish\"],\"ironia\":[\"spanish\"],\"isla\":[\"spanish\"],\"islote\":[\"spanish\"],\"jabali\":[\"spanish\"],\"jabon\":[\"spanish\"],\"jamon\":[\"spanish\"],\"jarabe\":[\"spanish\"],\"jardin\":[\"spanish\"],\"jarra\":[\"spanish\"],\"jaula\":[\"spanish\"],\"jazmin\":[\"spanish\"],\"jefe\":[\"spanish\"],\"jeringa\":[\"spanish\"],\"jinete\":[\"spanish\"],\"jornada\":[\"spanish\"],\"joroba\":[\"spanish\"],\"joven\":[\"spanish\"],\"joya\":[\"spanish\"],\"juerga\":[\"spanish\"],\"jueves\":[\"spanish\"],\"juez\":[\"spanish\"],\"jugador\":[\"spanish\"],\"jugo\":[\"spanish\"],\"juguete\":[\"spanish\"],\"juicio\":[\"spanish\"],\"junco\":[\"spanish\"],\"jungla\":[\"spanish\"],\"junio\":[\"spanish\"],\"juntar\":[\"spanish\"],\"jupiter\":[\"spanish\"],\"jurar\":[\"spanish\"],\"justo\":[\"spanish\"],\"juvenil\":[\"spanish\"],\"juzgar\":[\"spanish\"],\"kilo\":[\"spanish\"],\"koala\":[\"spanish\"],\"labio\":[\"spanish\"],\"lacio\":[\"spanish\"],\"lacra\":[\"spanish\"],\"lado\":[\"spanish\"],\"ladron\":[\"spanish\"],\"lagarto\":[\"spanish\"],\"lagrima\":[\"spanish\"],\"laguna\":[\"spanish\"],\"laico\":[\"spanish\"],\"lamer\":[\"spanish\"],\"lamina\":[\"spanish\"],\"lampara\":[\"spanish\"],\"lana\":[\"spanish\"],\"lancha\":[\"spanish\"],\"langosta\":[\"spanish\"],\"lanza\":[\"spanish\"],\"lapiz\":[\"spanish\"],\"largo\":[\"spanish\"],\"larva\":[\"spanish\"],\"lastima\":[\"spanish\"],\"lata\":[\"spanish\"],\"latex\":[\"spanish\"],\"latir\":[\"spanish\"],\"laurel\":[\"spanish\"],\"lavar\":[\"spanish\"],\"lazo\":[\"spanish\"],\"leal\":[\"spanish\"],\"leccion\":[\"spanish\"],\"leche\":[\"spanish\"],\"lector\":[\"spanish\"],\"leer\":[\"spanish\"],\"legion\":[\"spanish\"],\"legumbre\":[\"spanish\"],\"lejano\":[\"spanish\"],\"lengua\":[\"spanish\"],\"lento\":[\"spanish\"],\"lena\":[\"spanish\"],\"leon\":[\"spanish\"],\"leopardo\":[\"spanish\"],\"lesion\":[\"spanish\"],\"letal\":[\"spanish\"],\"letra\":[\"spanish\"],\"leve\":[\"spanish\"],\"leyenda\":[\"spanish\"],\"libertad\":[\"spanish\"],\"libro\":[\"spanish\"],\"licor\":[\"spanish\"],\"lider\":[\"spanish\"],\"lidiar\":[\"spanish\"],\"lienzo\":[\"spanish\"],\"liga\":[\"spanish\"],\"ligero\":[\"spanish\"],\"lima\":[\"spanish\"],\"limite\":[\"spanish\"],\"limon\":[\"spanish\"],\"limpio\":[\"spanish\"],\"lince\":[\"spanish\"],\"lindo\":[\"spanish\"],\"linea\":[\"spanish\"],\"lingote\":[\"spanish\"],\"lino\":[\"spanish\"],\"linterna\":[\"spanish\"],\"liquido\":[\"spanish\"],\"liso\":[\"spanish\"],\"lista\":[\"spanish\"],\"litera\":[\"spanish\"],\"litio\":[\"spanish\"],\"litro\":[\"spanish\"],\"llaga\":[\"spanish\"],\"llama\":[\"spanish\"],\"llanto\":[\"spanish\"],\"llave\":[\"spanish\"],\"llegar\":[\"spanish\"],\"llenar\":[\"spanish\"],\"llevar\":[\"spanish\"],\"llorar\":[\"spanish\"],\"llover\":[\"spanish\"],\"lluvia\":[\"spanish\"],\"lobo\":[\"spanish\"],\"locion\":[\"spanish\"],\"loco\":[\"spanish\"],\"locura\":[\"spanish\"],\"logica\":[\"spanish\"],\"logro\":[\"spanish\"],\"lombriz\":[\"spanish\"],\"lomo\":[\"spanish\"],\"lonja\":[\"spanish\"],\"lote\":[\"spanish\"],\"lucha\":[\"spanish\"],\"lucir\":[\"spanish\"],\"lugar\":[\"spanish\"],\"lujo\":[\"spanish\"],\"luna\":[\"spanish\"],\"lunes\":[\"spanish\"],\"lupa\":[\"spanish\"],\"lustro\":[\"spanish\"],\"luto\":[\"spanish\"],\"luz\":[\"spanish\"],\"maceta\":[\"spanish\"],\"macho\":[\"spanish\"],\"madera\":[\"spanish\"],\"madre\":[\"spanish\"],\"maduro\":[\"spanish\"],\"maestro\":[\"spanish\"],\"mafia\":[\"spanish\"],\"magia\":[\"spanish\"],\"mago\":[\"spanish\"],\"maiz\":[\"spanish\"],\"maldad\":[\"spanish\"],\"maleta\":[\"spanish\"],\"malla\":[\"spanish\"],\"malo\":[\"spanish\"],\"mama\":[\"spanish\"],\"mambo\":[\"spanish\"],\"mamut\":[\"spanish\"],\"manco\":[\"spanish\"],\"mando\":[\"spanish\"],\"manejar\":[\"spanish\"],\"manga\":[\"spanish\"],\"maniqui\":[\"spanish\"],\"manjar\":[\"spanish\"],\"mano\":[\"spanish\"],\"manso\":[\"spanish\"],\"manta\":[\"spanish\"],\"manana\":[\"spanish\"],\"mapa\":[\"spanish\"],\"maquina\":[\"spanish\"],\"mar\":[\"spanish\"],\"marco\":[\"spanish\"],\"marea\":[\"spanish\"],\"marfil\":[\"spanish\"],\"margen\":[\"spanish\"],\"marido\":[\"spanish\"],\"marmol\":[\"spanish\"],\"marron\":[\"spanish\"],\"martes\":[\"spanish\"],\"marzo\":[\"spanish\"],\"masa\":[\"spanish\"],\"mascara\":[\"spanish\"],\"masivo\":[\"spanish\"],\"matar\":[\"spanish\"],\"materia\":[\"spanish\"],\"matiz\":[\"spanish\"],\"matriz\":[\"spanish\"],\"maximo\":[\"spanish\"],\"mayor\":[\"spanish\"],\"mazorca\":[\"spanish\"],\"mecha\":[\"spanish\"],\"medalla\":[\"spanish\"],\"medio\":[\"spanish\"],\"medula\":[\"spanish\"],\"mejilla\":[\"spanish\"],\"mejor\":[\"spanish\"],\"melena\":[\"spanish\"],\"melon\":[\"spanish\"],\"memoria\":[\"spanish\"],\"menor\":[\"spanish\"],\"mensaje\":[\"spanish\"],\"mente\":[\"spanish\"],\"menu\":[\"spanish\"],\"mercado\":[\"spanish\"],\"merengue\":[\"spanish\"],\"merito\":[\"spanish\"],\"mes\":[\"spanish\"],\"meson\":[\"spanish\"],\"meta\":[\"spanish\"],\"meter\":[\"spanish\"],\"metodo\":[\"spanish\"],\"metro\":[\"spanish\"],\"mezcla\":[\"spanish\"],\"miedo\":[\"spanish\"],\"miel\":[\"spanish\"],\"miembro\":[\"spanish\"],\"miga\":[\"spanish\"],\"mil\":[\"spanish\"],\"milagro\":[\"spanish\"],\"militar\":[\"spanish\"],\"millon\":[\"spanish\"],\"mimo\":[\"spanish\"],\"mina\":[\"spanish\"],\"minero\":[\"spanish\"],\"minimo\":[\"spanish\"],\"minuto\":[\"spanish\"],\"miope\":[\"spanish\"],\"mirar\":[\"spanish\"],\"misa\":[\"spanish\"],\"miseria\":[\"spanish\"],\"misil\":[\"spanish\"],\"mismo\":[\"spanish\"],\"mitad\":[\"spanish\"],\"mito\":[\"spanish\"],\"mochila\":[\"spanish\"],\"mocion\":[\"spanish\"],\"moda\":[\"spanish\"],\"modelo\":[\"spanish\"],\"moho\":[\"spanish\"],\"mojar\":[\"spanish\"],\"molde\":[\"spanish\"],\"moler\":[\"spanish\"],\"molino\":[\"spanish\"],\"momento\":[\"spanish\"],\"momia\":[\"spanish\"],\"monarca\":[\"spanish\"],\"moneda\":[\"spanish\"],\"monja\":[\"spanish\"],\"monto\":[\"spanish\"],\"mono\":[\"spanish\"],\"morada\":[\"spanish\"],\"morder\":[\"spanish\"],\"moreno\":[\"spanish\"],\"morir\":[\"spanish\"],\"morro\":[\"spanish\"],\"morsa\":[\"spanish\"],\"mortal\":[\"spanish\"],\"mosca\":[\"spanish\"],\"mostrar\":[\"spanish\"],\"motivo\":[\"spanish\"],\"mover\":[\"spanish\"],\"movil\":[\"spanish\"],\"mozo\":[\"spanish\"],\"mucho\":[\"spanish\"],\"mudar\":[\"spanish\"],\"mueble\":[\"spanish\"],\"muela\":[\"spanish\"],\"muerte\":[\"spanish\"],\"muestra\":[\"spanish\"],\"mugre\":[\"spanish\"],\"mujer\":[\"spanish\"],\"mula\":[\"spanish\"],\"muleta\":[\"spanish\"],\"multa\":[\"spanish\"],\"mundo\":[\"spanish\"],\"muneca\":[\"spanish\"],\"mural\":[\"spanish\"],\"muro\":[\"spanish\"],\"musculo\":[\"spanish\"],\"museo\":[\"spanish\"],\"musgo\":[\"spanish\"],\"musica\":[\"spanish\"],\"muslo\":[\"spanish\"],\"nacar\":[\"spanish\"],\"nacion\":[\"spanish\"],\"nadar\":[\"spanish\"],\"naipe\":[\"spanish\"],\"naranja\":[\"spanish\"],\"nariz\":[\"spanish\"],\"narrar\":[\"spanish\"],\"nasal\":[\"spanish\"],\"natal\":[\"spanish\"],\"nativo\":[\"spanish\"],\"natural\":[\"spanish\"],\"nausea\":[\"spanish\"],\"naval\":[\"spanish\"],\"nave\":[\"spanish\"],\"navidad\":[\"spanish\"],\"necio\":[\"spanish\"],\"nectar\":[\"spanish\"],\"negar\":[\"spanish\"],\"negocio\":[\"spanish\"],\"negro\":[\"spanish\"],\"neon\":[\"spanish\"],\"nervio\":[\"spanish\"],\"neto\":[\"spanish\"],\"neutro\":[\"spanish\"],\"nevar\":[\"spanish\"],\"nevera\":[\"spanish\"],\"nicho\":[\"spanish\"],\"nido\":[\"spanish\"],\"niebla\":[\"spanish\"],\"nieto\":[\"spanish\"],\"ninez\":[\"spanish\"],\"nino\":[\"spanish\"],\"nitido\":[\"spanish\"],\"nivel\":[\"spanish\"],\"nobleza\":[\"spanish\"],\"noche\":[\"spanish\"],\"nomina\":[\"spanish\"],\"noria\":[\"spanish\"],\"norma\":[\"spanish\"],\"norte\":[\"spanish\"],\"nota\":[\"spanish\"],\"noticia\":[\"spanish\"],\"novato\":[\"spanish\"],\"novela\":[\"spanish\"],\"novio\":[\"spanish\"],\"nube\":[\"spanish\"],\"nuca\":[\"spanish\"],\"nucleo\":[\"spanish\"],\"nudillo\":[\"spanish\"],\"nudo\":[\"spanish\"],\"nuera\":[\"spanish\"],\"nueve\":[\"spanish\"],\"nuez\":[\"spanish\"],\"nulo\":[\"spanish\"],\"numero\":[\"spanish\"],\"nutria\":[\"spanish\"],\"oasis\":[\"spanish\"],\"obeso\":[\"spanish\"],\"obispo\":[\"spanish\"],\"objeto\":[\"spanish\"],\"obra\":[\"spanish\"],\"obrero\":[\"spanish\"],\"observar\":[\"spanish\"],\"obtener\":[\"spanish\"],\"obvio\":[\"spanish\"],\"oca\":[\"spanish\"],\"ocaso\":[\"spanish\"],\"oceano\":[\"spanish\"],\"ochenta\":[\"spanish\"],\"ocho\":[\"spanish\"],\"ocio\":[\"spanish\"],\"ocre\":[\"spanish\"],\"octavo\":[\"spanish\"],\"octubre\":[\"spanish\"],\"oculto\":[\"spanish\"],\"ocupar\":[\"spanish\"],\"ocurrir\":[\"spanish\"],\"odiar\":[\"spanish\"],\"odio\":[\"spanish\"],\"odisea\":[\"spanish\"],\"oeste\":[\"spanish\"],\"ofensa\":[\"spanish\"],\"oferta\":[\"spanish\"],\"oficio\":[\"spanish\"],\"ofrecer\":[\"spanish\"],\"ogro\":[\"spanish\"],\"oido\":[\"spanish\"],\"oir\":[\"spanish\"],\"ojo\":[\"spanish\"],\"ola\":[\"spanish\"],\"oleada\":[\"spanish\"],\"olfato\":[\"spanish\"],\"olivo\":[\"spanish\"],\"olla\":[\"spanish\"],\"olmo\":[\"spanish\"],\"olor\":[\"spanish\"],\"olvido\":[\"spanish\"],\"ombligo\":[\"spanish\"],\"onda\":[\"spanish\"],\"onza\":[\"spanish\"],\"opaco\":[\"spanish\"],\"opcion\":[\"spanish\"],\"opera\":[\"spanish\"],\"opinar\":[\"spanish\"],\"oponer\":[\"spanish\"],\"optar\":[\"spanish\"],\"optica\":[\"spanish\"],\"opuesto\":[\"spanish\"],\"oracion\":[\"spanish\"],\"orador\":[\"spanish\"],\"oral\":[\"spanish\",\"turkish\"],\"orbita\":[\"spanish\"],\"orca\":[\"spanish\"],\"orden\":[\"spanish\"],\"oreja\":[\"spanish\"],\"organo\":[\"spanish\"],\"orgia\":[\"spanish\"],\"orgullo\":[\"spanish\"],\"oriente\":[\"spanish\"],\"origen\":[\"spanish\"],\"orilla\":[\"spanish\"],\"oro\":[\"spanish\"],\"orquesta\":[\"spanish\"],\"oruga\":[\"spanish\"],\"osadia\":[\"spanish\"],\"oscuro\":[\"spanish\"],\"osezno\":[\"spanish\"],\"oso\":[\"spanish\"],\"ostra\":[\"spanish\"],\"otono\":[\"spanish\"],\"otro\":[\"spanish\"],\"oveja\":[\"spanish\"],\"ovulo\":[\"spanish\"],\"oxido\":[\"spanish\"],\"oxigeno\":[\"spanish\"],\"oyente\":[\"spanish\"],\"ozono\":[\"spanish\"],\"pacto\":[\"spanish\"],\"padre\":[\"spanish\"],\"paella\":[\"spanish\"],\"pagina\":[\"spanish\"],\"pago\":[\"spanish\"],\"pais\":[\"spanish\"],\"pajaro\":[\"spanish\"],\"palabra\":[\"spanish\"],\"palco\":[\"spanish\"],\"paleta\":[\"spanish\"],\"palido\":[\"spanish\"],\"palma\":[\"spanish\"],\"paloma\":[\"spanish\"],\"palpar\":[\"spanish\"],\"pan\":[\"spanish\"],\"panal\":[\"spanish\"],\"panico\":[\"spanish\"],\"pantera\":[\"spanish\"],\"panuelo\":[\"spanish\"],\"papa\":[\"spanish\"],\"papel\":[\"spanish\"],\"papilla\":[\"spanish\"],\"paquete\":[\"spanish\"],\"parar\":[\"spanish\"],\"parcela\":[\"spanish\"],\"pared\":[\"spanish\"],\"parir\":[\"spanish\"],\"paro\":[\"spanish\"],\"parpado\":[\"spanish\"],\"parque\":[\"spanish\"],\"parrafo\":[\"spanish\"],\"parte\":[\"spanish\"],\"pasar\":[\"spanish\"],\"paseo\":[\"spanish\"],\"pasion\":[\"spanish\"],\"paso\":[\"spanish\"],\"pasta\":[\"spanish\"],\"pata\":[\"spanish\"],\"patio\":[\"spanish\"],\"patria\":[\"spanish\"],\"pausa\":[\"spanish\"],\"pauta\":[\"spanish\"],\"pavo\":[\"spanish\"],\"payaso\":[\"spanish\"],\"peaton\":[\"spanish\"],\"pecado\":[\"spanish\"],\"pecera\":[\"spanish\"],\"pecho\":[\"spanish\"],\"pedal\":[\"spanish\",\"turkish\"],\"pedir\":[\"spanish\"],\"pegar\":[\"spanish\"],\"peine\":[\"spanish\"],\"pelar\":[\"spanish\"],\"peldano\":[\"spanish\"],\"pelea\":[\"spanish\"],\"peligro\":[\"spanish\"],\"pellejo\":[\"spanish\"],\"pelo\":[\"spanish\"],\"peluca\":[\"spanish\"],\"pena\":[\"spanish\",\"turkish\"],\"pensar\":[\"spanish\"],\"penon\":[\"spanish\"],\"peon\":[\"spanish\"],\"peor\":[\"spanish\"],\"pepino\":[\"spanish\"],\"pequeno\":[\"spanish\"],\"pera\":[\"spanish\"],\"percha\":[\"spanish\"],\"perder\":[\"spanish\"],\"pereza\":[\"spanish\"],\"perfil\":[\"spanish\"],\"perico\":[\"spanish\"],\"perla\":[\"spanish\"],\"permiso\":[\"spanish\"],\"perro\":[\"spanish\"],\"persona\":[\"spanish\"],\"pesa\":[\"spanish\"],\"pesca\":[\"spanish\"],\"pesimo\":[\"spanish\"],\"pestana\":[\"spanish\"],\"petalo\":[\"spanish\"],\"petroleo\":[\"spanish\"],\"pez\":[\"spanish\"],\"pezuna\":[\"spanish\"],\"picar\":[\"spanish\"],\"pichon\":[\"spanish\"],\"pie\":[\"spanish\"],\"piedra\":[\"spanish\"],\"pierna\":[\"spanish\"],\"pieza\":[\"spanish\"],\"pijama\":[\"spanish\"],\"pilar\":[\"spanish\"],\"piloto\":[\"spanish\"],\"pimienta\":[\"spanish\"],\"pino\":[\"spanish\"],\"pintor\":[\"spanish\"],\"pinza\":[\"spanish\"],\"pina\":[\"spanish\"],\"piojo\":[\"spanish\"],\"pipa\":[\"spanish\"],\"pirata\":[\"spanish\"],\"pisar\":[\"spanish\"],\"piscina\":[\"spanish\"],\"piso\":[\"spanish\"],\"pista\":[\"spanish\"],\"piton\":[\"spanish\"],\"pizca\":[\"spanish\"],\"placa\":[\"spanish\"],\"plan\":[\"spanish\"],\"plata\":[\"spanish\"],\"playa\":[\"spanish\"],\"plaza\":[\"spanish\"],\"pleito\":[\"spanish\"],\"pleno\":[\"spanish\"],\"plomo\":[\"spanish\"],\"pluma\":[\"spanish\"],\"plural\":[\"spanish\"],\"pobre\":[\"spanish\"],\"poco\":[\"spanish\"],\"poder\":[\"spanish\"],\"podio\":[\"spanish\"],\"poema\":[\"spanish\"],\"poesia\":[\"spanish\"],\"poeta\":[\"spanish\"],\"polen\":[\"spanish\",\"turkish\"],\"policia\":[\"spanish\"],\"pollo\":[\"spanish\"],\"polvo\":[\"spanish\"],\"pomada\":[\"spanish\"],\"pomelo\":[\"spanish\"],\"pomo\":[\"spanish\"],\"pompa\":[\"spanish\",\"turkish\"],\"poner\":[\"spanish\"],\"porcion\":[\"spanish\"],\"portal\":[\"spanish\"],\"posada\":[\"spanish\"],\"poseer\":[\"spanish\"],\"posible\":[\"spanish\"],\"poste\":[\"spanish\"],\"potencia\":[\"spanish\"],\"potro\":[\"spanish\"],\"pozo\":[\"spanish\"],\"prado\":[\"spanish\"],\"precoz\":[\"spanish\"],\"pregunta\":[\"spanish\"],\"premio\":[\"spanish\"],\"prensa\":[\"spanish\"],\"preso\":[\"spanish\"],\"previo\":[\"spanish\"],\"primo\":[\"spanish\"],\"principe\":[\"spanish\"],\"prision\":[\"spanish\"],\"privar\":[\"spanish\"],\"proa\":[\"spanish\"],\"probar\":[\"spanish\"],\"proceso\":[\"spanish\"],\"producto\":[\"spanish\"],\"proeza\":[\"spanish\"],\"profesor\":[\"spanish\"],\"programa\":[\"spanish\"],\"prole\":[\"spanish\"],\"promesa\":[\"spanish\"],\"pronto\":[\"spanish\"],\"propio\":[\"spanish\"],\"proximo\":[\"spanish\"],\"prueba\":[\"spanish\"],\"publico\":[\"spanish\"],\"puchero\":[\"spanish\"],\"pudor\":[\"spanish\"],\"pueblo\":[\"spanish\"],\"puerta\":[\"spanish\"],\"puesto\":[\"spanish\"],\"pulga\":[\"spanish\"],\"pulir\":[\"spanish\"],\"pulmon\":[\"spanish\"],\"pulpo\":[\"spanish\"],\"pulso\":[\"spanish\"],\"puma\":[\"spanish\"],\"punto\":[\"spanish\"],\"punal\":[\"spanish\"],\"puno\":[\"spanish\"],\"pupa\":[\"spanish\"],\"pupila\":[\"spanish\"],\"pure\":[\"spanish\"],\"quedar\":[\"spanish\"],\"queja\":[\"spanish\"],\"quemar\":[\"spanish\"],\"querer\":[\"spanish\"],\"queso\":[\"spanish\"],\"quieto\":[\"spanish\"],\"quimica\":[\"spanish\"],\"quince\":[\"spanish\"],\"quitar\":[\"spanish\"],\"rabano\":[\"spanish\"],\"rabia\":[\"spanish\"],\"rabo\":[\"spanish\"],\"racion\":[\"spanish\"],\"radical\":[\"spanish\"],\"raiz\":[\"spanish\"],\"rama\":[\"spanish\"],\"rampa\":[\"spanish\",\"turkish\"],\"rancho\":[\"spanish\"],\"rango\":[\"spanish\"],\"rapaz\":[\"spanish\"],\"rapido\":[\"spanish\"],\"rapto\":[\"spanish\"],\"rasgo\":[\"spanish\"],\"raspa\":[\"spanish\"],\"rato\":[\"spanish\"],\"rayo\":[\"spanish\"],\"raza\":[\"spanish\"],\"razon\":[\"spanish\"],\"reaccion\":[\"spanish\"],\"realidad\":[\"spanish\"],\"rebano\":[\"spanish\"],\"rebote\":[\"spanish\"],\"recaer\":[\"spanish\"],\"receta\":[\"spanish\"],\"rechazo\":[\"spanish\"],\"recoger\":[\"spanish\"],\"recreo\":[\"spanish\"],\"recto\":[\"spanish\"],\"recurso\":[\"spanish\"],\"red\":[\"spanish\"],\"redondo\":[\"spanish\"],\"reducir\":[\"spanish\"],\"reflejo\":[\"spanish\"],\"reforma\":[\"spanish\"],\"refran\":[\"spanish\"],\"refugio\":[\"spanish\"],\"regalo\":[\"spanish\"],\"regir\":[\"spanish\"],\"regla\":[\"spanish\"],\"regreso\":[\"spanish\"],\"rehen\":[\"spanish\"],\"reino\":[\"spanish\"],\"reir\":[\"spanish\"],\"reja\":[\"spanish\"],\"relato\":[\"spanish\"],\"relevo\":[\"spanish\"],\"relieve\":[\"spanish\"],\"relleno\":[\"spanish\"],\"reloj\":[\"spanish\"],\"remar\":[\"spanish\"],\"remedio\":[\"spanish\"],\"remo\":[\"spanish\"],\"rencor\":[\"spanish\"],\"rendir\":[\"spanish\"],\"renta\":[\"spanish\"],\"reparto\":[\"spanish\"],\"repetir\":[\"spanish\"],\"reposo\":[\"spanish\"],\"reptil\":[\"spanish\"],\"res\":[\"spanish\"],\"rescate\":[\"spanish\"],\"resina\":[\"spanish\"],\"respeto\":[\"spanish\"],\"resto\":[\"spanish\"],\"resumen\":[\"spanish\"],\"retiro\":[\"spanish\"],\"retorno\":[\"spanish\"],\"retrato\":[\"spanish\"],\"reunir\":[\"spanish\"],\"reves\":[\"spanish\"],\"revista\":[\"spanish\"],\"rey\":[\"spanish\"],\"rezar\":[\"spanish\"],\"rico\":[\"spanish\"],\"riego\":[\"spanish\"],\"rienda\":[\"spanish\"],\"riesgo\":[\"spanish\"],\"rifa\":[\"spanish\"],\"rigido\":[\"spanish\"],\"rigor\":[\"spanish\"],\"rincon\":[\"spanish\"],\"rinon\":[\"spanish\"],\"rio\":[\"spanish\"],\"riqueza\":[\"spanish\"],\"risa\":[\"spanish\"],\"ritmo\":[\"spanish\"],\"rito\":[\"spanish\"],\"rizo\":[\"spanish\"],\"roble\":[\"spanish\"],\"roce\":[\"spanish\"],\"rociar\":[\"spanish\"],\"rodar\":[\"spanish\"],\"rodeo\":[\"spanish\"],\"rodilla\":[\"spanish\"],\"roer\":[\"spanish\"],\"rojizo\":[\"spanish\"],\"rojo\":[\"spanish\"],\"romero\":[\"spanish\"],\"romper\":[\"spanish\"],\"ron\":[\"spanish\"],\"ronco\":[\"spanish\"],\"ronda\":[\"spanish\"],\"ropa\":[\"spanish\"],\"ropero\":[\"spanish\"],\"rosa\":[\"spanish\"],\"rosca\":[\"spanish\"],\"rostro\":[\"spanish\"],\"rotar\":[\"spanish\"],\"rubi\":[\"spanish\"],\"rubor\":[\"spanish\"],\"rudo\":[\"spanish\"],\"rueda\":[\"spanish\"],\"rugir\":[\"spanish\"],\"ruido\":[\"spanish\"],\"ruina\":[\"spanish\"],\"ruleta\":[\"spanish\"],\"rulo\":[\"spanish\",\"turkish\"],\"rumbo\":[\"spanish\"],\"rumor\":[\"spanish\"],\"ruptura\":[\"spanish\"],\"ruta\":[\"spanish\"],\"rutina\":[\"spanish\"],\"sabado\":[\"spanish\"],\"saber\":[\"spanish\"],\"sabio\":[\"spanish\"],\"sable\":[\"spanish\"],\"sacar\":[\"spanish\"],\"sagaz\":[\"spanish\"],\"sagrado\":[\"spanish\"],\"sala\":[\"spanish\"],\"saldo\":[\"spanish\"],\"salero\":[\"spanish\"],\"salir\":[\"spanish\"],\"salmon\":[\"spanish\"],\"salon\":[\"spanish\"],\"salsa\":[\"spanish\"],\"salto\":[\"spanish\"],\"salud\":[\"spanish\"],\"salvar\":[\"spanish\"],\"samba\":[\"spanish\"],\"sancion\":[\"spanish\"],\"sandia\":[\"spanish\"],\"sanear\":[\"spanish\"],\"sangre\":[\"spanish\"],\"sanidad\":[\"spanish\"],\"sano\":[\"spanish\"],\"santo\":[\"spanish\"],\"sapo\":[\"spanish\"],\"saque\":[\"spanish\"],\"sardina\":[\"spanish\"],\"sarten\":[\"spanish\"],\"sastre\":[\"spanish\"],\"satan\":[\"spanish\"],\"sauna\":[\"spanish\"],\"saxofon\":[\"spanish\"],\"seccion\":[\"spanish\"],\"seco\":[\"spanish\"],\"secreto\":[\"spanish\"],\"secta\":[\"spanish\"],\"sed\":[\"spanish\"],\"seguir\":[\"spanish\"],\"seis\":[\"spanish\"],\"sello\":[\"spanish\"],\"selva\":[\"spanish\"],\"semana\":[\"spanish\"],\"semilla\":[\"spanish\"],\"senda\":[\"spanish\"],\"sensor\":[\"spanish\"],\"senal\":[\"spanish\"],\"senor\":[\"spanish\"],\"separar\":[\"spanish\"],\"sepia\":[\"spanish\"],\"sequia\":[\"spanish\"],\"ser\":[\"spanish\"],\"serie\":[\"spanish\"],\"sermon\":[\"spanish\"],\"servir\":[\"spanish\"],\"sesenta\":[\"spanish\"],\"sesion\":[\"spanish\"],\"seta\":[\"spanish\"],\"setenta\":[\"spanish\"],\"severo\":[\"spanish\"],\"sexo\":[\"spanish\"],\"sexto\":[\"spanish\"],\"sidra\":[\"spanish\"],\"siesta\":[\"spanish\"],\"siete\":[\"spanish\"],\"siglo\":[\"spanish\"],\"signo\":[\"spanish\"],\"silaba\":[\"spanish\"],\"silbar\":[\"spanish\"],\"silencio\":[\"spanish\"],\"silla\":[\"spanish\"],\"simbolo\":[\"spanish\"],\"simio\":[\"spanish\"],\"sirena\":[\"spanish\"],\"sistema\":[\"spanish\"],\"sitio\":[\"spanish\"],\"situar\":[\"spanish\"],\"sobre\":[\"spanish\"],\"socio\":[\"spanish\"],\"sodio\":[\"spanish\"],\"sol\":[\"spanish\"],\"solapa\":[\"spanish\"],\"soldado\":[\"spanish\"],\"soledad\":[\"spanish\"],\"solido\":[\"spanish\"],\"soltar\":[\"spanish\"],\"solucion\":[\"spanish\"],\"sombra\":[\"spanish\"],\"sondeo\":[\"spanish\"],\"sonido\":[\"spanish\"],\"sonoro\":[\"spanish\"],\"sonrisa\":[\"spanish\"],\"sopa\":[\"spanish\"],\"soplar\":[\"spanish\"],\"soporte\":[\"spanish\"],\"sordo\":[\"spanish\"],\"sorpresa\":[\"spanish\"],\"sorteo\":[\"spanish\"],\"sosten\":[\"spanish\"],\"sotano\":[\"spanish\"],\"suave\":[\"spanish\"],\"subir\":[\"spanish\"],\"suceso\":[\"spanish\"],\"sudor\":[\"spanish\"],\"suegra\":[\"spanish\"],\"suelo\":[\"spanish\"],\"sueno\":[\"spanish\"],\"suerte\":[\"spanish\"],\"sufrir\":[\"spanish\"],\"sujeto\":[\"spanish\"],\"sultan\":[\"spanish\"],\"sumar\":[\"spanish\"],\"superar\":[\"spanish\"],\"suplir\":[\"spanish\"],\"suponer\":[\"spanish\"],\"supremo\":[\"spanish\"],\"sur\":[\"spanish\"],\"surco\":[\"spanish\"],\"sureno\":[\"spanish\"],\"surgir\":[\"spanish\"],\"susto\":[\"spanish\"],\"sutil\":[\"spanish\"],\"tabaco\":[\"spanish\"],\"tabique\":[\"spanish\"],\"tabla\":[\"spanish\"],\"tabu\":[\"spanish\"],\"taco\":[\"spanish\"],\"tacto\":[\"spanish\"],\"tajo\":[\"spanish\"],\"talar\":[\"spanish\"],\"talco\":[\"spanish\"],\"talento\":[\"spanish\"],\"talla\":[\"spanish\"],\"talon\":[\"spanish\"],\"tamano\":[\"spanish\"],\"tambor\":[\"spanish\"],\"tango\":[\"spanish\"],\"tanque\":[\"spanish\"],\"tapa\":[\"spanish\"],\"tapete\":[\"spanish\"],\"tapia\":[\"spanish\"],\"tapon\":[\"spanish\"],\"taquilla\":[\"spanish\"],\"tarde\":[\"spanish\"],\"tarea\":[\"spanish\"],\"tarifa\":[\"spanish\"],\"tarjeta\":[\"spanish\"],\"tarot\":[\"spanish\"],\"tarro\":[\"spanish\"],\"tarta\":[\"spanish\"],\"tatuaje\":[\"spanish\"],\"tauro\":[\"spanish\"],\"taza\":[\"spanish\"],\"tazon\":[\"spanish\"],\"teatro\":[\"spanish\"],\"techo\":[\"spanish\"],\"tecla\":[\"spanish\"],\"tecnica\":[\"spanish\"],\"tejado\":[\"spanish\"],\"tejer\":[\"spanish\"],\"tejido\":[\"spanish\"],\"tela\":[\"spanish\"],\"telefono\":[\"spanish\"],\"tema\":[\"spanish\"],\"temor\":[\"spanish\"],\"templo\":[\"spanish\"],\"tenaz\":[\"spanish\"],\"tender\":[\"spanish\"],\"tener\":[\"spanish\"],\"tenis\":[\"spanish\"],\"tenso\":[\"spanish\"],\"teoria\":[\"spanish\"],\"terapia\":[\"spanish\"],\"terco\":[\"spanish\"],\"termino\":[\"spanish\"],\"ternura\":[\"spanish\"],\"terror\":[\"spanish\"],\"tesis\":[\"spanish\"],\"tesoro\":[\"spanish\"],\"testigo\":[\"spanish\"],\"tetera\":[\"spanish\"],\"texto\":[\"spanish\"],\"tez\":[\"spanish\"],\"tibio\":[\"spanish\"],\"tiburon\":[\"spanish\"],\"tiempo\":[\"spanish\"],\"tienda\":[\"spanish\"],\"tierra\":[\"spanish\"],\"tieso\":[\"spanish\"],\"tigre\":[\"spanish\"],\"tijera\":[\"spanish\"],\"tilde\":[\"spanish\"],\"timbre\":[\"spanish\"],\"timido\":[\"spanish\"],\"timo\":[\"spanish\"],\"tinta\":[\"spanish\"],\"tio\":[\"spanish\"],\"tipico\":[\"spanish\"],\"tipo\":[\"spanish\"],\"tira\":[\"spanish\"],\"tiron\":[\"spanish\"],\"titan\":[\"spanish\"],\"titere\":[\"spanish\"],\"titulo\":[\"spanish\"],\"tiza\":[\"spanish\"],\"toalla\":[\"spanish\"],\"tobillo\":[\"spanish\"],\"tocar\":[\"spanish\"],\"tocino\":[\"spanish\"],\"todo\":[\"spanish\"],\"toga\":[\"spanish\"],\"toldo\":[\"spanish\"],\"tomar\":[\"spanish\",\"turkish\"],\"tono\":[\"spanish\"],\"tonto\":[\"spanish\"],\"topar\":[\"spanish\"],\"tope\":[\"spanish\"],\"toque\":[\"spanish\"],\"torax\":[\"spanish\"],\"torero\":[\"spanish\"],\"tormenta\":[\"spanish\"],\"torneo\":[\"spanish\"],\"toro\":[\"spanish\"],\"torpedo\":[\"spanish\"],\"torre\":[\"spanish\"],\"torso\":[\"spanish\"],\"tortuga\":[\"spanish\"],\"tos\":[\"spanish\"],\"tosco\":[\"spanish\"],\"toser\":[\"spanish\"],\"toxico\":[\"spanish\"],\"trabajo\":[\"spanish\"],\"tractor\":[\"spanish\"],\"traer\":[\"spanish\"],\"trafico\":[\"spanish\"],\"trago\":[\"spanish\"],\"traje\":[\"spanish\"],\"tramo\":[\"spanish\"],\"trance\":[\"spanish\"],\"trato\":[\"spanish\"],\"trauma\":[\"spanish\"],\"trazar\":[\"spanish\"],\"trebol\":[\"spanish\"],\"tregua\":[\"spanish\"],\"treinta\":[\"spanish\"],\"tren\":[\"spanish\"],\"trepar\":[\"spanish\"],\"tres\":[\"spanish\"],\"tribu\":[\"spanish\"],\"trigo\":[\"spanish\"],\"tripa\":[\"spanish\"],\"triste\":[\"spanish\"],\"triunfo\":[\"spanish\"],\"trofeo\":[\"spanish\"],\"trompa\":[\"spanish\"],\"tronco\":[\"spanish\"],\"tropa\":[\"spanish\"],\"trote\":[\"spanish\"],\"trozo\":[\"spanish\"],\"truco\":[\"spanish\"],\"trueno\":[\"spanish\"],\"trufa\":[\"spanish\"],\"tuberia\":[\"spanish\"],\"tubo\":[\"spanish\"],\"tuerto\":[\"spanish\"],\"tumba\":[\"spanish\"],\"tumor\":[\"spanish\"],\"tunel\":[\"spanish\"],\"tunica\":[\"spanish\"],\"turbina\":[\"spanish\"],\"turismo\":[\"spanish\"],\"turno\":[\"spanish\"],\"tutor\":[\"spanish\"],\"ubicar\":[\"spanish\"],\"ulcera\":[\"spanish\"],\"umbral\":[\"spanish\"],\"unidad\":[\"spanish\"],\"unir\":[\"spanish\"],\"universo\":[\"spanish\"],\"uno\":[\"spanish\"],\"untar\":[\"spanish\"],\"una\":[\"spanish\"],\"urbano\":[\"spanish\"],\"urbe\":[\"spanish\"],\"urgente\":[\"spanish\"],\"urna\":[\"spanish\"],\"usar\":[\"spanish\"],\"usuario\":[\"spanish\"],\"util\":[\"spanish\"],\"utopia\":[\"spanish\"],\"uva\":[\"spanish\"],\"vaca\":[\"spanish\"],\"vacio\":[\"spanish\"],\"vacuna\":[\"spanish\"],\"vagar\":[\"spanish\"],\"vago\":[\"spanish\"],\"vaina\":[\"spanish\"],\"vajilla\":[\"spanish\"],\"vale\":[\"spanish\"],\"valido\":[\"spanish\"],\"valle\":[\"spanish\"],\"valor\":[\"spanish\"],\"valvula\":[\"spanish\"],\"vampiro\":[\"spanish\"],\"vara\":[\"spanish\"],\"variar\":[\"spanish\"],\"varon\":[\"spanish\"],\"vaso\":[\"spanish\"],\"vecino\":[\"spanish\"],\"vector\":[\"spanish\"],\"vehiculo\":[\"spanish\"],\"veinte\":[\"spanish\"],\"vejez\":[\"spanish\"],\"vela\":[\"spanish\"],\"velero\":[\"spanish\"],\"veloz\":[\"spanish\"],\"vena\":[\"spanish\"],\"vencer\":[\"spanish\"],\"venda\":[\"spanish\"],\"veneno\":[\"spanish\"],\"vengar\":[\"spanish\"],\"venir\":[\"spanish\"],\"venta\":[\"spanish\"],\"venus\":[\"spanish\"],\"ver\":[\"spanish\"],\"verano\":[\"spanish\"],\"verbo\":[\"spanish\"],\"verde\":[\"spanish\"],\"vereda\":[\"spanish\"],\"verja\":[\"spanish\"],\"verso\":[\"spanish\"],\"verter\":[\"spanish\"],\"via\":[\"spanish\"],\"viaje\":[\"spanish\"],\"vibrar\":[\"spanish\"],\"vicio\":[\"spanish\"],\"victima\":[\"spanish\"],\"vida\":[\"spanish\"],\"video\":[\"spanish\"],\"vidrio\":[\"spanish\"],\"viejo\":[\"spanish\"],\"viernes\":[\"spanish\"],\"vigor\":[\"spanish\"],\"vil\":[\"spanish\"],\"villa\":[\"spanish\"],\"vinagre\":[\"spanish\"],\"vino\":[\"spanish\"],\"vinedo\":[\"spanish\"],\"violin\":[\"spanish\"],\"viral\":[\"spanish\"],\"virgo\":[\"spanish\"],\"virtud\":[\"spanish\"],\"visor\":[\"spanish\"],\"vispera\":[\"spanish\"],\"vista\":[\"spanish\"],\"vitamina\":[\"spanish\"],\"viudo\":[\"spanish\"],\"vivaz\":[\"spanish\"],\"vivero\":[\"spanish\"],\"vivir\":[\"spanish\"],\"vivo\":[\"spanish\"],\"volcan\":[\"spanish\"],\"volumen\":[\"spanish\"],\"volver\":[\"spanish\"],\"voraz\":[\"spanish\"],\"votar\":[\"spanish\"],\"voto\":[\"spanish\"],\"voz\":[\"spanish\"],\"vuelo\":[\"spanish\"],\"vulgar\":[\"spanish\"],\"yacer\":[\"spanish\"],\"yate\":[\"spanish\"],\"yegua\":[\"spanish\"],\"yema\":[\"spanish\"],\"yerno\":[\"spanish\"],\"yeso\":[\"spanish\"],\"yodo\":[\"spanish\"],\"yoga\":[\"spanish\"],\"yogur\":[\"spanish\"],\"zafiro\":[\"spanish\"],\"zanja\":[\"spanish\"],\"zapato\":[\"spanish\"],\"zarza\":[\"spanish\"],\"zona\":[\"spanish\"],\"zorro\":[\"spanish\"],\"zumo\":[\"spanish\"],\"zurdo\":[\"spanish\"],\"abajur\":[\"turkish\"],\"abaks\":[\"turkish\"],\"abart\":[\"turkish\"],\"abdal\":[\"turkish\"],\"abdest\":[\"turkish\"],\"abiye\":[\"turkish\"],\"abluka\":[\"turkish\"],\"abone\":[\"turkish\"],\"absorbe\":[\"turkish\"],\"absrt\":[\"turkish\"],\"acayip\":[\"turkish\"],\"acele\":[\"turkish\"],\"acemi\":[\"turkish\"],\"akgz\":[\"turkish\"],\"adalet\":[\"turkish\"],\"adam\":[\"turkish\"],\"adezyon\":[\"turkish\"],\"adisyon\":[\"turkish\"],\"adliye\":[\"turkish\"],\"adres\":[\"turkish\"],\"afacan\":[\"turkish\"],\"afili\":[\"turkish\"],\"afi\":[\"turkish\"],\"afiyet\":[\"turkish\"],\"aforizm\":[\"turkish\"],\"afra\":[\"turkish\"],\"aa\":[\"turkish\"],\"ar\":[\"turkish\"],\"ahbap\":[\"turkish\"],\"ahkam\":[\"turkish\"],\"ahlak\":[\"turkish\"],\"ahtapot\":[\"turkish\"],\"aidat\":[\"turkish\"],\"aile\":[\"turkish\"],\"ajan\":[\"turkish\"],\"akademi\":[\"turkish\"],\"akarsu\":[\"turkish\"],\"akba\":[\"turkish\"],\"akcier\":[\"turkish\"],\"akdeniz\":[\"turkish\"],\"akbet\":[\"turkish\"],\"akl\":[\"turkish\"],\"aknt\":[\"turkish\"],\"akide\":[\"turkish\"],\"akrep\":[\"turkish\"],\"akrobasi\":[\"turkish\"],\"aksiyon\":[\"turkish\"],\"akam\":[\"turkish\"],\"aktif\":[\"turkish\"],\"aktr\":[\"turkish\"],\"aktris\":[\"turkish\"],\"akustik\":[\"turkish\"],\"alaca\":[\"turkish\"],\"albm\":[\"turkish\"],\"alak\":[\"turkish\"],\"aldanma\":[\"turkish\"],\"aleni\":[\"turkish\"],\"alet\":[\"turkish\"],\"alfabe\":[\"turkish\"],\"alglama\":[\"turkish\"],\"alngan\":[\"turkish\"],\"alk\":[\"turkish\"],\"alkol\":[\"turkish\"],\"alpay\":[\"turkish\"],\"alperen\":[\"turkish\"],\"altn\":[\"turkish\"],\"altst\":[\"turkish\"],\"altyap\":[\"turkish\"],\"alyuvar\":[\"turkish\"],\"amade\":[\"turkish\"],\"amatr\":[\"turkish\"],\"amazon\":[\"turkish\"],\"ambalaj\":[\"turkish\"],\"amblem\":[\"turkish\"],\"ambulans\":[\"turkish\"],\"amca\":[\"turkish\"],\"amel\":[\"turkish\"],\"amir\":[\"turkish\"],\"amiyane\":[\"turkish\"],\"amorti\":[\"turkish\"],\"ampul\":[\"turkish\"],\"anadolu\":[\"turkish\"],\"anahtar\":[\"turkish\"],\"anakonda\":[\"turkish\"],\"anaokul\":[\"turkish\"],\"anapara\":[\"turkish\"],\"anari\":[\"turkish\"],\"anatomi\":[\"turkish\"],\"anayasa\":[\"turkish\"],\"anekdot\":[\"turkish\"],\"anestezi\":[\"turkish\"],\"angaje\":[\"turkish\"],\"anka\":[\"turkish\"],\"anket\":[\"turkish\"],\"anlaml\":[\"turkish\"],\"anne\":[\"turkish\"],\"anomali\":[\"turkish\"],\"anonim\":[\"turkish\"],\"anten\":[\"turkish\"],\"antlama\":[\"turkish\"],\"apse\":[\"turkish\"],\"araba\":[\"turkish\"],\"arac\":[\"turkish\"],\"araf\":[\"turkish\"],\"arbede\":[\"turkish\"],\"arda\":[\"turkish\"],\"arefe\":[\"turkish\"],\"argo\":[\"turkish\"],\"argman\":[\"turkish\"],\"arkada\":[\"turkish\"],\"armoni\":[\"turkish\"],\"arsa\":[\"turkish\"],\"arsz\":[\"turkish\"],\"art\":[\"turkish\"],\"aruz\":[\"turkish\"],\"asansr\":[\"turkish\"],\"asayi\":[\"turkish\"],\"asgari\":[\"turkish\"],\"asil\":[\"turkish\"],\"asker\":[\"turkish\"],\"ask\":[\"turkish\"],\"aslan\":[\"turkish\"],\"asosyal\":[\"turkish\"],\"astsubay\":[\"turkish\"],\"asya\":[\"turkish\"],\"a\":[\"turkish\"],\"ar\":[\"turkish\"],\"aure\":[\"turkish\"],\"atabey\":[\"turkish\"],\"ataman\":[\"turkish\"],\"ate\":[\"turkish\"],\"atmaca\":[\"turkish\"],\"atmosfer\":[\"turkish\"],\"atlye\":[\"turkish\"],\"avc\":[\"turkish\"],\"avdet\":[\"turkish\"],\"avize\":[\"turkish\"],\"avlu\":[\"turkish\"],\"avokado\":[\"turkish\"],\"avrupa\":[\"turkish\"],\"avukat\":[\"turkish\"],\"ayaz\":[\"turkish\"],\"ayiei\":[\"turkish\"],\"aydn\":[\"turkish\"],\"aygt\":[\"turkish\"],\"ayna\":[\"turkish\"],\"ayran\":[\"turkish\"],\"ayrnt\":[\"turkish\"],\"azim\":[\"turkish\"],\"baca\":[\"turkish\"],\"bagaj\":[\"turkish\"],\"balant\":[\"turkish\"],\"bahadr\":[\"turkish\"],\"bahe\":[\"turkish\"],\"baki\":[\"turkish\"],\"bakkal\":[\"turkish\"],\"baklava\":[\"turkish\"],\"bakteri\":[\"turkish\"],\"balk\":[\"turkish\"],\"balina\":[\"turkish\"],\"balo\":[\"turkish\"],\"balta\":[\"turkish\"],\"bant\":[\"turkish\"],\"banyo\":[\"turkish\"],\"bardak\":[\"turkish\"],\"bar\":[\"turkish\"],\"babu\":[\"turkish\"],\"babo\":[\"turkish\"],\"bakan\":[\"turkish\"],\"balk\":[\"turkish\"],\"bavul\":[\"turkish\"],\"bayndr\":[\"turkish\"],\"bayku\":[\"turkish\"],\"bazlama\":[\"turkish\"],\"bedel\":[\"turkish\"],\"begm\":[\"turkish\"],\"beki\":[\"turkish\"],\"bekle\":[\"turkish\"],\"belge\":[\"turkish\"],\"belki\":[\"turkish\"],\"bencil\":[\"turkish\"],\"benek\":[\"turkish\"],\"bengi\":[\"turkish\"],\"berjer\":[\"turkish\"],\"berk\":[\"turkish\"],\"berrak\":[\"turkish\"],\"beik\":[\"turkish\"],\"beyin\":[\"turkish\"],\"beyolu\":[\"turkish\"],\"bak\":[\"turkish\"],\"biberiye\":[\"turkish\"],\"bidon\":[\"turkish\"],\"bihaber\":[\"turkish\"],\"bikini\":[\"turkish\"],\"bilezik\":[\"turkish\"],\"bilin\":[\"turkish\"],\"bilye\":[\"turkish\"],\"bina\":[\"turkish\"],\"binba\":[\"turkish\"],\"binyl\":[\"turkish\"],\"bisiklet\":[\"turkish\"],\"biskvi\":[\"turkish\"],\"bitki\":[\"turkish\"],\"bizzat\":[\"turkish\"],\"bodrum\":[\"turkish\"],\"boaz\":[\"turkish\"],\"boha\":[\"turkish\"],\"boncuk\":[\"turkish\"],\"bonfile\":[\"turkish\"],\"borsa\":[\"turkish\"],\"boru\":[\"turkish\"],\"bostan\":[\"turkish\"],\"boboaz\":[\"turkish\"],\"botanik\":[\"turkish\"],\"boya\":[\"turkish\"],\"boykot\":[\"turkish\"],\"boynuz\":[\"turkish\"],\"bozgun\":[\"turkish\"],\"bozkr\":[\"turkish\"],\"blm\":[\"turkish\"],\"brek\":[\"turkish\"],\"buuk\":[\"turkish\"],\"bugn\":[\"turkish\"],\"buday\":[\"turkish\"],\"buhar\":[\"turkish\"],\"buhran\":[\"turkish\"],\"bulvar\":[\"turkish\"],\"buram\":[\"turkish\"],\"burak\":[\"turkish\"],\"burs\":[\"turkish\"],\"burun\":[\"turkish\"],\"buzda\":[\"turkish\"],\"buzkran\":[\"turkish\"],\"bcr\":[\"turkish\"],\"bfe\":[\"turkish\"],\"blten\":[\"turkish\"],\"bte\":[\"turkish\"],\"btn\":[\"turkish\"],\"byk\":[\"turkish\"],\"cack\":[\"turkish\"],\"cad\":[\"turkish\"],\"cahil\":[\"turkish\"],\"cambaz\":[\"turkish\"],\"canhra\":[\"turkish\"],\"casus\":[\"turkish\"],\"cazibe\":[\"turkish\"],\"cehalet\":[\"turkish\"],\"cehennem\":[\"turkish\"],\"ceket\":[\"turkish\"],\"cemre\":[\"turkish\"],\"cenin\":[\"turkish\"],\"cennet\":[\"turkish\"],\"cepken\":[\"turkish\"],\"cerrah\":[\"turkish\"],\"cesur\":[\"turkish\"],\"cetvel\":[\"turkish\"],\"cevher\":[\"turkish\"],\"ceylan\":[\"turkish\"],\"clz\":[\"turkish\"],\"cva\":[\"turkish\"],\"cilt\":[\"turkish\"],\"cisim\":[\"turkish\"],\"ciyak\":[\"turkish\"],\"corafya\":[\"turkish\"],\"cmert\":[\"turkish\"],\"cumba\":[\"turkish\"],\"czdan\":[\"turkish\"],\"abucak\":[\"turkish\"],\"adr\":[\"turkish\"],\"ada\":[\"turkish\"],\"alayan\":[\"turkish\"],\"ar\":[\"turkish\"],\"akmak\":[\"turkish\"],\"alkan\":[\"turkish\"],\"amar\":[\"turkish\"],\"apa\":[\"turkish\"],\"aput\":[\"turkish\"],\"ark\":[\"turkish\"],\"arpan\":[\"turkish\"],\"araf\":[\"turkish\"],\"ayhane\":[\"turkish\"],\"ekirdek\":[\"turkish\"],\"elebi\":[\"turkish\"],\"ember\":[\"turkish\"],\"enet\":[\"turkish\"],\"engel\":[\"turkish\"],\"ereve\":[\"turkish\"],\"erez\":[\"turkish\"],\"eit\":[\"turkish\"],\"eme\":[\"turkish\"],\"ete\":[\"turkish\"],\"evre\":[\"turkish\"],\"eyiz\":[\"turkish\"],\"eyrek\":[\"turkish\"],\"r\":[\"turkish\"],\"lgn\":[\"turkish\"],\"ngrak\":[\"turkish\"],\"ift\":[\"turkish\"],\"idem\":[\"turkish\"],\"ikolata\":[\"turkish\"],\"ilek\":[\"turkish\"],\"imen\":[\"turkish\"],\"ivi\":[\"turkish\"],\"oban\":[\"turkish\"],\"ocuk\":[\"turkish\"],\"okgen\":[\"turkish\"],\"omak\":[\"turkish\"],\"orba\":[\"turkish\"],\"zelti\":[\"turkish\"],\"ubuk\":[\"turkish\"],\"ukur\":[\"turkish\"],\"uval\":[\"turkish\"],\"rk\":[\"turkish\"],\"daba\":[\"turkish\"],\"dalm\":[\"turkish\"],\"daktilo\":[\"turkish\"],\"daldr\":[\"turkish\"],\"dalga\":[\"turkish\"],\"dalkavuk\":[\"turkish\"],\"damak\":[\"turkish\"],\"damtma\":[\"turkish\"],\"damla\":[\"turkish\"],\"dana\":[\"turkish\"],\"dandik\":[\"turkish\"],\"danman\":[\"turkish\"],\"daniska\":[\"turkish\"],\"dantel\":[\"turkish\"],\"dargeit\":[\"turkish\"],\"darphane\":[\"turkish\"],\"davet\":[\"turkish\"],\"day\":[\"turkish\"],\"defter\":[\"turkish\"],\"deer\":[\"turkish\"],\"deirmen\":[\"turkish\"],\"dehet\":[\"turkish\"],\"delge\":[\"turkish\"],\"demir\":[\"turkish\"],\"deneyim\":[\"turkish\"],\"denge\":[\"turkish\"],\"depo\":[\"turkish\"],\"deprem\":[\"turkish\"],\"derdest\":[\"turkish\"],\"dere\":[\"turkish\"],\"derhal\":[\"turkish\"],\"derman\":[\"turkish\"],\"dernek\":[\"turkish\"],\"dervi\":[\"turkish\"],\"desen\":[\"turkish\"],\"destan\":[\"turkish\"],\"dar\":[\"turkish\"],\"dbkey\":[\"turkish\"],\"dijital\":[\"turkish\"],\"dikbal\":[\"turkish\"],\"dileke\":[\"turkish\"],\"dima\":[\"turkish\"],\"dinamik\":[\"turkish\"],\"dindar\":[\"turkish\"],\"dinleme\":[\"turkish\"],\"dinozor\":[\"turkish\"],\"dipik\":[\"turkish\"],\"dipnot\":[\"turkish\"],\"direni\":[\"turkish\"],\"dirsek\":[\"turkish\"],\"disiplin\":[\"turkish\"],\"divrii\":[\"turkish\"],\"dizst\":[\"turkish\"],\"dobra\":[\"turkish\"],\"dodurga\":[\"turkish\"],\"doalgaz\":[\"turkish\"],\"dokman\":[\"turkish\"],\"dolap\":[\"turkish\"],\"donanm\":[\"turkish\"],\"dondurma\":[\"turkish\"],\"donr\":[\"turkish\"],\"doruk\":[\"turkish\"],\"dosdoru\":[\"turkish\"],\"dost\":[\"turkish\"],\"dosya\":[\"turkish\"],\"dozer\":[\"turkish\"],\"dkm\":[\"turkish\"],\"dnence\":[\"turkish\"],\"drtyol\":[\"turkish\"],\"dvme\":[\"turkish\"],\"dram\":[\"turkish\"],\"dublaj\":[\"turkish\"],\"durum\":[\"turkish\"],\"duvak\":[\"turkish\"],\"duyarga\":[\"turkish\"],\"duyma\":[\"turkish\"],\"duyuru\":[\"turkish\"],\"dme\":[\"turkish\"],\"dm\":[\"turkish\"],\"dkkan\":[\"turkish\"],\"dnr\":[\"turkish\"],\"dpedz\":[\"turkish\"],\"drbn\":[\"turkish\"],\"dnr\":[\"turkish\"],\"dzayak\":[\"turkish\"],\"dzeltme\":[\"turkish\"],\"ebeveyn\":[\"turkish\"],\"ebru\":[\"turkish\"],\"ecel\":[\"turkish\"],\"ecnebi\":[\"turkish\"],\"ecza\":[\"turkish\"],\"edat\":[\"turkish\"],\"edilgen\":[\"turkish\"],\"efendi\":[\"turkish\"],\"efor\":[\"turkish\"],\"efsane\":[\"turkish\"],\"egemen\":[\"turkish\"],\"egzersiz\":[\"turkish\"],\"erelti\":[\"turkish\"],\"ekarte\":[\"turkish\"],\"ekip\":[\"turkish\"],\"eklem\":[\"turkish\"],\"ekmek\":[\"turkish\"],\"ekol\":[\"turkish\"],\"ekonomi\":[\"turkish\"],\"ekose\":[\"turkish\"],\"ekran\":[\"turkish\"],\"ekvator\":[\"turkish\"],\"elaman\":[\"turkish\"],\"elastik\":[\"turkish\"],\"elbet\":[\"turkish\"],\"elbise\":[\"turkish\"],\"eli\":[\"turkish\"],\"eldiven\":[\"turkish\"],\"eleba\":[\"turkish\"],\"eletiri\":[\"turkish\"],\"elma\":[\"turkish\"],\"elolu\":[\"turkish\"],\"elveda\":[\"turkish\"],\"emare\":[\"turkish\"],\"emeki\":[\"turkish\"],\"emisyon\":[\"turkish\"],\"emniyet\":[\"turkish\"],\"empati\":[\"turkish\"],\"emsal\":[\"turkish\"],\"emzik\":[\"turkish\"],\"endstri\":[\"turkish\"],\"enerji\":[\"turkish\"],\"engebe\":[\"turkish\"],\"enite\":[\"turkish\"],\"enkaz\":[\"turkish\"],\"entari\":[\"turkish\"],\"entegre\":[\"turkish\"],\"entrika\":[\"turkish\"],\"enzim\":[\"turkish\"],\"erdem\":[\"turkish\"],\"ergen\":[\"turkish\"],\"erguvan\":[\"turkish\"],\"erkek\":[\"turkish\"],\"erozyon\":[\"turkish\"],\"ertesi\":[\"turkish\"],\"erzak\":[\"turkish\"],\"esaret\":[\"turkish\"],\"esenlik\":[\"turkish\"],\"eser\":[\"turkish\"],\"eski\":[\"turkish\"],\"esnek\":[\"turkish\"],\"earp\":[\"turkish\"],\"eofman\":[\"turkish\"],\"eraf\":[\"turkish\"],\"eya\":[\"turkish\"],\"ezaman\":[\"turkish\"],\"etik\":[\"turkish\"],\"etken\":[\"turkish\"],\"etkinlik\":[\"turkish\"],\"ett\":[\"turkish\"],\"evet\":[\"turkish\"],\"evire\":[\"turkish\"],\"evrak\":[\"turkish\"],\"evrim\":[\"turkish\"],\"eyalet\":[\"turkish\"],\"eyvah\":[\"turkish\"],\"ezber\":[\"turkish\"],\"fabrika\":[\"turkish\"],\"fanus\":[\"turkish\"],\"fason\":[\"turkish\"],\"fasulye\":[\"turkish\"],\"fatih\":[\"turkish\"],\"fatura\":[\"turkish\"],\"fayans\":[\"turkish\"],\"fayton\":[\"turkish\"],\"fazl\":[\"turkish\"],\"fazilet\":[\"turkish\"],\"felsefe\":[\"turkish\"],\"fener\":[\"turkish\"],\"feribot\":[\"turkish\"],\"fersah\":[\"turkish\"],\"fesih\":[\"turkish\"],\"feveran\":[\"turkish\"],\"feza\":[\"turkish\"],\"f\":[\"turkish\"],\"fldr\":[\"turkish\"],\"fndk\":[\"turkish\"],\"fra\":[\"turkish\"],\"frsat\":[\"turkish\"],\"frtna\":[\"turkish\"],\"ftk\":[\"turkish\"],\"fidan\":[\"turkish\"],\"fidye\":[\"turkish\"],\"figr\":[\"turkish\"],\"fihrist\":[\"turkish\"],\"fikir\":[\"turkish\"],\"fildii\":[\"turkish\"],\"filtre\":[\"turkish\"],\"fincan\":[\"turkish\"],\"firuze\":[\"turkish\"],\"fitil\":[\"turkish\"],\"fiyaka\":[\"turkish\"],\"fizik\":[\"turkish\"],\"fla\":[\"turkish\"],\"flt\":[\"turkish\"],\"fosil\":[\"turkish\"],\"fren\":[\"turkish\"],\"fukara\":[\"turkish\"],\"futbol\":[\"turkish\"],\"garabet\":[\"turkish\"],\"gariban\":[\"turkish\"],\"garnitr\":[\"turkish\"],\"gazi\":[\"turkish\"],\"gece\":[\"turkish\"],\"gedik\":[\"turkish\"],\"gelenek\":[\"turkish\"],\"gelin\":[\"turkish\"],\"gemi\":[\"turkish\"],\"gen\":[\"turkish\"],\"geni\":[\"turkish\"],\"geometri\":[\"turkish\"],\"gerek\":[\"turkish\"],\"gevrek\":[\"turkish\"],\"gezegen\":[\"turkish\"],\"gezgin\":[\"turkish\"],\"geziyolu\":[\"turkish\"],\"gck\":[\"turkish\"],\"gda\":[\"turkish\"],\"gybet\":[\"turkish\"],\"girdap\":[\"turkish\"],\"giriim\":[\"turkish\"],\"gitar\":[\"turkish\"],\"giyecek\":[\"turkish\"],\"giysi\":[\"turkish\"],\"gizem\":[\"turkish\"],\"gofret\":[\"turkish\"],\"goril\":[\"turkish\"],\"gbek\":[\"turkish\"],\"gebe\":[\"turkish\"],\"gs\":[\"turkish\"],\"gkdelen\":[\"turkish\"],\"gkmen\":[\"turkish\"],\"gkyz\":[\"turkish\"],\"glge\":[\"turkish\"],\"gmlek\":[\"turkish\"],\"gnl\":[\"turkish\"],\"grenek\":[\"turkish\"],\"grkemli\":[\"turkish\"],\"grsel\":[\"turkish\"],\"gsteri\":[\"turkish\"],\"gvde\":[\"turkish\"],\"gzalt\":[\"turkish\"],\"gzc\":[\"turkish\"],\"gzda\":[\"turkish\"],\"gzleme\":[\"turkish\"],\"gzya\":[\"turkish\"],\"grup\":[\"turkish\"],\"gurbet\":[\"turkish\"],\"gusl\":[\"turkish\"],\"gbre\":[\"turkish\"],\"gfte\":[\"turkish\"],\"gm\":[\"turkish\"],\"gnaydn\":[\"turkish\"],\"gncel\":[\"turkish\"],\"gndz\":[\"turkish\"],\"gne\":[\"turkish\"],\"gnyz\":[\"turkish\"],\"grbz\":[\"turkish\"],\"gvercin\":[\"turkish\"],\"gzel\":[\"turkish\"],\"hacamat\":[\"turkish\"],\"hacim\":[\"turkish\"],\"hademe\":[\"turkish\"],\"hafz\":[\"turkish\"],\"hafriyat\":[\"turkish\"],\"hafta\":[\"turkish\"],\"hakan\":[\"turkish\"],\"hakem\":[\"turkish\"],\"hakikat\":[\"turkish\"],\"haksever\":[\"turkish\"],\"hal\":[\"turkish\"],\"haner\":[\"turkish\"],\"hane\":[\"turkish\"],\"hapis\":[\"turkish\"],\"haprk\":[\"turkish\"],\"harf\":[\"turkish\"],\"haseki\":[\"turkish\"],\"hasret\":[\"turkish\"],\"hatun\":[\"turkish\"],\"havu\":[\"turkish\"],\"haylaz\":[\"turkish\"],\"haysiyet\":[\"turkish\"],\"hayvan\":[\"turkish\"],\"hedef\":[\"turkish\"],\"hemen\":[\"turkish\"],\"hemfikir\":[\"turkish\"],\"hendek\":[\"turkish\"],\"hepsi\":[\"turkish\"],\"hergele\":[\"turkish\"],\"herhangi\":[\"turkish\"],\"hesap\":[\"turkish\"],\"heyecan\":[\"turkish\"],\"heykel\":[\"turkish\"],\"hezimet\":[\"turkish\"],\"hkrk\":[\"turkish\"],\"hzler\":[\"turkish\"],\"hicviye\":[\"turkish\"],\"hikaye\":[\"turkish\"],\"hikmet\":[\"turkish\"],\"hile\":[\"turkish\"],\"hisse\":[\"turkish\"],\"hobi\":[\"turkish\"],\"hoca\":[\"turkish\"],\"horlama\":[\"turkish\"],\"hobe\":[\"turkish\"],\"hogr\":[\"turkish\"],\"hoyrat\":[\"turkish\"],\"hrg\":[\"turkish\"],\"hyk\":[\"turkish\"],\"hudut\":[\"turkish\"],\"hukuk\":[\"turkish\"],\"hunhar\":[\"turkish\"],\"hurda\":[\"turkish\"],\"huysuz\":[\"turkish\"],\"huzur\":[\"turkish\"],\"hcum\":[\"turkish\"],\"hkmet\":[\"turkish\"],\"hnkar\":[\"turkish\"],\"hviyet\":[\"turkish\"],\"rmak\":[\"turkish\"],\"sler\":[\"turkish\"],\"stc\":[\"turkish\"],\"spanak\":[\"turkish\"],\"srar\":[\"turkish\"],\"ldak\":[\"turkish\"],\"zdrap\":[\"turkish\"],\"zgara\":[\"turkish\"],\"ibadet\":[\"turkish\"],\"icat\":[\"turkish\"],\"ibkey\":[\"turkish\"],\"iecek\":[\"turkish\"],\"igd\":[\"turkish\"],\"isel\":[\"turkish\"],\"idman\":[\"turkish\"],\"iftihar\":[\"turkish\"],\"ine\":[\"turkish\"],\"ihanet\":[\"turkish\"],\"ihbar\":[\"turkish\"],\"ihdas\":[\"turkish\"],\"ihmal\":[\"turkish\"],\"ihracat\":[\"turkish\"],\"ihsan\":[\"turkish\"],\"ikilem\":[\"turkish\"],\"ikindi\":[\"turkish\"],\"ikircik\":[\"turkish\"],\"iklim\":[\"turkish\"],\"iksir\":[\"turkish\"],\"iktibas\":[\"turkish\"],\"ila\":[\"turkish\"],\"ile\":[\"turkish\"],\"ileri\":[\"turkish\"],\"iletiim\":[\"turkish\"],\"ilgi\":[\"turkish\"],\"ilhak\":[\"turkish\"],\"ilkbahar\":[\"turkish\"],\"ilkokul\":[\"turkish\"],\"ilmek\":[\"turkish\"],\"imkan\":[\"turkish\"],\"imle\":[\"turkish\"],\"imsak\":[\"turkish\"],\"imtihan\":[\"turkish\"],\"imza\":[\"turkish\"],\"ince\":[\"turkish\"],\"inkar\":[\"turkish\"],\"ina\":[\"turkish\"],\"ipek\":[\"turkish\"],\"ipucu\":[\"turkish\"],\"irade\":[\"turkish\"],\"irfan\":[\"turkish\"],\"irmik\":[\"turkish\"],\"isabet\":[\"turkish\"],\"iskele\":[\"turkish\"],\"israf\":[\"turkish\"],\"isyan\":[\"turkish\"],\"ii\":[\"turkish\"],\"igal\":[\"turkish\"],\"igzar\":[\"turkish\"],\"ilem\":[\"turkish\"],\"itibar\":[\"turkish\"],\"itiraf\":[\"turkish\"],\"ivedi\":[\"turkish\"],\"ivme\":[\"turkish\"],\"iyileme\":[\"turkish\"],\"iyimser\":[\"turkish\"],\"izbandut\":[\"turkish\"],\"izci\":[\"turkish\"],\"izdiham\":[\"turkish\"],\"izin\":[\"turkish\"],\"jakoben\":[\"turkish\"],\"jandarma\":[\"turkish\"],\"jargon\":[\"turkish\"],\"kabaday\":[\"turkish\"],\"kablo\":[\"turkish\"],\"kabus\":[\"turkish\"],\"kaamak\":[\"turkish\"],\"kadeh\":[\"turkish\"],\"kadn\":[\"turkish\"],\"kadraj\":[\"turkish\"],\"kafa\":[\"turkish\"],\"kafkas\":[\"turkish\"],\"kat\":[\"turkish\"],\"kan\":[\"turkish\"],\"kahkaha\":[\"turkish\"],\"kahraman\":[\"turkish\"],\"kahvalt\":[\"turkish\"],\"kakl\":[\"turkish\"],\"kaldrm\":[\"turkish\"],\"kale\":[\"turkish\"],\"kalibre\":[\"turkish\"],\"kalkan\":[\"turkish\"],\"kalpak\":[\"turkish\"],\"kam\":[\"turkish\"],\"kamyon\":[\"turkish\"],\"kanat\":[\"turkish\"],\"kanda\":[\"turkish\"],\"kanepe\":[\"turkish\"],\"kanser\":[\"turkish\"],\"kanun\":[\"turkish\"],\"kaos\":[\"turkish\"],\"kap\":[\"turkish\"],\"kaplca\":[\"turkish\"],\"kaptan\":[\"turkish\"],\"karanlk\":[\"turkish\"],\"karde\":[\"turkish\"],\"karga\":[\"turkish\"],\"karnca\":[\"turkish\"],\"karmaa\":[\"turkish\"],\"kart\":[\"turkish\"],\"kasrga\":[\"turkish\"],\"kask\":[\"turkish\"],\"kasvet\":[\"turkish\"],\"katk\":[\"turkish\"],\"katman\":[\"turkish\"],\"kavram\":[\"turkish\"],\"kaygan\":[\"turkish\"],\"kaynaka\":[\"turkish\"],\"kayyum\":[\"turkish\"],\"kedi\":[\"turkish\"],\"kehanet\":[\"turkish\"],\"kekik\":[\"turkish\"],\"kelebek\":[\"turkish\"],\"kenar\":[\"turkish\"],\"kerkenez\":[\"turkish\"],\"kerpi\":[\"turkish\"],\"kesirli\":[\"turkish\"],\"kesmece\":[\"turkish\"],\"kestane\":[\"turkish\"],\"kekek\":[\"turkish\"],\"ketap\":[\"turkish\"],\"keyfiyet\":[\"turkish\"],\"kble\":[\"turkish\"],\"kdemli\":[\"turkish\"],\"klavuz\":[\"turkish\"],\"klk\":[\"turkish\"],\"klf\":[\"turkish\"],\"kra\":[\"turkish\"],\"krmz\":[\"turkish\"],\"krsal\":[\"turkish\"],\"ksayol\":[\"turkish\"],\"ksm\":[\"turkish\"],\"kskan\":[\"turkish\"],\"ksmet\":[\"turkish\"],\"kla\":[\"turkish\"],\"kvan\":[\"turkish\"],\"kvlcm\":[\"turkish\"],\"kvrk\":[\"turkish\"],\"kyafet\":[\"turkish\"],\"kymetli\":[\"turkish\"],\"kzak\":[\"turkish\"],\"kzlck\":[\"turkish\"],\"kibar\":[\"turkish\"],\"kinaye\":[\"turkish\"],\"kira\":[\"turkish\"],\"kiremit\":[\"turkish\"],\"kirli\":[\"turkish\"],\"kirpik\":[\"turkish\"],\"kiisel\":[\"turkish\"],\"kitap\":[\"turkish\"],\"koba\":[\"turkish\"],\"kodaman\":[\"turkish\"],\"kou\":[\"turkish\"],\"kokteyl\":[\"turkish\"],\"kolayc\":[\"turkish\"],\"kolbast\":[\"turkish\"],\"kolonya\":[\"turkish\"],\"koltuk\":[\"turkish\"],\"kolye\":[\"turkish\"],\"kombine\":[\"turkish\"],\"komedyen\":[\"turkish\"],\"komiser\":[\"turkish\"],\"komposto\":[\"turkish\"],\"komu\":[\"turkish\"],\"komuta\":[\"turkish\"],\"konak\":[\"turkish\"],\"konfor\":[\"turkish\"],\"koni\":[\"turkish\"],\"konsl\":[\"turkish\"],\"kopya\":[\"turkish\"],\"korkusuz\":[\"turkish\"],\"korna\":[\"turkish\"],\"korse\":[\"turkish\"],\"korunak\":[\"turkish\"],\"korvet\":[\"turkish\"],\"kostm\":[\"turkish\"],\"koul\":[\"turkish\"],\"koyu\":[\"turkish\"],\"kozmik\":[\"turkish\"],\"kfte\":[\"turkish\"],\"kkensel\":[\"turkish\"],\"kprck\":[\"turkish\"],\"kpk\":[\"turkish\"],\"krdm\":[\"turkish\"],\"krfez\":[\"turkish\"],\"kstebek\":[\"turkish\"],\"kegen\":[\"turkish\"],\"kt\":[\"turkish\"],\"kravat\":[\"turkish\"],\"kriter\":[\"turkish\"],\"kuantum\":[\"turkish\"],\"kudurma\":[\"turkish\"],\"kuluka\":[\"turkish\"],\"kulbe\":[\"turkish\"],\"kumanya\":[\"turkish\"],\"kumbara\":[\"turkish\"],\"kumlu\":[\"turkish\"],\"kumpir\":[\"turkish\"],\"kumral\":[\"turkish\"],\"kundura\":[\"turkish\"],\"kupa\":[\"turkish\"],\"kupkuru\":[\"turkish\"],\"kuramsal\":[\"turkish\"],\"kurbaa\":[\"turkish\"],\"kurdele\":[\"turkish\"],\"kurgu\":[\"turkish\"],\"kurmay\":[\"turkish\"],\"kurun\":[\"turkish\"],\"kurtulu\":[\"turkish\"],\"kurultay\":[\"turkish\"],\"kurye\":[\"turkish\"],\"kusursuz\":[\"turkish\"],\"kuak\":[\"turkish\"],\"kuba\":[\"turkish\"],\"kukulu\":[\"turkish\"],\"kutlama\":[\"turkish\"],\"kutsal\":[\"turkish\"],\"kutup\":[\"turkish\"],\"kuver\":[\"turkish\"],\"kuyruk\":[\"turkish\"],\"kuzey\":[\"turkish\"],\"kuzgun\":[\"turkish\"],\"kk\":[\"turkish\"],\"kle\":[\"turkish\"],\"klfet\":[\"turkish\"],\"klliye\":[\"turkish\"],\"kltrel\":[\"turkish\"],\"kmes\":[\"turkish\"],\"knefe\":[\"turkish\"],\"kresel\":[\"turkish\"],\"ktle\":[\"turkish\"],\"lahana\":[\"turkish\"],\"lahmacun\":[\"turkish\"],\"lamba\":[\"turkish\"],\"lansman\":[\"turkish\"],\"lava\":[\"turkish\"],\"layk\":[\"turkish\"],\"leen\":[\"turkish\"],\"levent\":[\"turkish\"],\"leziz\":[\"turkish\"],\"lezzet\":[\"turkish\"],\"lider\":[\"turkish\"],\"likide\":[\"turkish\"],\"liman\":[\"turkish\"],\"liste\":[\"turkish\"],\"litre\":[\"turkish\"],\"liyakat\":[\"turkish\"],\"lodos\":[\"turkish\"],\"lokanta\":[\"turkish\"],\"lokman\":[\"turkish\"],\"lokum\":[\"turkish\"],\"lunapark\":[\"turkish\"],\"ltfen\":[\"turkish\"],\"lzum\":[\"turkish\"],\"nokta\":[\"turkish\"],\"mabet\":[\"turkish\"],\"macera\":[\"turkish\"],\"macun\":[\"turkish\"],\"madalya\":[\"turkish\"],\"madde\":[\"turkish\"],\"madem\":[\"turkish\"],\"maara\":[\"turkish\"],\"madur\":[\"turkish\"],\"mafiret\":[\"turkish\"],\"malup\":[\"turkish\"],\"mahalle\":[\"turkish\"],\"mahcup\":[\"turkish\"],\"mahir\":[\"turkish\"],\"mahkeme\":[\"turkish\"],\"mahlas\":[\"turkish\"],\"mahrum\":[\"turkish\"],\"mahsul\":[\"turkish\"],\"makas\":[\"turkish\"],\"makbuz\":[\"turkish\"],\"makine\":[\"turkish\"],\"makro\":[\"turkish\"],\"maksat\":[\"turkish\"],\"makul\":[\"turkish\"],\"maliye\":[\"turkish\"],\"manav\":[\"turkish\"],\"mangal\":[\"turkish\"],\"manidar\":[\"turkish\"],\"manken\":[\"turkish\"],\"mantk\":[\"turkish\"],\"manzara\":[\"turkish\"],\"mareal\":[\"turkish\"],\"margarin\":[\"turkish\"],\"marifet\":[\"turkish\"],\"marmelat\":[\"turkish\"],\"masast\":[\"turkish\"],\"masmavi\":[\"turkish\"],\"masraf\":[\"turkish\"],\"masum\":[\"turkish\"],\"matah\":[\"turkish\"],\"materyal\":[\"turkish\"],\"matrak\":[\"turkish\"],\"maval\":[\"turkish\"],\"mavra\":[\"turkish\"],\"maydanoz\":[\"turkish\"],\"mayho\":[\"turkish\"],\"maytap\":[\"turkish\"],\"mazbata\":[\"turkish\"],\"mazeret\":[\"turkish\"],\"mazlum\":[\"turkish\"],\"mazot\":[\"turkish\"],\"mazur\":[\"turkish\"],\"mebla\":[\"turkish\"],\"mebus\":[\"turkish\"],\"mecaz\":[\"turkish\"],\"mecbur\":[\"turkish\"],\"meclis\":[\"turkish\"],\"mecmua\":[\"turkish\"],\"mecnun\":[\"turkish\"],\"mehul\":[\"turkish\"],\"medeni\":[\"turkish\"],\"mehtap\":[\"turkish\"],\"mekanik\":[\"turkish\"],\"melodi\":[\"turkish\"],\"meltem\":[\"turkish\"],\"memur\":[\"turkish\"],\"mendil\":[\"turkish\"],\"meneke\":[\"turkish\"],\"mentee\":[\"turkish\"],\"merakl\":[\"turkish\"],\"mercek\":[\"turkish\"],\"merdiven\":[\"turkish\"],\"merhaba\":[\"turkish\"],\"merinos\":[\"turkish\"],\"merkez\":[\"turkish\"],\"mermi\":[\"turkish\"],\"mert\":[\"turkish\"],\"mesafe\":[\"turkish\"],\"mesele\":[\"turkish\"],\"mesken\":[\"turkish\"],\"meslek\":[\"turkish\"],\"meale\":[\"turkish\"],\"megul\":[\"turkish\"],\"mehur\":[\"turkish\"],\"metafor\":[\"turkish\"],\"metin\":[\"turkish\"],\"metre\":[\"turkish\"],\"mevcut\":[\"turkish\"],\"mevkida\":[\"turkish\"],\"meydan\":[\"turkish\"],\"meyil\":[\"turkish\"],\"meyve\":[\"turkish\"],\"meziyet\":[\"turkish\"],\"mezun\":[\"turkish\"],\"mknats\":[\"turkish\"],\"msra\":[\"turkish\"],\"mzka\":[\"turkish\"],\"mifer\":[\"turkish\"],\"mihrak\":[\"turkish\"],\"miktar\":[\"turkish\"],\"milat\":[\"turkish\"],\"milli\":[\"turkish\"],\"mimar\":[\"turkish\"],\"minare\":[\"turkish\"],\"mineral\":[\"turkish\"],\"minik\":[\"turkish\"],\"minyon\":[\"turkish\"],\"mirliva\":[\"turkish\"],\"misafir\":[\"turkish\"],\"miskin\":[\"turkish\"],\"miting\":[\"turkish\"],\"miyop\":[\"turkish\"],\"mizah\":[\"turkish\"],\"mobilya\":[\"turkish\"],\"monitr\":[\"turkish\"],\"mortesi\":[\"turkish\"],\"motive\":[\"turkish\"],\"mozaik\":[\"turkish\"],\"muavin\":[\"turkish\"],\"mucize\":[\"turkish\"],\"muhafz\":[\"turkish\"],\"muhteem\":[\"turkish\"],\"mukayese\":[\"turkish\"],\"mumya\":[\"turkish\"],\"musluk\":[\"turkish\"],\"muamba\":[\"turkish\"],\"mutabk\":[\"turkish\"],\"mutfak\":[\"turkish\"],\"mutlu\":[\"turkish\"],\"muzaffer\":[\"turkish\"],\"muzdarip\":[\"turkish\"],\"mbarek\":[\"turkish\"],\"mcadele\":[\"turkish\"],\"mdr\":[\"turkish\"],\"mfredat\":[\"turkish\"],\"mft\":[\"turkish\"],\"mhendis\":[\"turkish\"],\"mhim\":[\"turkish\"],\"mhlet\":[\"turkish\"],\"mkemmel\":[\"turkish\"],\"mlk\":[\"turkish\"],\"mmkn\":[\"turkish\"],\"mmtaz\":[\"turkish\"],\"msrif\":[\"turkish\"],\"mstesna\":[\"turkish\"],\"mahit\":[\"turkish\"],\"mteri\":[\"turkish\"],\"mtercim\":[\"turkish\"],\"mthi\":[\"turkish\"],\"mze\":[\"turkish\"],\"mzik\":[\"turkish\"],\"nabz\":[\"turkish\"],\"nadas\":[\"turkish\"],\"nadir\":[\"turkish\"],\"naho\":[\"turkish\"],\"nakarat\":[\"turkish\"],\"nak\":[\"turkish\"],\"nalbur\":[\"turkish\"],\"namlu\":[\"turkish\"],\"namus\":[\"turkish\"],\"nankr\":[\"turkish\"],\"nargile\":[\"turkish\"],\"narkoz\":[\"turkish\"],\"nasl\":[\"turkish\"],\"nasip\":[\"turkish\"],\"naylon\":[\"turkish\"],\"nazar\":[\"turkish\"],\"nazm\":[\"turkish\"],\"nazik\":[\"turkish\"],\"neden\":[\"turkish\"],\"nefes\":[\"turkish\"],\"negatif\":[\"turkish\"],\"neon\":[\"turkish\"],\"neptn\":[\"turkish\"],\"nerede\":[\"turkish\"],\"nesil\":[\"turkish\"],\"nesnel\":[\"turkish\"],\"neeli\":[\"turkish\"],\"netice\":[\"turkish\"],\"nevresim\":[\"turkish\"],\"neyse\":[\"turkish\"],\"neyzen\":[\"turkish\"],\"nezaket\":[\"turkish\"],\"nezih\":[\"turkish\"],\"nezle\":[\"turkish\"],\"nicel\":[\"turkish\"],\"nilfer\":[\"turkish\"],\"nimet\":[\"turkish\"],\"nisan\":[\"turkish\"],\"nispet\":[\"turkish\"],\"nitekim\":[\"turkish\"],\"nizam\":[\"turkish\"],\"nohut\":[\"turkish\"],\"noksan\":[\"turkish\"],\"nostalji\":[\"turkish\"],\"noter\":[\"turkish\"],\"nbet\":[\"turkish\"],\"numara\":[\"turkish\"],\"numune\":[\"turkish\"],\"nutuk\":[\"turkish\"],\"nfus\":[\"turkish\"],\"obaba\":[\"turkish\"],\"obez\":[\"turkish\"],\"obje\":[\"turkish\"],\"ocak\":[\"turkish\"],\"odun\":[\"turkish\"],\"ofansif\":[\"turkish\"],\"ofis\":[\"turkish\"],\"olak\":[\"turkish\"],\"ouz\":[\"turkish\"],\"oku\":[\"turkish\"],\"oklava\":[\"turkish\"],\"oksijen\":[\"turkish\"],\"okul\":[\"turkish\"],\"okumu\":[\"turkish\"],\"okutman\":[\"turkish\"],\"okuyucu\":[\"turkish\"],\"okyanus\":[\"turkish\"],\"olaan\":[\"turkish\"],\"olanak\":[\"turkish\"],\"olas\":[\"turkish\"],\"olay\":[\"turkish\"],\"olgun\":[\"turkish\"],\"olimpik\":[\"turkish\"],\"olumlu\":[\"turkish\"],\"omlet\":[\"turkish\"],\"omurga\":[\"turkish\"],\"onarm\":[\"turkish\"],\"onursal\":[\"turkish\"],\"optik\":[\"turkish\"],\"orant\":[\"turkish\"],\"ordu\":[\"turkish\"],\"organik\":[\"turkish\"],\"orijin\":[\"turkish\"],\"orkide\":[\"turkish\"],\"orman\":[\"turkish\"],\"orta\":[\"turkish\"],\"oru\":[\"turkish\"],\"ota\":[\"turkish\"],\"otantik\":[\"turkish\"],\"otel\":[\"turkish\"],\"otoban\":[\"turkish\"],\"otogar\":[\"turkish\"],\"otomobil\":[\"turkish\"],\"otonom\":[\"turkish\"],\"otopark\":[\"turkish\"],\"otorite\":[\"turkish\"],\"otoyol\":[\"turkish\"],\"oturum\":[\"turkish\"],\"oyuk\":[\"turkish\"],\"oyuncak\":[\"turkish\"],\"ozan\":[\"turkish\"],\"deme\":[\"turkish\"],\"denek\":[\"turkish\"],\"dev\":[\"turkish\"],\"dl\":[\"turkish\"],\"dn\":[\"turkish\"],\"fke\":[\"turkish\"],\"len\":[\"turkish\"],\"renci\":[\"turkish\"],\"n\":[\"turkish\"],\"tc\":[\"turkish\"],\"ksrk\":[\"turkish\"],\"lme\":[\"turkish\"],\"l\":[\"turkish\"],\"lmsz\":[\"turkish\"],\"mr\":[\"turkish\"],\"nayak\":[\"turkish\"],\"nc\":[\"turkish\"],\"nder\":[\"turkish\"],\"nem\":[\"turkish\"],\"nerge\":[\"turkish\"],\"ngr\":[\"turkish\"],\"nlk\":[\"turkish\"],\"nsezi\":[\"turkish\"],\"pck\":[\"turkish\"],\"rdek\":[\"turkish\"],\"rg\":[\"turkish\"],\"rtbas\":[\"turkish\"],\"rtme\":[\"turkish\"],\"rt\":[\"turkish\"],\"rmcek\":[\"turkish\"],\"rnt\":[\"turkish\"],\"teberi\":[\"turkish\"],\"teki\":[\"turkish\"],\"vn\":[\"turkish\"],\"yk\":[\"turkish\"],\"yleyse\":[\"turkish\"],\"zekim\":[\"turkish\"],\"zdeyi\":[\"turkish\"],\"zel\":[\"turkish\"],\"zenti\":[\"turkish\"],\"zerk\":[\"turkish\"],\"zgrlk\":[\"turkish\"],\"zlem\":[\"turkish\"],\"zl\":[\"turkish\"],\"zne\":[\"turkish\"],\"zsever\":[\"turkish\"],\"zmseme\":[\"turkish\"],\"zr\":[\"turkish\"],\"zveri\":[\"turkish\"],\"pabu\":[\"turkish\"],\"padiah\":[\"turkish\"],\"palamut\":[\"turkish\"],\"palmiye\":[\"turkish\"],\"palto\":[\"turkish\"],\"palyao\":[\"turkish\"],\"pamuk\":[\"turkish\"],\"panayr\":[\"turkish\"],\"pancar\":[\"turkish\"],\"panik\":[\"turkish\"],\"panjur\":[\"turkish\"],\"pankart\":[\"turkish\"],\"pano\":[\"turkish\"],\"pansuman\":[\"turkish\"],\"pantolon\":[\"turkish\"],\"panzehir\":[\"turkish\"],\"papatya\":[\"turkish\"],\"papyon\":[\"turkish\"],\"parat\":[\"turkish\"],\"para\":[\"turkish\"],\"pards\":[\"turkish\"],\"parfm\":[\"turkish\"],\"parlt\":[\"turkish\"],\"parkur\":[\"turkish\"],\"parmak\":[\"turkish\"],\"parodi\":[\"turkish\"],\"parsel\":[\"turkish\"],\"partner\":[\"turkish\"],\"pasaport\":[\"turkish\"],\"pasif\":[\"turkish\"],\"paskalya\":[\"turkish\"],\"pastrma\":[\"turkish\"],\"paa\":[\"turkish\"],\"patates\":[\"turkish\"],\"paten\":[\"turkish\"],\"patika\":[\"turkish\"],\"patlcan\":[\"turkish\"],\"patolog\":[\"turkish\"],\"payanda\":[\"turkish\"],\"payda\":[\"turkish\"],\"payidar\":[\"turkish\"],\"paylama\":[\"turkish\"],\"paytak\":[\"turkish\"],\"peete\":[\"turkish\"],\"peder\":[\"turkish\"],\"pehlivan\":[\"turkish\"],\"pekala\":[\"turkish\"],\"pekmez\":[\"turkish\"],\"pelerin\":[\"turkish\"],\"pelikan\":[\"turkish\"],\"pel\":[\"turkish\"],\"pembe\":[\"turkish\"],\"pencere\":[\"turkish\"],\"pense\":[\"turkish\"],\"perin\":[\"turkish\"],\"perde\":[\"turkish\"],\"pergel\":[\"turkish\"],\"perian\":[\"turkish\"],\"peron\":[\"turkish\"],\"personel\":[\"turkish\"],\"perembe\":[\"turkish\"],\"peruk\":[\"turkish\"],\"pervane\":[\"turkish\"],\"pespaye\":[\"turkish\"],\"pestil\":[\"turkish\"],\"pein\":[\"turkish\"],\"petek\":[\"turkish\"],\"petrol\":[\"turkish\"],\"petunya\":[\"turkish\"],\"peynir\":[\"turkish\"],\"peyzaj\":[\"turkish\"],\"pnar\":[\"turkish\"],\"prasa\":[\"turkish\"],\"prlanta\":[\"turkish\"],\"pide\":[\"turkish\"],\"pikap\":[\"turkish\"],\"pilav\":[\"turkish\"],\"pili\":[\"turkish\"],\"pipet\":[\"turkish\"],\"pipo\":[\"turkish\"],\"piramit\":[\"turkish\"],\"pirin\":[\"turkish\"],\"pirzola\":[\"turkish\"],\"pist\":[\"turkish\"],\"piik\":[\"turkish\"],\"piman\":[\"turkish\"],\"piyasa\":[\"turkish\"],\"piyes\":[\"turkish\"],\"plaj\":[\"turkish\"],\"plaket\":[\"turkish\"],\"planlama\":[\"turkish\"],\"platform\":[\"turkish\"],\"plazma\":[\"turkish\"],\"podyum\":[\"turkish\"],\"poaa\":[\"turkish\"],\"polat\":[\"turkish\"],\"politika\":[\"turkish\"],\"popler\":[\"turkish\"],\"porselen\":[\"turkish\"],\"portakal\":[\"turkish\"],\"poster\":[\"turkish\"],\"poet\":[\"turkish\"],\"poyraz\":[\"turkish\"],\"pozitif\":[\"turkish\"],\"pranga\":[\"turkish\"],\"pratik\":[\"turkish\"],\"prenses\":[\"turkish\"],\"prim\":[\"turkish\"],\"profil\":[\"turkish\"],\"proje\":[\"turkish\"],\"protokol\":[\"turkish\"],\"puan\":[\"turkish\"],\"pudra\":[\"turkish\"],\"pusula\":[\"turkish\"],\"pre\":[\"turkish\"],\"prz\":[\"turkish\"],\"pstl\":[\"turkish\"],\"psr\":[\"turkish\"],\"racon\":[\"turkish\"],\"radikal\":[\"turkish\"],\"radyo\":[\"turkish\"],\"rafadan\":[\"turkish\"],\"rafine\":[\"turkish\"],\"rabet\":[\"turkish\"],\"rahat\":[\"turkish\"],\"rahle\":[\"turkish\"],\"rakam\":[\"turkish\"],\"raket\":[\"turkish\"],\"rakip\":[\"turkish\"],\"rakun\":[\"turkish\"],\"ralli\":[\"turkish\"],\"randevu\":[\"turkish\"],\"ranza\":[\"turkish\"],\"rapor\":[\"turkish\"],\"rastgele\":[\"turkish\"],\"rasyonel\":[\"turkish\"],\"raz\":[\"turkish\"],\"realite\":[\"turkish\"],\"reine\":[\"turkish\"],\"refah\":[\"turkish\"],\"referans\":[\"turkish\"],\"refik\":[\"turkish\"],\"rehber\":[\"turkish\"],\"rehin\":[\"turkish\"],\"reis\":[\"turkish\"],\"rekabet\":[\"turkish\"],\"reklam\":[\"turkish\"],\"rekor\":[\"turkish\"],\"rektr\":[\"turkish\"],\"renk\":[\"turkish\"],\"resim\":[\"turkish\"],\"resmen\":[\"turkish\"],\"restoran\":[\"turkish\"],\"retorik\":[\"turkish\"],\"reva\":[\"turkish\"],\"reyon\":[\"turkish\"],\"rezalet\":[\"turkish\"],\"rezerv\":[\"turkish\"],\"rezil\":[\"turkish\"],\"rhtm\":[\"turkish\"],\"rza\":[\"turkish\"],\"ritim\":[\"turkish\"],\"ritel\":[\"turkish\"],\"rivayet\":[\"turkish\"],\"roman\":[\"turkish\"],\"rozet\":[\"turkish\"],\"rportaj\":[\"turkish\"],\"rtar\":[\"turkish\"],\"ruble\":[\"turkish\"],\"ruhban\":[\"turkish\"],\"ruhsat\":[\"turkish\"],\"rulet\":[\"turkish\"],\"runik\":[\"turkish\"],\"rutin\":[\"turkish\"],\"rutubet\":[\"turkish\"],\"rvet\":[\"turkish\"],\"rtbe\":[\"turkish\"],\"rya\":[\"turkish\"],\"rzgar\":[\"turkish\"],\"sabah\":[\"turkish\"],\"sabka\":[\"turkish\"],\"sabit\":[\"turkish\"],\"sabun\":[\"turkish\"],\"sama\":[\"turkish\"],\"sade\":[\"turkish\"],\"sadk\":[\"turkish\"],\"safahat\":[\"turkish\"],\"safdil\":[\"turkish\"],\"safkan\":[\"turkish\"],\"saanak\":[\"turkish\"],\"saduyu\":[\"turkish\"],\"salam\":[\"turkish\"],\"saha\":[\"turkish\"],\"sahiden\":[\"turkish\"],\"sahne\":[\"turkish\"],\"sakal\":[\"turkish\"],\"sakz\":[\"turkish\"],\"sakin\":[\"turkish\"],\"saklama\":[\"turkish\"],\"saksaan\":[\"turkish\"],\"salamura\":[\"turkish\"],\"sala\":[\"turkish\"],\"salg\":[\"turkish\"],\"salnm\":[\"turkish\"],\"salkm\":[\"turkish\"],\"saltanat\":[\"turkish\"],\"sanat\":[\"turkish\"],\"sancak\":[\"turkish\"],\"sandalye\":[\"turkish\"],\"saniye\":[\"turkish\"],\"saplant\":[\"turkish\"],\"sapsz\":[\"turkish\"],\"saray\":[\"turkish\"],\"sarn\":[\"turkish\"],\"sarkk\":[\"turkish\"],\"sarmak\":[\"turkish\"],\"satr\":[\"turkish\"],\"savam\":[\"turkish\"],\"savunma\":[\"turkish\"],\"saydam\":[\"turkish\"],\"sayfa\":[\"turkish\"],\"saygn\":[\"turkish\"],\"saysal\":[\"turkish\"],\"sebep\":[\"turkish\"],\"seenek\":[\"turkish\"],\"seim\":[\"turkish\"],\"sekin\":[\"turkish\"],\"semen\":[\"turkish\"],\"sedir\":[\"turkish\"],\"sedye\":[\"turkish\"],\"sefer\":[\"turkish\"],\"sehpa\":[\"turkish\"],\"sekizgen\":[\"turkish\"],\"selektr\":[\"turkish\"],\"selvi\":[\"turkish\"],\"semavi\":[\"turkish\"],\"sembol\":[\"turkish\"],\"seminer\":[\"turkish\"],\"senaryo\":[\"turkish\"],\"sendika\":[\"turkish\"],\"senkron\":[\"turkish\"],\"sensr\":[\"turkish\"],\"sentez\":[\"turkish\"],\"sepet\":[\"turkish\"],\"seramik\":[\"turkish\"],\"serbest\":[\"turkish\"],\"serdar\":[\"turkish\"],\"seremoni\":[\"turkish\"],\"sergi\":[\"turkish\"],\"serhat\":[\"turkish\"],\"serin\":[\"turkish\"],\"sermaye\":[\"turkish\"],\"serpu\":[\"turkish\"],\"sersem\":[\"turkish\"],\"serven\":[\"turkish\"],\"sesli\":[\"turkish\"],\"seste\":[\"turkish\"],\"sevap\":[\"turkish\"],\"seviye\":[\"turkish\"],\"seyahat\":[\"turkish\"],\"seyirci\":[\"turkish\"],\"sezon\":[\"turkish\"],\"scak\":[\"turkish\"],\"sfat\":[\"turkish\"],\"shhi\":[\"turkish\"],\"snanma\":[\"turkish\"],\"snr\":[\"turkish\"],\"sradan\":[\"turkish\"],\"srda\":[\"turkish\"],\"srma\":[\"turkish\"],\"srtst\":[\"turkish\"],\"szgt\":[\"turkish\"],\"siftah\":[\"turkish\"],\"sigorta\":[\"turkish\"],\"sihirbaz\":[\"turkish\"],\"silah\":[\"turkish\"],\"silecek\":[\"turkish\"],\"silindir\":[\"turkish\"],\"simetri\":[\"turkish\"],\"simge\":[\"turkish\"],\"simit\":[\"turkish\"],\"sincap\":[\"turkish\"],\"sindirim\":[\"turkish\"],\"sinema\":[\"turkish\"],\"sinirli\":[\"turkish\"],\"sipari\":[\"turkish\"],\"sirke\":[\"turkish\"],\"siroz\":[\"turkish\"],\"sistem\":[\"turkish\"],\"sivilce\":[\"turkish\"],\"siyasi\":[\"turkish\"],\"soba\":[\"turkish\"],\"sofra\":[\"turkish\"],\"souk\":[\"turkish\"],\"sohbet\":[\"turkish\"],\"sokak\":[\"turkish\"],\"solfej\":[\"turkish\"],\"solunum\":[\"turkish\"],\"somut\":[\"turkish\"],\"sonbahar\":[\"turkish\"],\"sonraki\":[\"turkish\"],\"sonsuz\":[\"turkish\"],\"sorunsuz\":[\"turkish\"],\"sosyete\":[\"turkish\"],\"soyaac\":[\"turkish\"],\"soyda\":[\"turkish\"],\"soygun\":[\"turkish\"],\"soytar\":[\"turkish\"],\"s\":[\"turkish\"],\"smrge\":[\"turkish\"],\"snk\":[\"turkish\"],\"sylem\":[\"turkish\"],\"szck\":[\"turkish\"],\"szde\":[\"turkish\"],\"spatula\":[\"turkish\"],\"spektrum\":[\"turkish\"],\"spiker\":[\"turkish\"],\"sporcu\":[\"turkish\"],\"sprey\":[\"turkish\"],\"stabil\":[\"turkish\"],\"stat\":[\"turkish\"],\"stok\":[\"turkish\"],\"stopaj\":[\"turkish\"],\"strateji\":[\"turkish\"],\"subay\":[\"turkish\"],\"sucuk\":[\"turkish\"],\"sust\":[\"turkish\"],\"suhulet\":[\"turkish\"],\"sulama\":[\"turkish\"],\"sungur\":[\"turkish\"],\"sunucu\":[\"turkish\"],\"surat\":[\"turkish\"],\"susam\":[\"turkish\"],\"suskun\":[\"turkish\"],\"skse\":[\"turkish\"],\"skut\":[\"turkish\"],\"slale\":[\"turkish\"],\"snger\":[\"turkish\"],\"sprge\":[\"turkish\"],\"srahi\":[\"turkish\"],\"sre\":[\"turkish\"],\"srgn\":[\"turkish\"],\"srm\":[\"turkish\"],\"ssleme\":[\"turkish\"],\"stanne\":[\"turkish\"],\"stla\":[\"turkish\"],\"stun\":[\"turkish\"],\"svari\":[\"turkish\"],\"ahane\":[\"turkish\"],\"ahbaz\":[\"turkish\"],\"ahit\":[\"turkish\"],\"ahsiyet\":[\"turkish\"],\"akma\":[\"turkish\"],\"aklaban\":[\"turkish\"],\"akrak\":[\"turkish\"],\"amar\":[\"turkish\"],\"ampiyon\":[\"turkish\"],\"ansl\":[\"turkish\"],\"antiye\":[\"turkish\"],\"apka\":[\"turkish\"],\"arkc\":[\"turkish\"],\"artname\":[\"turkish\"],\"arma\":[\"turkish\"],\"akn\":[\"turkish\"],\"atafat\":[\"turkish\"],\"ayet\":[\"turkish\"],\"ebeke\":[\"turkish\"],\"efkat\":[\"turkish\"],\"eftali\":[\"turkish\"],\"ehir\":[\"turkish\"],\"ehvet\":[\"turkish\"],\"eker\":[\"turkish\"],\"ekil\":[\"turkish\"],\"elale\":[\"turkish\"],\"ema\":[\"turkish\"],\"emsiye\":[\"turkish\"],\"erbet\":[\"turkish\"],\"eref\":[\"turkish\"],\"erit\":[\"turkish\"],\"mark\":[\"turkish\"],\"pdk\":[\"turkish\"],\"ifre\":[\"turkish\"],\"imdi\":[\"turkish\"],\"imek\":[\"turkish\"],\"ipak\":[\"turkish\"],\"irin\":[\"turkish\"],\"ie\":[\"turkish\"],\"iirme\":[\"turkish\"],\"ofben\":[\"turkish\"],\"hret\":[\"turkish\"],\"len\":[\"turkish\"],\"phe\":[\"turkish\"],\"tabaka\":[\"turkish\"],\"tabure\":[\"turkish\"],\"tadilat\":[\"turkish\"],\"taharet\":[\"turkish\"],\"tahl\":[\"turkish\"],\"tahkim\":[\"turkish\"],\"tahlil\":[\"turkish\"],\"tahmin\":[\"turkish\"],\"tahrifat\":[\"turkish\"],\"tahsilat\":[\"turkish\"],\"tahta\":[\"turkish\"],\"taklit\":[\"turkish\"],\"takoz\":[\"turkish\"],\"taksici\":[\"turkish\"],\"taktik\":[\"turkish\"],\"takvim\":[\"turkish\"],\"talebe\":[\"turkish\"],\"talip\":[\"turkish\"],\"tamamen\":[\"turkish\"],\"tamirci\":[\"turkish\"],\"tamtakr\":[\"turkish\"],\"tandr\":[\"turkish\"],\"tanecik\":[\"turkish\"],\"tantm\":[\"turkish\"],\"tanr\":[\"turkish\"],\"tansiyon\":[\"turkish\"],\"tapan\":[\"turkish\"],\"tapnak\":[\"turkish\"],\"taptaze\":[\"turkish\"],\"tapu\":[\"turkish\"],\"tarafgir\":[\"turkish\"],\"tarhana\":[\"turkish\"],\"tarm\":[\"turkish\"],\"tarih\":[\"turkish\"],\"tarla\":[\"turkish\"],\"tartak\":[\"turkish\"],\"tarumar\":[\"turkish\"],\"tasarm\":[\"turkish\"],\"tasdik\":[\"turkish\"],\"taslak\":[\"turkish\"],\"tastamam\":[\"turkish\"],\"taeron\":[\"turkish\"],\"tanmaz\":[\"turkish\"],\"tara\":[\"turkish\"],\"tatava\":[\"turkish\"],\"tatbikat\":[\"turkish\"],\"tatil\":[\"turkish\"],\"tatl\":[\"turkish\"],\"tavsiye\":[\"turkish\"],\"tavan\":[\"turkish\"],\"tavuk\":[\"turkish\"],\"taze\":[\"turkish\"],\"taziye\":[\"turkish\"],\"tazminat\":[\"turkish\"],\"tebeir\":[\"turkish\"],\"tebrik\":[\"turkish\"],\"tecrbe\":[\"turkish\"],\"tehizat\":[\"turkish\"],\"tedarik\":[\"turkish\"],\"tedbir\":[\"turkish\"],\"tefti\":[\"turkish\"],\"teet\":[\"turkish\"],\"temen\":[\"turkish\"],\"tehdit\":[\"turkish\"],\"tehlike\":[\"turkish\"],\"tekdze\":[\"turkish\"],\"tekerlek\":[\"turkish\"],\"tekme\":[\"turkish\"],\"teknik\":[\"turkish\"],\"tekrar\":[\"turkish\"],\"telef\":[\"turkish\"],\"telsiz\":[\"turkish\"],\"telve\":[\"turkish\"],\"temas\":[\"turkish\"],\"tembel\":[\"turkish\"],\"temiz\":[\"turkish\"],\"temkin\":[\"turkish\"],\"temsilci\":[\"turkish\"],\"tendon\":[\"turkish\"],\"teneke\":[\"turkish\"],\"tenha\":[\"turkish\"],\"tenkit\":[\"turkish\"],\"tepegz\":[\"turkish\"],\"tepki\":[\"turkish\"],\"terazi\":[\"turkish\"],\"terbiye\":[\"turkish\"],\"tercih\":[\"turkish\"],\"tereya\":[\"turkish\"],\"terfi\":[\"turkish\"],\"terim\":[\"turkish\"],\"terminal\":[\"turkish\"],\"tersane\":[\"turkish\"],\"tertip\":[\"turkish\"],\"tesadf\":[\"turkish\"],\"tescil\":[\"turkish\"],\"tesir\":[\"turkish\"],\"teslimat\":[\"turkish\"],\"tespit\":[\"turkish\"],\"testere\":[\"turkish\"],\"teekkr\":[\"turkish\"],\"tehir\":[\"turkish\"],\"terif\":[\"turkish\"],\"tevik\":[\"turkish\"],\"teyze\":[\"turkish\"],\"tezahr\":[\"turkish\"],\"tezgah\":[\"turkish\"],\"tbbi\":[\"turkish\"],\"tka\":[\"turkish\"],\"tkk\":[\"turkish\"],\"tknaz\":[\"turkish\"],\"tlsm\":[\"turkish\"],\"tpk\":[\"turkish\"],\"tra\":[\"turkish\"],\"trka\":[\"turkish\"],\"trman\":[\"turkish\"],\"trnak\":[\"turkish\"],\"trpan\":[\"turkish\"],\"tslama\":[\"turkish\"],\"ticaret\":[\"turkish\"],\"tilki\":[\"turkish\"],\"tiryaki\":[\"turkish\"],\"titreim\":[\"turkish\"],\"tohum\":[\"turkish\"],\"tokat\":[\"turkish\"],\"tolere\":[\"turkish\"],\"tombak\":[\"turkish\"],\"tomurcuk\":[\"turkish\"],\"topa\":[\"turkish\"],\"toplum\":[\"turkish\"],\"toprak\":[\"turkish\"],\"toptan\":[\"turkish\"],\"toraman\":[\"turkish\"],\"torpido\":[\"turkish\"],\"tortu\":[\"turkish\"],\"tosbaa\":[\"turkish\"],\"toynak\":[\"turkish\"],\"tren\":[\"turkish\"],\"trafik\":[\"turkish\"],\"trajedi\":[\"turkish\"],\"tramvay\":[\"turkish\"],\"tribn\":[\"turkish\"],\"triko\":[\"turkish\"],\"tugay\":[\"turkish\"],\"tula\":[\"turkish\"],\"turul\":[\"turkish\"],\"tuhaf\":[\"turkish\"],\"tulumba\":[\"turkish\"],\"tun\":[\"turkish\"],\"turan\":[\"turkish\"],\"turkuaz\":[\"turkish\"],\"turnusol\":[\"turkish\"],\"turu\":[\"turkish\"],\"turuncu\":[\"turkish\"],\"tutanak\":[\"turkish\"],\"tutkal\":[\"turkish\"],\"tutsak\":[\"turkish\"],\"tutum\":[\"turkish\"],\"tuyu\":[\"turkish\"],\"tuzlu\":[\"turkish\"],\"tccar\":[\"turkish\"],\"tfek\":[\"turkish\"],\"tkenmez\":[\"turkish\"],\"tlbent\":[\"turkish\"],\"tmle\":[\"turkish\"],\"tnel\":[\"turkish\"],\"trbin\":[\"turkish\"],\"trev\":[\"turkish\"],\"trk\":[\"turkish\"],\"tzk\":[\"turkish\"],\"ucube\":[\"turkish\"],\"ucuz\":[\"turkish\"],\"uak\":[\"turkish\"],\"uurtma\":[\"turkish\"],\"ufuk\":[\"turkish\"],\"urak\":[\"turkish\"],\"uur\":[\"turkish\"],\"ukala\":[\"turkish\"],\"ulam\":[\"turkish\"],\"ulema\":[\"turkish\"],\"ulus\":[\"turkish\"],\"ulvi\":[\"turkish\"],\"umursama\":[\"turkish\"],\"umut\":[\"turkish\"],\"unutkan\":[\"turkish\"],\"uslu\":[\"turkish\"],\"ustaba\":[\"turkish\"],\"ustura\":[\"turkish\"],\"usul\":[\"turkish\"],\"utanga\":[\"turkish\"],\"uyank\":[\"turkish\"],\"uyar\":[\"turkish\"],\"uydu\":[\"turkish\"],\"uygar\":[\"turkish\"],\"uygulama\":[\"turkish\"],\"uykusuz\":[\"turkish\"],\"uysal\":[\"turkish\"],\"uyuma\":[\"turkish\"],\"uzant\":[\"turkish\"],\"uzay\":[\"turkish\"],\"uzgren\":[\"turkish\"],\"uzlama\":[\"turkish\"],\"uzman\":[\"turkish\"],\"uzun\":[\"turkish\"],\"cra\":[\"turkish\"],\"cret\":[\"turkish\"],\"budak\":[\"turkish\"],\"gen\":[\"turkish\"],\"kat\":[\"turkish\"],\"leme\":[\"turkish\"],\"frk\":[\"turkish\"],\"lke\":[\"turkish\"],\"mit\":[\"turkish\"],\"niforma\":[\"turkish\"],\"nite\":[\"turkish\"],\"nlem\":[\"turkish\"],\"retken\":[\"turkish\"],\"rn\":[\"turkish\"],\"slup\":[\"turkish\"],\"stel\":[\"turkish\"],\"stn\":[\"turkish\"],\"enge\":[\"turkish\"],\"me\":[\"turkish\"],\"topya\":[\"turkish\"],\"vey\":[\"turkish\"],\"zengi\":[\"turkish\"],\"zgn\":[\"turkish\"],\"zm\":[\"turkish\"],\"vaka\":[\"turkish\"],\"vakfiye\":[\"turkish\"],\"vakf\":[\"turkish\"],\"vakit\":[\"turkish\"],\"vakum\":[\"turkish\"],\"vapur\":[\"turkish\"],\"varil\":[\"turkish\"],\"varlk\":[\"turkish\"],\"varsaym\":[\"turkish\"],\"varyemez\":[\"turkish\"],\"vasta\":[\"turkish\"],\"vasiyet\":[\"turkish\"],\"vatanda\":[\"turkish\"],\"vazife\":[\"turkish\"],\"vazo\":[\"turkish\"],\"veciz\":[\"turkish\"],\"vefa\":[\"turkish\"],\"vehim\":[\"turkish\"],\"veliaht\":[\"turkish\"],\"veresiye\":[\"turkish\"],\"verimli\":[\"turkish\"],\"verka\":[\"turkish\"],\"vernik\":[\"turkish\"],\"vertigo\":[\"turkish\"],\"vesait\":[\"turkish\"],\"vesika\":[\"turkish\"],\"vestiyer\":[\"turkish\"],\"veznedar\":[\"turkish\"],\"vicdan\":[\"turkish\"],\"vilayet\":[\"turkish\"],\"virane\":[\"turkish\"],\"virgl\":[\"turkish\"],\"vine\":[\"turkish\"],\"vites\":[\"turkish\"],\"vokal\":[\"turkish\"],\"volkan\":[\"turkish\"],\"vurma\":[\"turkish\"],\"vurucu\":[\"turkish\"],\"vcut\":[\"turkish\"],\"yabanc\":[\"turkish\"],\"yabgu\":[\"turkish\"],\"ya\":[\"turkish\"],\"yal\":[\"turkish\"],\"yamur\":[\"turkish\"],\"yakamoz\":[\"turkish\"],\"yakn\":[\"turkish\"],\"yaklak\":[\"turkish\"],\"yaln\":[\"turkish\"],\"yaltm\":[\"turkish\"],\"yaman\":[\"turkish\"],\"yanarda\":[\"turkish\"],\"yangn\":[\"turkish\"],\"yant\":[\"turkish\"],\"yank\":[\"turkish\"],\"yanl\":[\"turkish\"],\"yansma\":[\"turkish\"],\"yapay\":[\"turkish\"],\"yapboz\":[\"turkish\"],\"yapmc\":[\"turkish\"],\"yaprak\":[\"turkish\"],\"yaratk\":[\"turkish\"],\"yarbay\":[\"turkish\"],\"yardm\":[\"turkish\"],\"yarg\":[\"turkish\"],\"yarap\":[\"turkish\"],\"yasemin\":[\"turkish\"],\"yastk\":[\"turkish\"],\"yaam\":[\"turkish\"],\"yatak\":[\"turkish\"],\"yatrm\":[\"turkish\"],\"yavru\":[\"turkish\"],\"yaygara\":[\"turkish\"],\"yaync\":[\"turkish\"],\"yayla\":[\"turkish\"],\"yazlm\":[\"turkish\"],\"yekpare\":[\"turkish\"],\"yekvcut\":[\"turkish\"],\"yelkovan\":[\"turkish\"],\"yelpaze\":[\"turkish\"],\"yemek\":[\"turkish\"],\"yemi\":[\"turkish\"],\"yenge\":[\"turkish\"],\"yenieri\":[\"turkish\"],\"yeralt\":[\"turkish\"],\"yerkre\":[\"turkish\"],\"yerleke\":[\"turkish\"],\"yeryz\":[\"turkish\"],\"yeil\":[\"turkish\"],\"yetenek\":[\"turkish\"],\"yetkili\":[\"turkish\"],\"ynak\":[\"turkish\"],\"ykama\":[\"turkish\"],\"ylba\":[\"turkish\"],\"yldrm\":[\"turkish\"],\"ylk\":[\"turkish\"],\"ylmaz\":[\"turkish\"],\"yrtc\":[\"turkish\"],\"yiit\":[\"turkish\"],\"yourt\":[\"turkish\"],\"yoku\":[\"turkish\"],\"yolcu\":[\"turkish\"],\"yolda\":[\"turkish\"],\"yolgeen\":[\"turkish\"],\"yolkesen\":[\"turkish\"],\"yolst\":[\"turkish\"],\"yordam\":[\"turkish\"],\"yorgan\":[\"turkish\"],\"yorumcu\":[\"turkish\"],\"yosun\":[\"turkish\"],\"ynde\":[\"turkish\"],\"ynetim\":[\"turkish\"],\"ynl\":[\"turkish\"],\"yntem\":[\"turkish\"],\"yresel\":[\"turkish\"],\"yrnge\":[\"turkish\"],\"yufka\":[\"turkish\"],\"yukar\":[\"turkish\"],\"yumruk\":[\"turkish\"],\"yumurta\":[\"turkish\"],\"yuvarlak\":[\"turkish\"],\"ycelme\":[\"turkish\"],\"ykeker\":[\"turkish\"],\"yklem\":[\"turkish\"],\"yksek\":[\"turkish\"],\"yrek\":[\"turkish\"],\"yrtme\":[\"turkish\"],\"yzde\":[\"turkish\"],\"yzeysel\":[\"turkish\"],\"yzge\":[\"turkish\"],\"yzst\":[\"turkish\"],\"yzyl\":[\"turkish\"],\"zabta\":[\"turkish\"],\"zafer\":[\"turkish\"],\"zahmet\":[\"turkish\"],\"zambak\":[\"turkish\"],\"zaptiye\":[\"turkish\"],\"zarafet\":[\"turkish\"],\"zaruret\":[\"turkish\"],\"zeka\":[\"turkish\"],\"zekice\":[\"turkish\"],\"zemberek\":[\"turkish\"],\"zemin\":[\"turkish\"],\"zencefil\":[\"turkish\"],\"zeplin\":[\"turkish\"],\"zeytin\":[\"turkish\"],\"zbn\":[\"turkish\"],\"zlgt\":[\"turkish\"],\"zmbrt\":[\"turkish\"],\"zmpara\":[\"turkish\"],\"zpkn\":[\"turkish\"],\"zigon\":[\"turkish\"],\"zihinsel\":[\"turkish\"],\"zihniyet\":[\"turkish\"],\"zincir\":[\"turkish\"],\"zindan\":[\"turkish\"],\"zirzop\":[\"turkish\"],\"ziyaret\":[\"turkish\"],\"ziynet\":[\"turkish\"],\"zoraki\":[\"turkish\"],\"zorlu\":[\"turkish\"],\"zorunlu\":[\"turkish\"],\"zrt\":[\"turkish\"],\"zmre\":[\"turkish\"]}[\"abacate\",\"abaixo\",\"abalar\",\"abater\",\"abduzir\",\"abelha\",\"aberto\",\"abismo\",\"abotoar\",\"abranger\",\"abreviar\",\"abrigar\",\"abrupto\",\"absinto\",\"absoluto\",\"absurdo\",\"abutre\",\"acabado\",\"acalmar\",\"acampar\",\"acanhar\",\"acaso\",\"aceitar\",\"acelerar\",\"acenar\",\"acervo\",\"acessar\",\"acetona\",\"achatar\",\"acidez\",\"acima\",\"acionado\",\"acirrar\",\"aclamar\",\"aclive\",\"acolhida\",\"acomodar\",\"acoplar\",\"acordar\",\"acumular\",\"acusador\",\"adaptar\",\"adega\",\"adentro\",\"adepto\",\"adequar\",\"aderente\",\"adesivo\",\"adeus\",\"adiante\",\"aditivo\",\"adjetivo\",\"adjunto\",\"admirar\",\"adorar\",\"adquirir\",\"adubo\",\"adverso\",\"advogado\",\"aeronave\",\"afastar\",\"aferir\",\"afetivo\",\"afinador\",\"afivelar\",\"aflito\",\"afluente\",\"afrontar\",\"agachar\",\"agarrar\",\"agasalho\",\"agenciar\",\"agilizar\",\"agiota\",\"agitado\",\"agora\",\"agradar\",\"agreste\",\"agrupar\",\"aguardar\",\"agulha\",\"ajoelhar\",\"ajudar\",\"ajustar\",\"alameda\",\"alarme\",\"alastrar\",\"alavanca\",\"albergue\",\"albino\",\"alcatra\",\"aldeia\",\"alecrim\",\"alegria\",\"alertar\",\"alface\",\"alfinete\",\"algum\",\"alheio\",\"aliar\",\"alicate\",\"alienar\",\"alinhar\",\"aliviar\",\"almofada\",\"alocar\",\"alpiste\",\"alterar\",\"altitude\",\"alucinar\",\"alugar\",\"aluno\",\"alusivo\",\"alvo\",\"amaciar\",\"amador\",\"amarelo\",\"amassar\",\"ambas\",\"ambiente\",\"ameixa\",\"amenizar\",\"amido\",\"amistoso\",\"amizade\",\"amolador\",\"amontoar\",\"amoroso\",\"amostra\",\"amparar\",\"ampliar\",\"ampola\",\"anagrama\",\"analisar\",\"anarquia\",\"anatomia\",\"andaime\",\"anel\",\"anexo\",\"angular\",\"animar\",\"anjo\",\"anomalia\",\"anotado\",\"ansioso\",\"anterior\",\"anuidade\",\"anunciar\",\"anzol\",\"apagador\",\"apalpar\",\"apanhado\",\"apego\",\"apelido\",\"apertada\",\"apesar\",\"apetite\",\"apito\",\"aplauso\",\"aplicada\",\"apoio\",\"apontar\",\"aposta\",\"aprendiz\",\"aprovar\",\"aquecer\",\"arame\",\"aranha\",\"arara\",\"arcada\",\"ardente\",\"areia\",\"arejar\",\"arenito\",\"aresta\",\"argiloso\",\"argola\",\"arma\",\"arquivo\",\"arraial\",\"arrebate\",\"arriscar\",\"arroba\",\"arrumar\",\"arsenal\",\"arterial\",\"artigo\",\"arvoredo\",\"asfaltar\",\"asilado\",\"aspirar\",\"assador\",\"assinar\",\"assoalho\",\"assunto\",\"astral\",\"atacado\",\"atadura\",\"atalho\",\"atarefar\",\"atear\",\"atender\",\"aterro\",\"ateu\",\"atingir\",\"atirador\",\"ativo\",\"atoleiro\",\"atracar\",\"atrevido\",\"atriz\",\"atual\",\"atum\",\"auditor\",\"aumentar\",\"aura\",\"aurora\",\"autismo\",\"autoria\",\"autuar\",\"avaliar\",\"avante\",\"avaria\",\"avental\",\"avesso\",\"aviador\",\"avisar\",\"avulso\",\"axila\",\"azarar\",\"azedo\",\"azeite\",\"azulejo\",\"babar\",\"babosa\",\"bacalhau\",\"bacharel\",\"bacia\",\"bagagem\",\"baiano\",\"bailar\",\"baioneta\",\"bairro\",\"baixista\",\"bajular\",\"baleia\",\"baliza\",\"balsa\",\"banal\",\"bandeira\",\"banho\",\"banir\",\"banquete\",\"barato\",\"barbado\",\"baronesa\",\"barraca\",\"barulho\",\"baseado\",\"bastante\",\"batata\",\"batedor\",\"batida\",\"batom\",\"batucar\",\"baunilha\",\"beber\",\"beijo\",\"beirada\",\"beisebol\",\"beldade\",\"beleza\",\"belga\",\"beliscar\",\"bendito\",\"bengala\",\"benzer\",\"berimbau\",\"berlinda\",\"berro\",\"besouro\",\"bexiga\",\"bezerro\",\"bico\",\"bicudo\",\"bienal\",\"bifocal\",\"bifurcar\",\"bigorna\",\"bilhete\",\"bimestre\",\"bimotor\",\"biologia\",\"biombo\",\"biosfera\",\"bipolar\",\"birrento\",\"biscoito\",\"bisneto\",\"bispo\",\"bissexto\",\"bitola\",\"bizarro\",\"blindado\",\"bloco\",\"bloquear\",\"boato\",\"bobagem\",\"bocado\",\"bocejo\",\"bochecha\",\"boicotar\",\"bolada\",\"boletim\",\"bolha\",\"bolo\",\"bombeiro\",\"bonde\",\"boneco\",\"bonita\",\"borbulha\",\"borda\",\"boreal\",\"borracha\",\"bovino\",\"boxeador\",\"branco\",\"brasa\",\"braveza\",\"breu\",\"briga\",\"brilho\",\"brincar\",\"broa\",\"brochura\",\"bronzear\",\"broto\",\"bruxo\",\"bucha\",\"budismo\",\"bufar\",\"bule\",\"buraco\",\"busca\",\"busto\",\"buzina\",\"cabana\",\"cabelo\",\"cabide\",\"cabo\",\"cabrito\",\"cacau\",\"cacetada\",\"cachorro\",\"cacique\",\"cadastro\",\"cadeado\",\"cafezal\",\"caiaque\",\"caipira\",\"caixote\",\"cajado\",\"caju\",\"calafrio\",\"calcular\",\"caldeira\",\"calibrar\",\"calmante\",\"calota\",\"camada\",\"cambista\",\"camisa\",\"camomila\",\"campanha\",\"camuflar\",\"canavial\",\"cancelar\",\"caneta\",\"canguru\",\"canhoto\",\"canivete\",\"canoa\",\"cansado\",\"cantar\",\"canudo\",\"capacho\",\"capela\",\"capinar\",\"capotar\",\"capricho\",\"captador\",\"capuz\",\"caracol\",\"carbono\",\"cardeal\",\"careca\",\"carimbar\",\"carneiro\",\"carpete\",\"carreira\",\"cartaz\",\"carvalho\",\"casaco\",\"casca\",\"casebre\",\"castelo\",\"casulo\",\"catarata\",\"cativar\",\"caule\",\"causador\",\"cautelar\",\"cavalo\",\"caverna\",\"cebola\",\"cedilha\",\"cegonha\",\"celebrar\",\"celular\",\"cenoura\",\"censo\",\"centeio\",\"cercar\",\"cerrado\",\"certeiro\",\"cerveja\",\"cetim\",\"cevada\",\"chacota\",\"chaleira\",\"chamado\",\"chapada\",\"charme\",\"chatice\",\"chave\",\"chefe\",\"chegada\",\"cheiro\",\"cheque\",\"chicote\",\"chifre\",\"chinelo\",\"chocalho\",\"chover\",\"chumbo\",\"chutar\",\"chuva\",\"cicatriz\",\"ciclone\",\"cidade\",\"cidreira\",\"ciente\",\"cigana\",\"cimento\",\"cinto\",\"cinza\",\"ciranda\",\"circuito\",\"cirurgia\",\"citar\",\"clareza\",\"clero\",\"clicar\",\"clone\",\"clube\",\"coado\",\"coagir\",\"cobaia\",\"cobertor\",\"cobrar\",\"cocada\",\"coelho\",\"coentro\",\"coeso\",\"cogumelo\",\"coibir\",\"coifa\",\"coiote\",\"colar\",\"coleira\",\"colher\",\"colidir\",\"colmeia\",\"colono\",\"coluna\",\"comando\",\"combinar\",\"comentar\",\"comitiva\",\"comover\",\"complexo\",\"comum\",\"concha\",\"condor\",\"conectar\",\"confuso\",\"congelar\",\"conhecer\",\"conjugar\",\"consumir\",\"contrato\",\"convite\",\"cooperar\",\"copeiro\",\"copiador\",\"copo\",\"coquetel\",\"coragem\",\"cordial\",\"corneta\",\"coronha\",\"corporal\",\"correio\",\"cortejo\",\"coruja\",\"corvo\",\"cosseno\",\"costela\",\"cotonete\",\"couro\",\"couve\",\"covil\",\"cozinha\",\"cratera\",\"cravo\",\"creche\",\"credor\",\"creme\",\"crer\",\"crespo\",\"criada\",\"criminal\",\"crioulo\",\"crise\",\"criticar\",\"crosta\",\"crua\",\"cruzeiro\",\"cubano\",\"cueca\",\"cuidado\",\"cujo\",\"culatra\",\"culminar\",\"culpar\",\"cultura\",\"cumprir\",\"cunhado\",\"cupido\",\"curativo\",\"curral\",\"cursar\",\"curto\",\"cuspir\",\"custear\",\"cutelo\",\"damasco\",\"datar\",\"debater\",\"debitar\",\"deboche\",\"debulhar\",\"decalque\",\"decimal\",\"declive\",\"decote\",\"decretar\",\"dedal\",\"dedicado\",\"deduzir\",\"defesa\",\"defumar\",\"degelo\",\"degrau\",\"degustar\",\"deitado\",\"deixar\",\"delator\",\"delegado\",\"delinear\",\"delonga\",\"demanda\",\"demitir\",\"demolido\",\"dentista\",\"depenado\",\"depilar\",\"depois\",\"depressa\",\"depurar\",\"deriva\",\"derramar\",\"desafio\",\"desbotar\",\"descanso\",\"desenho\",\"desfiado\",\"desgaste\",\"desigual\",\"deslize\",\"desmamar\",\"desova\",\"despesa\",\"destaque\",\"desviar\",\"detalhar\",\"detentor\",\"detonar\",\"detrito\",\"deusa\",\"dever\",\"devido\",\"devotado\",\"dezena\",\"diagrama\",\"dialeto\",\"didata\",\"difuso\",\"digitar\",\"dilatado\",\"diluente\",\"diminuir\",\"dinastia\",\"dinheiro\",\"diocese\",\"direto\",\"discreta\",\"disfarce\",\"disparo\",\"disquete\",\"dissipar\",\"distante\",\"ditador\",\"diurno\",\"diverso\",\"divisor\",\"divulgar\",\"dizer\",\"dobrador\",\"dolorido\",\"domador\",\"dominado\",\"donativo\",\"donzela\",\"dormente\",\"dorsal\",\"dosagem\",\"dourado\",\"doutor\",\"drenagem\",\"drible\",\"drogaria\",\"duelar\",\"duende\",\"dueto\",\"duplo\",\"duquesa\",\"durante\",\"duvidoso\",\"eclodir\",\"ecoar\",\"ecologia\",\"edificar\",\"edital\",\"educado\",\"efeito\",\"efetivar\",\"ejetar\",\"elaborar\",\"eleger\",\"eleitor\",\"elenco\",\"elevador\",\"eliminar\",\"elogiar\",\"embargo\",\"embolado\",\"embrulho\",\"embutido\",\"emenda\",\"emergir\",\"emissor\",\"empatia\",\"empenho\",\"empinado\",\"empolgar\",\"emprego\",\"empurrar\",\"emulador\",\"encaixe\",\"encenado\",\"enchente\",\"encontro\",\"endeusar\",\"endossar\",\"enfaixar\",\"enfeite\",\"enfim\",\"engajado\",\"engenho\",\"englobar\",\"engomado\",\"engraxar\",\"enguia\",\"enjoar\",\"enlatar\",\"enquanto\",\"enraizar\",\"enrolado\",\"enrugar\",\"ensaio\",\"enseada\",\"ensino\",\"ensopado\",\"entanto\",\"enteado\",\"entidade\",\"entortar\",\"entrada\",\"entulho\",\"envergar\",\"enviado\",\"envolver\",\"enxame\",\"enxerto\",\"enxofre\",\"enxuto\",\"epiderme\",\"equipar\",\"ereto\",\"erguido\",\"errata\",\"erva\",\"ervilha\",\"esbanjar\",\"esbelto\",\"escama\",\"escola\",\"escrita\",\"escuta\",\"esfinge\",\"esfolar\",\"esfregar\",\"esfumado\",\"esgrima\",\"esmalte\",\"espanto\",\"espelho\",\"espiga\",\"esponja\",\"espreita\",\"espumar\",\"esquerda\",\"estaca\",\"esteira\",\"esticar\",\"estofado\",\"estrela\",\"estudo\",\"esvaziar\",\"etanol\",\"etiqueta\",\"euforia\",\"europeu\",\"evacuar\",\"evaporar\",\"evasivo\",\"eventual\",\"evidente\",\"evoluir\",\"exagero\",\"exalar\",\"examinar\",\"exato\",\"exausto\",\"excesso\",\"excitar\",\"exclamar\",\"executar\",\"exemplo\",\"exibir\",\"exigente\",\"exonerar\",\"expandir\",\"expelir\",\"expirar\",\"explanar\",\"exposto\",\"expresso\",\"expulsar\",\"externo\",\"extinto\",\"extrato\",\"fabricar\",\"fabuloso\",\"faceta\",\"facial\",\"fada\",\"fadiga\",\"faixa\",\"falar\",\"falta\",\"familiar\",\"fandango\",\"fanfarra\",\"fantoche\",\"fardado\",\"farelo\",\"farinha\",\"farofa\",\"farpa\",\"fartura\",\"fatia\",\"fator\",\"favorita\",\"faxina\",\"fazenda\",\"fechado\",\"feijoada\",\"feirante\",\"felino\",\"feminino\",\"fenda\",\"feno\",\"fera\",\"feriado\",\"ferrugem\",\"ferver\",\"festejar\",\"fetal\",\"feudal\",\"fiapo\",\"fibrose\",\"ficar\",\"ficheiro\",\"figurado\",\"fileira\",\"filho\",\"filme\",\"filtrar\",\"firmeza\",\"fisgada\",\"fissura\",\"fita\",\"fivela\",\"fixador\",\"fixo\",\"flacidez\",\"flamingo\",\"flanela\",\"flechada\",\"flora\",\"flutuar\",\"fluxo\",\"focal\",\"focinho\",\"fofocar\",\"fogo\",\"foguete\",\"foice\",\"folgado\",\"folheto\",\"forjar\",\"formiga\",\"forno\",\"forte\",\"fosco\",\"fossa\",\"fragata\",\"fralda\",\"frango\",\"frasco\",\"fraterno\",\"freira\",\"frente\",\"fretar\",\"frieza\",\"friso\",\"fritura\",\"fronha\",\"frustrar\",\"fruteira\",\"fugir\",\"fulano\",\"fuligem\",\"fundar\",\"fungo\",\"funil\",\"furador\",\"furioso\",\"futebol\",\"gabarito\",\"gabinete\",\"gado\",\"gaiato\",\"gaiola\",\"gaivota\",\"galega\",\"galho\",\"galinha\",\"galocha\",\"ganhar\",\"garagem\",\"garfo\",\"gargalo\",\"garimpo\",\"garoupa\",\"garrafa\",\"gasoduto\",\"gasto\",\"gata\",\"gatilho\",\"gaveta\",\"gazela\",\"gelado\",\"geleia\",\"gelo\",\"gemada\",\"gemer\",\"gemido\",\"generoso\",\"gengiva\",\"genial\",\"genoma\",\"genro\",\"geologia\",\"gerador\",\"germinar\",\"gesso\",\"gestor\",\"ginasta\",\"gincana\",\"gingado\",\"girafa\",\"girino\",\"glacial\",\"glicose\",\"global\",\"glorioso\",\"goela\",\"goiaba\",\"golfe\",\"golpear\",\"gordura\",\"gorjeta\",\"gorro\",\"gostoso\",\"goteira\",\"governar\",\"gracejo\",\"gradual\",\"grafite\",\"gralha\",\"grampo\",\"granada\",\"gratuito\",\"graveto\",\"graxa\",\"grego\",\"grelhar\",\"greve\",\"grilo\",\"grisalho\",\"gritaria\",\"grosso\",\"grotesco\",\"grudado\",\"grunhido\",\"gruta\",\"guache\",\"guarani\",\"guaxinim\",\"guerrear\",\"guiar\",\"guincho\",\"guisado\",\"gula\",\"guloso\",\"guru\",\"habitar\",\"harmonia\",\"haste\",\"haver\",\"hectare\",\"herdar\",\"heresia\",\"hesitar\",\"hiato\",\"hibernar\",\"hidratar\",\"hiena\",\"hino\",\"hipismo\",\"hipnose\",\"hipoteca\",\"hoje\",\"holofote\",\"homem\",\"honesto\",\"honrado\",\"hormonal\",\"hospedar\",\"humorado\",\"iate\",\"ideia\",\"idoso\",\"ignorado\",\"igreja\",\"iguana\",\"ileso\",\"ilha\",\"iludido\",\"iluminar\",\"ilustrar\",\"imagem\",\"imediato\",\"imenso\",\"imersivo\",\"iminente\",\"imitador\",\"imortal\",\"impacto\",\"impedir\",\"implante\",\"impor\",\"imprensa\",\"impune\",\"imunizar\",\"inalador\",\"inapto\",\"inativo\",\"incenso\",\"inchar\",\"incidir\",\"incluir\",\"incolor\",\"indeciso\",\"indireto\",\"indutor\",\"ineficaz\",\"inerente\",\"infantil\",\"infestar\",\"infinito\",\"inflamar\",\"informal\",\"infrator\",\"ingerir\",\"inibido\",\"inicial\",\"inimigo\",\"injetar\",\"inocente\",\"inodoro\",\"inovador\",\"inox\",\"inquieto\",\"inscrito\",\"inseto\",\"insistir\",\"inspetor\",\"instalar\",\"insulto\",\"intacto\",\"integral\",\"intimar\",\"intocado\",\"intriga\",\"invasor\",\"inverno\",\"invicto\",\"invocar\",\"iogurte\",\"iraniano\",\"ironizar\",\"irreal\",\"irritado\",\"isca\",\"isento\",\"isolado\",\"isqueiro\",\"italiano\",\"janeiro\",\"jangada\",\"janta\",\"jararaca\",\"jardim\",\"jarro\",\"jasmim\",\"jato\",\"javali\",\"jazida\",\"jejum\",\"joaninha\",\"joelhada\",\"jogador\",\"joia\",\"jornal\",\"jorrar\",\"jovem\",\"juba\",\"judeu\",\"judoca\",\"juiz\",\"julgador\",\"julho\",\"jurado\",\"jurista\",\"juro\",\"justa\",\"labareda\",\"laboral\",\"lacre\",\"lactante\",\"ladrilho\",\"lagarta\",\"lagoa\",\"laje\",\"lamber\",\"lamentar\",\"laminar\",\"lampejo\",\"lanche\",\"lapidar\",\"lapso\",\"laranja\",\"lareira\",\"largura\",\"lasanha\",\"lastro\",\"lateral\",\"latido\",\"lavanda\",\"lavoura\",\"lavrador\",\"laxante\",\"lazer\",\"lealdade\",\"lebre\",\"legado\",\"legendar\",\"legista\",\"leigo\",\"leiloar\",\"leitura\",\"lembrete\",\"leme\",\"lenhador\",\"lentilha\",\"leoa\",\"lesma\",\"leste\",\"letivo\",\"letreiro\",\"levar\",\"leveza\",\"levitar\",\"liberal\",\"libido\",\"liderar\",\"ligar\",\"ligeiro\",\"limitar\",\"limoeiro\",\"limpador\",\"linda\",\"linear\",\"linhagem\",\"liquidez\",\"listagem\",\"lisura\",\"litoral\",\"livro\",\"lixa\",\"lixeira\",\"locador\",\"locutor\",\"lojista\",\"lombo\",\"lona\",\"longe\",\"lontra\",\"lorde\",\"lotado\",\"loteria\",\"loucura\",\"lousa\",\"louvar\",\"luar\",\"lucidez\",\"lucro\",\"luneta\",\"lustre\",\"lutador\",\"luva\",\"macaco\",\"macete\",\"machado\",\"macio\",\"madeira\",\"madrinha\",\"magnata\",\"magreza\",\"maior\",\"mais\",\"malandro\",\"malha\",\"malote\",\"maluco\",\"mamilo\",\"mamoeiro\",\"mamute\",\"manada\",\"mancha\",\"mandato\",\"manequim\",\"manhoso\",\"manivela\",\"manobrar\",\"mansa\",\"manter\",\"manusear\",\"mapeado\",\"maquinar\",\"marcador\",\"maresia\",\"marfim\",\"margem\",\"marinho\",\"marmita\",\"maroto\",\"marquise\",\"marreco\",\"martelo\",\"marujo\",\"mascote\",\"masmorra\",\"massagem\",\"mastigar\",\"matagal\",\"materno\",\"matinal\",\"matutar\",\"maxilar\",\"medalha\",\"medida\",\"medusa\",\"megafone\",\"meiga\",\"melancia\",\"melhor\",\"membro\",\"memorial\",\"menino\",\"menos\",\"mensagem\",\"mental\",\"merecer\",\"mergulho\",\"mesada\",\"mesclar\",\"mesmo\",\"mesquita\",\"mestre\",\"metade\",\"meteoro\",\"metragem\",\"mexer\",\"mexicano\",\"micro\",\"migalha\",\"migrar\",\"milagre\",\"milenar\",\"milhar\",\"mimado\",\"minerar\",\"minhoca\",\"ministro\",\"minoria\",\"miolo\",\"mirante\",\"mirtilo\",\"misturar\",\"mocidade\",\"moderno\",\"modular\",\"moeda\",\"moer\",\"moinho\",\"moita\",\"moldura\",\"moleza\",\"molho\",\"molinete\",\"molusco\",\"montanha\",\"moqueca\",\"morango\",\"morcego\",\"mordomo\",\"morena\",\"mosaico\",\"mosquete\",\"mostarda\",\"motel\",\"motim\",\"moto\",\"motriz\",\"muda\",\"muito\",\"mulata\",\"mulher\",\"multar\",\"mundial\",\"munido\",\"muralha\",\"murcho\",\"muscular\",\"museu\",\"musical\",\"nacional\",\"nadador\",\"naja\",\"namoro\",\"narina\",\"narrado\",\"nascer\",\"nativa\",\"natureza\",\"navalha\",\"navegar\",\"navio\",\"neblina\",\"nebuloso\",\"negativa\",\"negociar\",\"negrito\",\"nervoso\",\"neta\",\"neural\",\"nevasca\",\"nevoeiro\",\"ninar\",\"ninho\",\"nitidez\",\"nivelar\",\"nobreza\",\"noite\",\"noiva\",\"nomear\",\"nominal\",\"nordeste\",\"nortear\",\"notar\",\"noticiar\",\"noturno\",\"novelo\",\"novilho\",\"novo\",\"nublado\",\"nudez\",\"numeral\",\"nupcial\",\"nutrir\",\"nuvem\",\"obcecado\",\"obedecer\",\"objetivo\",\"obrigado\",\"obscuro\",\"obstetra\",\"obter\",\"obturar\",\"ocidente\",\"ocioso\",\"ocorrer\",\"oculista\",\"ocupado\",\"ofegante\",\"ofensiva\",\"oferenda\",\"oficina\",\"ofuscado\",\"ogiva\",\"olaria\",\"oleoso\",\"olhar\",\"oliveira\",\"ombro\",\"omelete\",\"omisso\",\"omitir\",\"ondulado\",\"oneroso\",\"ontem\",\"opcional\",\"operador\",\"oponente\",\"oportuno\",\"oposto\",\"orar\",\"orbitar\",\"ordem\",\"ordinal\",\"orfanato\",\"orgasmo\",\"orgulho\",\"oriental\",\"origem\",\"oriundo\",\"orla\",\"ortodoxo\",\"orvalho\",\"oscilar\",\"ossada\",\"osso\",\"ostentar\",\"otimismo\",\"ousadia\",\"outono\",\"outubro\",\"ouvido\",\"ovelha\",\"ovular\",\"oxidar\",\"oxigenar\",\"pacato\",\"paciente\",\"pacote\",\"pactuar\",\"padaria\",\"padrinho\",\"pagar\",\"pagode\",\"painel\",\"pairar\",\"paisagem\",\"palavra\",\"palestra\",\"palheta\",\"palito\",\"palmada\",\"palpitar\",\"pancada\",\"panela\",\"panfleto\",\"panqueca\",\"pantanal\",\"papagaio\",\"papelada\",\"papiro\",\"parafina\",\"parcial\",\"pardal\",\"parede\",\"partida\",\"pasmo\",\"passado\",\"pastel\",\"patamar\",\"patente\",\"patinar\",\"patrono\",\"paulada\",\"pausar\",\"peculiar\",\"pedalar\",\"pedestre\",\"pediatra\",\"pedra\",\"pegada\",\"peitoral\",\"peixe\",\"pele\",\"pelicano\",\"penca\",\"pendurar\",\"peneira\",\"penhasco\",\"pensador\",\"pente\",\"perceber\",\"perfeito\",\"pergunta\",\"perito\",\"permitir\",\"perna\",\"perplexo\",\"persiana\",\"pertence\",\"peruca\",\"pescado\",\"pesquisa\",\"pessoa\",\"petiscar\",\"piada\",\"picado\",\"piedade\",\"pigmento\",\"pilastra\",\"pilhado\",\"pilotar\",\"pimenta\",\"pincel\",\"pinguim\",\"pinha\",\"pinote\",\"pintar\",\"pioneiro\",\"pipoca\",\"piquete\",\"piranha\",\"pires\",\"pirueta\",\"piscar\",\"pistola\",\"pitanga\",\"pivete\",\"planta\",\"plaqueta\",\"platina\",\"plebeu\",\"plumagem\",\"pluvial\",\"pneu\",\"poda\",\"poeira\",\"poetisa\",\"polegada\",\"policiar\",\"poluente\",\"polvilho\",\"pomar\",\"pomba\",\"ponderar\",\"pontaria\",\"populoso\",\"porta\",\"possuir\",\"postal\",\"pote\",\"poupar\",\"pouso\",\"povoar\",\"praia\",\"prancha\",\"prato\",\"praxe\",\"prece\",\"predador\",\"prefeito\",\"premiar\",\"prensar\",\"preparar\",\"presilha\",\"pretexto\",\"prevenir\",\"prezar\",\"primata\",\"princesa\",\"prisma\",\"privado\",\"processo\",\"produto\",\"profeta\",\"proibido\",\"projeto\",\"prometer\",\"propagar\",\"prosa\",\"protetor\",\"provador\",\"publicar\",\"pudim\",\"pular\",\"pulmonar\",\"pulseira\",\"punhal\",\"punir\",\"pupilo\",\"pureza\",\"puxador\",\"quadra\",\"quantia\",\"quarto\",\"quase\",\"quebrar\",\"queda\",\"queijo\",\"quente\",\"querido\",\"quimono\",\"quina\",\"quiosque\",\"rabanada\",\"rabisco\",\"rachar\",\"racionar\",\"radial\",\"raiar\",\"rainha\",\"raio\",\"raiva\",\"rajada\",\"ralado\",\"ramal\",\"ranger\",\"ranhura\",\"rapadura\",\"rapel\",\"rapidez\",\"raposa\",\"raquete\",\"raridade\",\"rasante\",\"rascunho\",\"rasgar\",\"raspador\",\"rasteira\",\"rasurar\",\"ratazana\",\"ratoeira\",\"realeza\",\"reanimar\",\"reaver\",\"rebaixar\",\"rebelde\",\"rebolar\",\"recado\",\"recente\",\"recheio\",\"recibo\",\"recordar\",\"recrutar\",\"recuar\",\"rede\",\"redimir\",\"redonda\",\"reduzida\",\"reenvio\",\"refinar\",\"refletir\",\"refogar\",\"refresco\",\"refugiar\",\"regalia\",\"regime\",\"regra\",\"reinado\",\"reitor\",\"rejeitar\",\"relativo\",\"remador\",\"remendo\",\"remorso\",\"renovado\",\"reparo\",\"repelir\",\"repleto\",\"repolho\",\"represa\",\"repudiar\",\"requerer\",\"resenha\",\"resfriar\",\"resgatar\",\"residir\",\"resolver\",\"respeito\",\"ressaca\",\"restante\",\"resumir\",\"retalho\",\"reter\",\"retirar\",\"retomada\",\"retratar\",\"revelar\",\"revisor\",\"revolta\",\"riacho\",\"rica\",\"rigidez\",\"rigoroso\",\"rimar\",\"ringue\",\"risada\",\"risco\",\"risonho\",\"robalo\",\"rochedo\",\"rodada\",\"rodeio\",\"rodovia\",\"roedor\",\"roleta\",\"romano\",\"roncar\",\"rosado\",\"roseira\",\"rosto\",\"rota\",\"roteiro\",\"rotina\",\"rotular\",\"rouco\",\"roupa\",\"roxo\",\"rubro\",\"rugido\",\"rugoso\",\"ruivo\",\"rumo\",\"rupestre\",\"russo\",\"sabor\",\"saciar\",\"sacola\",\"sacudir\",\"sadio\",\"safira\",\"saga\",\"sagrada\",\"saibro\",\"salada\",\"saleiro\",\"salgado\",\"saliva\",\"salpicar\",\"salsicha\",\"saltar\",\"salvador\",\"sambar\",\"samurai\",\"sanar\",\"sanfona\",\"sangue\",\"sanidade\",\"sapato\",\"sarda\",\"sargento\",\"sarjeta\",\"saturar\",\"saudade\",\"saxofone\",\"sazonal\",\"secar\",\"secular\",\"seda\",\"sedento\",\"sediado\",\"sedoso\",\"sedutor\",\"segmento\",\"segredo\",\"segundo\",\"seiva\",\"seleto\",\"selvagem\",\"semanal\",\"semente\",\"senador\",\"senhor\",\"sensual\",\"sentado\",\"separado\",\"sereia\",\"seringa\",\"serra\",\"servo\",\"setembro\",\"setor\",\"sigilo\",\"silhueta\",\"silicone\",\"simetria\",\"simpatia\",\"simular\",\"sinal\",\"sincero\",\"singular\",\"sinopse\",\"sintonia\",\"sirene\",\"siri\",\"situado\",\"soberano\",\"sobra\",\"socorro\",\"sogro\",\"soja\",\"solda\",\"soletrar\",\"solteiro\",\"sombrio\",\"sonata\",\"sondar\",\"sonegar\",\"sonhador\",\"sono\",\"soprano\",\"soquete\",\"sorrir\",\"sorteio\",\"sossego\",\"sotaque\",\"soterrar\",\"sovado\",\"sozinho\",\"suavizar\",\"subida\",\"submerso\",\"subsolo\",\"subtrair\",\"sucata\",\"sucesso\",\"suco\",\"sudeste\",\"sufixo\",\"sugador\",\"sugerir\",\"sujeito\",\"sulfato\",\"sumir\",\"suor\",\"superior\",\"suplicar\",\"suposto\",\"suprimir\",\"surdina\",\"surfista\",\"surpresa\",\"surreal\",\"surtir\",\"suspiro\",\"sustento\",\"tabela\",\"tablete\",\"tabuada\",\"tacho\",\"tagarela\",\"talher\",\"talo\",\"talvez\",\"tamanho\",\"tamborim\",\"tampa\",\"tangente\",\"tanto\",\"tapar\",\"tapioca\",\"tardio\",\"tarefa\",\"tarja\",\"tarraxa\",\"tatuagem\",\"taurino\",\"taxativo\",\"taxista\",\"teatral\",\"tecer\",\"tecido\",\"teclado\",\"tedioso\",\"teia\",\"teimar\",\"telefone\",\"telhado\",\"tempero\",\"tenente\",\"tensor\",\"tentar\",\"termal\",\"terno\",\"terreno\",\"tese\",\"tesoura\",\"testado\",\"teto\",\"textura\",\"texugo\",\"tiara\",\"tigela\",\"tijolo\",\"timbrar\",\"timidez\",\"tingido\",\"tinteiro\",\"tiragem\",\"titular\",\"toalha\",\"tocha\",\"tolerar\",\"tolice\",\"tomada\",\"tomilho\",\"tonel\",\"tontura\",\"topete\",\"tora\",\"torcido\",\"torneio\",\"torque\",\"torrada\",\"torto\",\"tostar\",\"touca\",\"toupeira\",\"toxina\",\"trabalho\",\"tracejar\",\"tradutor\",\"trafegar\",\"trajeto\",\"trama\",\"trancar\",\"trapo\",\"traseiro\",\"tratador\",\"travar\",\"treino\",\"tremer\",\"trepidar\",\"trevo\",\"triagem\",\"tribo\",\"triciclo\",\"tridente\",\"trilogia\",\"trindade\",\"triplo\",\"triturar\",\"triunfal\",\"trocar\",\"trombeta\",\"trova\",\"trunfo\",\"truque\",\"tubular\",\"tucano\",\"tudo\",\"tulipa\",\"tupi\",\"turbo\",\"turma\",\"turquesa\",\"tutelar\",\"tutorial\",\"uivar\",\"umbigo\",\"unha\",\"unidade\",\"uniforme\",\"urologia\",\"urso\",\"urtiga\",\"urubu\",\"usado\",\"usina\",\"usufruir\",\"vacina\",\"vadiar\",\"vagaroso\",\"vaidoso\",\"vala\",\"valente\",\"validade\",\"valores\",\"vantagem\",\"vaqueiro\",\"varanda\",\"vareta\",\"varrer\",\"vascular\",\"vasilha\",\"vassoura\",\"vazar\",\"vazio\",\"veado\",\"vedar\",\"vegetar\",\"veicular\",\"veleiro\",\"velhice\",\"veludo\",\"vencedor\",\"vendaval\",\"venerar\",\"ventre\",\"verbal\",\"verdade\",\"vereador\",\"vergonha\",\"vermelho\",\"verniz\",\"versar\",\"vertente\",\"vespa\",\"vestido\",\"vetorial\",\"viaduto\",\"viagem\",\"viajar\",\"viatura\",\"vibrador\",\"videira\",\"vidraria\",\"viela\",\"viga\",\"vigente\",\"vigiar\",\"vigorar\",\"vilarejo\",\"vinco\",\"vinheta\",\"vinil\",\"violeta\",\"virada\",\"virtude\",\"visitar\",\"visto\",\"vitral\",\"viveiro\",\"vizinho\",\"voador\",\"voar\",\"vogal\",\"volante\",\"voleibol\",\"voltagem\",\"volumoso\",\"vontade\",\"vulto\",\"vuvuzela\",\"xadrez\",\"xarope\",\"xeque\",\"xeretar\",\"xerife\",\"xingar\",\"zangado\",\"zarpar\",\"zebu\",\"zelador\",\"zombar\",\"zoologia\",\"zumbido\"][\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"][\"abaco\",\"abdomen\",\"abeja\",\"abierto\",\"abogado\",\"abono\",\"aborto\",\"abrazo\",\"abrir\",\"abuelo\",\"abuso\",\"acabar\",\"academia\",\"acceso\",\"accion\",\"aceite\",\"acelga\",\"acento\",\"aceptar\",\"acido\",\"aclarar\",\"acne\",\"acoger\",\"acoso\",\"activo\",\"acto\",\"actriz\",\"actuar\",\"acudir\",\"acuerdo\",\"acusar\",\"adicto\",\"admitir\",\"adoptar\",\"adorno\",\"aduana\",\"adulto\",\"aereo\",\"afectar\",\"aficion\",\"afinar\",\"afirmar\",\"agil\",\"agitar\",\"agonia\",\"agosto\",\"agotar\",\"agregar\",\"agrio\",\"agua\",\"agudo\",\"aguila\",\"aguja\",\"ahogo\",\"ahorro\",\"aire\",\"aislar\",\"ajedrez\",\"ajeno\",\"ajuste\",\"alacran\",\"alambre\",\"alarma\",\"alba\",\"album\",\"alcalde\",\"aldea\",\"alegre\",\"alejar\",\"alerta\",\"aleta\",\"alfiler\",\"alga\",\"algodon\",\"aliado\",\"aliento\",\"alivio\",\"alma\",\"almeja\",\"almibar\",\"altar\",\"alteza\",\"altivo\",\"alto\",\"altura\",\"alumno\",\"alzar\",\"amable\",\"amante\",\"amapola\",\"amargo\",\"amasar\",\"ambar\",\"ambito\",\"ameno\",\"amigo\",\"amistad\",\"amor\",\"amparo\",\"amplio\",\"ancho\",\"anciano\",\"ancla\",\"andar\",\"anden\",\"anemia\",\"angulo\",\"anillo\",\"animo\",\"anis\",\"anotar\",\"antena\",\"antiguo\",\"antojo\",\"anual\",\"anular\",\"anuncio\",\"anadir\",\"anejo\",\"ano\",\"apagar\",\"aparato\",\"apetito\",\"apio\",\"aplicar\",\"apodo\",\"aporte\",\"apoyo\",\"aprender\",\"aprobar\",\"apuesta\",\"apuro\",\"arado\",\"arana\",\"arar\",\"arbitro\",\"arbol\",\"arbusto\",\"archivo\",\"arco\",\"arder\",\"ardilla\",\"arduo\",\"area\",\"arido\",\"aries\",\"armonia\",\"arnes\",\"aroma\",\"arpa\",\"arpon\",\"arreglo\",\"arroz\",\"arruga\",\"arte\",\"artista\",\"asa\",\"asado\",\"asalto\",\"ascenso\",\"asegurar\",\"aseo\",\"asesor\",\"asiento\",\"asilo\",\"asistir\",\"asno\",\"asombro\",\"aspero\",\"astilla\",\"astro\",\"astuto\",\"asumir\",\"asunto\",\"atajo\",\"ataque\",\"atar\",\"atento\",\"ateo\",\"atico\",\"atleta\",\"atomo\",\"atraer\",\"atroz\",\"atun\",\"audaz\",\"audio\",\"auge\",\"aula\",\"aumento\",\"ausente\",\"autor\",\"aval\",\"avance\",\"avaro\",\"ave\",\"avellana\",\"avena\",\"avestruz\",\"avion\",\"aviso\",\"ayer\",\"ayuda\",\"ayuno\",\"azafran\",\"azar\",\"azote\",\"azucar\",\"azufre\",\"azul\",\"baba\",\"babor\",\"bache\",\"bahia\",\"baile\",\"bajar\",\"balanza\",\"balcon\",\"balde\",\"bambu\",\"banco\",\"banda\",\"bano\",\"barba\",\"barco\",\"barniz\",\"barro\",\"bascula\",\"baston\",\"basura\",\"batalla\",\"bateria\",\"batir\",\"batuta\",\"baul\",\"bazar\",\"bebe\",\"bebida\",\"bello\",\"besar\",\"beso\",\"bestia\",\"bicho\",\"bien\",\"bingo\",\"blanco\",\"bloque\",\"blusa\",\"boa\",\"bobina\",\"bobo\",\"boca\",\"bocina\",\"boda\",\"bodega\",\"boina\",\"bola\",\"bolero\",\"bolsa\",\"bomba\",\"bondad\",\"bonito\",\"bono\",\"bonsai\",\"borde\",\"borrar\",\"bosque\",\"bote\",\"botin\",\"boveda\",\"bozal\",\"bravo\",\"brazo\",\"brecha\",\"breve\",\"brillo\",\"brinco\",\"brisa\",\"broca\",\"broma\",\"bronce\",\"brote\",\"bruja\",\"brusco\",\"bruto\",\"buceo\",\"bucle\",\"bueno\",\"buey\",\"bufanda\",\"bufon\",\"buho\",\"buitre\",\"bulto\",\"burbuja\",\"burla\",\"burro\",\"buscar\",\"butaca\",\"buzon\",\"caballo\",\"cabeza\",\"cabina\",\"cabra\",\"cacao\",\"cadaver\",\"cadena\",\"caer\",\"cafe\",\"caida\",\"caiman\",\"caja\",\"cajon\",\"cal\",\"calamar\",\"calcio\",\"caldo\",\"calidad\",\"calle\",\"calma\",\"calor\",\"calvo\",\"cama\",\"cambio\",\"camello\",\"camino\",\"campo\",\"cancer\",\"candil\",\"canela\",\"canguro\",\"canica\",\"canto\",\"cana\",\"canon\",\"caoba\",\"caos\",\"capaz\",\"capitan\",\"capote\",\"captar\",\"capucha\",\"cara\",\"carbon\",\"carcel\",\"careta\",\"carga\",\"carino\",\"carne\",\"carpeta\",\"carro\",\"carta\",\"casa\",\"casco\",\"casero\",\"caspa\",\"castor\",\"catorce\",\"catre\",\"caudal\",\"causa\",\"cazo\",\"cebolla\",\"ceder\",\"cedro\",\"celda\",\"celebre\",\"celoso\",\"celula\",\"cemento\",\"ceniza\",\"centro\",\"cerca\",\"cerdo\",\"cereza\",\"cero\",\"cerrar\",\"certeza\",\"cesped\",\"cetro\",\"chacal\",\"chaleco\",\"champu\",\"chancla\",\"chapa\",\"charla\",\"chico\",\"chiste\",\"chivo\",\"choque\",\"choza\",\"chuleta\",\"chupar\",\"ciclon\",\"ciego\",\"cielo\",\"cien\",\"cierto\",\"cifra\",\"cigarro\",\"cima\",\"cinco\",\"cine\",\"cinta\",\"cipres\",\"circo\",\"ciruela\",\"cisne\",\"cita\",\"ciudad\",\"clamor\",\"clan\",\"claro\",\"clase\",\"clave\",\"cliente\",\"clima\",\"clinica\",\"cobre\",\"coccion\",\"cochino\",\"cocina\",\"coco\",\"codigo\",\"codo\",\"cofre\",\"coger\",\"cohete\",\"cojin\",\"cojo\",\"cola\",\"colcha\",\"colegio\",\"colgar\",\"colina\",\"collar\",\"colmo\",\"columna\",\"combate\",\"comer\",\"comida\",\"comodo\",\"compra\",\"conde\",\"conejo\",\"conga\",\"conocer\",\"consejo\",\"contar\",\"copa\",\"copia\",\"corazon\",\"corbata\",\"corcho\",\"cordon\",\"corona\",\"correr\",\"coser\",\"cosmos\",\"costa\",\"craneo\",\"crater\",\"crear\",\"crecer\",\"creido\",\"crema\",\"cria\",\"crimen\",\"cripta\",\"crisis\",\"cromo\",\"cronica\",\"croqueta\",\"crudo\",\"cruz\",\"cuadro\",\"cuarto\",\"cuatro\",\"cubo\",\"cubrir\",\"cuchara\",\"cuello\",\"cuento\",\"cuerda\",\"cuesta\",\"cueva\",\"cuidar\",\"culebra\",\"culpa\",\"culto\",\"cumbre\",\"cumplir\",\"cuna\",\"cuneta\",\"cuota\",\"cupon\",\"cupula\",\"curar\",\"curioso\",\"curso\",\"curva\",\"cutis\",\"dama\",\"danza\",\"dar\",\"dardo\",\"datil\",\"deber\",\"debil\",\"decada\",\"decir\",\"dedo\",\"defensa\",\"definir\",\"dejar\",\"delfin\",\"delgado\",\"delito\",\"demora\",\"denso\",\"dental\",\"deporte\",\"derecho\",\"derrota\",\"desayuno\",\"deseo\",\"desfile\",\"desnudo\",\"destino\",\"desvio\",\"detalle\",\"detener\",\"deuda\",\"dia\",\"diablo\",\"diadema\",\"diamante\",\"diana\",\"diario\",\"dibujo\",\"dictar\",\"diente\",\"dieta\",\"diez\",\"dificil\",\"digno\",\"dilema\",\"diluir\",\"dinero\",\"directo\",\"dirigir\",\"disco\",\"diseno\",\"disfraz\",\"diva\",\"divino\",\"doble\",\"doce\",\"dolor\",\"domingo\",\"don\",\"donar\",\"dorado\",\"dormir\",\"dorso\",\"dos\",\"dosis\",\"dragon\",\"droga\",\"ducha\",\"duda\",\"duelo\",\"dueno\",\"dulce\",\"duo\",\"duque\",\"durar\",\"dureza\",\"duro\",\"ebano\",\"ebrio\",\"echar\",\"eco\",\"ecuador\",\"edad\",\"edicion\",\"edificio\",\"editor\",\"educar\",\"efecto\",\"eficaz\",\"eje\",\"ejemplo\",\"elefante\",\"elegir\",\"elemento\",\"elevar\",\"elipse\",\"elite\",\"elixir\",\"elogio\",\"eludir\",\"embudo\",\"emitir\",\"emocion\",\"empate\",\"empeno\",\"empleo\",\"empresa\",\"enano\",\"encargo\",\"enchufe\",\"encia\",\"enemigo\",\"enero\",\"enfado\",\"enfermo\",\"engano\",\"enigma\",\"enlace\",\"enorme\",\"enredo\",\"ensayo\",\"ensenar\",\"entero\",\"entrar\",\"envase\",\"envio\",\"epoca\",\"equipo\",\"erizo\",\"escala\",\"escena\",\"escolar\",\"escribir\",\"escudo\",\"esencia\",\"esfera\",\"esfuerzo\",\"espada\",\"espejo\",\"espia\",\"esposa\",\"espuma\",\"esqui\",\"estar\",\"este\",\"estilo\",\"estufa\",\"etapa\",\"eterno\",\"etica\",\"etnia\",\"evadir\",\"evaluar\",\"evento\",\"evitar\",\"exacto\",\"examen\",\"exceso\",\"excusa\",\"exento\",\"exigir\",\"exilio\",\"existir\",\"exito\",\"experto\",\"explicar\",\"exponer\",\"extremo\",\"fabrica\",\"fabula\",\"fachada\",\"facil\",\"factor\",\"faena\",\"faja\",\"falda\",\"fallo\",\"falso\",\"faltar\",\"fama\",\"familia\",\"famoso\",\"faraon\",\"farmacia\",\"farol\",\"farsa\",\"fase\",\"fatiga\",\"fauna\",\"favor\",\"fax\",\"febrero\",\"fecha\",\"feliz\",\"feo\",\"feria\",\"feroz\",\"fertil\",\"fervor\",\"festin\",\"fiable\",\"fianza\",\"fiar\",\"fibra\",\"ficcion\",\"ficha\",\"fideo\",\"fiebre\",\"fiel\",\"fiera\",\"fiesta\",\"figura\",\"fijar\",\"fijo\",\"fila\",\"filete\",\"filial\",\"filtro\",\"fin\",\"finca\",\"fingir\",\"finito\",\"firma\",\"flaco\",\"flauta\",\"flecha\",\"flor\",\"flota\",\"fluir\",\"flujo\",\"fluor\",\"fobia\",\"foca\",\"fogata\",\"fogon\",\"folio\",\"folleto\",\"fondo\",\"forma\",\"forro\",\"fortuna\",\"forzar\",\"fosa\",\"foto\",\"fracaso\",\"fragil\",\"franja\",\"frase\",\"fraude\",\"freir\",\"freno\",\"fresa\",\"frio\",\"frito\",\"fruta\",\"fuego\",\"fuente\",\"fuerza\",\"fuga\",\"fumar\",\"funcion\",\"funda\",\"furgon\",\"furia\",\"fusil\",\"futbol\",\"futuro\",\"gacela\",\"gafas\",\"gaita\",\"gajo\",\"gala\",\"galeria\",\"gallo\",\"gamba\",\"ganar\",\"gancho\",\"ganga\",\"ganso\",\"garaje\",\"garza\",\"gasolina\",\"gastar\",\"gato\",\"gavilan\",\"gemelo\",\"gemir\",\"gen\",\"genero\",\"genio\",\"gente\",\"geranio\",\"gerente\",\"germen\",\"gesto\",\"gigante\",\"gimnasio\",\"girar\",\"giro\",\"glaciar\",\"globo\",\"gloria\",\"gol\",\"golfo\",\"goloso\",\"golpe\",\"goma\",\"gordo\",\"gorila\",\"gorra\",\"gota\",\"goteo\",\"gozar\",\"grada\",\"grafico\",\"grano\",\"grasa\",\"gratis\",\"grave\",\"grieta\",\"grillo\",\"gripe\",\"gris\",\"grito\",\"grosor\",\"grua\",\"grueso\",\"grumo\",\"grupo\",\"guante\",\"guapo\",\"guardia\",\"guerra\",\"guia\",\"guino\",\"guion\",\"guiso\",\"guitarra\",\"gusano\",\"gustar\",\"haber\",\"habil\",\"hablar\",\"hacer\",\"hacha\",\"hada\",\"hallar\",\"hamaca\",\"harina\",\"haz\",\"hazana\",\"hebilla\",\"hebra\",\"hecho\",\"helado\",\"helio\",\"hembra\",\"herir\",\"hermano\",\"heroe\",\"hervir\",\"hielo\",\"hierro\",\"higado\",\"higiene\",\"hijo\",\"himno\",\"historia\",\"hocico\",\"hogar\",\"hoguera\",\"hoja\",\"hombre\",\"hongo\",\"honor\",\"honra\",\"hora\",\"hormiga\",\"horno\",\"hostil\",\"hoyo\",\"hueco\",\"huelga\",\"huerta\",\"hueso\",\"huevo\",\"huida\",\"huir\",\"humano\",\"humedo\",\"humilde\",\"humo\",\"hundir\",\"huracan\",\"hurto\",\"icono\",\"ideal\",\"idioma\",\"idolo\",\"iglesia\",\"iglu\",\"igual\",\"ilegal\",\"ilusion\",\"imagen\",\"iman\",\"imitar\",\"impar\",\"imperio\",\"imponer\",\"impulso\",\"incapaz\",\"indice\",\"inerte\",\"infiel\",\"informe\",\"ingenio\",\"inicio\",\"inmenso\",\"inmune\",\"innato\",\"insecto\",\"instante\",\"interes\",\"intimo\",\"intuir\",\"inutil\",\"invierno\",\"ira\",\"iris\",\"ironia\",\"isla\",\"islote\",\"jabali\",\"jabon\",\"jamon\",\"jarabe\",\"jardin\",\"jarra\",\"jaula\",\"jazmin\",\"jefe\",\"jeringa\",\"jinete\",\"jornada\",\"joroba\",\"joven\",\"joya\",\"juerga\",\"jueves\",\"juez\",\"jugador\",\"jugo\",\"juguete\",\"juicio\",\"junco\",\"jungla\",\"junio\",\"juntar\",\"jupiter\",\"jurar\",\"justo\",\"juvenil\",\"juzgar\",\"kilo\",\"koala\",\"labio\",\"lacio\",\"lacra\",\"lado\",\"ladron\",\"lagarto\",\"lagrima\",\"laguna\",\"laico\",\"lamer\",\"lamina\",\"lampara\",\"lana\",\"lancha\",\"langosta\",\"lanza\",\"lapiz\",\"largo\",\"larva\",\"lastima\",\"lata\",\"latex\",\"latir\",\"laurel\",\"lavar\",\"lazo\",\"leal\",\"leccion\",\"leche\",\"lector\",\"leer\",\"legion\",\"legumbre\",\"lejano\",\"lengua\",\"lento\",\"lena\",\"leon\",\"leopardo\",\"lesion\",\"letal\",\"letra\",\"leve\",\"leyenda\",\"libertad\",\"libro\",\"licor\",\"lider\",\"lidiar\",\"lienzo\",\"liga\",\"ligero\",\"lima\",\"limite\",\"limon\",\"limpio\",\"lince\",\"lindo\",\"linea\",\"lingote\",\"lino\",\"linterna\",\"liquido\",\"liso\",\"lista\",\"litera\",\"litio\",\"litro\",\"llaga\",\"llama\",\"llanto\",\"llave\",\"llegar\",\"llenar\",\"llevar\",\"llorar\",\"llover\",\"lluvia\",\"lobo\",\"locion\",\"loco\",\"locura\",\"logica\",\"logro\",\"lombriz\",\"lomo\",\"lonja\",\"lote\",\"lucha\",\"lucir\",\"lugar\",\"lujo\",\"luna\",\"lunes\",\"lupa\",\"lustro\",\"luto\",\"luz\",\"maceta\",\"macho\",\"madera\",\"madre\",\"maduro\",\"maestro\",\"mafia\",\"magia\",\"mago\",\"maiz\",\"maldad\",\"maleta\",\"malla\",\"malo\",\"mama\",\"mambo\",\"mamut\",\"manco\",\"mando\",\"manejar\",\"manga\",\"maniqui\",\"manjar\",\"mano\",\"manso\",\"manta\",\"manana\",\"mapa\",\"maquina\",\"mar\",\"marco\",\"marea\",\"marfil\",\"margen\",\"marido\",\"marmol\",\"marron\",\"martes\",\"marzo\",\"masa\",\"mascara\",\"masivo\",\"matar\",\"materia\",\"matiz\",\"matriz\",\"maximo\",\"mayor\",\"mazorca\",\"mecha\",\"medalla\",\"medio\",\"medula\",\"mejilla\",\"mejor\",\"melena\",\"melon\",\"memoria\",\"menor\",\"mensaje\",\"mente\",\"menu\",\"mercado\",\"merengue\",\"merito\",\"mes\",\"meson\",\"meta\",\"meter\",\"metodo\",\"metro\",\"mezcla\",\"miedo\",\"miel\",\"miembro\",\"miga\",\"mil\",\"milagro\",\"militar\",\"millon\",\"mimo\",\"mina\",\"minero\",\"minimo\",\"minuto\",\"miope\",\"mirar\",\"misa\",\"miseria\",\"misil\",\"mismo\",\"mitad\",\"mito\",\"mochila\",\"mocion\",\"moda\",\"modelo\",\"moho\",\"mojar\",\"molde\",\"moler\",\"molino\",\"momento\",\"momia\",\"monarca\",\"moneda\",\"monja\",\"monto\",\"mono\",\"morada\",\"morder\",\"moreno\",\"morir\",\"morro\",\"morsa\",\"mortal\",\"mosca\",\"mostrar\",\"motivo\",\"mover\",\"movil\",\"mozo\",\"mucho\",\"mudar\",\"mueble\",\"muela\",\"muerte\",\"muestra\",\"mugre\",\"mujer\",\"mula\",\"muleta\",\"multa\",\"mundo\",\"muneca\",\"mural\",\"muro\",\"musculo\",\"museo\",\"musgo\",\"musica\",\"muslo\",\"nacar\",\"nacion\",\"nadar\",\"naipe\",\"naranja\",\"nariz\",\"narrar\",\"nasal\",\"natal\",\"nativo\",\"natural\",\"nausea\",\"naval\",\"nave\",\"navidad\",\"necio\",\"nectar\",\"negar\",\"negocio\",\"negro\",\"neon\",\"nervio\",\"neto\",\"neutro\",\"nevar\",\"nevera\",\"nicho\",\"nido\",\"niebla\",\"nieto\",\"ninez\",\"nino\",\"nitido\",\"nivel\",\"nobleza\",\"noche\",\"nomina\",\"noria\",\"norma\",\"norte\",\"nota\",\"noticia\",\"novato\",\"novela\",\"novio\",\"nube\",\"nuca\",\"nucleo\",\"nudillo\",\"nudo\",\"nuera\",\"nueve\",\"nuez\",\"nulo\",\"numero\",\"nutria\",\"oasis\",\"obeso\",\"obispo\",\"objeto\",\"obra\",\"obrero\",\"observar\",\"obtener\",\"obvio\",\"oca\",\"ocaso\",\"oceano\",\"ochenta\",\"ocho\",\"ocio\",\"ocre\",\"octavo\",\"octubre\",\"oculto\",\"ocupar\",\"ocurrir\",\"odiar\",\"odio\",\"odisea\",\"oeste\",\"ofensa\",\"oferta\",\"oficio\",\"ofrecer\",\"ogro\",\"oido\",\"oir\",\"ojo\",\"ola\",\"oleada\",\"olfato\",\"olivo\",\"olla\",\"olmo\",\"olor\",\"olvido\",\"ombligo\",\"onda\",\"onza\",\"opaco\",\"opcion\",\"opera\",\"opinar\",\"oponer\",\"optar\",\"optica\",\"opuesto\",\"oracion\",\"orador\",\"oral\",\"orbita\",\"orca\",\"orden\",\"oreja\",\"organo\",\"orgia\",\"orgullo\",\"oriente\",\"origen\",\"orilla\",\"oro\",\"orquesta\",\"oruga\",\"osadia\",\"oscuro\",\"osezno\",\"oso\",\"ostra\",\"otono\",\"otro\",\"oveja\",\"ovulo\",\"oxido\",\"oxigeno\",\"oyente\",\"ozono\",\"pacto\",\"padre\",\"paella\",\"pagina\",\"pago\",\"pais\",\"pajaro\",\"palabra\",\"palco\",\"paleta\",\"palido\",\"palma\",\"paloma\",\"palpar\",\"pan\",\"panal\",\"panico\",\"pantera\",\"panuelo\",\"papa\",\"papel\",\"papilla\",\"paquete\",\"parar\",\"parcela\",\"pared\",\"parir\",\"paro\",\"parpado\",\"parque\",\"parrafo\",\"parte\",\"pasar\",\"paseo\",\"pasion\",\"paso\",\"pasta\",\"pata\",\"patio\",\"patria\",\"pausa\",\"pauta\",\"pavo\",\"payaso\",\"peaton\",\"pecado\",\"pecera\",\"pecho\",\"pedal\",\"pedir\",\"pegar\",\"peine\",\"pelar\",\"peldano\",\"pelea\",\"peligro\",\"pellejo\",\"pelo\",\"peluca\",\"pena\",\"pensar\",\"penon\",\"peon\",\"peor\",\"pepino\",\"pequeno\",\"pera\",\"percha\",\"perder\",\"pereza\",\"perfil\",\"perico\",\"perla\",\"permiso\",\"perro\",\"persona\",\"pesa\",\"pesca\",\"pesimo\",\"pestana\",\"petalo\",\"petroleo\",\"pez\",\"pezuna\",\"picar\",\"pichon\",\"pie\",\"piedra\",\"pierna\",\"pieza\",\"pijama\",\"pilar\",\"piloto\",\"pimienta\",\"pino\",\"pintor\",\"pinza\",\"pina\",\"piojo\",\"pipa\",\"pirata\",\"pisar\",\"piscina\",\"piso\",\"pista\",\"piton\",\"pizca\",\"placa\",\"plan\",\"plata\",\"playa\",\"plaza\",\"pleito\",\"pleno\",\"plomo\",\"pluma\",\"plural\",\"pobre\",\"poco\",\"poder\",\"podio\",\"poema\",\"poesia\",\"poeta\",\"polen\",\"policia\",\"pollo\",\"polvo\",\"pomada\",\"pomelo\",\"pomo\",\"pompa\",\"poner\",\"porcion\",\"portal\",\"posada\",\"poseer\",\"posible\",\"poste\",\"potencia\",\"potro\",\"pozo\",\"prado\",\"precoz\",\"pregunta\",\"premio\",\"prensa\",\"preso\",\"previo\",\"primo\",\"principe\",\"prision\",\"privar\",\"proa\",\"probar\",\"proceso\",\"producto\",\"proeza\",\"profesor\",\"programa\",\"prole\",\"promesa\",\"pronto\",\"propio\",\"proximo\",\"prueba\",\"publico\",\"puchero\",\"pudor\",\"pueblo\",\"puerta\",\"puesto\",\"pulga\",\"pulir\",\"pulmon\",\"pulpo\",\"pulso\",\"puma\",\"punto\",\"punal\",\"puno\",\"pupa\",\"pupila\",\"pure\",\"quedar\",\"queja\",\"quemar\",\"querer\",\"queso\",\"quieto\",\"quimica\",\"quince\",\"quitar\",\"rabano\",\"rabia\",\"rabo\",\"racion\",\"radical\",\"raiz\",\"rama\",\"rampa\",\"rancho\",\"rango\",\"rapaz\",\"rapido\",\"rapto\",\"rasgo\",\"raspa\",\"rato\",\"rayo\",\"raza\",\"razon\",\"reaccion\",\"realidad\",\"rebano\",\"rebote\",\"recaer\",\"receta\",\"rechazo\",\"recoger\",\"recreo\",\"recto\",\"recurso\",\"red\",\"redondo\",\"reducir\",\"reflejo\",\"reforma\",\"refran\",\"refugio\",\"regalo\",\"regir\",\"regla\",\"regreso\",\"rehen\",\"reino\",\"reir\",\"reja\",\"relato\",\"relevo\",\"relieve\",\"relleno\",\"reloj\",\"remar\",\"remedio\",\"remo\",\"rencor\",\"rendir\",\"renta\",\"reparto\",\"repetir\",\"reposo\",\"reptil\",\"res\",\"rescate\",\"resina\",\"respeto\",\"resto\",\"resumen\",\"retiro\",\"retorno\",\"retrato\",\"reunir\",\"reves\",\"revista\",\"rey\",\"rezar\",\"rico\",\"riego\",\"rienda\",\"riesgo\",\"rifa\",\"rigido\",\"rigor\",\"rincon\",\"rinon\",\"rio\",\"riqueza\",\"risa\",\"ritmo\",\"rito\",\"rizo\",\"roble\",\"roce\",\"rociar\",\"rodar\",\"rodeo\",\"rodilla\",\"roer\",\"rojizo\",\"rojo\",\"romero\",\"romper\",\"ron\",\"ronco\",\"ronda\",\"ropa\",\"ropero\",\"rosa\",\"rosca\",\"rostro\",\"rotar\",\"rubi\",\"rubor\",\"rudo\",\"rueda\",\"rugir\",\"ruido\",\"ruina\",\"ruleta\",\"rulo\",\"rumbo\",\"rumor\",\"ruptura\",\"ruta\",\"rutina\",\"sabado\",\"saber\",\"sabio\",\"sable\",\"sacar\",\"sagaz\",\"sagrado\",\"sala\",\"saldo\",\"salero\",\"salir\",\"salmon\",\"salon\",\"salsa\",\"salto\",\"salud\",\"salvar\",\"samba\",\"sancion\",\"sandia\",\"sanear\",\"sangre\",\"sanidad\",\"sano\",\"santo\",\"sapo\",\"saque\",\"sardina\",\"sarten\",\"sastre\",\"satan\",\"sauna\",\"saxofon\",\"seccion\",\"seco\",\"secreto\",\"secta\",\"sed\",\"seguir\",\"seis\",\"sello\",\"selva\",\"semana\",\"semilla\",\"senda\",\"sensor\",\"senal\",\"senor\",\"separar\",\"sepia\",\"sequia\",\"ser\",\"serie\",\"sermon\",\"servir\",\"sesenta\",\"sesion\",\"seta\",\"setenta\",\"severo\",\"sexo\",\"sexto\",\"sidra\",\"siesta\",\"siete\",\"siglo\",\"signo\",\"silaba\",\"silbar\",\"silencio\",\"silla\",\"simbolo\",\"simio\",\"sirena\",\"sistema\",\"sitio\",\"situar\",\"sobre\",\"socio\",\"sodio\",\"sol\",\"solapa\",\"soldado\",\"soledad\",\"solido\",\"soltar\",\"solucion\",\"sombra\",\"sondeo\",\"sonido\",\"sonoro\",\"sonrisa\",\"sopa\",\"soplar\",\"soporte\",\"sordo\",\"sorpresa\",\"sorteo\",\"sosten\",\"sotano\",\"suave\",\"subir\",\"suceso\",\"sudor\",\"suegra\",\"suelo\",\"sueno\",\"suerte\",\"sufrir\",\"sujeto\",\"sultan\",\"sumar\",\"superar\",\"suplir\",\"suponer\",\"supremo\",\"sur\",\"surco\",\"sureno\",\"surgir\",\"susto\",\"sutil\",\"tabaco\",\"tabique\",\"tabla\",\"tabu\",\"taco\",\"tacto\",\"tajo\",\"talar\",\"talco\",\"talento\",\"talla\",\"talon\",\"tamano\",\"tambor\",\"tango\",\"tanque\",\"tapa\",\"tapete\",\"tapia\",\"tapon\",\"taquilla\",\"tarde\",\"tarea\",\"tarifa\",\"tarjeta\",\"tarot\",\"tarro\",\"tarta\",\"tatuaje\",\"tauro\",\"taza\",\"tazon\",\"teatro\",\"techo\",\"tecla\",\"tecnica\",\"tejado\",\"tejer\",\"tejido\",\"tela\",\"telefono\",\"tema\",\"temor\",\"templo\",\"tenaz\",\"tender\",\"tener\",\"tenis\",\"tenso\",\"teoria\",\"terapia\",\"terco\",\"termino\",\"ternura\",\"terror\",\"tesis\",\"tesoro\",\"testigo\",\"tetera\",\"texto\",\"tez\",\"tibio\",\"tiburon\",\"tiempo\",\"tienda\",\"tierra\",\"tieso\",\"tigre\",\"tijera\",\"tilde\",\"timbre\",\"timido\",\"timo\",\"tinta\",\"tio\",\"tipico\",\"tipo\",\"tira\",\"tiron\",\"titan\",\"titere\",\"titulo\",\"tiza\",\"toalla\",\"tobillo\",\"tocar\",\"tocino\",\"todo\",\"toga\",\"toldo\",\"tomar\",\"tono\",\"tonto\",\"topar\",\"tope\",\"toque\",\"torax\",\"torero\",\"tormenta\",\"torneo\",\"toro\",\"torpedo\",\"torre\",\"torso\",\"tortuga\",\"tos\",\"tosco\",\"toser\",\"toxico\",\"trabajo\",\"tractor\",\"traer\",\"trafico\",\"trago\",\"traje\",\"tramo\",\"trance\",\"trato\",\"trauma\",\"trazar\",\"trebol\",\"tregua\",\"treinta\",\"tren\",\"trepar\",\"tres\",\"tribu\",\"trigo\",\"tripa\",\"triste\",\"triunfo\",\"trofeo\",\"trompa\",\"tronco\",\"tropa\",\"trote\",\"trozo\",\"truco\",\"trueno\",\"trufa\",\"tuberia\",\"tubo\",\"tuerto\",\"tumba\",\"tumor\",\"tunel\",\"tunica\",\"turbina\",\"turismo\",\"turno\",\"tutor\",\"ubicar\",\"ulcera\",\"umbral\",\"unidad\",\"unir\",\"universo\",\"uno\",\"untar\",\"una\",\"urbano\",\"urbe\",\"urgente\",\"urna\",\"usar\",\"usuario\",\"util\",\"utopia\",\"uva\",\"vaca\",\"vacio\",\"vacuna\",\"vagar\",\"vago\",\"vaina\",\"vajilla\",\"vale\",\"valido\",\"valle\",\"valor\",\"valvula\",\"vampiro\",\"vara\",\"variar\",\"varon\",\"vaso\",\"vecino\",\"vector\",\"vehiculo\",\"veinte\",\"vejez\",\"vela\",\"velero\",\"veloz\",\"vena\",\"vencer\",\"venda\",\"veneno\",\"vengar\",\"venir\",\"venta\",\"venus\",\"ver\",\"verano\",\"verbo\",\"verde\",\"vereda\",\"verja\",\"verso\",\"verter\",\"via\",\"viaje\",\"vibrar\",\"vicio\",\"victima\",\"vida\",\"video\",\"vidrio\",\"viejo\",\"viernes\",\"vigor\",\"vil\",\"villa\",\"vinagre\",\"vino\",\"vinedo\",\"violin\",\"viral\",\"virgo\",\"virtud\",\"visor\",\"vispera\",\"vista\",\"vitamina\",\"viudo\",\"vivaz\",\"vivero\",\"vivir\",\"vivo\",\"volcan\",\"volumen\",\"volver\",\"voraz\",\"votar\",\"voto\",\"voz\",\"vuelo\",\"vulgar\",\"yacer\",\"yate\",\"yegua\",\"yema\",\"yerno\",\"yeso\",\"yodo\",\"yoga\",\"yogur\",\"zafiro\",\"zanja\",\"zapato\",\"zarza\",\"zona\",\"zorro\",\"zumo\",\"zurdo\"][\"abajur\",\"abaks\",\"abart\",\"abdal\",\"abdest\",\"abiye\",\"abluka\",\"abone\",\"absorbe\",\"absrt\",\"acayip\",\"acele\",\"acemi\",\"akgz\",\"adalet\",\"adam\",\"adezyon\",\"adisyon\",\"adliye\",\"adres\",\"afacan\",\"afili\",\"afi\",\"afiyet\",\"aforizm\",\"afra\",\"aa\",\"ar\",\"ahbap\",\"ahkam\",\"ahlak\",\"ahtapot\",\"aidat\",\"aile\",\"ajan\",\"akademi\",\"akarsu\",\"akba\",\"akcier\",\"akdeniz\",\"akbet\",\"akl\",\"aknt\",\"akide\",\"akrep\",\"akrobasi\",\"aksiyon\",\"akam\",\"aktif\",\"aktr\",\"aktris\",\"akustik\",\"alaca\",\"albm\",\"alak\",\"aldanma\",\"aleni\",\"alet\",\"alfabe\",\"alglama\",\"alngan\",\"alk\",\"alkol\",\"alpay\",\"alperen\",\"altn\",\"altst\",\"altyap\",\"alyuvar\",\"amade\",\"amatr\",\"amazon\",\"ambalaj\",\"amblem\",\"ambulans\",\"amca\",\"amel\",\"amigo\",\"amir\",\"amiyane\",\"amorti\",\"ampul\",\"anadolu\",\"anahtar\",\"anakonda\",\"anaokul\",\"anapara\",\"anari\",\"anatomi\",\"anayasa\",\"anekdot\",\"anestezi\",\"angaje\",\"anka\",\"anket\",\"anlaml\",\"anne\",\"anomali\",\"anonim\",\"anten\",\"antlama\",\"apse\",\"araba\",\"arac\",\"araf\",\"arbede\",\"arda\",\"arefe\",\"arena\",\"argo\",\"argman\",\"arkada\",\"armoni\",\"aroma\",\"arsa\",\"arsz\",\"art\",\"artist\",\"aruz\",\"asansr\",\"asayi\",\"asfalt\",\"asgari\",\"asil\",\"asker\",\"ask\",\"aslan\",\"asosyal\",\"astsubay\",\"asya\",\"a\",\"ar\",\"aure\",\"atabey\",\"ataman\",\"ate\",\"atmaca\",\"atmosfer\",\"atom\",\"atlye\",\"avc\",\"avdet\",\"avize\",\"avlu\",\"avokado\",\"avrupa\",\"avukat\",\"ayaz\",\"ayiei\",\"aydn\",\"aygt\",\"ayna\",\"ayran\",\"ayrnt\",\"azim\",\"baca\",\"bagaj\",\"balant\",\"bahadr\",\"bahe\",\"baki\",\"bakkal\",\"baklava\",\"bakteri\",\"balk\",\"balina\",\"balo\",\"balta\",\"bant\",\"banyo\",\"bardak\",\"bar\",\"babu\",\"babo\",\"bakan\",\"balk\",\"bavul\",\"bayndr\",\"bayku\",\"bazlama\",\"bedel\",\"begm\",\"beki\",\"bekle\",\"belge\",\"belki\",\"bencil\",\"benek\",\"bengi\",\"benzer\",\"berjer\",\"berk\",\"bermuda\",\"berrak\",\"beik\",\"beton\",\"beyin\",\"beyolu\",\"bak\",\"biberiye\",\"bidon\",\"biftek\",\"bihaber\",\"bikini\",\"bilezik\",\"bilin\",\"bilye\",\"bina\",\"binba\",\"binyl\",\"bisiklet\",\"biskvi\",\"bitki\",\"bizzat\",\"bodrum\",\"boaz\",\"boha\",\"bolero\",\"boncuk\",\"bonfile\",\"borsa\",\"boru\",\"bostan\",\"boboaz\",\"botanik\",\"boya\",\"boykot\",\"boynuz\",\"bozgun\",\"bozkr\",\"blm\",\"brek\",\"buuk\",\"bugn\",\"buday\",\"buhar\",\"buhran\",\"bulvar\",\"buram\",\"burak\",\"burs\",\"burun\",\"butik\",\"buzda\",\"buzkran\",\"bcr\",\"bfe\",\"blten\",\"bte\",\"btn\",\"byk\",\"cack\",\"cad\",\"cahil\",\"cambaz\",\"canhra\",\"casus\",\"cazibe\",\"cehalet\",\"cehennem\",\"ceket\",\"cemre\",\"cenin\",\"cennet\",\"cepken\",\"cerrah\",\"cesur\",\"cetvel\",\"cevher\",\"ceylan\",\"clz\",\"cva\",\"cilt\",\"cisim\",\"ciyak\",\"corafya\",\"cmert\",\"cumba\",\"czdan\",\"abucak\",\"adr\",\"ada\",\"alayan\",\"ar\",\"akmak\",\"alkan\",\"amar\",\"apa\",\"aput\",\"ark\",\"arpan\",\"araf\",\"ayhane\",\"ekirdek\",\"elebi\",\"ember\",\"enet\",\"engel\",\"ereve\",\"erez\",\"eit\",\"eme\",\"ete\",\"evre\",\"eyiz\",\"eyrek\",\"r\",\"lgn\",\"ngrak\",\"ift\",\"idem\",\"ikolata\",\"ilek\",\"imen\",\"ivi\",\"oban\",\"ocuk\",\"okgen\",\"omak\",\"orba\",\"zelti\",\"ubuk\",\"ukur\",\"uval\",\"rk\",\"daba\",\"dalm\",\"daktilo\",\"daldr\",\"dalga\",\"dalkavuk\",\"damak\",\"damtma\",\"damla\",\"dana\",\"dandik\",\"danman\",\"daniska\",\"dantel\",\"dargeit\",\"darphane\",\"davet\",\"day\",\"defter\",\"deer\",\"deirmen\",\"dehet\",\"delge\",\"demir\",\"deneyim\",\"denge\",\"depo\",\"deprem\",\"derdest\",\"dere\",\"derhal\",\"derman\",\"dernek\",\"dervi\",\"desen\",\"destan\",\"dar\",\"dbkey\",\"dijital\",\"dikbal\",\"dileke\",\"dima\",\"dinamik\",\"dindar\",\"dinleme\",\"dinozor\",\"dipik\",\"dipnot\",\"direni\",\"dirsek\",\"disiplin\",\"disk\",\"divrii\",\"dizst\",\"dobra\",\"dodurga\",\"doalgaz\",\"doktor\",\"dokman\",\"dolap\",\"donanm\",\"dondurma\",\"donr\",\"doruk\",\"dosdoru\",\"dost\",\"dosya\",\"dozer\",\"dkm\",\"dnence\",\"drtyol\",\"dvme\",\"dram\",\"dublaj\",\"durum\",\"duvak\",\"duyarga\",\"duyma\",\"duyuru\",\"dme\",\"dm\",\"dkkan\",\"dnr\",\"dpedz\",\"drbn\",\"dnr\",\"dzayak\",\"dzeltme\",\"ebeveyn\",\"ebru\",\"ecel\",\"ecnebi\",\"ecza\",\"edat\",\"edilgen\",\"efendi\",\"efor\",\"efsane\",\"egemen\",\"egzersiz\",\"erelti\",\"ekarte\",\"ekip\",\"eklem\",\"ekmek\",\"ekol\",\"ekonomi\",\"ekose\",\"ekran\",\"ekvator\",\"elaman\",\"elastik\",\"elbet\",\"elbise\",\"eli\",\"eldiven\",\"eleba\",\"eletiri\",\"elma\",\"elolu\",\"elveda\",\"emare\",\"emeki\",\"emisyon\",\"emniyet\",\"empati\",\"emsal\",\"emzik\",\"endstri\",\"enerji\",\"engebe\",\"engin\",\"enite\",\"enkaz\",\"entari\",\"entegre\",\"entrika\",\"enzim\",\"erdem\",\"ergen\",\"erguvan\",\"erkek\",\"erozyon\",\"ertesi\",\"erzak\",\"esaret\",\"esenlik\",\"eser\",\"eski\",\"esnek\",\"earp\",\"eofman\",\"eraf\",\"eya\",\"ezaman\",\"etik\",\"etken\",\"etkinlik\",\"ett\",\"evet\",\"evire\",\"evrak\",\"evrim\",\"eyalet\",\"eyvah\",\"ezber\",\"fabrika\",\"fanatik\",\"fanus\",\"fason\",\"fasulye\",\"fatih\",\"fatura\",\"fauna\",\"favori\",\"fayans\",\"fayton\",\"fazl\",\"fazilet\",\"federal\",\"felsefe\",\"fener\",\"feribot\",\"fersah\",\"fesih\",\"festival\",\"feveran\",\"feza\",\"f\",\"fldr\",\"fndk\",\"fra\",\"frsat\",\"frtna\",\"ftk\",\"fidan\",\"fidye\",\"figr\",\"fihrist\",\"fikir\",\"fildii\",\"filo\",\"filtre\",\"fincan\",\"firuze\",\"fitil\",\"fiyaka\",\"fizik\",\"fla\",\"flt\",\"fosil\",\"fren\",\"fukara\",\"futbol\",\"garabet\",\"gariban\",\"garnitr\",\"gazi\",\"gece\",\"gedik\",\"gelenek\",\"gelin\",\"gemi\",\"gen\",\"geni\",\"geometri\",\"gerek\",\"gevrek\",\"gezegen\",\"gezgin\",\"geziyolu\",\"gck\",\"gda\",\"gybet\",\"girdap\",\"giriim\",\"gitar\",\"giyecek\",\"giysi\",\"gizem\",\"gofret\",\"goril\",\"gbek\",\"gebe\",\"gs\",\"gkdelen\",\"gkmen\",\"gkyz\",\"glge\",\"gmlek\",\"gnl\",\"grenek\",\"grkemli\",\"grsel\",\"gsteri\",\"gvde\",\"gzalt\",\"gzc\",\"gzda\",\"gzleme\",\"gzya\",\"grup\",\"gurbet\",\"gusl\",\"gbre\",\"gfte\",\"gm\",\"gnaydn\",\"gncel\",\"gndz\",\"gne\",\"gnyz\",\"grbz\",\"gvercin\",\"gzel\",\"haber\",\"hacamat\",\"hacim\",\"hademe\",\"hafz\",\"hafriyat\",\"hafta\",\"hakan\",\"hakem\",\"hakikat\",\"haksever\",\"hal\",\"haner\",\"hane\",\"hangar\",\"hapis\",\"haprk\",\"harf\",\"haseki\",\"hasret\",\"hatun\",\"havu\",\"haylaz\",\"haysiyet\",\"hayvan\",\"hedef\",\"hektar\",\"hemen\",\"hemfikir\",\"hendek\",\"hepsi\",\"hergele\",\"herhangi\",\"hesap\",\"heyecan\",\"heykel\",\"hezimet\",\"hkrk\",\"hzler\",\"hicviye\",\"hikaye\",\"hikmet\",\"hile\",\"hisse\",\"hobi\",\"hoca\",\"horlama\",\"hormon\",\"hobe\",\"hogr\",\"hoyrat\",\"hrg\",\"hyk\",\"hudut\",\"hukuk\",\"hunhar\",\"hurda\",\"huysuz\",\"huzur\",\"hcum\",\"hkmet\",\"hnkar\",\"hviyet\",\"rmak\",\"sler\",\"stc\",\"spanak\",\"srar\",\"ldak\",\"zdrap\",\"zgara\",\"ibadet\",\"icat\",\"ibkey\",\"iecek\",\"igd\",\"isel\",\"idman\",\"iftihar\",\"ine\",\"ihanet\",\"ihbar\",\"ihdas\",\"ihmal\",\"ihracat\",\"ihsan\",\"ikilem\",\"ikindi\",\"ikircik\",\"iklim\",\"iksir\",\"iktibas\",\"ila\",\"ile\",\"ileri\",\"iletiim\",\"ilgi\",\"ilhak\",\"ilkbahar\",\"ilkokul\",\"ilmek\",\"imkan\",\"imle\",\"imsak\",\"imtihan\",\"imza\",\"ince\",\"inkar\",\"ina\",\"ipek\",\"ipucu\",\"irade\",\"irfan\",\"irmik\",\"isabet\",\"iskele\",\"israf\",\"isyan\",\"ii\",\"igal\",\"igzar\",\"ilem\",\"itibar\",\"itiraf\",\"ivedi\",\"ivme\",\"iyileme\",\"iyimser\",\"izbandut\",\"izci\",\"izdiham\",\"izin\",\"jakoben\",\"jandarma\",\"jargon\",\"kabaday\",\"kablo\",\"kabus\",\"kaamak\",\"kadeh\",\"kadn\",\"kadraj\",\"kafa\",\"kafkas\",\"kat\",\"kan\",\"kahkaha\",\"kahraman\",\"kahvalt\",\"kakl\",\"kaldrm\",\"kale\",\"kalibre\",\"kalkan\",\"kalpak\",\"kam\",\"kamyon\",\"kanat\",\"kanda\",\"kanepe\",\"kanser\",\"kanun\",\"kaos\",\"kap\",\"kaplca\",\"kaptan\",\"karanlk\",\"karde\",\"karga\",\"karnca\",\"karmaa\",\"kart\",\"kasrga\",\"kask\",\"kasvet\",\"katk\",\"katman\",\"kavram\",\"kaygan\",\"kaynaka\",\"kayyum\",\"kedi\",\"kehanet\",\"kekik\",\"kelebek\",\"kenar\",\"kerkenez\",\"kerpi\",\"kesirli\",\"kesmece\",\"kestane\",\"kekek\",\"ketap\",\"keyfiyet\",\"kble\",\"kdemli\",\"klavuz\",\"klk\",\"klf\",\"kra\",\"krmz\",\"krsal\",\"ksayol\",\"ksm\",\"kskan\",\"ksmet\",\"kla\",\"kvan\",\"kvlcm\",\"kvrk\",\"kyafet\",\"kymetli\",\"kzak\",\"kzlck\",\"kibar\",\"kinaye\",\"kira\",\"kiremit\",\"kirli\",\"kirpik\",\"kiisel\",\"kitap\",\"koba\",\"kodaman\",\"kou\",\"kokteyl\",\"kolayc\",\"kolbast\",\"kolonya\",\"koltuk\",\"kolye\",\"kombine\",\"komedyen\",\"komiser\",\"komposto\",\"komu\",\"komuta\",\"konak\",\"konfor\",\"koni\",\"konsl\",\"kopya\",\"korkusuz\",\"korna\",\"korse\",\"korunak\",\"korvet\",\"kostm\",\"koul\",\"koyu\",\"kozmik\",\"kfte\",\"kkensel\",\"kprck\",\"kpk\",\"krdm\",\"krfez\",\"kstebek\",\"kegen\",\"kt\",\"kravat\",\"kriter\",\"kuantum\",\"kudurma\",\"kuluka\",\"kulbe\",\"kumanya\",\"kumbara\",\"kumlu\",\"kumpir\",\"kumral\",\"kundura\",\"kupa\",\"kupkuru\",\"kuramsal\",\"kurbaa\",\"kurdele\",\"kurgu\",\"kurmay\",\"kurun\",\"kurtulu\",\"kurultay\",\"kurye\",\"kusursuz\",\"kuak\",\"kuba\",\"kukulu\",\"kutlama\",\"kutsal\",\"kutup\",\"kuver\",\"kuyruk\",\"kuzey\",\"kuzgun\",\"kk\",\"kle\",\"klfet\",\"klliye\",\"kltrel\",\"kmes\",\"knefe\",\"kresel\",\"ktle\",\"lahana\",\"lahmacun\",\"lamba\",\"lansman\",\"lava\",\"layk\",\"leen\",\"levent\",\"leziz\",\"lezzet\",\"lider\",\"likide\",\"liman\",\"liste\",\"litre\",\"liyakat\",\"lodos\",\"lokanta\",\"lokman\",\"lokum\",\"lunapark\",\"ltfen\",\"lzum\",\"nokta\",\"mabet\",\"macera\",\"macun\",\"madalya\",\"madde\",\"madem\",\"maara\",\"madur\",\"mafiret\",\"malup\",\"mahalle\",\"mahcup\",\"mahir\",\"mahkeme\",\"mahlas\",\"mahrum\",\"mahsul\",\"makas\",\"makbuz\",\"makine\",\"makro\",\"maksat\",\"makul\",\"maliye\",\"manav\",\"mangal\",\"manidar\",\"manken\",\"mantk\",\"manzara\",\"mareal\",\"margarin\",\"marifet\",\"market\",\"marmelat\",\"masast\",\"masmavi\",\"masraf\",\"masum\",\"matah\",\"materyal\",\"matrak\",\"maval\",\"mavra\",\"maydanoz\",\"mayho\",\"maytap\",\"mazbata\",\"mazeret\",\"mazlum\",\"mazot\",\"mazur\",\"mebla\",\"mebus\",\"mecaz\",\"mecbur\",\"meclis\",\"mecmua\",\"mecnun\",\"mehul\",\"medeni\",\"mehtap\",\"mekanik\",\"melodi\",\"meltem\",\"memur\",\"mendil\",\"meneke\",\"mentee\",\"merakl\",\"mercek\",\"merdiven\",\"merhaba\",\"merinos\",\"merkez\",\"mermi\",\"mert\",\"mesafe\",\"mesele\",\"mesken\",\"meslek\",\"meale\",\"megul\",\"mehur\",\"metafor\",\"metin\",\"metre\",\"mevcut\",\"mevkida\",\"meydan\",\"meyil\",\"meyve\",\"meziyet\",\"mezun\",\"mknats\",\"msra\",\"mzka\",\"mifer\",\"mihrak\",\"mikrofon\",\"miktar\",\"milat\",\"milli\",\"mimar\",\"minare\",\"mineral\",\"minik\",\"minyon\",\"mirliva\",\"misafir\",\"miskin\",\"miting\",\"miyop\",\"mizah\",\"mobilya\",\"model\",\"monitr\",\"mortesi\",\"motive\",\"motor\",\"mozaik\",\"muavin\",\"mucize\",\"muhafz\",\"muhteem\",\"mukayese\",\"mumya\",\"musluk\",\"muamba\",\"mutabk\",\"mutfak\",\"mutlu\",\"muzaffer\",\"muzdarip\",\"mbarek\",\"mcadele\",\"mdr\",\"mfredat\",\"mft\",\"mhendis\",\"mhim\",\"mhlet\",\"mkemmel\",\"mlk\",\"mmkn\",\"mmtaz\",\"msrif\",\"mstesna\",\"mahit\",\"mteri\",\"mtercim\",\"mthi\",\"mze\",\"mzik\",\"nabz\",\"nadas\",\"nadir\",\"naho\",\"nakarat\",\"nak\",\"nalbur\",\"namlu\",\"namus\",\"nankr\",\"nargile\",\"narkoz\",\"nasl\",\"nasip\",\"naylon\",\"nazar\",\"nazm\",\"nazik\",\"neden\",\"nefes\",\"negatif\",\"neon\",\"neptn\",\"nerede\",\"nesil\",\"nesnel\",\"neeli\",\"netice\",\"nevresim\",\"neyse\",\"neyzen\",\"nezaket\",\"nezih\",\"nezle\",\"nicel\",\"nilfer\",\"nimet\",\"nisan\",\"nispet\",\"nitekim\",\"nizam\",\"nohut\",\"noksan\",\"normal\",\"nostalji\",\"noter\",\"nbet\",\"numara\",\"numune\",\"nutuk\",\"nfus\",\"obaba\",\"obez\",\"obje\",\"ocak\",\"odun\",\"ofansif\",\"ofis\",\"olak\",\"ouz\",\"oku\",\"oklava\",\"oksijen\",\"okul\",\"okumu\",\"okutman\",\"okuyucu\",\"okyanus\",\"olaan\",\"olanak\",\"olas\",\"olay\",\"olgun\",\"olimpik\",\"olumlu\",\"omlet\",\"omurga\",\"onarm\",\"onursal\",\"opera\",\"optik\",\"oral\",\"orant\",\"ordu\",\"organik\",\"orijin\",\"orkide\",\"orman\",\"orta\",\"oru\",\"ota\",\"otantik\",\"otel\",\"otoban\",\"otogar\",\"otomobil\",\"otonom\",\"otopark\",\"otorite\",\"otoyol\",\"oturum\",\"oyuk\",\"oyuncak\",\"ozan\",\"deme\",\"denek\",\"dev\",\"dl\",\"dn\",\"fke\",\"len\",\"renci\",\"n\",\"tc\",\"ksrk\",\"lme\",\"l\",\"lmsz\",\"mr\",\"nayak\",\"nc\",\"nder\",\"nem\",\"nerge\",\"ngr\",\"nlk\",\"nsezi\",\"pck\",\"rdek\",\"rg\",\"rtbas\",\"rtme\",\"rt\",\"rmcek\",\"rnt\",\"teberi\",\"teki\",\"vn\",\"yk\",\"yleyse\",\"zekim\",\"zdeyi\",\"zel\",\"zenti\",\"zerk\",\"zgrlk\",\"zlem\",\"zl\",\"zne\",\"zsever\",\"zmseme\",\"zr\",\"zveri\",\"pabu\",\"padiah\",\"palamut\",\"palmiye\",\"palto\",\"palyao\",\"pamuk\",\"panayr\",\"pancar\",\"panda\",\"panel\",\"panik\",\"panjur\",\"pankart\",\"pano\",\"pansuman\",\"pantolon\",\"panzehir\",\"papatya\",\"papyon\",\"parat\",\"para\",\"pards\",\"parfm\",\"parlt\",\"parkur\",\"parmak\",\"parodi\",\"parsel\",\"partner\",\"pasaport\",\"pasif\",\"paskalya\",\"pastrma\",\"paa\",\"patates\",\"paten\",\"patika\",\"patlcan\",\"patolog\",\"patron\",\"payanda\",\"payda\",\"payidar\",\"paylama\",\"paytak\",\"peete\",\"pedal\",\"peder\",\"pehlivan\",\"pekala\",\"pekmez\",\"pelerin\",\"pelikan\",\"pel\",\"pembe\",\"pena\",\"pencere\",\"pense\",\"perin\",\"perde\",\"pergel\",\"perian\",\"peron\",\"personel\",\"perembe\",\"peruk\",\"pervane\",\"pespaye\",\"pestil\",\"pein\",\"petek\",\"petrol\",\"petunya\",\"peynir\",\"peyzaj\",\"pnar\",\"prasa\",\"prlanta\",\"pide\",\"pikap\",\"piknik\",\"pilav\",\"pili\",\"pilot\",\"pipet\",\"pipo\",\"piramit\",\"pirin\",\"pirzola\",\"pist\",\"piik\",\"piman\",\"piyasa\",\"piyes\",\"plaj\",\"plaket\",\"planlama\",\"platform\",\"plazma\",\"podyum\",\"poaa\",\"polat\",\"polen\",\"politika\",\"pompa\",\"popler\",\"porselen\",\"portakal\",\"posa\",\"poster\",\"poet\",\"poyraz\",\"pozitif\",\"pranga\",\"pratik\",\"prenses\",\"prim\",\"problem\",\"profil\",\"program\",\"proje\",\"protokol\",\"prova\",\"puan\",\"pudra\",\"pusula\",\"pre\",\"prz\",\"pstl\",\"psr\",\"racon\",\"radar\",\"radikal\",\"radyo\",\"rafadan\",\"rafine\",\"rabet\",\"rahat\",\"rahle\",\"rakam\",\"raket\",\"rakip\",\"rakun\",\"ralli\",\"rampa\",\"randevu\",\"ranza\",\"rapor\",\"rastgele\",\"rasyonel\",\"raz\",\"realite\",\"reine\",\"refah\",\"referans\",\"refik\",\"reform\",\"rehber\",\"rehin\",\"reis\",\"rekabet\",\"reklam\",\"rekor\",\"rektr\",\"renk\",\"resim\",\"resmen\",\"restoran\",\"retorik\",\"reva\",\"revize\",\"reyon\",\"rezalet\",\"rezerv\",\"rezil\",\"rhtm\",\"rza\",\"ritim\",\"ritel\",\"rivayet\",\"robot\",\"roman\",\"rota\",\"rozet\",\"rportaj\",\"rtar\",\"ruble\",\"ruhban\",\"ruhsat\",\"rulet\",\"rulo\",\"runik\",\"rutin\",\"rutubet\",\"rvet\",\"rtbe\",\"rya\",\"rzgar\",\"sabah\",\"sabka\",\"sabit\",\"sabun\",\"sama\",\"sade\",\"sadk\",\"safahat\",\"safdil\",\"safkan\",\"saanak\",\"saduyu\",\"salam\",\"saha\",\"sahiden\",\"sahne\",\"sakal\",\"sakz\",\"sakin\",\"saklama\",\"saksaan\",\"salamura\",\"sala\",\"salg\",\"salnm\",\"salkm\",\"salon\",\"saltanat\",\"sanat\",\"sancak\",\"sandalye\",\"saniye\",\"saplant\",\"sapsz\",\"saray\",\"sarn\",\"sarkk\",\"sarmak\",\"satr\",\"savam\",\"savunma\",\"saydam\",\"sayfa\",\"saygn\",\"saysal\",\"sebep\",\"seenek\",\"seim\",\"sekin\",\"semen\",\"seda\",\"sedir\",\"sedye\",\"sefer\",\"sehpa\",\"sekizgen\",\"selektr\",\"selvi\",\"semavi\",\"sembol\",\"seminer\",\"senaryo\",\"sendika\",\"senkron\",\"sensr\",\"sentez\",\"sepet\",\"seramik\",\"serbest\",\"serdar\",\"seremoni\",\"sergi\",\"serhat\",\"serin\",\"sermaye\",\"serpu\",\"sersem\",\"serven\",\"servis\",\"sesli\",\"seste\",\"sevap\",\"seviye\",\"seyahat\",\"seyirci\",\"sezon\",\"scak\",\"sfat\",\"shhi\",\"snanma\",\"snr\",\"sradan\",\"srda\",\"srma\",\"srtst\",\"szgt\",\"siftah\",\"sigorta\",\"sihirbaz\",\"silah\",\"silecek\",\"silindir\",\"simetri\",\"simge\",\"simit\",\"sincap\",\"sindirim\",\"sinema\",\"sinirli\",\"sipari\",\"sirke\",\"siroz\",\"sistem\",\"sivilce\",\"siyasi\",\"slogan\",\"soba\",\"sofra\",\"souk\",\"sohbet\",\"sokak\",\"solfej\",\"solunum\",\"somut\",\"sonbahar\",\"sonraki\",\"sonsuz\",\"sorunsuz\",\"sosyete\",\"soyaac\",\"soyda\",\"soygun\",\"soytar\",\"s\",\"smrge\",\"snk\",\"sylem\",\"szck\",\"szde\",\"spatula\",\"spektrum\",\"spiker\",\"spiral\",\"sponsor\",\"sporcu\",\"sprey\",\"stabil\",\"stat\",\"stok\",\"stopaj\",\"strateji\",\"subay\",\"sucuk\",\"sust\",\"suhulet\",\"sulama\",\"sungur\",\"sunucu\",\"surat\",\"susam\",\"suskun\",\"skse\",\"skut\",\"slale\",\"snger\",\"sprge\",\"srahi\",\"sre\",\"srgn\",\"srm\",\"ssleme\",\"stanne\",\"stla\",\"stun\",\"svari\",\"ahane\",\"ahbaz\",\"ahit\",\"ahsiyet\",\"akma\",\"aklaban\",\"akrak\",\"amar\",\"ampiyon\",\"ansl\",\"antiye\",\"apka\",\"arkc\",\"artname\",\"arma\",\"akn\",\"atafat\",\"ayet\",\"ebeke\",\"efkat\",\"eftali\",\"ehir\",\"ehvet\",\"eker\",\"ekil\",\"elale\",\"ema\",\"emsiye\",\"erbet\",\"eref\",\"erit\",\"mark\",\"pdk\",\"ifre\",\"imdi\",\"imek\",\"ipak\",\"irin\",\"ie\",\"iirme\",\"ofben\",\"hret\",\"len\",\"phe\",\"tabaka\",\"tabela\",\"tabure\",\"tadilat\",\"taharet\",\"tahl\",\"tahkim\",\"tahlil\",\"tahmin\",\"tahrifat\",\"tahsilat\",\"tahta\",\"taklit\",\"takoz\",\"taksici\",\"taktik\",\"takvim\",\"talebe\",\"talip\",\"tamamen\",\"tamirci\",\"tampon\",\"tamtakr\",\"tandr\",\"tanecik\",\"tantm\",\"tanr\",\"tansiyon\",\"tapan\",\"tapnak\",\"taptaze\",\"tapu\",\"tarafgir\",\"tarhana\",\"tarm\",\"tarih\",\"tarla\",\"tartak\",\"tarumar\",\"tasarm\",\"tasdik\",\"taslak\",\"tastamam\",\"taeron\",\"tanmaz\",\"tara\",\"tatava\",\"tatbikat\",\"tatil\",\"tatl\",\"tavsiye\",\"tavan\",\"tavuk\",\"taze\",\"taziye\",\"tazminat\",\"tebeir\",\"tebrik\",\"tecrbe\",\"tehizat\",\"tedarik\",\"tedbir\",\"tefti\",\"teet\",\"temen\",\"tehdit\",\"tehlike\",\"tekdze\",\"tekerlek\",\"tekme\",\"teknik\",\"tekrar\",\"telef\",\"telsiz\",\"telve\",\"temas\",\"tembel\",\"temiz\",\"temkin\",\"tempo\",\"temsilci\",\"tendon\",\"teneke\",\"tenha\",\"tenkit\",\"tepegz\",\"tepki\",\"terazi\",\"terbiye\",\"tercih\",\"tereya\",\"terfi\",\"terim\",\"terminal\",\"tersane\",\"tertip\",\"tesadf\",\"tescil\",\"tesir\",\"teslimat\",\"tespit\",\"testere\",\"teekkr\",\"tehir\",\"terif\",\"tevik\",\"teyze\",\"tezahr\",\"tezgah\",\"tbbi\",\"tka\",\"tkk\",\"tknaz\",\"tlsm\",\"tpk\",\"tra\",\"trka\",\"trman\",\"trnak\",\"trpan\",\"tslama\",\"ticaret\",\"tilki\",\"tiryaki\",\"titreim\",\"tohum\",\"tokat\",\"tolere\",\"tomar\",\"tombak\",\"tomurcuk\",\"topa\",\"toplum\",\"toprak\",\"toptan\",\"toraman\",\"torpido\",\"tortu\",\"tosbaa\",\"toynak\",\"tren\",\"trafik\",\"trajedi\",\"tramvay\",\"transfer\",\"tribn\",\"triko\",\"tugay\",\"tula\",\"turul\",\"tuhaf\",\"tulumba\",\"tun\",\"turan\",\"turkuaz\",\"turnusol\",\"turu\",\"turuncu\",\"tutanak\",\"tutkal\",\"tutsak\",\"tutum\",\"tuyu\",\"tuzlu\",\"tccar\",\"tfek\",\"tkenmez\",\"tlbent\",\"tmle\",\"tnel\",\"trbin\",\"trev\",\"trk\",\"tzk\",\"ucube\",\"ucuz\",\"uak\",\"uurtma\",\"ufuk\",\"urak\",\"uur\",\"ukala\",\"ulam\",\"ulema\",\"ulus\",\"ulvi\",\"umursama\",\"umut\",\"unutkan\",\"uslu\",\"ustaba\",\"ustura\",\"usul\",\"utanga\",\"uyank\",\"uyar\",\"uydu\",\"uygar\",\"uygulama\",\"uykusuz\",\"uysal\",\"uyuma\",\"uzant\",\"uzay\",\"uzgren\",\"uzlama\",\"uzman\",\"uzun\",\"cra\",\"cret\",\"budak\",\"gen\",\"kat\",\"leme\",\"frk\",\"lke\",\"mit\",\"niforma\",\"nite\",\"nlem\",\"retken\",\"rn\",\"slup\",\"stel\",\"stn\",\"enge\",\"me\",\"topya\",\"vey\",\"zengi\",\"zgn\",\"zm\",\"vagon\",\"vaka\",\"vakfiye\",\"vakf\",\"vakit\",\"vakum\",\"vapur\",\"varil\",\"varlk\",\"varsaym\",\"varyemez\",\"vasta\",\"vasiyet\",\"vatanda\",\"vazife\",\"vazo\",\"veciz\",\"vefa\",\"vehim\",\"veliaht\",\"veresiye\",\"verimli\",\"verka\",\"vernik\",\"vertigo\",\"vesait\",\"vesika\",\"vestiyer\",\"veznedar\",\"vicdan\",\"vilayet\",\"virane\",\"virgl\",\"vine\",\"vites\",\"vokal\",\"volkan\",\"vurma\",\"vurucu\",\"vcut\",\"yabanc\",\"yabgu\",\"ya\",\"yal\",\"yamur\",\"yakamoz\",\"yakn\",\"yaklak\",\"yaln\",\"yaltm\",\"yaman\",\"yanarda\",\"yangn\",\"yant\",\"yank\",\"yanl\",\"yansma\",\"yapay\",\"yapboz\",\"yapmc\",\"yaprak\",\"yaratk\",\"yarbay\",\"yardm\",\"yarg\",\"yarap\",\"yasemin\",\"yastk\",\"yaam\",\"yatak\",\"yatrm\",\"yavru\",\"yaygara\",\"yaync\",\"yayla\",\"yazlm\",\"yekpare\",\"yekvcut\",\"yelkovan\",\"yelpaze\",\"yemek\",\"yemi\",\"yenge\",\"yenieri\",\"yeralt\",\"yerkre\",\"yerleke\",\"yeryz\",\"yeil\",\"yetenek\",\"yetkili\",\"ynak\",\"ykama\",\"ylba\",\"yldrm\",\"ylk\",\"ylmaz\",\"yrtc\",\"yiit\",\"yourt\",\"yoku\",\"yolcu\",\"yolda\",\"yolgeen\",\"yolkesen\",\"yolst\",\"yordam\",\"yorgan\",\"yorumcu\",\"yosun\",\"ynde\",\"ynetim\",\"ynl\",\"yntem\",\"yresel\",\"yrnge\",\"yufka\",\"yukar\",\"yumruk\",\"yumurta\",\"yuvarlak\",\"ycelme\",\"ykeker\",\"yklem\",\"yksek\",\"yrek\",\"yrtme\",\"yzde\",\"yzeysel\",\"yzge\",\"yzst\",\"yzyl\",\"zabta\",\"zafer\",\"zahmet\",\"zambak\",\"zaptiye\",\"zarafet\",\"zaruret\",\"zeka\",\"zekice\",\"zemberek\",\"zemin\",\"zencefil\",\"zeplin\",\"zeytin\",\"zbn\",\"zlgt\",\"zmbrt\",\"zmpara\",\"zpkn\",\"zigon\",\"zihinsel\",\"zihniyet\",\"zincir\",\"zindan\",\"zirzop\",\"ziyaret\",\"ziynet\",\"zoraki\",\"zorlu\",\"zorunlu\",\"zrt\",\"zmre\"]module.exports = require('./lib/client.js')\nmodule.exports = class Backoff {\n  constructor (strategy) {\n    this.count = 0\n    this.strategy = strategy\n    this.timeout = null\n    this.resolve = null\n  }\n\n  async run () {\n    this.destroy()\n\n    await new Promise(resolve => {\n      const index = this.count >= this.strategy.length ? (this.count - 1) : this.count++\n      const time = this.strategy[index]\n      const delay = Math.round(1.5 * Math.random() * time)\n\n      this.resolve = resolve\n      this.timeout = setTimeout(() => {\n        this.timeout = null\n        resolve()\n      }, delay)\n    })\n  }\n\n  reset () {\n    this.count = 0\n  }\n\n  destroy () {\n    if (this.timeout !== null) {\n      const timeout = this.timeout\n      this.timeout = null\n\n      clearTimeout(timeout)\n      this.resolve()\n    }\n  }\n}\nconst DHT = require('hyperdht')\nconst ProtomuxRPC = require('protomux-rpc')\nconst c = require('compact-encoding')\nconst HypercoreId = require('hypercore-id-encoding')\nconst ReadyResource = require('ready-resource')\nconst safetyCatch = require('safety-catch')\nconst b4a = require('b4a')\nconst Backoff = require('./backoff.js')\nconst waitForRPC = require('./wait-for-rpc.js')\nconst select = require('./select.js')\n\nconst {\n  CoreRecord\n} = require('./messages.js')\n\nmodule.exports = class BlindMirror extends ReadyResource {\n  constructor (serverKey, opts = {}) {\n    super()\n\n    this.serverKey = HypercoreId.decode(serverKey)\n    this.rpc = null\n    this.suspended = !!opts.suspended\n\n    this._connecting = null\n    this._backoff = new Backoff([5000, 15000, 60000, 300000])\n\n    this._dht = opts.dht || new DHT({ bootstrap: opts.bootstrap })\n    this._pendingRPC = null\n    this._autoDestroy = !opts.dht\n    this._suspendedResolve = null\n    this._suspended = this.suspended ? new Promise(resolve => { this._suspendedResolve = resolve }) : null\n\n    this._keyPair = opts.keyPair || DHT.keyPair(opts.seed)\n    this._relayThrough = opts.relayThrough || null\n\n    this.ready().catch(safetyCatch)\n  }\n\n  async suspend () {\n    if (this.suspended) return\n    this.suspended = true\n    this._suspended = new Promise(resolve => { this._suspendedResolve = resolve })\n    this._backoff.destroy()\n    if (this.rpc) this.rpc.destroy()\n    if (this._pendingRPC) this._pendingRPC.destroy()\n    await this.connect() // flush\n  }\n\n  async resume () {\n    if (!this.suspended) return\n    this.suspended = false\n    this._backoff = new Backoff([5000, 15000, 60000, 300000])\n    this.connect().catch(safetyCatch) // bg resume\n    this._suspendedResolve()\n    this._suspended = null\n    this._suspendedResolve = null\n  }\n\n  async _open () {\n    await Promise.resolve() // allow a tick to train so users can attach listeners\n    await this.connect()\n  }\n\n  async close () {\n    this._backoff.destroy()\n    this.rpc.destroy()\n    if (this._pendingRPC) this._pendingRPC.destroy()\n    return super.close()\n  }\n\n  async _close () {\n    if (this._connecting) await this._connecting // Debounce\n    if (this._autoDestroy) await this._dht.destroy()\n  }\n\n  get key () {\n    return this.rpc.stream.publicKey\n  }\n\n  get stream () {\n    return this.rpc.stream\n  }\n\n  async connect () {\n    if (this._connecting) return this._connecting\n\n    this._connecting = this._connect()\n\n    try {\n      await this._connecting\n    } finally {\n      this._connecting = null\n    }\n  }\n\n  async _connect () {\n    if (this.rpc && !this.rpc.closed) return\n\n    this._backoff.reset()\n\n    while (!this.closing && !this.suspended) {\n      if (this._dht.destroyed) return\n\n      const socket = this._dht.connect(this.serverKey, {\n        relayThrough: this._relayThrough,\n        keyPair: this._keyPair\n      })\n      socket.setKeepAlive(5000)\n\n      const rpc = new ProtomuxRPC(socket, {\n        id: this.serverKey,\n        valueEncoding: c.none\n      })\n      rpc.once('close', () => socket.destroy())\n\n      // always set this so we can nuke it if we want\n      this._pendingRPC = rpc\n\n      // Only the first time, set it without waiting\n      if (this.rpc === null) {\n        this.rpc = rpc\n      }\n      this.emit('stream', rpc.stream)\n\n      try {\n        await waitForRPC(rpc)\n        this._pendingRPC = null\n        this.rpc = rpc\n        break\n      } catch (err) {\n        safetyCatch(err)\n        this._pendingRPC = null\n\n        if (this.closing || this.suspended) return\n\n        await this._backoff.run()\n      }\n    }\n\n    if (this.closing || this.suspended) return\n\n    const socket = this.rpc.stream\n    socket.once('close', () => this.connect().catch(safetyCatch))\n  }\n\n  async add (id, opts = {}) {\n    if (this.opened === false) await this.opening\n\n    const key = HypercoreId.decode(id)\n    const referrer = opts.referrer ? HypercoreId.decode(opts.referrer) : null\n    const autobase = opts.autobase || null\n\n    while (!this.rpc && !this.closing) {\n      await this.connect()\n      if (this._suspended !== null) await this._suspended\n    }\n\n    if (this.closing) return\n\n    await this.rpc.request('add-core', {\n      key,\n      referrer,\n      autobase: autobase\n        ? {\n            key: autobase.key,\n            blockEncryptionKey: autobase.blockEncryptionKey || null\n          }\n        : null\n    }, { requestEncoding: CoreRecord, responseEncoding: c.none })\n  }\n\n  async ping () {\n    if (this.opened === false) await this.opening\n    if (this.suspended) await this._suspended\n\n    await this.connect()\n\n    return this.rpc.request('ping', null, { requestEncoding: c.none, responseEncoding: c.string })\n  }\n\n  static select (servers, id) {\n    const closest = select(servers, id)\n    if (!closest) return []\n\n    const filtered = servers.filter(server => b4a.compare(HypercoreId.decode(server), closest) !== 0)\n    const second = select(filtered, id)\n    if (!second) return [closest]\n\n    return [closest, second]\n  }\n}\nconst c = require('compact-encoding')\n\nconst CoreRecord = {\n  preencode (state, v) {\n    state.end++ // flag\n    c.fixed32.preencode(state, v.key)\n\n    if (v.referrer) c.fixed32.preencode(state, v.referrer)\n\n    if (v.autobase) {\n      c.fixed32.preencode(state, v.autobase.key)\n      if (v.autobase.blockEncryptionKey) c.fixed32.preencode(state, v.autobase.blockEncryptionKey)\n    }\n  },\n  encode (state, v) {\n    const flags = ((v.referrer) ? 1 : 0) | (v.autobase ? 2 : 0) | (v.autobase && v.autobase.blockEncryptionKey ? 4 : 0)\n\n    c.uint.encode(state, flags)\n    c.fixed32.encode(state, v.key)\n\n    if (v.referrer) c.fixed32.encode(state, v.referrer)\n\n    if (v.autobase) {\n      c.fixed32.encode(state, v.autobase.key)\n      if (v.autobase.blockEncryptionKey) c.fixed32.encode(state, v.autobase.blockEncryptionKey)\n    }\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n\n    return {\n      key: c.fixed32.decode(state),\n      referrer: flags & 1 ? c.fixed32.decode(state) : null,\n      autobase: flags & 2\n        ? {\n            key: c.fixed32.decode(state),\n            blockEncryptionKey: flags & 4 ? c.fixed32.decode(state) : null\n          }\n        : null\n    }\n  }\n}\n\nmodule.exports = {\n  CoreRecord\n}\nconst xorDistance = require('xor-distance')\nconst HypercoreId = require('hypercore-id-encoding')\n\nmodule.exports = function select (servers, id) {\n  const target = HypercoreId.decode(id)\n  let chosen = null\n\n  for (const serverId of servers) {\n    const serverKey = HypercoreId.decode(serverId)\n    const current = chosen || serverKey\n\n    const a = xorDistance(serverKey, target)\n    const b = xorDistance(current, target)\n    const diff = xorDistance.compare(a, b)\n\n    chosen = diff <= 0 ? serverKey : current\n  }\n\n  return chosen\n}\nmodule.exports = function waitForRPC (client) {\n  return new Promise((resolve, reject) => {\n    client.on('open', onopen)\n    client.on('destroy', ondestroy)\n\n    function onopen (handshake) {\n      removeListener()\n      resolve(handshake)\n    }\n\n    function ondestroy () {\n      removeListener()\n      reject(new Error('Client could not connect'))\n    }\n\n    function removeListener () {\n      client.off('open', onopen)\n      client.off('destroy', ondestroy)\n    }\n  })\n}\n{\n  \"name\": \"@holepunchto/blind-mirror\",\n  \"version\": \"4.5.7\",\n  \"description\": \"Blind mirroring Hypercores at scale\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/blind-mirror.git\"\n  },\n  \"files\": [\n    \"client.js\",\n    \"index.js\",\n    \"lib/*\"\n  ],\n  \"author\": \"Holepunch Inc\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/blind-mirror/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/blind-mirror#readme\",\n  \"devDependencies\": {\n    \"autobase-test-helpers\": \"^2.0.4\",\n    \"brittle\": \"^3.3.2\",\n    \"corestore\": \"^6.15.13\",\n    \"hyperswarm\": \"^4.7.3\",\n    \"random-access-memory\": \"^6.2.0\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"dependencies\": {\n    \"autobase\": \"^6.0.0\",\n    \"@holepunchto/hyperindex\": \"^2.3.1\",\n    \"b4a\": \"^1.6.4\",\n    \"compact-encoding\": \"^2.12.0\",\n    \"debounceify\": \"^1.0.0\",\n    \"hyperbee\": \"^2.14.2\",\n    \"hypercore-id-encoding\": \"^1.2.0\",\n    \"hyperdht\": \"^6.8.9\",\n    \"protomux-rpc\": \"^1.4.1\",\n    \"ready-resource\": \"^1.0.0\",\n    \"safety-catch\": \"^1.0.2\",\n    \"sub-encoder\": \"^2.1.3\",\n    \"xor-distance\": \"^2.0.0\"\n  }\n}\nconst sodium = require('sodium-universal')\n\nmodule.exports = {\n  init: sodium.crypto_hash_sha256_init,\n  update: sodium.crypto_hash_sha256_update,\n  final: sodium.crypto_hash_sha256_final,\n  BYTES: sodium.crypto_hash_sha256_BYTES,\n  STATEBYTES: sodium.crypto_hash_sha256_STATEBYTES\n}\nconst sodium = require('sodium-universal')\n\nmodule.exports = {\n  init: sodium.crypto_hash_sha512_init,\n  update: sodium.crypto_hash_sha512_update,\n  final: sodium.crypto_hash_sha512_final,\n  BYTES: sodium.crypto_hash_sha512_BYTES,\n  STATEBYTES: sodium.crypto_hash_sha512_STATEBYTES\n}\nconst b4a = require('b4a')\n\nconst sha256 = require('./hash/sha256')\nconst sha512 = require('./hash/sha512')\n\nclass HMAC {\n  constructor (hash, key) {\n    this.hash = hash\n    this.length = hash.BYTES\n\n    this._blocksize = 2 * hash.BYTES\n\n    this._initialised = false\n\n    this.state = b4a.alloc(hash.STATEBYTES)\n    this.pad = b4a.alloc(this._blocksize)\n\n    if (key) this.init(key)\n  }\n\n  init (key) {\n    if (this._initialised) {\n      throw new Error('Already initialised, call final first')\n    }\n\n    if (key.length > this._blocksize) {\n      this.hash.init(this.state)\n      this.hash.update(this.state, key)\n      this.hash.final(this.state, this.pad.subarray(0, this.length))\n    } else {\n      this.pad.set(key)\n    }\n\n    bufferByteXor(this.pad, 0x36)\n\n    this.hash.init(this.state)\n    this.hash.update(this.state, this.pad)\n\n    bufferByteXor(this.pad, 0x5c ^ 0x36)\n\n    this._initialised = true\n\n    return this\n  }\n\n  update (data) {\n    if (!this._initialised) {\n      throw new Error('First initialise with a key')\n    }\n\n    this.hash.update(this.state, data)\n    return this\n  }\n\n  final (output = b4a.alloc(this.length)) {\n    if (!this._initialised) {\n      throw new Error('First initialise with a key')\n    }\n\n    const out = output.byteLength === this.length\n      ? output\n      : output.subarray(0, this.hash.BYTES)\n\n    this.hash.final(this.state, out)\n\n    this.hash.init(this.state)\n    this.hash.update(this.state, this.pad)\n    this.hash.update(this.state, out)\n    this.hash.final(this.state, out)\n\n    this.pad.fill(0)\n    this.state.fill(0)\n\n    this._initialised = false\n\n    return out\n  }\n\n  static sha256 (data, key, output) {\n    const hmac = new HMAC(sha256, key)\n    return hmac.update(data).final(output)\n  }\n\n  static sha512 (data, key, output) {\n    const hmac = new HMAC(sha512, key)\n    return hmac.update(data).final(output)\n  }\n}\n\nmodule.exports = {\n  HMAC,\n  sha256,\n  sha512\n}\n\nfunction bufferByteXor (output, byte) {\n  for (let i = 0; i < output.byteLength; i++) {\n    output[i] ^= byte\n  }\n\n  return output\n}\n{\n  \"name\": \"@holepunchto/hmac\",\n  \"version\": \"2.0.1\",\n  \"description\": \"HMAC utility\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"author\": \"\",\n  \"license\": \"Apache-2.0\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.6\",\n    \"sodium-universal\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.4.0\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/hmac.git\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"hash/*\"\n  ],\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hmac/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hmac#readme\"\n}\nconst { EventEmitter } = require('events')\nconst IndexEncoder = require('index-encoder')\nconst SubEncoder = require('sub-encoder')\nconst mutex = require('mutexify/promise')\nconst b4a = require('b4a')\nconst { pipeline, Transform } = require('streamx')\n\nconst EMPTY = b4a.alloc(1)\n\nclass IndexEntryWatcher extends EventEmitter {\n  constructor (index, watcher) {\n    super()\n    this.index = index\n    this.watcher = watcher\n    this.node = null\n\n    this.watcher.on('error', err => this.emit('error', err))\n    this.watcher.on('update', () => {\n      this._updateNode()\n      this.emit('update')\n    })\n    this._updateNode()\n  }\n\n  _updateNode () {\n    const node = this.watcher.node\n    this.node = node ? { key: node.key, value: node.value } : null\n  }\n\n  close () {\n    return this.watcher.close()\n  }\n}\n\nclass CollectionEntryWatcher extends EventEmitter {\n  constructor (collection, watcher) {\n    super()\n    this.collection = collection\n    this.watcher = watcher\n    this.node = null\n\n    this.watcher.on('error', err => this.emit('error', err))\n    this.watcher.on('update', () => {\n      this._updateNode()\n      this.emit('update')\n    })\n    this._updateNode()\n  }\n\n  _updateNode () {\n    this.node = this.watcher.node ? { _id: this.watcher.node.key, value: this.watcher.node.value } : null\n  }\n\n  close () {\n    return this.watcher.close()\n  }\n}\n\nclass Index {\n  constructor (bee, encodings) {\n    this.bee = bee\n    this.encodings = encodings\n  }\n\n  async get (key) {\n    const node = await this.bee.get(key, this.encodings)\n    if (!node) return null\n    return { key: node.key, value: node.value }\n  }\n\n  async delete (key) {\n    await this.bee.del(key, this.encodings)\n  }\n\n  insert (key, value = EMPTY) {\n    return this.bee.put(key, value, this.encodings)\n  }\n\n  async peek (opts) {\n    const node = await this.bee.peek(opts, this.encodings)\n    if (!node) return null\n\n    return { key: node.key, value: node.value }\n  }\n\n  createReadStream (opts = {}) {\n    const stream = this.bee.createReadStream(opts, this.encodings)\n\n    return pipeline(stream, new Transform({\n      transform: (node, cb) => {\n        cb(null, { key: node.key, value: node.value })\n      }\n    }))\n  }\n\n  createDiffStream (otherVersion, opts = {}) {\n    const stream = this.bee.createDiffStream(otherVersion, { ...opts, ...this.encodings })\n\n    return pipeline(stream, new Transform({\n      transform: (node, cb) => {\n        cb(null, {\n          left: node.left ? { key: node.left.key, value: node.left.value } : null,\n          right: node.right ? { key: node.right.key, value: node.right.value } : null\n        })\n      }\n    }))\n  }\n\n  async getAndWatch (path, opts) {\n    const watcher = await this.bee.getAndWatch(path, { ...opts, ...this.encodings })\n    return new IndexEntryWatcher(this, watcher)\n  }\n\n  watch (range, opts) {\n    return this.bee.watch(range, { ...opts, ...this.encodings })\n  }\n\n  transaction (tx) {\n    return new Index(tx.bee, this.encodings)\n  }\n}\n\nclass Collection {\n  constructor (sub, primary, { indexes, indexer, transaction, autoincrement } = {}) {\n    this.sub = sub\n    this.primary = primary\n    this.indexes = indexes || null\n    this.indexer = indexer || null\n\n    this.insert = this._locked(this._insert.bind(this))\n    this.update = this._locked(this._update.bind(this))\n    this.delete = this._locked(this._delete.bind(this))\n\n    this._autoincrement = !!autoincrement\n    this._transaction = transaction\n  }\n\n  _locked (fn) {\n    return async (id, record, opts) => {\n      if (!this._transaction) throw new Error('Can only mutate a collection with a transaction')\n      const release = await this._transaction.writeLock(this)\n      try {\n        return await fn(id, record, opts)\n      } finally {\n        release()\n      }\n    }\n  }\n\n  async _autoincrementId () {\n    const latest = await this.primary.peek({ reverse: true })\n    return latest ? latest.key + 1 : 0\n  }\n\n  async _update (id, record, { upsert = false } = {}) {\n    const prev = await this.primary.get(id)\n    if (!prev && !upsert) throw new Error('Cannot update a record that does not exist')\n    await this.primary.insert(id, record)\n    if (this.indexer) await this.indexer(this._transaction, { id, prev: prev?.value, next: record })\n    return id\n  }\n\n  async _insert (record) {\n    const id = this._autoincrement ? await this._autoincrementId() : record._id\n    return this._update(id, record, { upsert: true })\n  }\n\n  async _delete (id) {\n    const prev = await this.primary.get(id)\n    if (!prev) throw new Error('Deleting a record that does not exist')\n    await this.primary.delete(id)\n    if (this.indexer) await this.indexer(this._transaction, { id, prev: prev.value, next: null })\n  }\n\n  async get (id) {\n    const node = await this.primary.get(id)\n    if (!node) return null\n    return { _id: node.key, value: node.value }\n  }\n\n  async peek (opts) {\n    const node = await this.primary.peek(opts)\n    if (!node) return null\n    return { _id: node.key, value: node.value }\n  }\n\n  createReadStream (opts) {\n    const s = this.primary.createReadStream(opts)\n    return pipeline(s, new Transform({\n      transform (node, cb) {\n        return cb(null, { _id: node.key, value: node.value })\n      }\n    }))\n  }\n\n  createDiffStream (otherVersion, opts) {\n    const s = this.primary.createDiffStream(otherVersion, opts)\n    return pipeline(s, new Transform({\n      transform (node, cb) {\n        return cb(null, {\n          left: node.left ? { _id: node.left.key, value: node.left.value } : null,\n          right: node.right ? { _id: node.right.key, value: node.right.value } : null\n        })\n      }\n    }))\n  }\n\n  async getAndWatch (id, opts) {\n    const watcher = await this.primary.getAndWatch(id, opts)\n    return new CollectionEntryWatcher(this, watcher)\n  }\n\n  watch (range, opts) {\n    return this.primary.watch(range, opts)\n  }\n\n  transaction (tx) {\n    return new Collection(this.sub, this.primary.transaction(tx), {\n      transaction: tx,\n      indexer: this.indexer,\n      autoincrement: this._autoincrement,\n      indexes: this.indexes && this.indexes.map(i => i.transaction(tx))\n    })\n  }\n\n  createIndexes (descriptions, indexer) {\n    if (this.indexes || this.indexer) throw new Error('Already created indexes')\n    this.indexes = []\n    this.indexer = indexer\n\n    // 0 is reserved for the primary index\n    let next = 1\n    for (const description of descriptions) {\n      if (Array.isArray(description)) {\n        const indexes = []\n        for (const desc of description) {\n          indexes.push(createIndex(this.primary.bee, this.sub, next++, desc))\n        }\n        this.indexes.push(indexes)\n      } else {\n        this.indexes.push(createIndex(this.primary.bee, this.sub, next++, description))\n      }\n    }\n    return this.indexes\n  }\n}\n\nclass HyperIndex {\n  constructor (bee, { collections, sub, writable, release, offset = 0 } = {}) {\n    this.bee = bee\n    this.sub = sub || new SubEncoder()\n    this.collections = collections ? collections.map(c => c.transaction(this)) : null\n\n    this._writable = !!writable\n    this._writeLock = !this.collections ? mutex() : null\n    this._collectionLocks = this._writable ? new Map() : null\n\n    this._release = release\n    this._offset = offset\n  }\n\n  get version () {\n    return this.bee.version\n  }\n\n  async writeTransaction (opts) {\n    const release = await this._writeLock()\n    return new this.constructor(this.bee.batch(opts), {\n      collections: this.collections,\n      writable: true,\n      sub: this.sub,\n      release\n    })\n  }\n\n  readTransaction (opts) {\n    return new this.constructor(this.bee.batch(opts), {\n      collections: this.collections,\n      writable: false,\n      sub: this.sub\n    })\n  }\n\n  createCollections (descriptions) {\n    if (this.collections) throw new Error('Already created collections')\n    this.collections = []\n    for (let i = 0; i < descriptions.length; i++) {\n      const sub = this.sub.sub(b4a.from([i + this._offset]))\n      const opts = {\n        ...descriptions[i],\n        transaction: this._writable ? this : null\n      }\n      const primaryIndex = createIndex(this.bee, sub, 0, opts)\n      this.collections.push(new Collection(sub, primaryIndex, opts))\n    }\n    return this.collections\n  }\n\n  async writeLock (collection) {\n    if (!this._writable) throw new Error('Transaction is not writable')\n\n    let lock = this._collectionLocks.get(collection)\n    if (!lock) {\n      lock = mutex()\n      this._collectionLocks.set(collection, lock)\n    }\n\n    return lock()\n  }\n\n  async commit () {\n    if (!this._writable) throw new Error('Transaction is not writable')\n\n    await Promise.all([...this._collectionLocks.values()].map(lock => lock()))\n    await this.bee.flush()\n\n    this._releaseLock()\n  }\n\n  async close () {\n    await this.bee.close()\n    this._releaseLock()\n  }\n\n  _releaseLock () {\n    const release = this._release\n    this._release = null\n    if (release) release()\n  }\n\n  static UINT = IndexEncoder.UINT\n  static STRING = IndexEncoder.STRING\n  static BUFFER = IndexEncoder.BUFFER\n}\n\nmodule.exports = HyperIndex\n\nfunction createIndex (bee, sub, id, description) {\n  let { keyEncoding, valueEncoding, autoincrement } = description\n  if (autoincrement) {\n    keyEncoding = HyperIndex.UINT\n  }\n  const indexEncoding = Array.isArray(keyEncoding) ? new IndexEncoder(keyEncoding) : keyEncoding\n  const encodings = {\n    keyEncoding: sub.sub(b4a.from([id]), indexEncoding),\n    valueEncoding\n  }\n  return new Index(bee, encodings)\n}\n{\n  \"name\": \"@holepunchto/hyperindex\",\n  \"version\": \"2.3.3\",\n  \"description\": \"Indexing and aggregation on Hyperbee\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/hyperindex.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hyperindex/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hyperindex#readme\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.2.1\",\n    \"hyperbee\": \"^2.12.0\",\n    \"hypercore\": \"^10.9.2\",\n    \"random-access-memory\": \"^6.2.0\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"optionalDependencies\": {\n    \"bare-events\": \"^2.2.0\"\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.6.6\",\n    \"compact-encoding\": \"^2.11.0\",\n    \"index-encoder\": \"^3.0.0\",\n    \"mutexify\": \"^1.4.0\",\n    \"ready-resource\": \"^1.0.0\",\n    \"safety-catch\": \"^1.0.2\",\n    \"streamx\": \"^2.18.0\",\n    \"sub-encoder\": \"^2.1.0\"\n  }\n}\n{\n  \"name\": \"@holepunchto/keet-backend-rpc\",\n  \"version\": \"1.2.0\",\n  \"description\": \"RPC interface for connecting keet-backend and keet-store\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"client.js\",\n    \"server.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard\",\n    \"codegen\": \"node scripts/codegen.js && standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/keet-backend-rpc.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"UNLICENSED\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/keet-backend-rpc/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/keet-backend-rpc#readme\",\n  \"dependencies\": {\n    \"@holepunchto/keet-core-api\": \"^1.31.0\",\n    \"b4a\": \"^1.6.7\",\n    \"hypercore-id-encoding\": \"^1.3.0\",\n    \"safety-catch\": \"^1.0.2\",\n    \"streamx\": \"^2.20.2\",\n    \"tiny-buffer-rpc\": \"^2.2.2\"\n  },\n  \"standard\": {\n    \"ignore\": [\n      \"scripts/codegen.js\"\n    ]\n  },\n  \"devDependencies\": {\n    \"standard\": \"^17.1.0\"\n  }\n}\n// !!! This file is autogenerated! Do not modify directly.\nconst any = require('tiny-buffer-rpc/any')\nconst { pipeline } = require('streamx')\n\nmodule.exports = function registerServerAPI (backend, rpc) {\n  // swarm.ready\n  rpc.register(0, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.swarm.ready(...args)\n  })\n\n  // core.getVersion\n  rpc.register(1, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getVersion(...args)\n  })\n\n  // core.subscribeRoomVersion\n  rpc.register(2, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeRoomVersion(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.upgradeRoom\n  rpc.register(3, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.upgradeRoom(...args)\n  })\n\n  // core.getIdentity\n  rpc.register(4, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getIdentity(...args)\n  })\n\n  // core.subscribeIdentity\n  rpc.register(5, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeIdentity(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.generateIdentity\n  rpc.register(6, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.generateIdentity(...args)\n  })\n\n  // core.restoreIdentity\n  rpc.register(7, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.restoreIdentity(...args)\n  })\n\n  // core.confirmIdentity\n  rpc.register(8, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.confirmIdentity(...args)\n  })\n\n  // core.confirmPairingRequest\n  rpc.register(9, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.confirmPairingRequest(...args)\n  })\n\n  // core.subscribeIdentityPairingRequests\n  rpc.register(10, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeIdentityPairingRequests(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.updateIdentityProfile\n  rpc.register(11, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.updateIdentityProfile(...args)\n  })\n\n  // core.updateIdentityDevice\n  rpc.register(12, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.updateIdentityDevice(...args)\n  })\n\n  // core.startPairingIdentity\n  rpc.register(13, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.startPairingIdentity(...args)\n  })\n\n  // core.pairIdentity\n  rpc.register(14, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.pairIdentity(...args)\n  })\n\n  // core.createRoom\n  rpc.register(15, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.createRoom(...args)\n  })\n\n  // core.pairRoom\n  rpc.register(16, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.pairRoom(...args)\n  })\n\n  // core.leaveRoom\n  rpc.register(17, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.leaveRoom(...args)\n  })\n\n  // core.startPairingRoom\n  rpc.register(18, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.startPairingRoom(...args)\n  })\n\n  // core.stopPairingRoom\n  rpc.register(19, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.stopPairingRoom(...args)\n  })\n\n  // core.subscribePendingRooms\n  rpc.register(20, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribePendingRooms(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.subscribeActivateRoom\n  rpc.register(21, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeActivateRoom(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.getRoomKeys\n  rpc.register(22, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getRoomKeys(...args)\n  })\n\n  // core.getTipSize\n  rpc.register(23, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getTipSize(...args)\n  })\n\n  // core.bookmark\n  rpc.register(24, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.bookmark(...args)\n  })\n\n  // core.unbookmark\n  rpc.register(25, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.unbookmark(...args)\n  })\n\n  // core.subscribeBookmarks\n  rpc.register(26, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeBookmarks(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.getRecentRooms\n  rpc.register(27, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getRecentRooms(...args)\n  })\n\n  // core.getLocalRoomMetadata\n  rpc.register(28, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getLocalRoomMetadata(...args)\n  })\n\n  // core.subscribeRecentRooms\n  rpc.register(29, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeRecentRooms(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.subscribeUnreadActivity\n  rpc.register(30, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeUnreadActivity(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.setRoomUnread\n  rpc.register(31, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.setRoomUnread(...args)\n  })\n\n  // core.bumpRoomPriority\n  rpc.register(32, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.bumpRoomPriority(...args)\n  })\n\n  // core.addDevice\n  rpc.register(33, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.addDevice(...args)\n  })\n\n  // core.removeDevice\n  rpc.register(34, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.removeDevice(...args)\n  })\n\n  // core.getDevice\n  rpc.register(35, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getDevice(...args)\n  })\n\n  // core.getDevices\n  rpc.register(36, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getDevices(...args)\n  })\n\n  // core.subscribeDevice\n  rpc.register(37, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeDevice(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.subscribeDevices\n  rpc.register(38, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeDevices(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.createIdentityInvitation\n  rpc.register(39, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.createIdentityInvitation(...args)\n  })\n\n  // core.createInvitation\n  rpc.register(40, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.createInvitation(...args)\n  })\n\n  // core.updateMember\n  rpc.register(41, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.updateMember(...args)\n  })\n\n  // core.getMember\n  rpc.register(42, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getMember(...args)\n  })\n\n  // core.removeMember\n  rpc.register(43, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.removeMember(...args)\n  })\n\n  // core.getMembers\n  rpc.register(44, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getMembers(...args)\n  })\n\n  // core.getModerators\n  rpc.register(45, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getModerators(...args)\n  })\n\n  // core.getMemberCount\n  rpc.register(46, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getMemberCount(...args)\n  })\n\n  // core.waitUntilJoined\n  rpc.register(47, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.waitUntilJoined(...args)\n  })\n\n  // core.getMemberForDevice\n  rpc.register(48, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getMemberForDevice(...args)\n  })\n\n  // core.subscribeMemberCount\n  rpc.register(49, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeMemberCount(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.subscribeMember\n  rpc.register(50, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeMember(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.subscribeMembers\n  rpc.register(51, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeMembers(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.subscribeModerators\n  rpc.register(52, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeModerators(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.subscribeMemberForDevice\n  rpc.register(53, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeMemberForDevice(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.changeMemberRole\n  rpc.register(54, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.changeMemberRole(...args)\n  })\n\n  // core.getSearchMembers\n  rpc.register(55, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getSearchMembers(...args)\n  })\n\n  // core.getPushNotificationMembers\n  rpc.register(56, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getPushNotificationMembers(...args)\n  })\n\n  // core.subscribeSearchMembers\n  rpc.register(57, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeSearchMembers(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.subscribePushNotificationMembers\n  rpc.register(58, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribePushNotificationMembers(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.blockMember\n  rpc.register(59, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.blockMember(...args)\n  })\n\n  // core.unblockMember\n  rpc.register(60, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.unblockMember(...args)\n  })\n\n  // core.getBlockedMembers\n  rpc.register(61, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getBlockedMembers(...args)\n  })\n\n  // core.subscribeBlockedMembers\n  rpc.register(62, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeBlockedMembers(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.getConnectedMembers\n  rpc.register(63, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getConnectedMembers(...args)\n  })\n\n  // core.subscribeConnectedMembers\n  rpc.register(64, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeConnectedMembers(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.updateConfig\n  rpc.register(65, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.updateConfig(...args)\n  })\n\n  // core.getConfig\n  rpc.register(66, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getConfig(...args)\n  })\n\n  // core.subscribeConfig\n  rpc.register(67, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeConfig(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.addChatMessage\n  rpc.register(68, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.addChatMessage(...args)\n  })\n\n  // core.updateChatMessage\n  rpc.register(69, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.updateChatMessage(...args)\n  })\n\n  // core.removeChatMessage\n  rpc.register(70, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.removeChatMessage(...args)\n  })\n\n  // core.pinChatMessage\n  rpc.register(71, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.pinChatMessage(...args)\n  })\n\n  // core.addCallStartedEvent\n  rpc.register(72, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.addCallStartedEvent(...args)\n  })\n\n  // core.addRoomAvatarChangedEvent\n  rpc.register(73, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.addRoomAvatarChangedEvent(...args)\n  })\n\n  // core.addEvent\n  rpc.register(74, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.addEvent(...args)\n  })\n\n  // core.removeEvent\n  rpc.register(75, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.removeEvent(...args)\n  })\n\n  // core.getChatMessage\n  rpc.register(76, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getChatMessage(...args)\n  })\n\n  // core.getChatMessageById\n  rpc.register(77, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getChatMessageById(...args)\n  })\n\n  // core.getChatMessages\n  rpc.register(78, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getChatMessages(...args)\n  })\n\n  // core.getPinnedChatMessages\n  rpc.register(79, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getPinnedChatMessages(...args)\n  })\n\n  // core.getChatLength\n  rpc.register(80, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getChatLength(...args)\n  })\n\n  // core.subscribeChatMessages\n  rpc.register(81, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeChatMessages(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.subscribeChatLength\n  rpc.register(82, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeChatLength(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.sendInvitations\n  rpc.register(83, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.sendInvitations(...args)\n  })\n\n  // core.updatePrivateMailboxRecord\n  rpc.register(84, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.updatePrivateMailboxRecord(...args)\n  })\n\n  // core.getPrivateMailboxRecords\n  rpc.register(85, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getPrivateMailboxRecords(...args)\n  })\n\n  // core.subscribePrivateMailbox\n  rpc.register(86, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribePrivateMailbox(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.getSentPrivateMailboxRecords\n  rpc.register(87, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getSentPrivateMailboxRecords(...args)\n  })\n\n  // core.subscribeSentPrivateMailbox\n  rpc.register(88, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeSentPrivateMailbox(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.getDmList\n  rpc.register(89, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getDmList(...args)\n  })\n\n  // core.subscribeDmList\n  rpc.register(90, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeDmList(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.acceptDmRequest\n  rpc.register(91, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.acceptDmRequest(...args)\n  })\n\n  // core.rejectDmRequest\n  rpc.register(92, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.rejectDmRequest(...args)\n  })\n\n  // core.addReaction\n  rpc.register(93, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.addReaction(...args)\n  })\n\n  // core.removeReaction\n  rpc.register(94, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.removeReaction(...args)\n  })\n\n  // core.getReactions\n  rpc.register(95, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getReactions(...args)\n  })\n\n  // core.subscribeReactions\n  rpc.register(96, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeReactions(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.addFileBlob\n  rpc.register(97, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.addFileBlob(...args)\n  })\n\n  // core.addFile\n  rpc.register(98, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.addFile(...args)\n  })\n\n  // core.saveFileBlob\n  rpc.register(99, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.saveFileBlob(...args)\n  })\n\n  // core.saveFile\n  rpc.register(100, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.saveFile(...args)\n  })\n\n  // core.sendFile\n  rpc.register(101, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.sendFile(...args)\n  })\n\n  // core.removeFile\n  rpc.register(102, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.removeFile(...args)\n  })\n\n  // core.refreshFileLinks\n  rpc.register(103, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.refreshFileLinks(...args)\n  })\n\n  // core.subscribeFileInfo\n  rpc.register(104, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeFileInfo(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.clearAllFiles\n  rpc.register(105, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.clearAllFiles(...args)\n  })\n\n  // core.getFileEntry\n  rpc.register(106, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getFileEntry(...args)\n  })\n\n  // core.getLocalFiles\n  rpc.register(107, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getLocalFiles(...args)\n  })\n\n  // core.startDownload\n  rpc.register(108, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.startDownload(...args)\n  })\n\n  // core.cancelDownload\n  rpc.register(109, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.cancelDownload(...args)\n  })\n\n  // core.clearFile\n  rpc.register(110, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.clearFile(...args)\n  })\n\n  // core.unclearFile\n  rpc.register(111, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.unclearFile(...args)\n  })\n\n  // core.getFileCleared\n  rpc.register(112, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getFileCleared(...args)\n  })\n\n  // core.subscribeFileCleared\n  rpc.register(113, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.core.subscribeFileCleared(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // core.getStats\n  rpc.register(114, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.core.getStats(...args)\n  })\n\n  // preferences.subscribe\n  rpc.register(115, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.preferences.subscribe(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // preferences.update\n  rpc.register(116, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.preferences.update(...args)\n  })\n\n  // preferences.query\n  rpc.register(117, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.preferences.query(...args)\n  })\n\n  // call.authorize\n  rpc.register(118, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.authorize(...args)\n  })\n\n  // call.deauthorize\n  rpc.register(119, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.deauthorize(...args)\n  })\n\n  // call.joinPeer\n  rpc.register(120, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.joinPeer(...args)\n  })\n\n  // call.leavePeer\n  rpc.register(121, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.leavePeer(...args)\n  })\n\n  // call.requestTrack\n  rpc.register(122, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.requestTrack(...args)\n  })\n\n  // call.unrequestTrack\n  rpc.register(123, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.unrequestTrack(...args)\n  })\n\n  // call.signalMedia\n  rpc.register(124, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.signalMedia(...args)\n  })\n\n  // call.getRequestedTracks\n  rpc.register(125, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.getRequestedTracks(...args)\n  })\n\n  // call.subscribeRequestedTracks\n  rpc.register(126, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.call.subscribeRequestedTracks(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // call.subscribeMediaSignals\n  rpc.register(127, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.call.subscribeMediaSignals(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // call.subscribeProxyUpdates\n  rpc.register(128, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.call.subscribeProxyUpdates(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // call.shareTrack\n  rpc.register(129, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.shareTrack(...args)\n  })\n\n  // call.unshareTrack\n  rpc.register(130, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.unshareTrack(...args)\n  })\n\n  // call.relayTrack\n  rpc.register(131, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.relayTrack(...args)\n  })\n\n  // call.unrelayTrack\n  rpc.register(132, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.unrelayTrack(...args)\n  })\n\n  // call.subscribeAvailableTracks\n  rpc.register(133, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.call.subscribeAvailableTracks(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // call.getAvailableTracks\n  rpc.register(134, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.getAvailableTracks(...args)\n  })\n\n  // call.setPresent\n  rpc.register(135, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.setPresent(...args)\n  })\n\n  // call.setNotPresent\n  rpc.register(136, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.setNotPresent(...args)\n  })\n\n  // call.subscribePresence\n  rpc.register(137, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.call.subscribePresence(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // call.getPresence\n  rpc.register(138, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.call.getPresence(...args)\n  })\n\n  // tracing.start\n  rpc.register(139, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.tracing.start(...args)\n  })\n\n  // tracing.addFrontendTrace\n  rpc.register(140, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.tracing.addFrontendTrace(...args)\n  })\n\n  // console.log\n  rpc.register(141, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.console.log(...args)\n  })\n\n  // console.warn\n  rpc.register(142, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.console.warn(...args)\n  })\n\n  // console.error\n  rpc.register(143, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.console.error(...args)\n  })\n\n  // network.subscribe\n  rpc.register(144, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.network.subscribe(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n\n  // network.query\n  rpc.register(145, {\n    request: any,\n    response: any,\n    onrequest: args => backend.api.network.query(...args)\n  })\n\n  // error.subscribe\n  rpc.register(146, {\n    request: any,\n    response: any,\n    onstream: async stream => {\n      try {\n        for await (const args of stream) {\n          const src = backend.api.error.subscribe(...args)\n          pipeline(src, stream).on('error', noop)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  })\n}\n\nfunction noop () {}\nconst { Readable } = require('streamx')\n\nmodule.exports = class ErrorAPI {\n  constructor () {\n    this._subscriptions = []\n\n    this._handleError = this._handleError.bind(this)\n\n    this._listenersAttached = false\n  }\n\n  _handleError (err) {\n    for (const sub of this._subscriptions) {\n      sub.push({ message: err.message, stack: err.stack + '' })\n    }\n  }\n\n  subscribe (opts) {\n    const self = this\n\n    if (!this._listenersAttached) {\n      process.on('uncaughtException', this._handleError)\n      process.on('unhandledRejection', this._handleError)\n      this._listenersAttached = true\n    }\n\n    const stream = new Readable({\n      ...opts,\n      destroy (cb) {\n        const idx = self._subscriptions.indexOf(this)\n        if (idx !== -1) self._subscriptions.splice(idx, 1)\n        cb(null)\n      }\n    })\n\n    this._subscriptions.push(stream)\n\n    return stream\n  }\n}\nconst { Readable } = require('streamx')\n\nmodule.exports = class NetworkAPI {\n  constructor (swarm) {\n    this.swarm = swarm\n    this._subscriptions = []\n\n    this._handleUpdate = this._handleUpdate.bind(this)\n\n    this.swarm.on('update', this._handleUpdate)\n    this.swarm.dht.on('network-update', this._handleUpdate)\n  }\n\n  _handleUpdate () {\n    this._lastQuery = this.query()\n    for (const sub of this._subscriptions) {\n      sub.push(this._lastQuery)\n    }\n  }\n\n  subscribe (opts) {\n    const self = this\n\n    const stream = new Readable({\n      ...opts,\n      destroy (cb) {\n        const idx = self._subscriptions.indexOf(this)\n        if (idx !== -1) self._subscriptions.splice(idx, 1)\n        cb(null)\n      }\n    })\n\n    if (this._lastQuery) {\n      stream.push(this._lastQuery)\n    }\n\n    this._subscriptions.push(stream)\n\n    return stream\n  }\n\n  query () {\n    return {\n      host: this.swarm.dht.host,\n      port: this.swarm.dht.port,\n      online: this.swarm.dht.online,\n      connections: this.swarm.connections.size\n    }\n  }\n}\nconst { Readable } = require('streamx')\n\nmodule.exports = class PaymentsAPI {\n  constructor () {\n    this._subscriptions = []\n  }\n\n  internalAddStream (stream) {\n    // TODO: Deprecated\n  }\n\n  subscribe () {\n    const self = this\n    this._subscriptions.push(new Readable({\n      destroy (cb) {\n        const idx = self._subscriptions.indexOf(this)\n        if (idx !== -1) self._subscriptions.splice(idx, 1)\n        cb(null)\n      }\n    }))\n  }\n}\nconst c = require('compact-encoding')\nconst safetyCatch = require('safety-catch')\nconst ReadyResource = require('ready-resource')\nconst Hyperbee = require('hyperbee')\nconst { Readable } = require('streamx')\n\nconst PREFERENCES_CORE_NAME = 'keet-preferences'\nconst PREFERENCES_KEY = 0\n\nmodule.exports = class PreferencesAPI extends ReadyResource {\n  constructor (store) {\n    super()\n    this._encoding = {\n      keyEncoding: c.uint,\n      valueEncoding: c.json\n    }\n    this._bee = new Hyperbee(store.get({ name: PREFERENCES_CORE_NAME }))\n  }\n\n  _open () {\n    return this._bee.ready()\n  }\n\n  _close () {\n    return this._bee.close()\n  }\n\n  subscribe (opts) {\n    const self = this\n    let watcher = null\n    const stream = new Readable({\n      ...opts,\n      async open (cb) {\n        try {\n          watcher = await self._bee.getAndWatch(PREFERENCES_KEY, self._encoding)\n          if (watcher.node) {\n            this.push(watcher.node.value)\n          }\n          watcher.on('update', () => {\n            if (this.destroying) return\n            this.push(watcher.node.value)\n          })\n        } catch (err) {\n          return cb(err)\n        }\n        cb(null)\n      },\n      destroy (cb) {\n        if (watcher) watcher.close().catch(safetyCatch)\n        cb(null)\n      }\n    })\n    return stream\n  }\n\n  async update (key, value) {\n    const node = await this._bee.get(PREFERENCES_KEY, this._encoding)\n    if (this._bee.closing) return\n\n    const obj = node ? node.value : {}\n    if (value === undefined) {\n      delete obj[key]\n    } else {\n      obj[key] = value\n    }\n\n    await this._bee.put(PREFERENCES_KEY, obj, this._encoding)\n  }\n\n  async query () {\n    const node = await this._bee.get(PREFERENCES_KEY, this._encoding)\n    if (this._bee.closing || !node) {\n      return {}\n    }\n    return node.value\n  }\n}\nconst ReadyResource = require('ready-resource')\nconst Hyperswarm = require('hyperswarm')\nconst Corestore = require('corestore')\nconst KeetCore = require('@holepunchto/keet-core')\nconst KeetCallServer = require('@holepunchto/keet-call/server')\nconst HypercoreId = require('hypercore-id-encoding')\nconst safetyCatch = require('safety-catch')\nconst PreferencesAPI = require('./apis/preferences')\nconst PaymentsAPI = require('./apis/payments')\nconst NetworkAPI = require('./apis/network')\nconst ErrorAPI = require('./apis/error')\nconst {\n  DEFAULT_BLIND_MEDIA_MIRROR_KEYS,\n  DEFAULT_BLIND_MIRROR_KEYS,\n  DEFAULT_BLIND_RELAY_KEYS,\n  DEFAULT_GATEKEEPERS,\n  DEV_BLIND_MIRROR_KEYS,\n  DEV_BLIND_RELAY_KEYS\n} = require('@holepunchto/keet-default-config')\nconst Rache = require('rache')\n\nconst SWARM_KEYPAIR_NAME = 'keet-swarm-keypair'\nconst KEET_CORE_NAMESPACE = 'keet-core'\nconst PREFERENCES_NAMESPACE = 'preferences'\n\nconst DEFAULT_RELAY_KEYS = DEFAULT_BLIND_RELAY_KEYS.map(HypercoreId.decode)\nconst DEV_RELAY_KEYS = DEV_BLIND_RELAY_KEYS.map(HypercoreId.decode)\n\nmodule.exports = class KeetServer extends ReadyResource {\n  constructor (storage, opts = {}) {\n    super()\n\n    const globalCache = new Rache({ maxSize: opts.maxCacheSize })\n    this._corestore = new Corestore(storage, { globalCache, ...opts })\n\n    this._opts = opts\n    this._relayKeys = opts.devMirrors ? DEV_RELAY_KEYS : DEFAULT_RELAY_KEYS\n    this._mirrorKeys = opts.devMirrors ? DEV_BLIND_MIRROR_KEYS : DEFAULT_BLIND_MIRROR_KEYS\n    this._mediaMirrorKeys = DEFAULT_BLIND_MEDIA_MIRROR_KEYS || []\n    this._experimental = opts.experimental === true\n\n    // Set in _open\n    this._swarm = null\n    this.api = {\n      preferences: null,\n      payments: null,\n      core: null,\n      call: null,\n      connectionLogs: [],\n      network: null,\n      error: new ErrorAPI(),\n      console: {\n        log: (...args) => {\n          console.log('[UI Thread]', ...args)\n        },\n        error: (...args) => {\n          console.error('[UI Thread]', ...args)\n        },\n        warn: (...args) => {\n          console.warn('[UI Thread]', ...args)\n        }\n      }\n    }\n\n    this._relayThrough = (force) => (force || this._swarm.dht.randomized) ? this._relayKeys : null\n\n    this.suspended = false\n    this.ready().catch(safetyCatch)\n  }\n\n  async swarmReady () {\n    await this.ready()\n    return this._swarm.keyPair.publicKey\n  }\n\n  async suspend () {\n    if (!this.opened) await this.ready()\n    if (this.suspended) return\n\n    await this.api.core.suspend()\n\n    this.suspended = true\n  }\n\n  async resume () {\n    if (!this.suspended) return\n\n    await this.api.core.resume()\n\n    this.suspended = false\n  }\n\n  async _open () {\n    await this._corestore.ready()\n\n    this._swarm = new Hyperswarm({\n      ...this._opts,\n      keyPair: await this._corestore.createKeyPair(SWARM_KEYPAIR_NAME),\n      relayThrough: this._relayThrough\n    })\n\n    this.api.preferences = new PreferencesAPI(this._corestore.namespace(PREFERENCES_NAMESPACE))\n\n    this.api.core = new KeetCore(\n      this._corestore.namespace(KEET_CORE_NAMESPACE),\n      this._swarm,\n      {\n        experimental: this._experimental,\n        blindMirrorKeys: this._mirrorKeys,\n        blindMediaMirrorKeys: this._mediaMirrorKeys,\n        gatekeepers: DEFAULT_GATEKEEPERS,\n        ...this._opts\n      }\n    )\n\n    this.api.call = new KeetCallServer(this._swarm, {\n      firewall: this.api.core.createFirewall()\n    })\n\n    this.api.network = new NetworkAPI(this._swarm)\n\n    this.api.payments = new PaymentsAPI()\n\n    this._swarm.on('connection', conn => {\n      const localId = HypercoreId.encode(conn.publicKey)\n      const remoteId = HypercoreId.encode(conn.remotePublicKey)\n\n      const start = Date.now()\n      let bytes = 0\n\n      const log = `got ${(conn.isInitiator ? 'client' : 'server')} connection from ${localId} to ${remoteId}`\n      console.log(log)\n      this.api.connectionLogs.push(log)\n\n      let connErr = null\n      conn.once('error', err => { connErr = err })\n      conn.once('close', () => {\n        const log = `connection closed to ${remoteId}, with err: ${connErr} (${(Date.now() - start)} ms ${bytes} bytes recv)`\n        console.log(log)\n        this.api.connectionLogs.push(log)\n      })\n\n      const stream = this._corestore.replicate(conn)\n\n      this.api.payments.internalAddStream(stream)\n      conn.on('data', (data) => { bytes += data.byteLength })\n    })\n\n    await Promise.all([\n      this.api.preferences.ready(),\n      this.api.core.ready()\n    ])\n  }\n\n  async _close () {\n    await Promise.all([\n      this.api.preferences.close(),\n      this.api.core.close(),\n      this.api.call.close()\n    ])\n\n    await this._swarm.destroy()\n    await this._corestore.close()\n  }\n}\n{\n  \"name\": \"@holepunchto/keet-backend\",\n  \"version\": \"17.4.1\",\n  \"description\": \"Stateless APIs for Keet's P2P components\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test/index.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/keet-backend.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"UNLICENSED\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/keet-backend/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/keet-backend#readme\",\n  \"files\": [\n    \"index.js\",\n    \"apis/**.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"@holepunchto/keet-call\": \"^9.0.9\",\n    \"@holepunchto/keet-core\": \"^19.0.0\",\n    \"@holepunchto/keet-default-config\": \"^1.2.4\",\n    \"b4a\": \"^1.6.6\",\n    \"bare-events\": \"^2.2.2\",\n    \"compact-encoding\": \"^2.15.0\",\n    \"corestore\": \"^6.18.3\",\n    \"hyperbee\": \"2.20.7\",\n    \"hypercore-id-encoding\": \"^1.3.0\",\n    \"hyperswarm\": \"^4.7.14\",\n    \"rache\": \"^1.0.0\",\n    \"ready-resource\": \"^1.0.3\",\n    \"safety-catch\": \"^1.0.2\",\n    \"streamx\": \"^2.16.1\"\n  },\n  \"devDependencies\": {\n    \"@hyperswarm/testnet\": \"^3.1.4\",\n    \"brittle\": \"^3.5.2\",\n    \"random-access-memory\": \"^6.2.1\",\n    \"standard\": \"^17.1.0\"\n  }\n}\nconst safetyCatch = require('safety-catch')\nconst b4a = require('b4a')\n\nmodule.exports.TRACKER_EVENTS = {\n  HAVE: 'have-track',\n  UNHAVE: 'unhave-track'\n}\n\nmodule.exports.MEDIA_EVENTS = {\n  WANT: 'want-track',\n  UNWANT: 'unwant-track',\n  SIGNAL: 'media-signal',\n  PROXY_OPEN: 'proxy-open',\n  PROXY_CLOSE: 'proxy-close'\n}\n\nmodule.exports.PRESENCE_EVENTS = {\n  PEER_PRESENT: 'present',\n  PEER_NOT_PRESENT: 'not-present',\n  STREAM_AVAILABLE: 'stream-available',\n  STREAM_UNAVAILABLE: 'stream-unavailable',\n  STREAM_STATUS_CHANGED: 'stream-status-changed'\n}\n\nmodule.exports.encodeTrackId = function (streamId, trackKind) {\n  return `${streamId}:${trackKind}`\n}\n\nmodule.exports.decodeTrackId = function (id) {\n  const [streamId, trackKind] = id.split(':')\n  return { streamId, trackKind }\n}\n\nmodule.exports.getConnection = function (swarm, remotePublicKey) {\n  for (const conn of swarm.connections) {\n    if (!b4a.equals(conn.remotePublicKey, remotePublicKey)) continue\n    return conn\n  }\n  return null\n}\n\n// TODO: Make a module for this\nmodule.exports.createResourceManager = function (constructor) {\n  const collection = new Map()\n  return {\n    collection,\n    open,\n    release,\n    subscription,\n    method,\n    asyncMethod\n  }\n\n  function open (callId) {\n    const existing = collection.get(callId)\n    if (existing) {\n      existing.refs++\n      return existing.value\n    }\n\n    const value = constructor(callId)\n    collection.set(callId, { value, refs: 1 })\n\n    return value\n  }\n\n  function release (callId) {\n    const existing = collection.get(callId)\n    if (!existing) throw new Error('Releasing an unopened resource')\n\n    if (--existing.refs > 0) return\n    existing.value.close()\n\n    collection.delete(callId)\n  }\n\n  function asyncMethod (fn) {\n    return async (callId, ...args) => {\n      const value = open(callId)\n      try {\n        return await fn(value, ...args)\n      } finally {\n        release(callId)\n      }\n    }\n  }\n\n  function method (fn) {\n    return (callId, ...args) => {\n      const value = open(callId)\n      try {\n        return fn(value, ...args)\n      } finally {\n        release(callId)\n      }\n    }\n  }\n\n  function subscription (fn) {\n    return (callId, ...args) => {\n      const value = open(callId)\n      const stream = fn(value, ...args)\n      stream.once('close', () => {\n        release(callId)\n      })\n      stream.on('error', safetyCatch)\n      return stream\n    }\n  }\n}\nconst c = require('compact-encoding')\n\n// Presence Messages\n\nconst Stream = {\n  preencode (state, m) {\n    c.uint.preencode(state, 0) // flags\n    c.string.preencode(state, m.id)\n    c.string.preencode(state, m.name)\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.string.encode(state, m.id)\n    c.string.encode(state, m.name)\n\n    let flags = 0\n    if (m.audioMuted) {\n      flags |= 1\n    }\n    if (m.videoMuted) {\n      flags |= 2\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      id: c.string.decode(state),\n      name: c.string.decode(state),\n      audioMuted: (flags & 1) !== 0,\n      videoMuted: (flags & 2) !== 0\n    }\n  }\n}\n\nmodule.exports.StreamsMessage = c.array(Stream)\nmodule.exports.PeerPresenceMessage = {\n  preencode (state, m) {\n    c.uint.preencode(state, 1)\n    c.fixed32.preencode(state, m.key)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.present ? 1 : 0)\n    c.fixed32.encode(state, m.key)\n  },\n  decode (state) {\n    return {\n      present: !!c.uint.decode(state),\n      key: c.fixed32.decode(state)\n    }\n  }\n}\n\n// WebRTC Messages\n\nmodule.exports.HandshakeMessage = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.alias)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.alias)\n  },\n  decode (state) {\n    return {\n      alias: c.uint.decode(state)\n    }\n  }\n}\n\nmodule.exports.TrackRequestMessage = c.buffer\nmodule.exports.TrackResponseMessage = c.buffer\nmodule.exports.SignalMessage = c.json\n{\n  \"name\": \"@holepunchto/keet-call\",\n  \"version\": \"9.0.9\",\n  \"description\": \"Track management and relaying for Keet\",\n  \"main\": \"client/index.js\",\n  \"files\": [\n    \"client/**\",\n    \"server/**\",\n    \"lib/**\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"scripts\": {\n    \"lint\": \"standard\",\n    \"test\": \"standard && npm run test:app\",\n    \"test:app\": \"pear dev test-app --use-fake-device-for-media-stream\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/keet-call.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"UNLICENSED\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/keet-call/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/keet-call#readme\",\n  \"dependencies\": {\n    \"@holepunchto/protomap\": \"^2.0.0\",\n    \"bare-events\": \"^2.4.2\",\n    \"debounceify\": \"^1.0.0\",\n    \"fast-deep-equal\": \"^3.1.3\",\n    \"hypercore\": \"^10.33.0\",\n    \"hypercore-id-encoding\": \"^1.1.0\",\n    \"hypertrace\": \"^1.4.1\",\n    \"safety-catch\": \"^1.0.2\",\n    \"sdp-transform\": \"^2.14.1\",\n    \"signal-promise\": \"^1.0.3\",\n    \"tiny-buffer-map\": \"^1.1.1\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst safetyCatch = require('safety-catch')\nconst HypercoreId = require('hypercore-id-encoding')\nconst b4a = require('b4a')\n\nconst {\n  createResourceManager\n} = require('../lib/common')\n\nconst MediaServer = require('./media')\nconst PresenceServer = require('./presence')\n\nconst MAGIC = 0xE1\nconst MAX_ALIAS = 256\n\nclass RawStreamMuxer {\n  constructor (conn) {\n    this.connection = conn\n    this.closed = false\n    this.localAlias = 0\n\n    this._proxiesByRemoteAlias = new Array(MAX_ALIAS)\n    this._prefixesByLocalAlias = new Array(MAX_ALIAS)\n\n    this._onmessage = this._onMessage.bind(this)\n\n    this.connection.rawStream.on('message', this._onmessage)\n  }\n\n  _onMessage (message) {\n    if (this.closed) return\n\n    const alias = message[0]\n    const proxy = this._proxiesByRemoteAlias[alias]\n    if (!proxy) return\n\n    proxy.handleRawStreamData(message.subarray(2))\n  }\n\n  createLocalAlias () {\n    this.localAlias = (this.localAlias + 1) % MAX_ALIAS\n\n    const prefix = b4a.allocUnsafe(2)\n    prefix[0] = this.localAlias\n    prefix[1] = MAGIC\n    this._prefixesByLocalAlias[this.localAlias] = prefix\n\n    return this.localAlias\n  }\n\n  send (localAlias, data) {\n    if (this.closed) return\n\n    const buf = b4a.allocUnsafe(data.byteLength + 2)\n    this._prefixesByLocalAlias[localAlias].copy(buf, 0)\n    data.copy(buf, 2)\n\n    this.connection.rawStream.trySend(buf)\n  }\n\n  registerProxy (remoteAlias, proxy) {\n    this._proxiesByRemoteAlias[remoteAlias] = proxy\n  }\n\n  unregisterProxy (remoteAlias) {\n    this._proxiesByRemoteAlias[remoteAlias] = null\n  }\n\n  close () {\n    this.closed = true\n    this.connection.rawStream.removeListener('message', this._onmessage)\n  }\n}\n\nmodule.exports = class KeetCallServer {\n  constructor (swarm, { firewall, onerror = safetyCatch } = {}) {\n    this.swarm = swarm\n    this.onerror = onerror\n    this.firewall = firewall\n\n    // Used for raw stream messages\n    this._localAlias = 0\n    this._rawMuxersByStream = new Map()\n\n    const {\n      collection: mediaByCallId,\n      asyncMethod: mediaMethod,\n      subscription: mediaSubscription\n    } = createResourceManager(callId => {\n      return new MediaServer(this, callId)\n    })\n    const {\n      collection: presenceByCallId,\n      asyncMethod: presenceMethod,\n      subscription: presenceSubscription\n    } = createResourceManager(callId => {\n      return new PresenceServer(this, callId, firewall)\n    })\n    this._mediaByCallId = mediaByCallId\n    this._presenceByCallId = presenceByCallId\n    this._connectionsBySwarmId = new Map()\n    this._activatedCalls = new Set()\n\n    // Call Activation\n    this.activateCall = this._activateCall.bind(this)\n    this.deactivateCall = this._deactivateCall.bind(this)\n\n    // Swarm Mutations\n    this.authorize = this._authorize.bind(this)\n    this.deauthorize = this._deauthorize.bind(this)\n    this.joinPeer = this._joinPeer.bind(this)\n    this.leavePeer = this._leavePeer.bind(this)\n\n    this.signalMedia = mediaMethod(this._signalMedia.bind(this))\n    this.subscribeMediaSignals = mediaSubscription(this._subscribeMediaSignals.bind(this))\n    this.subscribeProxyUpdates = mediaSubscription(this._subscribeProxyUpdates.bind(this))\n\n    // Presence Mutations\n    this.setPresent = presenceMethod(this._setPresent.bind(this))\n    this.setNotPresent = presenceMethod(this._setNotPresent.bind(this))\n\n    // Presence Queries/Subscriptions\n    this.subscribePresence = presenceSubscription(this._subscribePresence.bind(this))\n    this.getPresence = presenceMethod(this._getPresence.bind(this))\n\n    const self = this\n    this._onconnection = this._onConnection.bind(this)\n    this._onconnectionclosed = function () {\n      self._onConnectionClosed(this)\n    }\n    this.swarm.on('connection', this._onconnection)\n  }\n\n  get callIsActive () {\n    return this._mediaByCallId.size > 0\n  }\n\n  mediaIsActive (callId) {\n    return this._mediaByCallId.has(callId)\n  }\n\n  shouldActivate (callId) {\n    return this.mediaIsActive(callId) || this._activatedCalls.has(callId)\n  }\n\n  // Call Activation\n  _activateCall (callId) {\n    this._activatedCalls.add(callId)\n    const record = this._presenceByCallId.get(callId)\n    if (!record) return\n    record.value.activate()\n  }\n\n  _deactivateCall (callId) {\n    this._activatedCalls.delete(callId)\n    const record = this._presenceByCallId.get(callId)\n    if (!record) return\n    record.value.deactivate()\n  }\n\n  internalActivateCall (mediaServer) {\n    return this._activateCall(mediaServer.callId)\n  }\n\n  internalDeactivateCall () {\n    // TODO: Implement\n  }\n\n  // Resource Management\n\n  close () {\n    this.swarm.removeListener('connection', this._onconnection)\n    for (const conn of this.swarm.connections) {\n      conn.removeListener('close', this._onconnectionclosed)\n    }\n    for (const rawMuxer of this._rawMuxersByStream.values()) {\n      rawMuxer.close()\n    }\n    for (const { value: media } of this._mediaByCallId.values()) {\n      media.close()\n    }\n    for (const { value: presence } of this._presenceByCallId.values()) {\n      presence.close()\n    }\n  }\n\n  _onConnection (conn) {\n    const swarmId = HypercoreId.encode(conn.remotePublicKey)\n    this._connectionsBySwarmId.set(swarmId, conn)\n\n    const rawMuxer = new RawStreamMuxer(conn)\n    this._rawMuxersByStream.set(conn, rawMuxer)\n\n    conn.on('close', this._onconnectionclosed)\n\n    for (const { value: media } of this._mediaByCallId.values()) {\n      media.addConnection(conn, rawMuxer)\n    }\n    for (const { value: presence } of this._presenceByCallId.values()) {\n      presence.addConnection(conn)\n    }\n  }\n\n  _onConnectionClosed (conn) {\n    const swarmId = HypercoreId.encode(conn.remotePublicKey)\n    this._connectionsBySwarmId.delete(swarmId)\n\n    const rawMuxer = this._rawMuxersByStream.get(conn)\n    if (rawMuxer) {\n      rawMuxer.close()\n      this._rawMuxersByStream.delete(conn)\n    }\n\n    for (const { value: media } of this._mediaByCallId.values()) {\n      media.removeConnection(conn, rawMuxer)\n    }\n    for (const { value: presence } of this._presenceByCallId.values()) {\n      presence.removeConnection(conn)\n    }\n  }\n\n  // Called by MediaServer\n\n  // Top-Level Mutations\n\n  // TODO: Deprecated\n  _authorize (callId, swarmId) {\n\n  }\n\n  // TODO: Deprecated\n  _deauthorize (callId, swarmId) {\n    // TODO: Implement\n  }\n\n  _joinPeer (swarmId) {\n    return this.swarm.joinPeer(HypercoreId.decode(swarmId))\n  }\n\n  _leavePeer (swarmId) {\n    return this.swarm.leavePeer(HypercoreId.decode(swarmId))\n  }\n\n  // Media Mutations\n\n  // Media Method\n  _signalMedia (media, swarmId, signal) {\n    const conn = this._connectionsBySwarmId.get(swarmId)\n    return media.signal(conn, signal)\n  }\n\n  // Media Subscriptions/Queries\n\n  // Media Subscription\n  _subscribeMediaSignals (media) {\n    return media.subscribeMediaSignals()\n  }\n\n  // Media Subscription\n  _subscribeProxyUpdates (media) {\n    return media.subscribeProxyUpdates()\n  }\n\n  // Presence Queries/Subscriptions\n\n  // Presence Subscription\n  _subscribePresence (presence) {\n    return presence.subscribePresence()\n  }\n\n  // Presence Method\n  _getPresence (presence) {\n    return presence.getPresence()\n  }\n\n  // Presence Mutation\n  _setPresent (presence, status) {\n    return presence.setPresence(status)\n  }\n\n  // Presence Mutation\n  _setNotPresent (presence) {\n    return presence.setNotPresent()\n  }\n\n  // Test Methods\n\n  debugSetHaveFilter (filter) {\n    this._haveFilter = filter\n    for (const { tracker } of this._trackersByCallId.values()) {\n      tracker.debugSetHaveFilter(this._haveFilter)\n    }\n  }\n}\nconst { Readable } = require('streamx')\nconst HypercoreId = require('hypercore-id-encoding')\n\nconst KeetWebRTCProxy = require('./webrtc')\n\nconst {\n  MEDIA_EVENTS\n} = require('../lib/common')\n\nmodule.exports = class MediaServer {\n  constructor (server, callId) {\n    this.server = server\n    this.swarm = server.swarm\n    this.onerror = server.onerror\n    this.callId = callId\n    this.swarmId = HypercoreId.encode(this.swarm.keyPair.publicKey)\n\n    this._proxiesByConnection = new Map()\n    this._sendingByConnection = new Map()\n    this._pendingSignalsByConnection = new Map()\n\n    this._signalSubscriptions = []\n    this._proxySubscriptions = []\n\n    this.server.internalActivateCall(this)\n\n    for (const conn of this.swarm.connections) {\n      this.addConnection(conn, this.server._rawMuxersByStream.get(conn))\n    }\n  }\n\n  close () {\n    for (const conn of this._proxiesByConnection.keys()) {\n      this.removeConnection(conn)\n    }\n\n    this.server.internalDeactivateCall(this)\n  }\n\n  addConnection (conn, rawMuxer) {\n    if (this._proxiesByConnection.has(conn)) return\n\n    const socket = this.swarm.dht.udx.createSocket()\n    const proxy = new KeetWebRTCProxy(this.callId, rawMuxer, socket, {\n      onsignal: signal => this._handleMediaSignal(conn, signal)\n    })\n    proxy.on('channel-open', () => this._onProxyOpen(conn, proxy))\n    proxy.on('channel-close', () => this._onProxyClose(conn))\n\n    this._proxiesByConnection.set(conn, proxy)\n    this._sendingByConnection.set(conn, new Set())\n  }\n\n  removeConnection (conn) {\n    const swarmId = HypercoreId.encode(conn.remotePublicKey)\n    const proxy = this._proxiesByConnection.get(conn)\n    if (!proxy) return\n\n    proxy.close()\n\n    this._proxiesByConnection.delete(conn)\n    this._sendingByConnection.delete(conn)\n    this._pendingSignalsByConnection.delete(conn)\n\n    for (const subscription of this._proxySubscriptions) {\n      subscription.push({\n        type: MEDIA_EVENTS.PROXY_CLOSE,\n        swarmId\n      })\n    }\n  }\n\n  _onProxyOpen (conn, proxy) {\n    const swarmId = HypercoreId.encode(conn.remotePublicKey)\n    for (const subscription of this._proxySubscriptions) {\n      subscription.push({\n        type: MEDIA_EVENTS.PROXY_OPEN,\n        proxyPort: proxy.proxyPort,\n        swarmId\n      })\n    }\n\n    const pendingSignals = this._pendingSignalsByConnection.get(conn)\n    if (pendingSignals) {\n      while (pendingSignals.length) {\n        proxy.sendSignal(pendingSignals.shift())\n      }\n      this._pendingSignalsByConnection.delete(conn)\n    }\n  }\n\n  _onProxyClose (conn) {\n    const swarmId = HypercoreId.encode(conn.remotePublicKey)\n    for (const subscription of this._proxySubscriptions) {\n      subscription.push({\n        type: MEDIA_EVENTS.PROXY_CLOSE,\n        swarmId\n      })\n    }\n  }\n\n  _handleMediaSignal (conn, signal) {\n    const swarmId = HypercoreId.encode(conn.remotePublicKey)\n    for (const subscription of this._signalSubscriptions) {\n      subscription.push({ swarmId, signal })\n    }\n  }\n\n  signal (conn, signal) {\n    const proxy = this._proxiesByConnection.get(conn)\n    proxy.sendSignal(signal)\n  }\n\n  subscribeMediaSignals () {\n    const stream = new Readable({\n      destroy: cb => {\n        const idx = this._signalSubscriptions.indexOf(stream)\n        if (idx !== -1) this._signalSubscriptions.splice(idx, 1)\n        cb(null)\n      }\n    })\n    this._signalSubscriptions.push(stream)\n    return stream\n  }\n\n  subscribeProxyUpdates () {\n    const stream = new Readable({\n      destroy: cb => {\n        const idx = this._proxySubscriptions.indexOf(stream)\n        if (idx !== -1) this._proxySubscriptions.splice(idx, 1)\n        cb(null)\n      }\n    })\n    this._proxySubscriptions.push(stream)\n\n    for (const [conn, proxy] of this._proxiesByConnection) {\n      if (!proxy.channelOpened) continue\n      stream.push({\n        type: MEDIA_EVENTS.PROXY_OPEN,\n        proxyPort: proxy.proxyPort,\n        swarmId: HypercoreId.encode(conn.remotePublicKey)\n      })\n    }\n\n    return stream\n  }\n}\nconst { Readable } = require('streamx')\nconst Hypercore = require('hypercore')\nconst HypercoreId = require('hypercore-id-encoding')\nconst safetyCatch = require('safety-catch')\nconst b4a = require('b4a')\n\nconst {\n  StreamsMessage,\n  PeerPresenceMessage\n} = require('../lib/messages')\nconst {\n  PRESENCE_EVENTS\n} = require('../lib/common')\n\nconst PRESENCE_PROTOCOL = 'keet-call-presence/v3'\n\nmodule.exports = class PresenceServer {\n  constructor (server, callId, firewall) {\n    this.server = server\n    this.swarm = server.swarm\n    this.onerror = server.onerror\n    this.firewall = firewall\n    this.callId = callId\n    this.closed = false\n\n    this.topic = HypercoreId.decode(callId)\n    this._description = { protocol: PRESENCE_PROTOCOL, id: this.topic }\n\n    this._directPresenceIds = new Set()\n    this._relayedPresenceBySwarmId = new Map()\n    this._streamsBySwarmId = new Map()\n    this._localStreams = null\n    this._activated = false\n\n    this._protocolsBySwarmId = new Map()\n    this._authorizedPeers = new Set()\n    this._presenceSubscriptions = []\n\n    this._firewallSubscription = null\n\n    for (const connection of this.swarm.connections) {\n      this.addConnection(connection)\n    }\n    if (this.server.shouldActivate(this.callId)) {\n      this.activate()\n    }\n  }\n\n  close () {\n    if (this._firewallSubscription) this._firewallSubscription.destroy()\n    for (const { connection, channel } of this._protocolsBySwarmId.values()) {\n      const muxer = getMuxer(connection)\n      if (muxer) muxer.unpair(this._description)\n      if (channel) channel.close()\n    }\n    this._protocolsBySwarmId.clear()\n    this.closed = true\n  }\n\n  async _backgroundObserveFirewall () {\n    try {\n      for await (const swarmIds of this._firewallSubscription) {\n        if (this.closed) return\n        for (const swarmId of swarmIds) {\n          this._authorizedPeers.add(swarmId)\n          const protocol = this._protocolsBySwarmId.get(swarmId)\n          if (!protocol || protocol.channel) continue\n          this._createChannel(protocol.connection)\n        }\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  _maybeStartFirewall () {\n    if (!this.firewall || this._firewallSubscription) return\n    this._firewallSubscription = this.firewall(this.callId)\n    this._backgroundObserveFirewall()\n  }\n\n  _bumpSubscriptions (ev) {\n    for (const sub of this._presenceSubscriptions) {\n      sub.push(ev)\n    }\n  }\n\n  // Authorization\n\n  addConnection (connection) {\n    const muxer = getMuxer(connection)\n    const remotePublicKey = connection.remotePublicKey\n    const remoteId = HypercoreId.encode(remotePublicKey)\n\n    const info = {\n      connection,\n      remotePublicKey,\n      remoteId,\n      muxer,\n      channel: null,\n      senders: null\n    }\n    this._protocolsBySwarmId.set(remoteId, info)\n\n    muxer.pair(this._description, () => this._createChannel(connection))\n\n    if (this._activated) this._createChannel(connection)\n  }\n\n  removeConnection (conn) {\n    const swarmId = HypercoreId.encode(conn.remotePublicKey)\n    this._protocolsBySwarmId.delete(swarmId)\n  }\n\n  activate () {\n    if (this._activated) return\n    this._activated = true\n\n    this._maybeStartFirewall()\n\n    for (const { connection } of this._protocolsBySwarmId.values()) {\n      this._createChannel(connection)\n    }\n  }\n\n  deactivate () {\n    // TODO: Implement\n    // this._activated = false\n  }\n\n  _createChannel (connection) {\n    const remoteId = HypercoreId.encode(connection.remotePublicKey)\n\n    // If an active participant triggers channel creation, start the firewall in response\n    this._maybeStartFirewall()\n\n    const authorized = !this.firewall || this._authorizedPeers.has(remoteId)\n    if (!authorized) return\n\n    const info = this._protocolsBySwarmId.get(remoteId)\n    if (!info) return\n\n    const muxer = getMuxer(connection)\n    const channel = muxer.createChannel({\n      id: this.topic,\n      protocol: PRESENCE_PROTOCOL,\n      onopen: () => this._onChannelOpen(info),\n      onclose: () => this._onChannelClose(info),\n      messages: [\n        {\n          encoding: PeerPresenceMessage,\n          onmessage: req => this._onPresenceUpdate(info, false, req)\n        },\n        {\n          encoding: StreamsMessage,\n          onmessage: req => this._onStreamsUpdate(info, req)\n        }\n      ]\n    })\n    if (channel === null) return\n\n    info.channel = channel\n    info.senders = {\n      updatePresence: info.channel.messages[0],\n      updateStreams: info.channel.messages[1]\n    }\n    info.channel.open()\n  }\n\n  _onChannelOpen (info) {\n    for (const swarmId of this._directPresenceIds) {\n      info.senders.updatePresence.send({\n        key: HypercoreId.decode(swarmId),\n        present: true\n      })\n    }\n    if (this._localStreams) {\n      info.senders.updatePresence.send({\n        key: HypercoreId.decode(this.swarm.keyPair.publicKey),\n        present: true\n      })\n      info.senders.updateStreams.send(this._localStreams)\n    }\n  }\n\n  _onChannelClose (info) {\n    this._onStreamsUpdate(info, [])\n    this._onPresenceUpdate(info, true, { key: info.remotePublicKey, present: false })\n    info.channel = null\n    info.senders = null\n  }\n\n  _onPresenceUpdate (info, channelClosed, { key, present }) {\n    if (b4a.equals(key, this.swarm.keyPair.publicKey)) return\n\n    const targetId = HypercoreId.encode(key)\n    const sourceId = info.remoteId\n    const direct = targetId === sourceId\n\n    if (present) {\n      this._onPeerPresent(sourceId, targetId, direct)\n    } else {\n      this._onPeerNotPresent(sourceId, targetId, direct, channelClosed)\n    }\n  }\n\n  _onPeerPresent (sourceId, targetId, direct) {\n    const alreadyDirect = this._directPresenceIds.has(targetId)\n    const alreadyRelayed = this._relayedPresenceBySwarmId.has(targetId)\n\n    if (direct) {\n      this._directPresenceIds.add(sourceId)\n      // Once a direct connection is established, ignore relayed info\n      this._relayedPresenceBySwarmId.delete(sourceId)\n    } else {\n      let peers = this._relayedPresenceBySwarmId.get(targetId)\n      if (!peers) {\n        peers = new Set()\n        this._relayedPresenceBySwarmId.set(targetId, peers)\n      }\n      peers.add(sourceId)\n    }\n\n    if (direct && !alreadyDirect) {\n      // Since this is a direct connection, relay presence to other peers\n      for (const info of this._protocolsBySwarmId.values()) {\n        if (!info.senders || (info.remoteId === sourceId)) continue\n        info.senders.updatePresence.send({\n          key: HypercoreId.decode(sourceId),\n          present: true\n        })\n      }\n    }\n\n    // If this is the first time seeing this peer, push an available event\n    if (alreadyDirect || alreadyRelayed) return\n\n    this._bumpSubscriptions({\n      type: PRESENCE_EVENTS.PEER_PRESENT,\n      swarmId: targetId\n    })\n  }\n\n  _removeRelayedPeer (sourceId, targetId) {\n    const peers = this._relayedPresenceBySwarmId.get(targetId)\n    if (!peers) return false\n\n    peers.delete(sourceId)\n    if (peers.size) return false\n\n    this._relayedPresenceBySwarmId.delete(targetId)\n    if (this._directPresenceIds.has(targetId)) return false\n\n    return true\n  }\n\n  _onPeerNotPresent (sourceId, targetId, direct, channelClosed) {\n    const bumps = new Set()\n    if (direct) {\n      bumps.add(sourceId)\n      this._directPresenceIds.delete(sourceId)\n      // Since this is a direct connection, we disregard any relayed information\n      this._relayedPresenceBySwarmId.delete(sourceId)\n      // Remove sourceId from the relaying set for every other peer\n      if (channelClosed) {\n        for (const swarmId of this._relayedPresenceBySwarmId.keys()) {\n          if (this._removeRelayedPeer(sourceId, swarmId)) {\n            bumps.add(swarmId)\n          }\n        }\n      }\n      // Since this is a direct connection, relay presence to other peers\n      for (const info of this._protocolsBySwarmId.values()) {\n        if (!info.senders || (info.remoteId === sourceId)) continue\n        info.senders.updatePresence.send({\n          key: HypercoreId.decode(sourceId),\n          present: false\n        })\n      }\n    } else {\n      if (this._removeRelayedPeer(sourceId, targetId)) {\n        bumps.add(targetId)\n      }\n    }\n\n    const empty = (this._directPresenceIds.size === 0) && (this._relayedPresenceBySwarmId.size === 0)\n    if (!this._activated && this.firewall && this._firewallSubscription && empty) {\n      this._firewallSubscription.destroy()\n      this._firewallSubscription = null\n    }\n\n    for (const swarmId of bumps) {\n      this._bumpSubscriptions({\n        type: PRESENCE_EVENTS.PEER_NOT_PRESENT,\n        swarmId\n      })\n    }\n  }\n\n  _onStreamsUpdate (info, streams) {\n    const existingStreams = this._streamsBySwarmId.get(info.remoteId)\n\n    const newStreams = new Map()\n    for (const info of streams) {\n      newStreams.set(info.id, info)\n    }\n\n    if (existingStreams) {\n      for (const [id, streamInfo] of existingStreams) {\n        if (newStreams.has(id)) continue\n        this._bumpSubscriptions({\n          type: PRESENCE_EVENTS.STREAM_UNAVAILABLE,\n          swarmId: info.remoteId,\n          streamId: streamInfo.id,\n          streamName: streamInfo.name\n        })\n      }\n    }\n\n    for (const [id, streamInfo] of newStreams) {\n      if (existingStreams && existingStreams.has(id)) continue\n      this._bumpSubscriptions({\n        type: PRESENCE_EVENTS.STREAM_AVAILABLE,\n        swarmId: info.remoteId,\n        streamId: streamInfo.id,\n        streamName: streamInfo.name\n      })\n    }\n\n    for (const [id, streamInfo] of newStreams) {\n      const existingInfo = existingStreams && existingStreams.get(id)\n      if (existingInfo && sameStatus(existingInfo, streamInfo)) continue\n      this._bumpSubscriptions({\n        type: PRESENCE_EVENTS.STREAM_STATUS_CHANGED,\n        swarmId: info.remoteId,\n        streamId: streamInfo.id,\n        audioMuted: streamInfo.audioMuted,\n        videoMuted: streamInfo.videoMuted\n      })\n    }\n\n    if (newStreams.size) {\n      this._streamsBySwarmId.set(info.remoteId, newStreams)\n    } else {\n      this._streamsBySwarmId.delete(info.remoteId)\n    }\n  }\n\n  // Presence Mutations\n\n  setPresence (presence) {\n    if (!this._localStreams) {\n      this._localStreams = []\n      for (const info of this._protocolsBySwarmId.values()) {\n        if (!info.senders) continue\n        info.senders.updatePresence.send({\n          key: this.swarm.keyPair.publicKey,\n          present: true\n        })\n      }\n    }\n    for (const info of this._protocolsBySwarmId.values()) {\n      if (!info.senders) continue\n      info.senders.updateStreams.send(presence.streams)\n    }\n    this._localStreams = presence.streams\n  }\n\n  setNotPresent () {\n    if (this._localStreams) {\n      this._localStreams = null\n      for (const info of this._protocolsBySwarmId.values()) {\n        if (!info.senders) continue\n        info.senders.updatePresence.send({\n          key: this.swarm.keyPair.publicKey,\n          present: false\n        })\n      }\n    }\n    for (const info of this._protocolsBySwarmId.values()) {\n      if (!info.senders) continue\n      info.senders.updateStreams.send([])\n    }\n  }\n\n  // Presence Queries/Subscriptions\n\n  subscribePresence () {\n    const stream = new Readable({\n      destroy: cb => {\n        const idx = this._presenceSubscriptions.indexOf(stream)\n        if (idx !== -1) this._presenceSubscriptions.splice(idx, 1)\n        cb(null)\n      }\n    })\n    this._presenceSubscriptions.push(stream)\n\n    const events = this.getPresentPeerEvents()\n    for (const ev of events) {\n      stream.push(ev)\n    }\n\n    return stream\n  }\n\n  getPresentPeerEvents () {\n    const evs = []\n    for (const swarmId of this._directPresenceIds) {\n      evs.push({\n        type: PRESENCE_EVENTS.PEER_PRESENT,\n        swarmId\n      })\n    }\n    for (const swarmId of this._relayedPresenceBySwarmId.keys()) {\n      if (this._directPresenceIds.has(swarmId)) continue\n      evs.push({\n        type: PRESENCE_EVENTS.PEER_PRESENT,\n        swarmId\n      })\n    }\n    for (const [swarmId, streams] of this._streamsBySwarmId) {\n      for (const [streamId, { name, audioMuted, videoMuted }] of streams) {\n        evs.push({\n          type: PRESENCE_EVENTS.STREAM_AVAILABLE,\n          streamName: name,\n          swarmId,\n          streamId\n        })\n        evs.push({\n          type: PRESENCE_EVENTS.STREAM_STATUS_CHANGED,\n          swarmId,\n          streamId,\n          audioMuted,\n          videoMuted\n        })\n      }\n    }\n    return evs\n  }\n}\n\nfunction sameStatus (s1, s2) {\n  return (s1.audioMuted === s2.audioMuted) && (s1.videoMuted === s2.videoMuted)\n}\n\nfunction getMuxer (conn) {\n  let muxer = Hypercore.getProtocolMuxer(conn)\n  if (!muxer) {\n    Hypercore.createProtocolStream(conn)\n    muxer = Hypercore.getProtocolMuxer(conn)\n  }\n  return muxer\n}\nconst { EventEmitter } = require('events')\nconst safetyCatch = require('safety-catch')\nconst Hypercore = require('hypercore')\nconst HypercoreId = require('hypercore-id-encoding')\n\nconst {\n  HandshakeMessage,\n  SignalMessage\n} = require('../lib/messages')\n\nconst LOCALHOST = '127.0.0.1'\nconst PROTOCOL_NAME = 'keet-webrtc/v1'\n\nmodule.exports = class KeetWebRTCProxy extends EventEmitter {\n  constructor (callId, rawMuxer, socket, opts = {}) {\n    super()\n    const {\n      onerror = console.error,\n      onsignal\n    } = opts\n\n    this.callId = callId\n    this.rawMuxer = rawMuxer\n    this.closed = false\n    this.proxyPort = 0\n    this.channelOpened = false\n\n    this.stream = this.rawMuxer.connection\n    this.localAlias = this.rawMuxer.createLocalAlias()\n    this.remoteAlias = -1 // Set after handshake\n\n    this._proxy = socket\n    this._onerror = onerror\n    this._onsignal = onsignal\n\n    this._rinfo = null\n    this._sendBuffer = []\n    this._recvBuffer = []\n    this._listeners = []\n\n    this._muxer = Hypercore.getProtocolMuxer(this.stream)\n    if (!this._muxer) {\n      this.stream = Hypercore.createProtocolStream(this.stream)\n      this._muxer = Hypercore.getProtocolMuxer(this.stream)\n    }\n    this._channel = null\n    this._senders = null\n\n    this._muxerInfo = {\n      protocol: PROTOCOL_NAME,\n      id: HypercoreId.decode(this.callId)\n    }\n    this._muxer.pair(this._muxerInfo, () => this._createChannel())\n    this._createChannel()\n\n    this._openProxy()\n  }\n\n  _openProxy () {\n    this._proxy.bind(0, LOCALHOST)\n    this._proxy.on('message', this._handleLocalData.bind(this))\n    this.proxyPort = this._proxy.address().port\n  }\n\n  close () {\n    if (this.closed) return\n    this.closed = true\n\n    this._channel.close()\n    this._proxy.close().catch(safetyCatch)\n    this._muxer.unpair(this._muxerInfo)\n  }\n\n  _createChannel () {\n    const messages = [\n      {\n        encoding: SignalMessage,\n        onmessage: req => this._onsignal(req)\n      }\n    ]\n    const channel = this._muxer.createChannel({\n      protocol: PROTOCOL_NAME,\n      handshake: HandshakeMessage,\n      onclose: this._onChannelClose.bind(this),\n      onopen: this._onChannelOpen.bind(this),\n      onerror: err => console.error('ERR HERE:', err),\n      id: HypercoreId.decode(this.callId),\n      messages\n    })\n    if (channel === null) return\n\n    this._channel = channel\n    this._senders = {\n      signal: channel.messages[0]\n    }\n\n    this._channel.open({ alias: this.localAlias })\n  }\n\n  _onChannelOpen ({ alias }) {\n    this.channelOpened = true\n\n    this.remoteAlias = alias\n    this.rawMuxer.registerProxy(this.remoteAlias, this)\n\n    this.emit('channel-open')\n\n    while (this._sendBuffer.length) {\n      this.rawMuxer.send(this.localAlias, this._sendBuffer.pop())\n    }\n  }\n\n  _onChannelClose () {\n    this.channelOpened = false\n\n    if (this.remoteAlias === -1) return\n\n    this.rawMuxer.unregisterProxy(this.remoteAlias, this)\n    this.remoteAlias = -1\n    this._rinfo = null\n\n    this.emit('channel-close')\n  }\n\n  // Protocol Handlers\n\n  _handleLocalData (message, rinfo) {\n    if (this.closed || this.remoteAlias === -1) return\n    if (rinfo.host !== LOCALHOST) return\n\n    if (!this._rinfo) {\n      // This is the first time the proxy has been connected to, so send buffered messages.\n      this._rinfo = rinfo\n      while (this._recvBuffer.length) {\n        this._proxy.trySend(this._recvBuffer.pop(), rinfo.port, LOCALHOST)\n      }\n    }\n\n    if (this.remoteAlias === -1) {\n      this._sendBuffer.unshift(message)\n    } else {\n      this.rawMuxer.send(this.localAlias, message)\n    }\n  }\n\n  // Called by RawStreamMuxer\n\n  handleRawStreamData (message) {\n    if (this.closed) return\n\n    if (!this._rinfo) {\n      this._recvBuffer.unshift(message)\n      return\n    }\n\n    this._proxy.trySend(message, this._rinfo.port, LOCALHOST)\n  }\n\n  // Public API\n\n  sendSignal (signal) {\n    if (this.closed) return\n    this._senders.signal.send(signal)\n  }\n}\nconst { CURRENT_ABI } = require('./lib/internal')\nconst { MAIL_STATUSES, MAIL_TYPES, DM_STATUSES } = require('./lib/mailbox')\nconst { FEATURES, MIN_ABIS, isFeatureSupported } = require('./lib/features')\nconst { CONFIG, VALIDATION, isValidConfigKey } = require('./lib/config')\nconst { PREFERENCES, isValidPreferenceKey, getPreferenceKeyName } = require('./lib/preferences')\nconst { ERRORS, KeetError } = require('./lib/errors')\nconst { MemberCapabilities, MemberRoles, getCapabilitiesForRole } = require('./lib/members')\nconst { GENERIC_EVENTS, DISPLAY_TYPES, isDisplaySupported } = require('./lib/chat')\n\nmodule.exports = {\n  CURRENT_ABI,\n  MAIL_TYPES,\n  MAIL_STATUSES,\n  DM_STATUSES,\n  PREFERENCES,\n  CONFIG,\n  FEATURES,\n  MIN_ABIS,\n  VALIDATION,\n  ERRORS,\n  GENERIC_EVENTS,\n  DISPLAY_TYPES,\n  MemberCapabilities,\n  MemberRoles,\n  getCapabilitiesForRole,\n  isDisplaySupported,\n  isFeatureSupported,\n  isValidConfigKey,\n  isValidPreferenceKey,\n  getPreferenceKeyName,\n  KeetError\n}\nconst GENERIC_EVENTS = {\n  MEMBER_JOINED: 1,\n  CALL_STARTED: 2,\n  ROOM_AVATAR_CHANGED: 3,\n  INVITATION_CREATED: 4,\n  MEMBER_LEFT: 5,\n  ROOM_TITLE_CHANGED: 6,\n  MEMBER_REMOVED: 7\n}\n\nconst DISPLAY_TYPES = {\n  MENTION: 1,\n  HTTP_LINK: 2,\n  PEAR_LINK: 3,\n  BOLD: 4,\n  ITALIC: 5,\n  CODE: 6,\n  EMOJI: 7,\n  CODE_BLOCK: 8,\n  STRIKE_THROUGH: 9\n}\n\nconst MIN_ABIS = {\n  [DISPLAY_TYPES.MENTION]: 0,\n  [DISPLAY_TYPES.HTTP_LINK]: 3,\n  [DISPLAY_TYPES.PEAR_LINK]: 3,\n  [DISPLAY_TYPES.BOLD]: 3,\n  [DISPLAY_TYPES.ITALIC]: 3,\n  [DISPLAY_TYPES.CODE]: 3,\n  [DISPLAY_TYPES.EMOJI]: 3,\n  [DISPLAY_TYPES.CODE_BLOCK]: 3,\n  [DISPLAY_TYPES.STRIKE_THROUGH]: 3\n}\n\nfunction isDisplaySupported (abi, displayType) {\n  const minABI = MIN_ABIS[displayType]\n  if (minABI !== 0 && !minABI) return false\n  return minABI <= abi\n}\n\nmodule.exports = {\n  GENERIC_EVENTS,\n  DISPLAY_TYPES,\n  isDisplaySupported\n}\nconst CONFIG = {\n  V1_CONFIG_KEY: 0,\n  // Identity\n  ID_PUBLIC_KEY: 'keet-identity-public-key',\n  ID_SHARED_INVITE_SEED: 'keet-shared-invite-seed',\n  ID_RECOVERY_PHRASE: 'keet-recovery-phrase',\n  // Room\n  ROOM_TITLE: 'title',\n  ROOM_DESCRIPTION: 'description',\n  ROOM_AVATAR: 'avatar',\n  ROOM_TYPE: 'roomType',\n  ROOM_CAN_CALL: 'canCall',\n  ROOM_MIRRORS: 'mirrors',\n  ROOM_IS_EXPERIMENTAL: 'experimental',\n  PINNED_MESSAGES: 'pinnedMessages',\n  ROOM_LOCKED: 'locked'\n}\n\nconst VALIDATION = {\n  PINNED_MESSAGES_LIMIT: 10\n}\n\nfunction isValidConfigKey (key) {\n  return Object.values(CONFIG).includes(key)\n}\n\nmodule.exports = { CONFIG, VALIDATION, isValidConfigKey }\nconst ERRORS = {\n  // Drives\n  RESOURCE_CLOSING: 'RESOURCE_CLOSING',\n  ONE_WRITABLE_DRIVE_PER_KEY: 'ONE_WRITABLE_DRIVE_PER_KEY',\n  // Invitations\n  INVITE_EXPIRED: 'INVITE_EXPIRED',\n  INVALID_INVITATION_TYPE: 'INVALID_INVITATION_TYPE',\n  INVALID_PRODUCTION_INVITATION: 'INVALID_PRODUCTION_INVITATION',\n  UNKNOWN_EXPIRATION: 'UNKNOWN_EXPIRATION',\n  // Pairing\n  PAIRING_EXPIRED: 'PAIRING_EXPIRED',\n  PAIRING_CANDIDATE_NOT_FOUND: 'PAIRING_CANDIDATE_NOT_FOUND',\n  // Permissions\n  MODERATORS_ONLY: 'MODERATORS_ONLY',\n  // Rooms\n  CANNOT_RELEASE_CLOSED_ROOM: 'CANNOT_RELEASE_CLOSED_ROOM',\n  UNKNOWN_ROOM_CONFIG_KEY: 'UNKNOWN_ROOM_CONFIG_KEY',\n  ROOM_LOCKED: 'ROOM_LOCKED',\n  // Commands\n  UNKNOWN_ROOM_COMMAND: 'UNKNOWN_ROOM_COMMAND',\n  INVALID_ROOM_COMMAND_ARGUMENTS: 'INVALID_ROOM_COMMAND_ARGUMENTS',\n  // Autobase\n  UNSUPPORTED_ABI_VERSION: 'UNSUPPORTED_ABI_VERSION',\n  AUTOBASE_IS_NOT_WRITEABLE: 'AUTOBASE_IS_NOT_WRITEABLE',\n  CANNOT_LEAVE_ROOM: 'CANNOT_LEAVE_ROOM',\n  // Plugins\n  PRIVATE_PROFILE_NOT_ENABLED: 'PRIVATE_PROFILE_NOT_ENABLED',\n  PLUGIN_NOT_ENABLED: 'PLUGIN_NOT_ENABLED',\n  // Identity\n  ALREADY_MIGRATING: 'ALREADY_MIGRATING',\n  IDENTITY_REQUIRED: 'IDENTITY_REQUIRED',\n  CANNOT_UPDATE_DEVICE_DURING_MIGRATION: 'CANNOT_UPDATE_DEVICE_DURING_MIGRATION',\n  // Profile\n  USERNAME_TOO_LONG: 'USERNAME_TOO_LONG',\n  AVATAR_TOO_LARGE: 'AVATAR_TOO_LARGE',\n  // Files\n  FILE_PREVIEW_SIZE_EXCEEDED: 'FILE_PREVIEW_SIZE_EXCEEDED',\n  // Feature Handling\n  FEATURE_NOT_SUPPORTED: 'FEATURE_NOT_SUPPORTED'\n}\n\nclass KeetError extends Error {\n  constructor (msg, code, fn = KeetError) {\n    super(msg ? `${code}: ${msg}` : code)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name () {\n    return 'KeetError'\n  }\n\n  static isKeetError (err) {\n    return err?.name === KeetError.name\n  }\n\n  static RESOURCE_CLOSING (msg = '') {\n    return new KeetError(msg, 'RESOURCE_CLOSING', KeetError.RESOURCE_CLOSING)\n  }\n\n  static ONE_WRITABLE_DRIVE_PER_KEY (msg = 'Only one writable drive per key can be made') {\n    return new KeetError(msg, 'ONE_WRITABLE_DRIVE_PER_KEY', KeetError.ONE_WRITABLE_DRIVE_PER_KEY)\n  }\n\n  static INVITE_EXPIRED (msg = 'Invitation has expired') {\n    return new KeetError(msg, 'INVITE_EXPIRED', KeetError.INVITE_EXPIRED)\n  }\n\n  static INVALID_INVITATION_TYPE (msg = 'Attempting to use a device sync invitation as a room invitation') {\n    return new KeetError(msg, 'INVALID_INVITATION_TYPE', KeetError.INVALID_INVITATION_TYPE)\n  }\n\n  static INVALID_PRODUCTION_INVITATION (msg = 'Attempting to use a production invitation in a test environment') {\n    return new KeetError(msg, 'INVALID_PRODUCTION_INVITATION', KeetError.INVALID_PRODUCTION_INVITATION)\n  }\n\n  static UNKNOWN_EXPIRATION (msg = '') {\n    return new KeetError(msg, 'UNKNOWN_EXPIRATION', KeetError.UNKNOWN_EXPIRATION)\n  }\n\n  static PAIRING_EXPIRED (msg = 'Pairing attempt expired') {\n    return new KeetError(msg, 'PAIRING_EXPIRED', KeetError.PAIRING_EXPIRED)\n  }\n\n  static PAIRING_CANDIDATE_NOT_FOUND (msg = 'Pairing candidate does not exist') {\n    return new KeetError(msg, 'PAIRING_CANDIDATE_NOT_FOUND', KeetError.PAIRING_CANDIDATE_NOT_FOUND)\n  }\n\n  static MODERATORS_ONLY (msg = '') {\n    return new KeetError(msg, 'MODERATORS_ONLY', KeetError.MODERATORS_ONLY)\n  }\n\n  static CANNOT_RELEASE_CLOSED_ROOM (msg = 'Cannot release a room that was not previously opened') {\n    return new KeetError(msg, 'CANNOT_RELEASE_CLOSED_ROOM', KeetError.CANNOT_RELEASE_CLOSED_ROOM)\n  }\n\n  static UNSUPPORTED_ABI_VERSION (msg = '') {\n    return new KeetError(msg, 'UNSUPPORTED_ABI_VERSION', KeetError.UNSUPPORTED_ABI_VERSION)\n  }\n\n  static AUTOBASE_IS_NOT_WRITEABLE (msg = '') {\n    return new KeetError(msg, 'AUTOBASE_IS_NOT_WRITEABLE', KeetError.AUTOBASE_IS_NOT_WRITEABLE)\n  }\n\n  static CANNOT_LEAVE_ROOM (msg = '') {\n    return new KeetError(msg, 'CANNOT_LEAVE_ROOM', KeetError.CANNOT_LEAVE_ROOM)\n  }\n\n  static PRIVATE_PROFILE_NOT_ENABLED (msg = 'Private profile plugin is not enabled on this room') {\n    return new KeetError(msg, 'PRIVATE_PROFILE_NOT_ENABLED', KeetError.PRIVATE_PROFILE_NOT_ENABLED)\n  }\n\n  static PLUGIN_NOT_ENABLED (msg = 'Plugin is not enabled for this room') {\n    return new KeetError(msg, 'PLUGIN_NOT_ENABLED', KeetError.PLUGIN_NOT_ENABLED)\n  }\n\n  static ALREADY_MIGRATING (msg = '') {\n    return new KeetError(msg, 'ALREADY_MIGRATING', KeetError.ALREADY_MIGRATING)\n  }\n\n  static IDENTITY_REQUIRED (msg = '') {\n    return new KeetError(msg, 'IDENTITY_REQUIRED', KeetError.IDENTITY_REQUIRED)\n  }\n\n  static CANNOT_UPDATE_DEVICE_DURING_MIGRATION (msg = '') {\n    return new KeetError(msg, 'CANNOT_UPDATE_DEVICE_DURING_MIGRATION', KeetError.CANNOT_UPDATE_DEVICE_DURING_MIGRATION)\n  }\n\n  static USERNAME_TOO_LONG (msg = '') {\n    return new KeetError(msg, 'USERNAME_TOO_LONG', KeetError.USERNAME_TOO_LONG)\n  }\n\n  static AVATAR_TOO_LARGE (msg = '') {\n    return new KeetError(msg, 'AVATAR_TOO_LARGE', KeetError.AVATAR_TOO_LARGE)\n  }\n\n  static FILE_PREVIEW_SIZE_EXCEEDED (msg = '') {\n    return new KeetError(msg, 'FILE_PREVIEW_SIZE_EXCEEDED', KeetError.FILE_PREVIEW_SIZE_EXCEEDED)\n  }\n\n  static UNKNOWN_ROOM_CONFIG_KEY (msg = '') {\n    return new KeetError(msg, 'UNKNOWN_ROOM_CONFIG_KEY', KeetError.UNKNOWN_ROOM_CONFIG_KEY)\n  }\n\n  static ROOM_LOCKED (msg = '') {\n    return new KeetError(msg, 'ROOM_LOCKED', KeetError.ROOM_LOCKED)\n  }\n\n  static UNKNOWN_ROOM_COMMAND (msg = '') {\n    return new KeetError(msg, 'UNKNOWN_ROOM_COMMAND', KeetError.UNKNOWN_ROOM_COMMAND)\n  }\n\n  static INVALID_ROOM_COMMAND_ARGUMENTS (msg = '') {\n    return new KeetError(msg, 'INVALID_ROOM_COMMAND_ARGUMENTS', KeetError.INVALID_ROOM_COMMAND_ARGUMENTS)\n  }\n\n  static FEATURE_NOT_SUPPORTED (msg = '') {\n    return new KeetError(msg, 'FEATURE_NOT_SUPPORTED', KeetError.FEATURE_NOT_SUPPORTED)\n  }\n}\n\nmodule.exports = {\n  ERRORS,\n  KeetError\n}\nconst FEATURES = {\n  DMS: 1,\n  LEAVE_ROOM: 2,\n  V2_CONFIG: 3,\n  PINNED_MESSAGES: 4,\n  ROOM_RENAME_EVENT: 5,\n  REPLY_TO: 6,\n  PERMISSION_DOWNGRADE: 7,\n  REMOVE_MEMBER: 8,\n  MUTE_MEMBER: 9,\n  V2_PRIVATE_PROFILE: 10,\n  ROOM_LOCKING: 11\n}\n\n// For each feature, record the ABI version where it was first introduced\n// Since our features are append-only, all future ABI versions must support the feature\nconst MIN_ABIS = {\n  [FEATURES.LEAVE_ROOM]: 1,\n  [FEATURES.V2_CONFIG]: 1,\n  [FEATURES.PINNED_MESSAGES]: 2,\n  [FEATURES.ROOM_RENAME_EVENT]: 2,\n  [FEATURES.REPLY_TO]: 2,\n  [FEATURES.MUTE_MEMBER]: 3,\n  [FEATURES.DMS]: 4,\n  [FEATURES.PERMISSION_DOWNGRADE]: 5,\n  [FEATURES.REMOVE_MEMBER]: 6,\n  [FEATURES.ROOM_LOCKING]: 7,\n  [FEATURES.V2_PRIVATE_PROFILE]: 8\n}\n\nfunction isFeatureSupported (abi, feature) {\n  const minABI = MIN_ABIS[feature]\n  if (!minABI) return false\n  return minABI <= abi\n}\n\nmodule.exports = {\n  FEATURES,\n  MIN_ABIS,\n  isFeatureSupported\n}\nconst CURRENT_ABI = {\n  // !!! Bump this whenever experimental mode should start using a new ABI version\n  EXPERIMENTAL: 7,\n  // !!! Bump this whenever production should start using a new ABI version\n  STABLE: 6\n}\n\nmodule.exports = {\n  CURRENT_ABI\n}\nconst MAIL_TYPES = {\n  DM_REQUEST: 0\n}\n\nconst DM_STATUSES = {\n  ACCEPTED: 1,\n  REJECTED: 2,\n  PENDING: 3,\n  DISCARDED: 4\n}\n\nconst MAIL_STATUSES = {\n  ...DM_STATUSES,\n  UNDELIVERED: 3,\n  DELIVERED: 4,\n  FAILED: 5\n}\n\nmodule.exports = { MAIL_TYPES, DM_STATUSES, MAIL_STATUSES }\n// Member Capabilities\nconst CAN_SHARE_FILES = 16\nconst CAN_REACT = 8\nconst CAN_MODERATE = 4\nconst CAN_INDEX = 2\nconst CAN_WRITE = 1\n\n// !!! NOTE: Whenever we add more capabilities, bump this\nconst HIGHEST_CAP = CAN_SHARE_FILES\n\nconst writeCapabilities = {\n  CAN_SHARE_FILES,\n  CAN_WRITE,\n  CAN_REACT\n}\n\nconst capabilities = {\n  ...writeCapabilities,\n  CAN_MODERATE,\n  CAN_INDEX\n}\n\nconst MemberCapabilities = {\n  ...capabilities,\n  ALL_WRITE_CAPABILITIES: CAN_WRITE | CAN_SHARE_FILES | CAN_REACT,\n  ALL_CAPABILITIES: (2 * HIGHEST_CAP) - 1\n}\n\nconst MemberRoles = {\n  ADMIN: 1,\n  MODERATOR: 2,\n  PEER: 3,\n  READ_ONLY: 4\n}\n\nfunction getCapabilitiesForRole (role) {\n  switch (role) {\n    case MemberRoles.ADMIN:\n      return MemberCapabilities.ALL_CAPABILITIES\n    case MemberRoles.MODERATOR:\n      return MemberCapabilities.ALL_WRITE_CAPABILITIES | capabilities.CAN_MODERATE\n    case MemberRoles.PEER:\n      return MemberCapabilities.ALL_WRITE_CAPABILITIES\n    case MemberRoles.READ_ONLY:\n      return 0\n    default:\n      return 0\n  }\n}\n\nmodule.exports = {\n  HIGHEST_CAP,\n  writeCapabilities,\n  capabilities,\n  MemberCapabilities,\n  MemberRoles,\n  getCapabilitiesForRole\n}\nconst PREFERENCES_INDEX_TO_KEY = [\n  'isFullyMuted',\n  'isMentionsOnlyMuted'\n]\nconst PREFERENCES = {\n  IS_FULLY_MUTED: 1,\n  IS_MENTIONS_ONLY_MUTED: 2\n}\n\nfunction getPreferenceKeyName (key) {\n  return PREFERENCES_INDEX_TO_KEY[key - 1]\n}\n\nfunction isValidPreferenceKey (key) {\n  return Object.values(PREFERENCES).includes(key)\n}\n\nmodule.exports = {\n  PREFERENCES,\n  isValidPreferenceKey,\n  getPreferenceKeyName\n}\n{\n  \"name\": \"@holepunchto/keet-core-api\",\n  \"description\": \"API definitions and structured error types for Keet Core\",\n  \"version\": \"1.36.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test/index.js\",\n    \"test:generate\": \"brittle -r test/index.js test/*.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"Holepunch Inc\",\n  \"license\": \"UNLICENSED\",\n  \"files\": [\n    \"index.js\",\n    \"api.json\",\n    \"lib/**.js\"\n  ],\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.0\",\n    \"standard\": \"^17.1.0\"\n  }\n}\nconst SchemaBuilder = require('./lib/schema-builder')\nconst KeetSchema = require('./lib/keet')\nconst InternalSchema = require('./lib/internal')\nconst ConfigSchema = require('./lib/config')\nconst ChatSchema = require('./lib/chat')\nconst MemberSchema = require('./lib/members')\nconst ReactionSchema = require('./lib/reactions')\nconst InvitationSchema = require('./lib/invitations')\nconst DeviceSchema = require('./lib/devices')\nconst MailboxSchema = require('./lib/mailbox')\nconst PrivateMailboxSchema = require('./lib/private-mailbox')\nconst PrivateRoomSchema = require('./lib/private-rooms')\nconst PrivateDeviceSchema = require('./lib/private-devices')\nconst PluginSchema = require('./lib/plugins')\nconst PrivateProfileSchema = require('./lib/plugins/private-profile')\n\nmodule.exports = {\n  SchemaBuilder,\n  KeetSchema,\n  InternalSchema,\n  ConfigSchema,\n  ChatSchema,\n  MemberSchema,\n  ReactionSchema,\n  InvitationSchema,\n  DeviceSchema,\n  MailboxSchema,\n  PluginSchema,\n  PrivateProfileSchema,\n  PrivateMailboxSchema,\n  PrivateRoomSchema,\n  PrivateDeviceSchema\n}\nconst HyperIndex = require('@holepunchto/hyperindex')\n\nconst {\n  IndexMemberId\n} = require('../members/messages')\nconst {\n  PRIMARY_THREAD_ID,\n  IndexEventId,\n  IndexMessageId,\n  ClockIndexEncoding,\n  EventIdValueEncoding,\n  EventRecord\n} = require('./messages')\nconst {\n  AddChatMessageOperation,\n  UpdateChatMessageOperation,\n  RemoveChatMessageOperation,\n  AddGenericEventOperation,\n  RemoveGenericEventOperation,\n  AddFileOperation,\n  RemoveFileOperation\n} = require('./ops')\n\nmodule.exports = class ChatSchema {\n  static Record = EventRecord\n\n  static Messages = {\n    PRIMARY_THREAD_ID\n  }\n\n  static Operations = {\n    AddChatMessageOperation,\n    UpdateChatMessageOperation,\n    RemoveChatMessageOperation,\n    AddGenericEventOperation,\n    RemoveGenericEventOperation,\n    AddFileOperation,\n    RemoveFileOperation\n  }\n\n  static ChatCollection = {\n    keyEncoding: IndexEventId,\n    valueEncoding: EventRecord\n  }\n\n  static ChatIndexes = [\n    {\n      keyEncoding: IndexMessageId, // eventIdsByMessageId\n      valueEncoding: EventIdValueEncoding\n    },\n    {\n      keyEncoding: ClockIndexEncoding, // eventIdsByClock\n      valueEncoding: EventIdValueEncoding\n    },\n    {\n      keyEncoding: [IndexMemberId, ...IndexEventId] // mentionsByMemberId\n    },\n    {\n      keyEncoding: [HyperIndex.STRING, HyperIndex.BUFFER, HyperIndex.UINT] // drivesByPath\n    }\n  ]\n}\nconst c = require('compact-encoding')\nconst HyperIndex = require('@holepunchto/hyperindex')\nconst { GENERIC_EVENTS, DISPLAY_TYPES } = require('@holepunchto/keet-core-api')\n\n// 0 is reserved for the the primary (top-level) thread, so all other thread IDs begin at 1\n// (i.e. the response thread for message 0 has thread ID 1)\nconst PRIMARY_THREAD_ID = 0\n\nconst IndexEventId = [HyperIndex.UINT, HyperIndex.UINT]\nconst IndexMessageId = [HyperIndex.BUFFER, HyperIndex.UINT]\nconst MemberId = c.fixed32\nconst ClockIndexEncoding = HyperIndex.UINT\n\nconst MessageId = {\n  preencode (state, id) {\n    c.fixed32.preencode(state, id.key)\n    c.uint.preencode(state, id.seq)\n  },\n  encode (state, id) {\n    c.fixed32.encode(state, id.key)\n    c.uint.encode(state, id.seq)\n  },\n  decode (state) {\n    return {\n      key: c.fixed32.decode(state),\n      seq: c.uint.decode(state)\n    }\n  }\n}\n\nconst EventIdValueEncoding = {\n  preencode (state, m) {\n    c.uint.preencode(state, m[0])\n    c.uint.preencode(state, m[1])\n  },\n  encode (state, m) {\n    c.uint.encode(state, m[0])\n    c.uint.encode(state, m[1])\n  },\n  decode (state) {\n    return [c.uint.decode(state), c.uint.decode(state)]\n  }\n}\n\nconst Mention = {\n  TYPE: DISPLAY_TYPES.MENTION,\n  preencode (state, m) {\n    MemberId.preencode(state, m.memberId)\n    Range.preencode(state, m)\n  },\n  encode (state, m) {\n    MemberId.encode(state, m.memberId)\n    Range.encode(state, m)\n  },\n  decode (state) {\n    return {\n      memberId: MemberId.decode(state),\n      ...Range.decode(state)\n    }\n  }\n}\n\nconst LinkPreview = {\n  preencode (state, m) {\n    let flags = 0\n    if (m.title) flags |= 1\n    if (m.description) flags |= 2\n    if (m.file) flags |= 4\n    c.uint.preencode(state, flags)\n    c.string.preencode(state, m.url)\n    if (m.title) c.string.preencode(state, m.title)\n    if (m.description) c.string.preencode(state, m.description)\n    if (m.file) FileRecord.preencode(state, m.file)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.title) flags |= 1\n    if (m.description) flags |= 2\n    if (m.file) flags |= 4\n    c.uint.encode(state, flags)\n    c.string.encode(state, m.url)\n    if (m.title) c.string.encode(state, m.title)\n    if (m.description) c.string.encode(state, m.description)\n    if (m.file) FileRecord.encode(state, m.file)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      url: c.string.decode(state),\n      title: (flags & 1) !== 0 ? c.string.decode(state) : null,\n      description: (flags & 2) !== 0 ? c.string.decode(state) : null,\n      file: (flags & 4) !== 0 ? FileRecord.decode(state) : null\n    }\n  }\n}\n\nconst HttpLink = {\n  TYPE: DISPLAY_TYPES.HTTP_LINK,\n  preencode (state, m) {\n    let flags = 0\n    if (m.preview) flags |= 1\n    c.uint.preencode(state, flags)\n    ContentRange.preencode(state, m)\n    if (m.preview) LinkPreview.preencode(state, m.preview)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.preview) flags |= 1\n    c.uint.encode(state, flags)\n    ContentRange.encode(state, m)\n    if (m.preview) LinkPreview.encode(state, m.preview)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      ...ContentRange.decode(state),\n      preview: (flags & 1) !== 0 ? LinkPreview.decode(state) : null\n    }\n  }\n}\n\nconst PearLink = {\n  TYPE: DISPLAY_TYPES.PEAR_LINK,\n  preencode (state, m) {\n    let flags = 0\n    if (m.preview) flags |= 1\n    c.uint.preencode(state, flags)\n    ContentRange.preencode(state, m)\n    if (m.preview) LinkPreview.preencode(state, m.preview)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.preview) flags |= 1\n    c.uint.encode(state, flags)\n    ContentRange.encode(state, m)\n    if (m.preview) LinkPreview.encode(state, m.preview)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      ...ContentRange.decode(state),\n      preview: (flags & 1) !== 0 ? LinkPreview.decode(state) : null\n    }\n  }\n}\n\nconst Code = {\n  TYPE: DISPLAY_TYPES.CODE,\n  preencode (state, m) {\n    Range.preencode(state, m)\n  },\n  encode (state, m) {\n    Range.encode(state, m)\n  },\n  decode (state) {\n    return Range.decode(state)\n  }\n}\n\nconst CodeBlock = {\n  TYPE: DISPLAY_TYPES.CODE_BLOCK,\n  preencode (state, m) {\n    Range.preencode(state, m)\n  },\n  encode (state, m) {\n    Range.encode(state, m)\n  },\n  decode (state) {\n    return Range.decode(state)\n  }\n}\n\nconst Bold = {\n  TYPE: DISPLAY_TYPES.BOLD,\n  preencode (state, m) {\n    Range.preencode(state, m)\n  },\n  encode (state, m) {\n    Range.encode(state, m)\n  },\n  decode (state) {\n    return Range.decode(state)\n  }\n}\n\nconst Italic = {\n  TYPE: DISPLAY_TYPES.ITALIC,\n  preencode (state, m) {\n    Range.preencode(state, m)\n  },\n  encode (state, m) {\n    Range.encode(state, m)\n  },\n  decode (state) {\n    return Range.decode(state)\n  }\n}\n\nconst Strikethrough = {\n  TYPE: DISPLAY_TYPES.STRIKE_THROUGH,\n  preencode (state, m) {\n    Range.preencode(state, m)\n  },\n  encode (state, m) {\n    Range.encode(state, m)\n  },\n  decode (state) {\n    return Range.decode(state)\n  }\n}\n\nconst Emoji = {\n  TYPE: DISPLAY_TYPES.EMOJI,\n  preencode (state, m) {\n    ContentRange.preencode(state, m)\n  },\n  encode (state, m) {\n    ContentRange.encode(state, m)\n  },\n  decode (state) {\n    return ContentRange.decode(state)\n  }\n}\n\nconst ContentRange = {\n  preencode (state, m) {\n    c.string.preencode(state, m.content)\n    Range.preencode(state, m)\n  },\n  encode (state, m) {\n    c.string.encode(state, m.content)\n    Range.encode(state, m)\n  },\n  decode (state) {\n    return {\n      content: c.string.decode(state),\n      ...Range.decode(state)\n    }\n  }\n}\n\nconst Range = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.start)\n    c.uint.preencode(state, m.length)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.start)\n    c.uint.encode(state, m.length)\n  },\n  decode (state) {\n    return {\n      start: c.uint.decode(state),\n      length: c.uint.decode(state)\n    }\n  }\n}\n\nfunction getDisplayEncoder (type) {\n  switch (type) {\n    case Mention.TYPE:\n      return Mention\n    case HttpLink.TYPE:\n      return HttpLink\n    case PearLink.TYPE:\n      return PearLink\n    case Bold.TYPE:\n      return Bold\n    case Italic.TYPE:\n      return Italic\n    case Code.TYPE:\n      return Code\n    case CodeBlock.TYPE:\n      return CodeBlock\n    case Strikethrough.TYPE:\n      return Strikethrough\n    case Emoji.TYPE:\n      return Emoji\n    default:\n      return null\n  }\n}\n\nconst Display = {\n  preencode (state, m) {\n    const encoder = getDisplayEncoder(m.type)\n\n    if (!encoder) throw new Error('Unsupported display type')\n    c.uint.preencode(state, m.type)\n    encoder.preencode(state, m.value)\n  },\n  encode (state, m) {\n    const encoder = getDisplayEncoder(m.type)\n\n    if (!encoder) throw new Error('Unsupported display type')\n    c.uint.encode(state, m.type)\n    encoder.encode(state, m.value)\n  },\n  decode (state) {\n    const type = c.uint.decode(state)\n    const encoder = getDisplayEncoder(type)\n\n    if (!encoder) throw new Error('Unsupported display type')\n    return {\n      type,\n      value: encoder.decode(state)\n    }\n  }\n}\n\nconst DisplayEvent = c.array(Display)\n\nconst ChatEvent = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.string.preencode(state, m.text)\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.string.encode(state, m.text)\n\n    let flags = 0\n    if (m.edited) {\n      flags |= 1\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      text: c.string.decode(state),\n      edited: (flags & 1) !== 0\n    }\n  }\n}\n\nconst FileEvent = {\n  preencode (state, m) {\n    FileRecord.preencode(state, m)\n  },\n  encode (state, m) {\n    FileRecord.encode(state, m)\n  },\n  decode (state) {\n    return FileRecord.decode(state)\n  }\n}\n\nfunction getGenericEncoder (type) {\n  switch (type) {\n    case GENERIC_EVENTS.MEMBER_JOINED:\n    case GENERIC_EVENTS.CALL_STARTED:\n    case GENERIC_EVENTS.ROOM_AVATAR_CHANGED:\n    case GENERIC_EVENTS.INVITATION_CREATED:\n    case GENERIC_EVENTS.MEMBER_LEFT:\n      return BaseGenericEvent\n    case GENERIC_EVENTS.MEMBER_REMOVED:\n      return MemberRemovedGenericEvent\n    case GENERIC_EVENTS.ROOM_TITLE_CHANGED:\n      return TitleChangedGenericEvent\n    default:\n      return c.buffer\n  }\n}\n\n// Generic Events\n\nconst GenericEvent = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.type)\n\n    const encoder = getGenericEncoder(m.type)\n    if (!encoder.preencode) return\n\n    encoder.preencode(state, m.value)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.type)\n\n    const encoder = getGenericEncoder(m.type)\n    if (!encoder.preencode) return\n\n    encoder.encode(state, m.value)\n  },\n  decode (state) {\n    const type = c.uint.decode(state)\n\n    const encoder = getGenericEncoder(type)\n    if (!encoder.preencode) return { type, value: null }\n\n    return {\n      type,\n      value: encoder.decode(state)\n    }\n  }\n}\n\nconst BaseGenericEvent = {}\n\nconst TitleChangedGenericEvent = {\n  preencode (state, m) {\n    c.string.preencode(state, m.from)\n    c.string.preencode(state, m.to)\n  },\n  encode (state, m) {\n    c.string.encode(state, m.from)\n    c.string.encode(state, m.to)\n  },\n  decode (state) {\n    return {\n      from: c.string.decode(state),\n      to: c.string.decode(state)\n    }\n  }\n}\n\nconst MemberRemovedGenericEvent = {\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.memberKey)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.memberKey)\n  },\n  decode (state) {\n    return {\n      memberKey: c.fixed32.decode(state)\n    }\n  }\n}\n\n// Top-Level Event Record\n\nconst EventRecord = {\n  preencode (state, m) {\n    let flags = 0\n    if (m.deleted) flags |= 1\n    if (m.timestamp) flags |= 2\n    if (m.chat) flags |= 4\n    if (m.file) flags |= 8\n    if (m.display) flags |= 16\n    if (m.event) flags |= 32\n    if (m.parent) flags |= 64\n    if (m.replyTo) flags |= 128\n    c.uint.preencode(state, flags)\n    c.uint.preencode(state, m.clock)\n    MessageId.preencode(state, m.id)\n    if (m.timestamp) c.uint.preencode(state, m.timestamp)\n    if (m.chat) ChatEvent.preencode(state, m.chat)\n    if (m.file) FileEvent.preencode(state, m.file)\n    if (m.display) DisplayEvent.preencode(state, m.display)\n    if (m.event) GenericEvent.preencode(state, m.event)\n    if (m.parent) MessageId.preencode(state, m.parent)\n    if (m.replyTo) MessageId.preencode(state, m.replyTo)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.deleted) flags |= 1\n    if (m.timestamp) flags |= 2\n    if (m.chat) flags |= 4\n    if (m.file) flags |= 8\n    if (m.display) flags |= 16\n    if (m.event) flags |= 32\n    if (m.parent) flags |= 64\n    if (m.replyTo) flags |= 128\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.clock)\n    MessageId.encode(state, m.id)\n    if (m.timestamp) c.uint.encode(state, m.timestamp)\n    if (m.chat) ChatEvent.encode(state, m.chat)\n    if (m.file) FileEvent.encode(state, m.file)\n    if (m.display) DisplayEvent.encode(state, m.display)\n    if (m.event) GenericEvent.encode(state, m.event)\n    if (m.parent) MessageId.encode(state, m.parent)\n    if (m.replyTo) MessageId.encode(state, m.replyTo)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      clock: c.uint.decode(state),\n      id: MessageId.decode(state),\n      deleted: (flags & 1) !== 0,\n      timestamp: (flags & 2) !== 0 ? c.uint.decode(state) : null,\n      chat: (flags & 4) !== 0 ? ChatEvent.decode(state) : null,\n      file: (flags & 8) !== 0 ? FileEvent.decode(state) : null,\n      display: (flags & 16) !== 0 ? DisplayEvent.decode(state) : null,\n      event: (flags & 32) !== 0 ? GenericEvent.decode(state) : null,\n      parent: (flags & 64) !== 0 ? MessageId.decode(state) : null,\n      replyTo: (flags & 128) !== 0 ? MessageId.decode(state) : null\n    }\n  }\n}\n\n// File\n\nconst FileLocation = {\n  preencode (state, l) {\n    c.fixed32.preencode(state, l.key)\n    c.string.preencode(state, l.path)\n    c.uint.preencode(state, l.version)\n  },\n  encode (state, l) {\n    c.fixed32.encode(state, l.key)\n    c.string.encode(state, l.path)\n    c.uint.encode(state, l.version)\n  },\n  decode (state) {\n    return {\n      key: c.fixed32.decode(state),\n      path: c.string.decode(state),\n      version: c.uint.decode(state)\n    }\n  }\n}\n\nconst FileDimensions = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.width)\n    c.uint.preencode(state, m.height)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.width)\n    c.uint.encode(state, m.height)\n  },\n  decode (state) {\n    return {\n      width: c.uint.decode(state),\n      height: c.uint.decode(state)\n    }\n  }\n}\n\nconst FileRecord = {\n  preencode (state, m) {\n    let flags = 0\n    if (m.type) flags |= 1\n    if (m.dimensions) flags |= 2\n    if (m.preview) flags |= 4\n    if (m.previewPointer) flags |= 8\n    c.uint.preencode(state, flags)\n    FileLocation.preencode(state, m)\n    if (m.type) c.string.preencode(state, m.type)\n    if (m.dimensions) FileDimensions.preencode(state, m.dimensions)\n    if (m.preview) c.buffer.preencode(state, m.preview)\n    if (m.previewPointer) FileLocation.preencode(state, m.previewPointer)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.type) flags |= 1\n    if (m.dimensions) flags |= 2\n    if (m.preview) flags |= 4\n    if (m.previewPointer) flags |= 8\n    c.uint.encode(state, flags)\n    FileLocation.encode(state, m)\n    if (m.type) c.string.encode(state, m.type)\n    if (m.dimensions) FileDimensions.encode(state, m.dimensions)\n    if (m.preview) c.buffer.encode(state, m.preview)\n    if (m.previewPointer) FileLocation.encode(state, m.previewPointer)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    const { key, path, version } = FileLocation.decode(state)\n    return {\n      key,\n      path,\n      version,\n      type: (flags & 1) !== 0 ? c.string.decode(state) : null,\n      dimensions: (flags & 2) !== 0 ? FileDimensions.decode(state) : null,\n      preview: (flags & 4) !== 0 ? c.buffer.decode(state) : null,\n      previewPointer: (flags & 8) !== 0 ? FileLocation.decode(state) : null\n    }\n  }\n}\n\nmodule.exports = {\n  PRIMARY_THREAD_ID,\n  IndexEventId,\n  IndexMessageId,\n  ClockIndexEncoding,\n  MessageId,\n  EventIdValueEncoding,\n  GenericEvent,\n  DisplayEvent,\n  ChatEvent,\n  EventRecord,\n  FileRecord\n}\nconst c = require('compact-encoding')\nconst { MessageId, ChatEvent, DisplayEvent, GenericEvent, FileRecord } = require('./messages')\n\nconst AddChatMessageOperation = {\n  TYPE: 3,\n  preencode (state, m) {\n    let flags = 0\n    if (m.display) flags |= 1\n    if (m.replyTo) flags |= 2\n    c.uint.preencode(state, flags)\n    ChatEvent.preencode(state, m)\n    if (m.display) DisplayEvent.preencode(state, m.display)\n    if (m.replyTo) MessageId.preencode(state, m.replyTo)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.display) flags |= 1\n    if (m.replyTo) flags |= 2\n    c.uint.encode(state, flags)\n    ChatEvent.encode(state, m)\n    if (m.display) DisplayEvent.encode(state, m.display)\n    if (m.replyTo) MessageId.encode(state, m.replyTo)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      ...ChatEvent.decode(state),\n      display: (flags & 1) !== 0 ? DisplayEvent.decode(state) : null,\n      replyTo: (flags & 2) !== 0 ? MessageId.decode(state) : null\n    }\n  }\n}\n\nconst UpdateChatMessageOperation = {\n  TYPE: 4,\n  preencode (state, m) {\n    let flags = 0\n    if (m.display) flags |= 1\n    if (m.replyTo) flags |= 2\n    c.uint.preencode(state, flags)\n    MessageId.preencode(state, m.id)\n    ChatEvent.preencode(state, m)\n    if (m.display) DisplayEvent.preencode(state, m.display)\n    if (m.replyTo) MessageId.preencode(state, m.replyTo)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.display) flags |= 1\n    if (m.replyTo) flags |= 2\n    c.uint.encode(state, flags)\n    MessageId.encode(state, m.id)\n    ChatEvent.encode(state, m)\n    if (m.display) DisplayEvent.encode(state, m.display)\n    if (m.replyTo) MessageId.encode(state, m.replyTo)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      id: MessageId.decode(state),\n      ...ChatEvent.decode(state),\n      display: (flags & 1) !== 0 ? DisplayEvent.decode(state) : null,\n      replyTo: (flags & 2) !== 0 ? MessageId.decode(state) : null\n    }\n  }\n}\n\nconst RemoveChatMessageOperation = {\n  TYPE: 5,\n  preencode (state, m) {\n    MessageId.preencode(state, m.id)\n  },\n  encode (state, m) {\n    MessageId.encode(state, m.id)\n  },\n  decode (state) {\n    return {\n      id: MessageId.decode(state)\n    }\n  }\n}\n\nconst AddGenericEventOperation = {\n  TYPE: 6,\n  ...GenericEvent\n}\n\nconst RemoveGenericEventOperation = {\n  TYPE: 7,\n  preencode (state, m) {\n    MessageId.preencode(state, m.id)\n  },\n  encode (state, m) {\n    MessageId.encode(state, m.id)\n  },\n  decode (state) {\n    return {\n      id: MessageId.decode(state)\n    }\n  }\n}\n\n// File\n\nconst AddFileOperation = {\n  TYPE: 1,\n  preencode (state, m) {\n    state.end++ // flags\n    FileRecord.preencode(state, m.file)\n    if (m.description) c.string.preencode(state, m.description)\n  },\n  encode (state, m) {\n    const start = state.start++\n    FileRecord.encode(state, m.file)\n\n    let flags = 0\n    if (m.description) {\n      flags |= 1\n      c.string.encode(state, m.description)\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      file: FileRecord.decode(state),\n      description: (flags & 1) !== 0 ? c.string.decode(state) : null\n    }\n  }\n}\n\nconst RemoveFileOperation = {\n  TYPE: 2,\n  preencode (state, m) {\n    MessageId.preencode(state, m.id)\n  },\n  encode (state, m) {\n    MessageId.encode(state, m.id)\n  },\n  decode (state) {\n    return {\n      id: MessageId.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  AddChatMessageOperation,\n  UpdateChatMessageOperation,\n  RemoveChatMessageOperation,\n  AddGenericEventOperation,\n  RemoveGenericEventOperation,\n  AddFileOperation,\n  RemoveFileOperation\n}\nconst c = require('compact-encoding')\nconst { CONFIG } = require('@holepunchto/keet-core-api')\n\nconst InternalSchema = require('../internal')\nconst {\n  UpdateConfigOperationV1,\n  UpdateConfigOperationV2\n} = require('./ops')\n\nconst { MirrorRecord } = require('./messages.js')\nconst { MessageId } = require('../chat/messages.js')\n\nmodule.exports = class ConfigSchema {\n  static Encoding = InternalSchema.ConfigEncoding\n\n  static Operations = {\n    UpdateConfigOperationV1,\n    UpdateConfigOperationV2\n  }\n\n  static Collection = {\n    keyEncoding: c.uint,\n    valueEncoding: c.any\n  }\n\n  // Array of message IDs\n  static PinnedMessages = c.array(MessageId)\n\n  // Mirrors\n  static Mirrors = c.array(MirrorRecord)\n\n  // Helpers\n\n  static getValue (record) {\n    if (!record || !record.value) return null\n    const { key, value } = record\n    return ConfigSchema.decodeValue(key, value)\n  }\n\n  static decodeValue (key, value) {\n    return ConfigSchema.encodeValue(key, value, true)\n  }\n\n  static encodeValue (key, value, decode = false) {\n    const enc = decode ? c.decode : c.encode\n    switch (key) {\n      // Identity\n      case CONFIG.ID_PUBLIC_KEY:\n      case CONFIG.ID_SHARED_INVITE_SEED:\n        return enc(c.string, value)\n      case CONFIG.ID_RECOVERY_PHRASE:\n        return enc(c.string, value)\n\n      // V1 keys\n      case CONFIG.ROOM_TITLE:\n      case CONFIG.ROOM_DESCRIPTION:\n      case CONFIG.ROOM_AVATAR:\n      case CONFIG.ROOM_TYPE:\n      case CONFIG.ROOM_CAN_CALL:\n        return enc(c.string, value)\n\n      // V2 keys\n      case CONFIG.PINNED_MESSAGES:\n        return enc(ConfigSchema.PinnedMessages, value)\n      case CONFIG.ROOM_MIRRORS:\n        return enc(ConfigSchema.Mirrors, value)\n      case CONFIG.ROOM_LOCKED:\n        return enc(c.uint, value)\n      case CONFIG.DISABLE_MEMBERSHIP_EVENTS:\n        return enc(c.uint, value)\n      default:\n        return enc(c.string, value)\n    }\n  }\n}\nconst c = require('compact-encoding')\n\nconst MirrorRecord = {\n  preencode (state, m) {\n    let flags = 0\n    if (m.type) flags |= 1\n    if (m.signature) flags |= 2\n\n    c.uint.preencode(state, flags)\n    c.fixed32.preencode(state, m.key)\n    if (m.type) {\n      c.uint.preencode(state, m.type)\n    }\n    if (m.signature) {\n      c.buffer.preencode(state, m.signature)\n    }\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.type) flags |= 1\n    if (m.signature) flags |= 2\n\n    c.uint.encode(state, flags)\n    c.fixed32.encode(state, m.key)\n    if (m.type) {\n      c.uint.encode(state, m.type)\n    }\n    if (m.signature) {\n      c.buffer.encode(state, m.signature)\n    }\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      key: c.fixed32.decode(state),\n      type: (flags & 1) !== 0 ? c.uint.decode(state) : 0,\n      signature: (flags & 2) !== 0 ? c.buffer.decode(state) : null\n    }\n  }\n}\n\nmodule.exports = {\n  MirrorRecord\n}\nconst c = require('compact-encoding')\n\nconst UpdateConfigOperationV1 = {\n  TYPE: 11,\n  preencode (state, m) {\n    state.end++ // flags\n    c.string.preencode(state, m.key)\n    if (m.value) c.string.preencode(state, m.value)\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.string.encode(state, m.key)\n\n    let flags = 0\n    if (m.value) {\n      flags |= 1\n      c.string.encode(state, m.value)\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      key: c.string.decode(state),\n      value: (flags & 1) !== 0 ? c.string.decode(state) : null\n    }\n  }\n}\n\nconst UpdateConfigOperationV2 = {\n  TYPE: 26,\n  preencode (state, m) {\n    c.string.preencode(state, m.key)\n    c.buffer.preencode(state, m.value)\n  },\n  encode (state, m) {\n    c.string.encode(state, m.key)\n    c.buffer.encode(state, m.value)\n  },\n  decode (state) {\n    return {\n      key: c.string.decode(state),\n      value: c.buffer.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  UpdateConfigOperationV1,\n  UpdateConfigOperationV2\n}\nconst c = require('compact-encoding')\nconst HyperIndex = require('@holepunchto/hyperindex')\n\nconst { IndexMemberId } = require('../members/messages')\nconst { DeviceRecord } = require('./messages')\n\nconst {\n  AddDeviceOperationV1,\n  AddDeviceOperationV2,\n  UpdateDeviceOperation,\n  RemoveDeviceOperationV1,\n  RemoveDeviceOperationV2\n} = require('./ops')\n\nmodule.exports = class DeviceSchema {\n  static Messages = {\n\n  }\n\n  static Operations = {\n    AddDeviceOperationV1,\n    AddDeviceOperationV2,\n    UpdateDeviceOperation,\n    RemoveDeviceOperationV1,\n    RemoveDeviceOperationV2\n  }\n\n  static DevicesCollection = {\n    keyEncoding: IndexMemberId,\n    valueEncoding: DeviceRecord\n  }\n\n  static DevicesIndexes = [\n    {\n      keyEncoding: HyperIndex.BUFFER, // devicesByNoisePublicKey\n      valueEncoding: IndexMemberId\n    },\n    {\n      keyEncoding: HyperIndex.UINT, // deviceCount\n      valueEncoding: c.uint\n    },\n    {\n      keyEncoding: HyperIndex.UINT, // mobileDeviceCount\n      valueEncoding: c.uint\n    }\n  ]\n}\nconst c = require('compact-encoding')\n\nconst DeviceRecord = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.fixed32.preencode(state, m.key)\n    c.fixed32.preencode(state, m.noisePublicKey)\n    c.uint.preencode(state, m.capabilities)\n    if (m.receipt) c.buffer.preencode(state, m.receipt)\n    if (m.name) c.string.preencode(state, m.name)\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.fixed32.encode(state, m.key)\n    c.fixed32.encode(state, m.noisePublicKey)\n    c.uint.encode(state, m.capabilities)\n\n    let flags = 0\n    if (m.receipt) {\n      flags |= 1\n      c.buffer.encode(state, m.receipt)\n    }\n    if (m.isMobile) {\n      flags |= 2\n    }\n    if (m.name) {\n      flags |= 4\n      c.string.encode(state, m.name)\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      key: c.fixed32.decode(state),\n      noisePublicKey: c.fixed32.decode(state),\n      capabilities: c.uint.decode(state),\n      receipt: (flags & 1) !== 0 ? c.buffer.decode(state) : null,\n      isMobile: (flags & 2) !== 0,\n      name: (flags & 4) !== 0 ? c.string.decode(state) : null\n    }\n  }\n}\n\nmodule.exports = {\n  DeviceRecord\n}\nconst c = require('compact-encoding')\n\nconst { MemberId } = require('../members/messages.js')\n\nconst AddDeviceOperationV1 = {\n  TYPE: 14,\n  preencode (state, m) {\n    state.end++ // flags\n    c.fixed32.preencode(state, m.key)\n    c.fixed32.preencode(state, m.noisePublicKey)\n    if (m.capabilities) c.uint.preencode(state, m.capabilities)\n    if (m.invitation) c.fixed32.preencode(state, m.invitation)\n    if (m.receipt) c.buffer.preencode(state, m.receipt)\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.fixed32.encode(state, m.key)\n    c.fixed32.encode(state, m.noisePublicKey)\n\n    let flags = 0\n    if (m.capabilities) {\n      flags |= 1\n      c.uint.encode(state, m.capabilities)\n    }\n    if (m.invitation) {\n      flags |= 2\n      c.fixed32.encode(state, m.invitation)\n    }\n    if (m.receipt) {\n      flags |= 4\n      c.buffer.encode(state, m.receipt)\n    }\n    if (m.isMobile) {\n      flags |= 8\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      key: c.fixed32.decode(state),\n      noisePublicKey: c.fixed32.decode(state),\n      capabilities: (flags & 1) !== 0 ? c.uint.decode(state) : null,\n      invitation: (flags & 2) !== 0 ? c.fixed32.decode(state) : null,\n      receipt: (flags & 4) !== 0 ? c.buffer.decode(state) : null,\n      isMobile: (flags & 8) !== 0\n    }\n  }\n}\n\nconst AddDeviceOperationV2 = {\n  TYPE: 18,\n  preencode (state, m) {\n    state.end++ // flags\n    c.fixed32.preencode(state, m.key)\n    c.fixed32.preencode(state, m.noisePublicKey)\n    if (m.capabilities) c.uint.preencode(state, m.capabilities)\n    if (m.invitation) c.fixed32.preencode(state, m.invitation)\n    if (m.receipt) c.buffer.preencode(state, m.receipt)\n    if (m.name) c.string.preencode(state, m.name)\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.fixed32.encode(state, m.key)\n    c.fixed32.encode(state, m.noisePublicKey)\n\n    let flags = 0\n    if (m.capabilities) {\n      flags |= 1\n      c.uint.encode(state, m.capabilities)\n    }\n    if (m.invitation) {\n      flags |= 2\n      c.fixed32.encode(state, m.invitation)\n    }\n    if (m.receipt) {\n      flags |= 4\n      c.buffer.encode(state, m.receipt)\n    }\n    if (m.isMobile) {\n      flags |= 8\n    }\n    if (m.name) {\n      flags |= 16\n      c.string.encode(state, m.name)\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      key: c.fixed32.decode(state),\n      noisePublicKey: c.fixed32.decode(state),\n      capabilities: (flags & 1) !== 0 ? c.uint.decode(state) : null,\n      invitation: (flags & 2) !== 0 ? c.fixed32.decode(state) : null,\n      receipt: (flags & 4) !== 0 ? c.buffer.decode(state) : null,\n      isMobile: (flags & 8) !== 0,\n      name: (flags & 16) !== 0 ? c.string.decode(state) : null\n    }\n  }\n}\n\nconst UpdateDeviceOperation = {\n  TYPE: 19,\n  preencode (state, m) {\n    state.end++ // flags\n    if (m.name) c.string.preencode(state, m.name)\n  },\n  encode (state, m) {\n    const start = state.start++\n\n    let flags = 0\n    if (m.isMobile) {\n      flags |= 1\n    }\n    if (m.name) {\n      flags |= 2\n      c.string.encode(state, m.name)\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      isMobile: (flags & 1) !== 0,\n      name: (flags & 2) !== 0 ? c.string.decode(state) : null\n    }\n  }\n}\n\nconst RemoveDeviceOperationV1 = {\n  TYPE: 15,\n  preencode (state, m) {\n    MemberId.preencode(state, m.key)\n  },\n  encode (state, m) {\n    MemberId.encode(state, m.key)\n  },\n  decode (state) {\n    return {\n      key: MemberId.decode(state)\n    }\n  }\n}\n\nconst RemoveDeviceOperationV2 = {\n  TYPE: 27,\n  preencode (state, m) {\n    MemberId.preencode(state, m.key)\n  },\n  encode (state, m) {\n    MemberId.encode(state, m.key)\n  },\n  decode (state) {\n    return {\n      key: MemberId.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  AddDeviceOperationV1,\n  AddDeviceOperationV2,\n  UpdateDeviceOperation,\n  RemoveDeviceOperationV1,\n  RemoveDeviceOperationV2\n}\nconst c = require('compact-encoding')\nconst SubEncoder = require('sub-encoder')\nconst b4a = require('b4a')\nconst { PluginRecord } = require('../plugins/messages')\nconst {\n  InternalOperation,\n  GenesisOperation,\n  UpgradeOperation,\n  AddPluginOperation\n} = require('./ops')\n\nconst INTERNALS_PREFIX = b4a.from([0])\nconst UPGRADER_SUB_PREFIX = b4a.from([0])\nconst PLUGINS_SUB_PREFIX = b4a.from([1])\nconst CONFIG_SUB_PREFIX = b4a.from([2])\n\nconst internalEncoder = new SubEncoder(INTERNALS_PREFIX)\n\nmodule.exports = class InternalSchema {\n  static CodeVersionKey = b4a.from([1])\n  static ExperimentalModeKey = b4a.from([2])\n\n  static UpgraderEncoding = {\n    keyEncoding: internalEncoder.sub(UPGRADER_SUB_PREFIX),\n    valueEncoding: c.uint\n  }\n\n  static PluginsEncoding = {\n    keyEncoding: internalEncoder.sub(PLUGINS_SUB_PREFIX, c.uint),\n    valueEncoding: PluginRecord\n  }\n\n  static ConfigEncoding = {\n    keyEncoding: internalEncoder.sub(CONFIG_SUB_PREFIX, c.string),\n    valueEncoding: c.buffer\n  }\n\n  static Operations = {\n    InternalOperation,\n    GenesisOperation,\n    UpgradeOperation,\n    AddPluginOperation\n  }\n}\nconst c = require('compact-encoding')\n\nconst { PluginRecord } = require('../plugins/messages')\n\nconst UpgradeOperation = {\n  SUBTYPE: 0,\n  preencode (state, m) {\n    c.uint.preencode(state, m.version)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.version)\n  },\n  decode (state) {\n    return {\n      version: c.uint.decode(state)\n    }\n  }\n}\n\nconst AddPluginOperation = {\n  SUBTYPE: 1,\n  preencode (state, m) {\n    PluginRecord.preencode(state, m)\n  },\n  encode (state, m) {\n    PluginRecord.encode(state, m)\n  },\n  decode (state) {\n    return PluginRecord.decode(state)\n  }\n}\n\nconst BootstrapMember = {\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.noisePublicKey)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.noisePublicKey)\n  },\n  decode (state) {\n    return {\n      noisePublicKey: c.fixed32.decode(state)\n    }\n  }\n}\n\nconst GenesisOperation = {\n  SUBTYPE: 2,\n  preencode (state, m) {\n    let flags = 0\n    if (m.experimental) flags |= 1\n    if (m.roomType) flags |= 2\n    if (m.title) flags |= 4\n\n    c.uint.preencode(state, flags)\n    c.uint.preencode(state, m.version)\n    BootstrapMember.preencode(state, m.bootstrap)\n\n    if (m.title) c.string.preencode(state, m.title)\n    if (m.roomType) c.uint.preencode(state, m.roomType)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.experimental) flags |= 1\n    if (m.roomType) flags |= 2\n    if (m.title) flags |= 4\n\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.version)\n    BootstrapMember.encode(state, m.bootstrap)\n\n    if (m.title) c.string.encode(state, m.title)\n    if (m.roomType) c.uint.encode(state, m.roomType)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      version: c.uint.decode(state),\n      bootstrap: BootstrapMember.decode(state),\n      experimental: (flags & 1) !== 0,\n      roomType: (flags & 2) !== 0 ? c.uint.decode(state) : 0,\n      title: (flags & 4) !== 0 ? c.string.decode(state) : 0\n    }\n  }\n}\n\n// All internal operations have type 0 and subtypes\nconst InternalOperation = {\n  TYPE: 0,\n  preencode (state, m) {\n    c.uint.preencode(state, m.subtype)\n    getSubtypeEncoding(m.subtype).preencode(state, m.value)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.subtype)\n    getSubtypeEncoding(m.subtype).encode(state, m.value)\n  },\n  decode (state) {\n    const subtype = c.uint.decode(state)\n    return {\n      subtype,\n      value: getSubtypeEncoding(subtype).decode(state)\n    }\n  }\n}\n\nfunction getSubtypeEncoding (subtype) {\n  switch (subtype) {\n    case UpgradeOperation.SUBTYPE:\n      return UpgradeOperation\n    case AddPluginOperation.SUBTYPE:\n      return AddPluginOperation\n    case GenesisOperation.SUBTYPE:\n      return GenesisOperation\n    default:\n      throw new Error('Invalid internal operation subtype')\n  }\n}\n\nmodule.exports = {\n  InternalOperation,\n  GenesisOperation,\n  UpgradeOperation,\n  AddPluginOperation\n}\nconst HyperIndex = require('@holepunchto/hyperindex')\n\nconst { InvitationRecord, InvitationUserData } = require('./messages')\n\nconst {\n  AddInvitationOperationV1,\n  AddInvitationOperationV2,\n  RemoveInvitationOperation\n} = require('./ops')\n\nmodule.exports = class InvitationSchema {\n  static Messages = {\n    InvitationUserData\n  }\n\n  static Operations = {\n    AddInvitationOperationV1,\n    AddInvitationOperationV2,\n    RemoveInvitationOperation\n  }\n\n  static InvitationsCollection = {\n    keyEncoding: HyperIndex.BUFFER,\n    valueEncoding: InvitationRecord\n  }\n}\nconst c = require('compact-encoding')\n\nconst InvitationRecordV1 = {\n  preencode (state, i) {\n    state.end++ // flags\n    c.fixed32.preencode(state, i.publicKey)\n    c.uint.preencode(state, i.capabilities)\n    if (i.expiration) c.uint.preencode(state, i.expiration)\n    if (i.uses) c.uint.preencode(state, i.uses)\n  },\n  encode (state, i) {\n    const start = state.start++\n    c.fixed32.encode(state, i.publicKey)\n    c.uint.encode(state, i.capabilities)\n\n    let flags = 0\n    if (i.expiration) {\n      flags |= 1\n      c.uint.encode(state, i.expiration)\n    }\n    if (i.uses) {\n      flags |= 2\n      c.uint.encode(state, i.uses)\n    }\n    if (i.reusable) {\n      flags |= 4\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      publicKey: c.fixed32.decode(state),\n      capabilities: c.uint.decode(state),\n      expiration: (flags & 1) !== 0 ? c.uint.decode(state) : 0,\n      uses: (flags & 2) !== 0 ? c.uint.decode(state) : 0,\n      reusable: (flags & 4) !== 0\n    }\n  }\n}\n\nconst InvitationAdditionalData = {\n  preencode (state, m) {\n    c.buffer.preencode(state, m.data)\n    c.buffer.preencode(state, m.signature)\n  },\n  encode (state, m) {\n    c.buffer.encode(state, m.data)\n    c.buffer.encode(state, m.signature)\n  },\n  decode (state) {\n    return {\n      data: c.buffer.decode(state),\n      signature: c.buffer.decode(state)\n    }\n  }\n}\n\nconst InvitationRecord = {\n  preencode (state, i) {\n    let flags = 0\n    if (i.expiration) flags |= 1\n    if (i.uses) flags |= 2\n    if (i.reusable) flags |= 4\n    if (i.attestsTo) flags |= 8\n    if (i.additional) flags |= 16\n    c.uint.preencode(state, flags)\n\n    c.fixed32.preencode(state, i.publicKey)\n    c.uint.preencode(state, i.capabilities)\n    if (i.expiration) c.uint.preencode(state, i.expiration)\n    if (i.uses) c.uint.preencode(state, i.uses)\n    if (i.attestsTo) c.fixed32.preencode(state, i.attestsTo)\n    if (i.additional) InvitationAdditionalData.preencode(state, i.additional)\n  },\n  encode (state, i) {\n    let flags = 0\n    if (i.expiration) flags |= 1\n    if (i.uses) flags |= 2\n    if (i.reusable) flags |= 4\n    if (i.attestsTo) flags |= 8\n    if (i.additional) flags |= 16\n    c.uint.encode(state, flags)\n\n    c.fixed32.encode(state, i.publicKey)\n    c.uint.encode(state, i.capabilities)\n\n    if (i.expiration) c.uint.encode(state, i.expiration)\n    if (i.uses) c.uint.encode(state, i.uses)\n    if (i.attestsTo) c.fixed32.encode(state, i.attestsTo)\n    if (i.additional) InvitationAdditionalData.encode(state, i.additional)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      publicKey: c.fixed32.decode(state),\n      capabilities: c.uint.decode(state),\n      expiration: (flags & 1) !== 0 ? c.uint.decode(state) : 0,\n      uses: (flags & 2) !== 0 ? c.uint.decode(state) : 0,\n      reusable: (flags & 4) !== 0,\n      attestsTo: (flags & 8) !== 0 ? c.fixed32.decode(state) : null,\n      additional: (flags & 16) !== 0 ? InvitationAdditionalData.decode(state) : null\n    }\n  }\n}\n\nconst InvitationUserData = {\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.deviceKey)\n    c.fixed32.preencode(state, m.noisePublicKey)\n    if (m.attestation) {\n      c.buffer.preencode(state, m.attestation)\n    } else if (m.deviceName) {\n      // add null for compat\n      c.buffer.preencode(state, null)\n    }\n\n    let flags = 0\n    if (m.deviceName) flags |= 1\n\n    c.uint.preencode(state, flags)\n\n    if (m.deviceName) c.string.preencode(state, m.deviceName)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.deviceKey)\n    c.fixed32.encode(state, m.noisePublicKey)\n    if (m.attestation) {\n      c.buffer.encode(state, m.attestation)\n    } else if (m.deviceName) {\n      // add null for compat\n      c.buffer.encode(state, null)\n    }\n\n    let flags = 0\n    if (m.deviceName) flags |= 1\n\n    c.uint.encode(state, flags)\n\n    if (m.deviceName) c.string.encode(state, m.deviceName)\n  },\n  decode (state) {\n    const invitation = {\n      deviceKey: c.fixed32.decode(state),\n      noisePublicKey: c.fixed32.decode(state),\n      attestation: state.start < state.end ? c.buffer.decode(state) : null,\n      deviceName: null\n    }\n\n    if (state.start < state.end) {\n      const flags = c.uint.decode(state)\n      invitation.deviceName = (flags & 1) !== 0 ? c.string.decode(state) : null\n    }\n\n    return invitation\n  }\n}\n\nmodule.exports = {\n  InvitationRecordV1,\n  InvitationRecord,\n  InvitationUserData\n}\nconst c = require('compact-encoding')\nconst { InvitationRecordV1, InvitationRecord } = require('./messages')\n\nconst AddInvitationOperationV1 = {\n  TYPE: 12,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.id)\n    InvitationRecordV1.preencode(state, m)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.id)\n    InvitationRecordV1.encode(state, m)\n  },\n  decode (state) {\n    return {\n      id: c.fixed32.decode(state),\n      ...InvitationRecordV1.decode(state)\n    }\n  }\n}\n\nconst AddInvitationOperationV2 = {\n  TYPE: 20,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.id)\n    InvitationRecord.preencode(state, m)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.id)\n    InvitationRecord.encode(state, m)\n  },\n  decode (state) {\n    return {\n      id: c.fixed32.decode(state),\n      ...InvitationRecord.decode(state)\n    }\n  }\n}\n\nconst RemoveInvitationOperation = {\n  TYPE: 13,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.id)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.id)\n  },\n  decode (state) {\n    return {\n      id: c.fixed32.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  AddInvitationOperationV1,\n  AddInvitationOperationV2,\n  RemoveInvitationOperation\n}\nconst { KeetOplogMessage } = require('./messages')\n\nconst {\n  AllOperations\n} = require('./ops')\n\nmodule.exports = class KeetSchema {\n  static Messages = {\n    KeetOplogMessage\n  }\n\n  static AllOperations = AllOperations\n}\nconst c = require('compact-encoding')\nconst { KeetOperation } = require('./ops')\n\nconst KeetOperations = c.array(KeetOperation)\n\nconst KeetOplogMessage = {\n  preencode (state, m) {\n    c.uint.preencode(state, 1) // version\n    c.uint.preencode(state, m.abi)\n    c.uint.preencode(state, m.timestamp)\n    KeetOperations.preencode(state, m.ops)\n  },\n  encode (state, m) {\n    c.uint.encode(state, 1) // version\n    c.uint.encode(state, m.abi)\n    c.uint.encode(state, m.timestamp)\n    KeetOperations.encode(state, m.ops)\n  },\n  decode (state) {\n    const version = c.uint.decode(state)\n    if (version > 1) throw new Error('Unsupported oplog message version')\n    return {\n      version,\n      abi: version === 1 ? c.uint.decode(state) : 0,\n      timestamp: c.uint.decode(state),\n      ops: KeetOperations.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  KeetOplogMessage\n}\nconst c = require('compact-encoding')\n\nconst {\n  InternalOperation\n} = require('../internal/ops')\nconst {\n  UpdateConfigOperationV1,\n  UpdateConfigOperationV2\n} = require('../config/ops')\nconst {\n  AddChatMessageOperation,\n  UpdateChatMessageOperation,\n  RemoveChatMessageOperation,\n  AddGenericEventOperation,\n  RemoveGenericEventOperation,\n  AddFileOperation,\n  RemoveFileOperation\n} = require('../chat/ops')\nconst {\n  UpdateMemberOperationV1,\n  UpdateMemberOperationV2,\n  RemoveMemberOperation,\n  ChangeMemberRoleOperation,\n  MuteMemberOperation,\n  UnmuteMemberOperation\n} = require('../members/ops')\nconst {\n  AddReactionOperation,\n  RemoveReactionOperation\n} = require('../reactions/ops')\nconst {\n  AddInvitationOperationV1,\n  AddInvitationOperationV2,\n  RemoveInvitationOperation\n} = require('../invitations/ops')\nconst {\n  AddDeviceOperationV1,\n  AddDeviceOperationV2,\n  UpdateDeviceOperation,\n  RemoveDeviceOperationV1,\n  RemoveDeviceOperationV2\n} = require('../devices/ops')\nconst {\n  PluginOperation\n} = require('../plugins/ops')\nconst {\n  AddDmRequestOperation,\n  RemoveDmRequestOperation,\n  AddMailboxRecordOperation,\n  RemoveMailboxRecordOperation,\n  OldOpenMailboxOperation,\n  OpenMailboxOperation\n} = require('../mailbox/ops')\nconst {\n  AddPrivateMailboxRecordOperation,\n  UpdatePrivateMailboxRecordOperation\n} = require('../private-mailbox/ops')\nconst {\n  AddPrivateRoomOperation,\n  RemovePrivateRoomOperation\n} = require('../private-rooms/ops')\nconst {\n  AddDeviceKeyOperation,\n  AddDeviceAttestationOperation\n} = require('../private-devices/ops')\n\n// Top-Level Oplog Messages\n\nconst InternalOperations = [\n  InternalOperation\n]\nconst NonInternalOperations = [\n  PluginOperation,\n  AddFileOperation,\n  RemoveFileOperation,\n  AddChatMessageOperation,\n  RemoveChatMessageOperation,\n  UpdateChatMessageOperation,\n  AddGenericEventOperation,\n  RemoveGenericEventOperation,\n  AddReactionOperation,\n  RemoveReactionOperation,\n  UpdateMemberOperationV1,\n  UpdateMemberOperationV2,\n  RemoveMemberOperation,\n  ChangeMemberRoleOperation,\n  MuteMemberOperation,\n  UnmuteMemberOperation,\n  UpdateConfigOperationV1,\n  UpdateConfigOperationV2,\n  AddInvitationOperationV1,\n  AddInvitationOperationV2,\n  RemoveInvitationOperation,\n  AddDeviceOperationV1,\n  AddDeviceOperationV2,\n  UpdateDeviceOperation,\n  RemoveDeviceOperationV1,\n  RemoveDeviceOperationV2,\n  OldOpenMailboxOperation,\n  OpenMailboxOperation,\n  AddDmRequestOperation,\n  RemoveDmRequestOperation,\n  AddMailboxRecordOperation,\n  RemoveMailboxRecordOperation,\n  AddPrivateMailboxRecordOperation,\n  UpdatePrivateMailboxRecordOperation,\n  AddPrivateRoomOperation,\n  RemovePrivateRoomOperation,\n  AddDeviceKeyOperation,\n  AddDeviceAttestationOperation\n]\nconst AllOperations = [\n  ...InternalOperations,\n  ...NonInternalOperations\n]\n\nconst opsByType = new Map()\nfor (const op of AllOperations) {\n  if (opsByType.has(op.TYPE)) throw new Error(`Duplicate oplog message type: ${op.TYPE}`)\n  opsByType.set(op.TYPE, op)\n}\n\n// Top-level operation encoding\n\nconst KeetOperation = {\n  preencode (state, m) {\n    const enc = opsByType.get(m.type)\n    c.uint.preencode(state, m.type)\n    enc.preencode(state, m.value)\n  },\n  encode (state, m) {\n    const enc = opsByType.get(m.type)\n    c.uint.encode(state, m.type)\n    enc.encode(state, m.value)\n  },\n  decode (state) {\n    const type = c.uint.decode(state)\n    const enc = opsByType.get(type)\n    return {\n      type,\n      value: enc.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  AllOperations,\n  KeetOperation\n}\nconst HyperIndex = require('@holepunchto/hyperindex')\nconst { MailboxRecord, MailboxRecordV2, OpenMailboxRecord, MailboxRecordData, MailboxRecordId } = require('./messages')\nconst { MemberId } = require('../members/messages')\nconst { IndexMessageId } = require('../chat/messages')\n\nconst {\n  AddDmRequestOperation,\n  RemoveDmRequestOperation,\n  AddMailboxRecordOperation,\n  RemoveMailboxRecordOperation,\n  OldOpenMailboxOperation,\n  OpenMailboxOperation\n} = require('./ops')\n\nmodule.exports = class MailboxSchema {\n  static Messages = {\n    MailboxRecordData\n  }\n\n  static Operations = {\n    AddDmRequestOperation,\n    RemoveDmRequestOperation,\n    AddMailboxRecordOperation,\n    RemoveMailboxRecordOperation,\n    OldOpenMailboxOperation,\n    OpenMailboxOperation\n  }\n\n  static MailboxCollection = {\n    keyEncoding: [MemberId, MemberId],\n    valueEncoding: MailboxRecord\n  }\n\n  static MailboxCollectionV2 = {\n    keyEncoding: [MemberId, HyperIndex.UINT],\n    valueEncoding: MailboxRecordV2\n  }\n\n  static OpenMailboxesCollection = {\n    keyEncoding: MemberId,\n    valueEncoding: OpenMailboxRecord\n  }\n\n  // Indexes\n\n  static MailboxIndexes = [\n    {\n      keyEncoding: HyperIndex.UINT, // mailboxCounter\n      valueEncoding: HyperIndex.UINT // noop\n    },\n    {\n      keyEncoding: IndexMessageId, // mailByMessageId\n      valueEncoding: MailboxRecordId\n    }\n  ]\n}\nconst c = require('compact-encoding')\nconst { MemberId } = require('../members/messages')\nconst { MessageId } = require('../chat/messages')\n\nconst MailboxRecordId = {\n  preencode (state, id) {\n    MemberId.preencode(state, id.key)\n    c.uint.preencode(state, id.seq)\n  },\n  encode (state, id) {\n    MemberId.encode(state, id.key)\n    c.uint.encode(state, id.seq)\n  },\n  decode (state) {\n    return {\n      key: MemberId.decode(state),\n      seq: c.uint.decode(state)\n    }\n  }\n}\n\nconst MailboxRecord = {\n  preencode (state, m) {\n    let flags = 0\n    if (m.link) flags |= 1\n    c.uint.preencode(state, flags)\n    c.uint.preencode(state, m.timestamp)\n    if (m.link) c.buffer.preencode(state, m.link)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.link) flags |= 1\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.timestamp)\n    if (m.link) c.buffer.encode(state, m.link)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      timestamp: c.uint.decode(state),\n      link: (flags & 1) !== 0 ? c.buffer.decode(state) : null\n    }\n  }\n}\n\nconst MailboxRecordV2 = {\n  preencode (state, m) {\n    let flags = 0\n    if (m.data) flags |= 1\n    if (m.id) flags |= 2\n    c.uint.preencode(state, flags)\n    if (m.data) c.buffer.preencode(state, m.data)\n    if (m.id) MessageId.preencode(state, m.id)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.data) flags |= 1\n    if (m.id) flags |= 2\n    c.uint.encode(state, flags)\n    if (m.data) c.buffer.encode(state, m.data)\n    if (m.id) MessageId.encode(state, m.id)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      data: (flags & 1) !== 0 ? c.buffer.decode(state) : null,\n      id: (flags & 2) !== 0 ? MessageId.decode(state) : null\n    }\n  }\n}\n\nconst MailboxRecordData = {\n  preencode (state, m) {\n    let flags = 0\n    if (m.message) flags |= 1\n    if (m.invitation) flags |= 2\n    c.uint.preencode(state, flags)\n    c.uint.preencode(state, m.type)\n    c.uint.preencode(state, m.timestamp)\n    c.buffer.preencode(state, m.senderKey)\n    if (m.message) c.string.preencode(state, m.message)\n    if (m.invitation) c.string.preencode(state, m.invitation)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.message) flags |= 1\n    if (m.invitation) flags |= 2\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.type)\n    c.uint.encode(state, m.timestamp)\n    c.buffer.encode(state, m.senderKey)\n    if (m.message) c.string.encode(state, m.message)\n    if (m.invitation) c.string.encode(state, m.invitation)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      type: c.uint.decode(state),\n      timestamp: c.uint.decode(state),\n      senderKey: c.buffer.decode(state),\n      message: (flags & 1) !== 0 ? c.string.decode(state) : null,\n      invitation: (flags & 2) !== 0 ? c.string.decode(state) : null\n    }\n  }\n}\n\nconst OpenMailboxRecord = {\n  preencode (state, m) {\n    let flags = 0\n    if (m.blindingKey) flags |= 1\n    c.uint.preencode(state, flags)\n    if (m.blindingKey) c.fixed32.preencode(state, m.blindingKey)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.blindingKey) flags |= 1\n    c.uint.encode(state, flags)\n    if (m.blindingKey) c.fixed32.encode(state, m.blindingKey)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      blindingKey: (flags & 1) !== 0 ? c.fixed32.decode(state) : null\n    }\n  }\n}\n\nmodule.exports = {\n  MailboxRecordId,\n  MailboxRecord,\n  MailboxRecordV2,\n  MailboxRecordData,\n  OpenMailboxRecord\n}\nconst c = require('compact-encoding')\nconst { MailboxRecordId } = require('./messages.js')\n\nconst AddDmRequestOperation = {\n  TYPE: 22,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.receiver)\n    c.buffer.preencode(state, m.link)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.receiver)\n    c.buffer.encode(state, m.link)\n  },\n  decode (state) {\n    return {\n      receiver: c.fixed32.decode(state),\n      link: c.buffer.decode(state)\n    }\n  }\n}\n\nconst RemoveDmRequestOperation = {\n  TYPE: 23,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.receiver)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.receiver)\n  },\n  decode (state) {\n    return {\n      receiver: c.fixed32.decode(state)\n    }\n  }\n}\n\nconst AddMailboxRecordOperation = {\n  TYPE: 28,\n  preencode (state, m) {\n    let flags = 0\n    if (m.data) flags |= 1\n    c.uint.preencode(state, flags)\n    c.fixed32.preencode(state, m.receiver)\n    if (m.data) c.buffer.preencode(state, m.data)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.data) flags |= 1\n    c.uint.encode(state, flags)\n    c.fixed32.encode(state, m.receiver)\n    if (m.data) c.buffer.encode(state, m.data)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      receiver: c.fixed32.decode(state),\n      data: (flags & 1) !== 0 ? c.buffer.decode(state) : null\n    }\n  }\n}\n\nconst RemoveMailboxRecordOperation = {\n  TYPE: 29,\n  preencode (state, m) {\n    MailboxRecordId.preencode(state, m.id)\n  },\n  encode (state, m) {\n    MailboxRecordId.encode(state, m.id)\n  },\n  decode (state) {\n    return {\n      id: MailboxRecordId.decode(state)\n    }\n  }\n}\n\n// !!! Note: All these operations will be ignored\nconst OldOpenMailboxOperation = {\n  TYPE: 24,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.blindingKey)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.blindingKey)\n  },\n  decode (state) {\n    return {\n      blindingKey: c.fixed32.decode(state)\n    }\n  }\n}\n\n// !!! Note: Type 24 is off limits forever due to premature release\nconst OpenMailboxOperation = {\n  TYPE: 25,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.blindingKey)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.blindingKey)\n  },\n  decode (state) {\n    return {\n      blindingKey: c.fixed32.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  AddDmRequestOperation,\n  RemoveDmRequestOperation,\n  AddMailboxRecordOperation,\n  RemoveMailboxRecordOperation,\n  OldOpenMailboxOperation,\n  OpenMailboxOperation\n}\nconst c = require('compact-encoding')\nconst HyperIndex = require('@holepunchto/hyperindex')\n\nconst {\n  IndexMemberId,\n  PendingMemberRecord,\n  IndexMemberRecord,\n  AvatarRecord,\n  MemberRecord\n} = require('./messages')\nconst {\n  UpdateMemberOperationV1,\n  UpdateMemberOperationV2,\n  RemoveMemberOperation,\n  ChangeMemberRoleOperation,\n  MuteMemberOperation,\n  UnmuteMemberOperation\n} = require('./ops')\n\nmodule.exports = class MemberSchema {\n  static Messages = {\n\n  }\n\n  static Operations = {\n    UpdateMemberOperationV1,\n    UpdateMemberOperationV2,\n    RemoveMemberOperation,\n    ChangeMemberRoleOperation,\n    MuteMemberOperation,\n    UnmuteMemberOperation\n  }\n\n  // Collections\n\n  static MembersCollection = {\n    keyEncoding: IndexMemberId,\n    valueEncoding: MemberRecord\n  }\n\n  static PendingMembersCollection = {\n    keyEncoding: IndexMemberId,\n    valueEncoding: PendingMemberRecord\n  }\n\n  static InactiveMembersCollection = {\n    keyEncoding: IndexMemberId,\n    valueEncoding: MemberRecord\n  }\n\n  static AvatarsCollection = {\n    keyEncoding: IndexMemberId,\n    valueEncoding: AvatarRecord\n  }\n\n  static MutedMembersCollection = {\n    keyEncoding: IndexMemberId,\n    valueEncoding: c.buffer\n  }\n\n  // Indexes\n\n  static MembersIndexes = [\n    {\n      keyEncoding: [HyperIndex.STRING, IndexMemberId] // memberKeysByMemberName\n    },\n    {\n      keyEncoding: HyperIndex.BUFFER, // membersByDeviceKey\n      valueEncoding: IndexMemberRecord\n    },\n    {\n      keyEncoding: IndexMemberId, // capabilitiesByDeviceKey\n      valueEncoding: c.uint\n    },\n    {\n      keyEncoding: IndexMemberId, // moderatorsByMemberKey\n      valueEncoding: c.buffer\n    },\n    {\n      keyEncoding: HyperIndex.UINT, // membersCount\n      valueEncoding: c.uint\n    }\n  ]\n\n  static InactiveMembersIndexes = [\n    {\n      keyEncoding: HyperIndex.BUFFER, // removedMembersByDeviceKey\n      valueEncoding: IndexMemberRecord\n    }\n  ]\n}\nconst HyperIndex = require('@holepunchto/hyperindex')\nconst c = require('compact-encoding')\n\nconst MemberId = c.fixed32\nconst AvatarRecord = c.buffer\nconst DeviceList = c.array(c.fixed32)\nconst IndexMemberId = HyperIndex.BUFFER\n\nconst Identity = {\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.memberKey)\n    c.buffer.preencode(state, m.proof)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.memberKey)\n    c.buffer.encode(state, m.proof)\n  },\n  decode (state) {\n    return {\n      memberKey: c.fixed32.decode(state),\n      proof: c.buffer.decode(state)\n    }\n  }\n}\n\nconst IndexMemberRecord = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.fixed32.preencode(state, m.key)\n    if (m.displayName) c.string.preencode(state, m.displayName)\n    if (m.capabilities) c.uint.preencode(state, m.capabilities)\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.fixed32.encode(state, m.key)\n\n    let flags = 0\n    if (m.displayName) {\n      flags |= 1\n      c.string.encode(state, m.displayName)\n    }\n    if (m.capabilities) {\n      flags |= 2\n      c.uint.encode(state, m.capabilities)\n    }\n    if (m.hasAvatar) {\n      flags |= 4\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      key: c.fixed32.decode(state),\n      displayName: (flags & 1) !== 0 ? c.string.decode(state) : null,\n      capabilities: (flags & 2) !== 0 ? c.uint.decode(state) : 0,\n      hasAvatar: (flags & 4) !== 0\n    }\n  }\n}\n\nconst Attestation = {\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.memberKey)\n    c.buffer.preencode(state, m.receipt)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.memberKey)\n    c.buffer.encode(state, m.receipt)\n  },\n  decode (state) {\n    return {\n      memberKey: c.fixed32.decode(state),\n      receipt: c.buffer.decode(state)\n    }\n  }\n}\n\nconst MemberRecord = {\n  preencode (state, m) {\n    let flags = 0\n    if (m.displayName) flags |= 1\n    if (m.hasAvatar) flags |= 2\n    if (m.inactive) flags |= 4\n    c.uint.preencode(state, flags) // flags\n\n    c.uint.preencode(state, m.timestamp)\n    c.fixed32.preencode(state, m.key)\n    c.uint.preencode(state, m.capabilities)\n    c.buffer.preencode(state, m.latestReceipt)\n    DeviceList.preencode(state, m.devices)\n\n    if (m.displayName) c.string.preencode(state, m.displayName)\n    if (m.inactive) DeviceList.preencode(state, m.inactive)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.displayName) flags |= 1\n    if (m.hasAvatar) flags |= 2\n    if (m.inactive) flags |= 4\n    c.uint.encode(state, flags)\n\n    c.uint.encode(state, m.timestamp)\n    c.fixed32.encode(state, m.key)\n    c.uint.encode(state, m.capabilities)\n    c.buffer.encode(state, m.latestReceipt)\n    DeviceList.encode(state, m.devices)\n\n    if (m.displayName) c.string.encode(state, m.displayName)\n    if (m.inactive) DeviceList.encode(state, m.inactive)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      timestamp: c.uint.decode(state),\n      key: c.fixed32.decode(state),\n      capabilities: c.uint.decode(state),\n      latestReceipt: c.buffer.decode(state),\n      devices: DeviceList.decode(state),\n      displayName: (flags & 1) !== 0 ? c.string.decode(state) : null,\n      hasAvatar: (flags & 2) !== 0,\n      inactive: (flags & 4) !== 0 ? DeviceList.decode(state) : null\n    }\n  }\n}\n\nconst PendingMemberRecord = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.uint.preencode(state, m.capabilities)\n    if (m.invitation) c.fixed32.preencode(state, m.invitation)\n    if (m.attestation) Attestation.preencode(state, m.attestation)\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.uint.encode(state, m.capabilities)\n\n    let flags = 0\n    if (m.invitation) {\n      flags |= 1\n      c.fixed32.encode(state, m.invitation)\n    }\n    if (m.attestation) {\n      flags |= 2\n      Attestation.encode(state, m.attestation)\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      capabilities: c.uint.decode(state),\n      invitation: (flags & 1) !== 0 ? c.fixed32.decode(state) : null,\n      attestation: (flags & 2) !== 0 ? Attestation.decode(state) : null\n    }\n  }\n}\n\nmodule.exports = {\n  Identity,\n  MemberId,\n  IndexMemberId,\n  PendingMemberRecord,\n  IndexMemberRecord,\n  AvatarRecord,\n  MemberRecord\n}\nconst c = require('compact-encoding')\nconst { Identity } = require('./messages')\n\nconst UpdateMemberOperationV1 = {\n  TYPE: 10,\n  preencode (state, m) {\n    state.end++ // flags\n    c.string.preencode(state, m.displayName)\n    c.buffer.preencode(state, m.avatar)\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.string.encode(state, m.displayName)\n    c.buffer.encode(state, m.avatar)\n\n    let flags = 0\n    if (m.pushNotifications) {\n      flags |= 1\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      displayName: c.string.decode(state),\n      avatar: c.buffer.decode(state),\n      pushNotifications: (flags & 1) !== 0\n    }\n  }\n}\n\nconst UpdateMemberOperationV2 = {\n  TYPE: 17,\n  preencode (state, m) {\n    let flags = 0\n    if (m.displayName) flags |= 1\n    if (m.avatar) flags |= 2\n    if (m.identity) flags |= 4\n    if (m.isMobile) flags |= 8\n    c.uint.preencode(state, flags) // flags\n\n    if (m.displayName) c.string.preencode(state, m.displayName)\n    if (m.avatar) c.buffer.preencode(state, m.avatar)\n    if (m.identity) Identity.preencode(state, m.identity)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.displayName) flags |= 1\n    if (m.avatar) flags |= 2\n    if (m.identity) flags |= 4\n    if (m.isMobile) flags |= 8\n    c.uint.encode(state, flags)\n\n    if (m.displayName) c.string.encode(state, m.displayName)\n    if (m.avatar) c.buffer.encode(state, m.avatar)\n    if (m.identity) Identity.encode(state, m.identity)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      displayName: (flags & 1) !== 0 ? c.string.decode(state) : null,\n      avatar: (flags & 2) !== 0 ? c.buffer.decode(state) : null,\n      identity: (flags & 4) !== 0 ? Identity.decode(state) : null,\n      isMobile: (flags & 8) !== 0\n    }\n  }\n}\n\nconst ChangeMemberRoleOperation = {\n  TYPE: 32,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.memberKey)\n    c.uint.preencode(state, m.role)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.memberKey)\n    c.uint.encode(state, m.role)\n  },\n  decode (state) {\n    return {\n      memberKey: c.fixed32.decode(state),\n      role: c.uint.decode(state)\n    }\n  }\n}\n\nconst RemoveMemberOperation = {\n  TYPE: 33,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.memberKey)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.memberKey)\n  },\n  decode (state) {\n    return {\n      memberKey: c.fixed32.decode(state)\n    }\n  }\n}\n\nconst MuteMemberOperation = {\n  TYPE: 38,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.memberKey)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.memberKey)\n  },\n  decode (state) {\n    return {\n      memberKey: c.fixed32.decode(state)\n    }\n  }\n}\n\nconst UnmuteMemberOperation = {\n  TYPE: 39,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.memberKey)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.memberKey)\n  },\n  decode (state) {\n    return {\n      memberKey: c.fixed32.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  UpdateMemberOperationV1,\n  UpdateMemberOperationV2,\n  ChangeMemberRoleOperation,\n  RemoveMemberOperation,\n  MuteMemberOperation,\n  UnmuteMemberOperation\n}\nconst SubEncoder = require('sub-encoder')\nconst b4a = require('b4a')\n\nconst { PluginOperation } = require('./ops')\n\nconst PLUGINS_PREFIX = b4a.from([1])\nconst pluginsEncoding = new SubEncoder(PLUGINS_PREFIX)\n\nmodule.exports = class PluginSchema {\n  static Encoding = pluginsEncoding\n\n  static Messages = {\n\n  }\n\n  static Operations = {\n    PluginOperation\n  }\n}\nconst c = require('compact-encoding')\n\nconst PluginRecord = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.string.preencode(state, m.name)\n    if (m.key) {\n      c.fixed32.preencode(state, m.key)\n      c.uint.preencode(state, m.length)\n      c.uint.preencode(state, m.fork)\n    }\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.string.encode(state, m.name)\n\n    let flags = 0\n    if (m.key) {\n      flags |= 1\n      c.fixed32.encode(state, m.key)\n      c.uint.encode(state, m.length)\n      c.uint.encode(state, m.fork)\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      name: c.string.decode(state),\n      key: (flags & 1) !== 0 ? c.fixed32.decode(state) : null,\n      length: (flags & 1) !== 0 ? c.uint.decode(state) : 0,\n      fork: (flags & 1) !== 0 ? c.uint.decode(state) : 0\n    }\n  }\n}\n\nmodule.exports = {\n  PluginRecord\n}\nconst c = require('compact-encoding')\n\nconst PluginOperation = {\n  TYPE: 16,\n  preencode (state, m) {\n    state.end++ // flags\n    c.string.preencode(state, m.name)\n    if (m.encoded) {\n      c.buffer.preencode(state, m.value)\n    } else {\n      c.any.preencode(state, m.value)\n    }\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.string.encode(state, m.name)\n\n    let flags = 0\n    if (m.encoded) {\n      flags |= 1\n      c.buffer.encode(state, m.value)\n    } else {\n      c.any.encode(state, m.value)\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      name: c.string.decode(state),\n      value: (flags & 1) !== 0 ? c.buffer.decode(state) : c.any.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  PluginOperation\n}\nconst c = require('compact-encoding')\nconst HyperIndex = require('@holepunchto/hyperindex')\n\nconst {\n  AddDeviceAttestationOperation,\n  AddDeviceKeyOperation,\n  RemoveRoomOperation,\n  AddRoomOperation\n} = require('./ops')\nconst { RoomRecord } = require('./messages')\n\nmodule.exports = class PrivateProfileSchema {\n  static Messages = {\n\n  }\n\n  static Operations = {\n    AddDeviceAttestationOperation,\n    AddDeviceKeyOperation,\n    RemoveRoomOperation,\n    AddRoomOperation\n  }\n\n  static AttestationsCollection = {\n    keyEncoding: HyperIndex.BUFFER,\n    valueEncoding: c.buffer\n  }\n\n  static DeviceKeysCollection = {\n    keyEncoding: HyperIndex.BUFFER,\n    valueEncoding: c.buffer\n  }\n\n  static RoomsCollection = {\n    keyEncoding: HyperIndex.BUFFER,\n    valueEncoding: RoomRecord\n  }\n}\nconst c = require('compact-encoding')\n\nconst RoomRecord = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.fixed32.preencode(state, m.key)\n  },\n  encode (state, m) {\n    c.uint.encode(state, 0) // flags\n    c.fixed32.encode(state, m.key)\n  },\n  decode (state) {\n    c.uint.decode(state) // flags\n    return {\n      key: c.fixed32.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  RoomRecord\n}\nconst c = require('compact-encoding')\n\nconst AddDeviceAttestationOperation = {\n  TYPE: 1,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.devicePublicKey)\n    c.buffer.preencode(state, m.attestation)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.devicePublicKey)\n    c.buffer.encode(state, m.attestation)\n  },\n  decode (state) {\n    return {\n      devicePublicKey: c.fixed32.decode(state),\n      attestation: c.buffer.decode(state)\n    }\n  }\n}\n\nconst AddDeviceKeyOperation = {\n  TYPE: 2,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.devicePublicKey)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.devicePublicKey)\n  },\n  decode (state) {\n    return {\n      devicePublicKey: c.fixed32.decode(state)\n    }\n  }\n}\n\nconst AddRoomOperation = {\n  TYPE: 3,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.key)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.key)\n  },\n  decode (state) {\n    return {\n      key: c.fixed32.decode(state)\n    }\n  }\n}\n\nconst RemoveRoomOperation = {\n  TYPE: 4,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.key)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.key)\n  },\n  decode (state) {\n    return {\n      key: c.fixed32.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  AddDeviceAttestationOperation,\n  AddDeviceKeyOperation,\n  RemoveRoomOperation,\n  AddRoomOperation\n}\nconst c = require('compact-encoding')\nconst HyperIndex = require('@holepunchto/hyperindex')\n\nconst {\n  AddDeviceKeyOperation,\n  AddDeviceAttestationOperation\n} = require('./ops')\n\nmodule.exports = class PrivateDeviceSchema {\n  static Messages = {\n    //\n  }\n\n  static Operations = {\n    AddDeviceKeyOperation,\n    AddDeviceAttestationOperation\n  }\n\n  static DeviceKeysCollection = {\n    keyEncoding: HyperIndex.BUFFER,\n    valueEncoding: c.buffer\n  }\n\n  static AttestationsCollection = {\n    keyEncoding: HyperIndex.BUFFER,\n    valueEncoding: c.buffer\n  }\n}\nconst c = require('compact-encoding')\n\nconst AddDeviceKeyOperation = {\n  TYPE: 36,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.devicePublicKey)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.devicePublicKey)\n  },\n  decode (state) {\n    return {\n      devicePublicKey: c.fixed32.decode(state)\n    }\n  }\n}\n\nconst AddDeviceAttestationOperation = {\n  TYPE: 37,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.devicePublicKey)\n    c.buffer.preencode(state, m.attestation)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.devicePublicKey)\n    c.buffer.encode(state, m.attestation)\n  },\n  decode (state) {\n    return {\n      devicePublicKey: c.fixed32.decode(state),\n      attestation: c.buffer.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  AddDeviceKeyOperation,\n  AddDeviceAttestationOperation\n}\nconst c = require('compact-encoding')\nconst HyperIndex = require('@holepunchto/hyperindex')\nconst { IndexMessageId } = require('../chat/messages')\nconst { PrivateMailboxRecordData, PrivateMailboxRecordId, DmIndexRecord } = require('./messages')\n\nconst {\n  AddPrivateMailboxRecordOperation,\n  UpdatePrivateMailboxRecordOperation\n} = require('./ops')\n\nmodule.exports = class PrivateMailboxSchema {\n  static Messages = {\n    //\n  }\n\n  static Operations = {\n    AddPrivateMailboxRecordOperation,\n    UpdatePrivateMailboxRecordOperation\n  }\n\n  static PrivateMailboxCollection = {\n    keyEncoding: [c.lexint, c.fixed32, c.uint], // timestamp, roomKey, mailbox seq\n    valueEncoding: PrivateMailboxRecordData\n  }\n\n  static SentPrivateMailboxCollection = {\n    keyEncoding: [c.lexint, c.fixed32, c.uint], // timestamp, roomKey, mailbox seq\n    valueEncoding: PrivateMailboxRecordData\n  }\n\n  static PrivateMailboxIndexes = [\n    {\n      keyEncoding: c.fixed32, // dmByMember\n      valueEncoding: DmIndexRecord\n    },\n    {\n      keyEncoding: IndexMessageId, // privateMailByMessageId\n      valueEncoding: PrivateMailboxRecordId\n    },\n    {\n      keyEncoding: [HyperIndex.BUFFER, ...IndexMessageId], // privateMailByPublicMail [roomKey, msg key, msg seq]\n      valueEncoding: PrivateMailboxRecordId\n    },\n    {\n      keyEncoding: HyperIndex.UINT, // privateMailboxCounter\n      valueEncoding: HyperIndex.UINT // noop\n    }\n  ]\n}\nconst c = require('compact-encoding')\nconst { MemberId } = require('../members/messages')\nconst { MessageId } = require('../chat/messages')\n\nconst PrivateMailboxRecordId = {\n  preencode (state, id) {\n    c.uint.preencode(state, id.timestamp)\n    MemberId.preencode(state, id.roomKey)\n    c.uint.preencode(state, id.seq)\n  },\n  encode (state, id) {\n    c.uint.encode(state, id.timestamp)\n    MemberId.encode(state, id.roomKey)\n    c.uint.encode(state, id.seq)\n  },\n  decode (state) {\n    return {\n      timestamp: c.uint.decode(state),\n      roomKey: MemberId.decode(state),\n      seq: c.uint.decode(state)\n    }\n  }\n}\n\nconst PrivateMailboxRecordData = {\n  preencode (state, m) {\n    let flags = 0\n    if (m.message) flags |= 1\n    if (m.invitation) flags |= 2\n    if (m.seen) flags |= 4\n    if (m.id) flags |= 8\n    if (m.mailId) flags |= 16\n    if (m.targetRoomKey) flags |= 32\n    if (m.receiverKey) flags |= 64\n    if (m.status) flags |= 128\n    c.uint.preencode(state, flags)\n    c.uint.preencode(state, m.type)\n    c.buffer.preencode(state, m.senderKey)\n    if (m.message) c.string.preencode(state, m.message)\n    if (m.invitation) c.string.preencode(state, m.invitation)\n    if (m.id) MessageId.preencode(state, m.id)\n    if (m.mailId) MessageId.preencode(state, m.mailId)\n    if (m.targetRoomKey) c.buffer.preencode(state, m.targetRoomKey)\n    if (m.receiverKey) c.buffer.preencode(state, m.receiverKey)\n    if (m.status) c.uint.preencode(state, m.status)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.message) flags |= 1\n    if (m.invitation) flags |= 2\n    if (m.seen) flags |= 4\n    if (m.id) flags |= 8\n    if (m.mailId) flags |= 16\n    if (m.targetRoomKey) flags |= 32\n    if (m.receiverKey) flags |= 64\n    if (m.status) flags |= 128\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.type)\n    c.buffer.encode(state, m.senderKey)\n    if (m.message) c.string.encode(state, m.message)\n    if (m.invitation) c.string.encode(state, m.invitation)\n    if (m.id) MessageId.encode(state, m.id)\n    if (m.mailId) MessageId.encode(state, m.mailId)\n    if (m.targetRoomKey) c.buffer.encode(state, m.targetRoomKey)\n    if (m.receiverKey) c.buffer.encode(state, m.receiverKey)\n    if (m.status) c.uint.encode(state, m.status)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      seen: (flags & 4) !== 0,\n      type: c.uint.decode(state),\n      senderKey: c.buffer.decode(state),\n      message: (flags & 1) !== 0 ? c.string.decode(state) : null,\n      invitation: (flags & 2) !== 0 ? c.string.decode(state) : null,\n      id: (flags & 8) !== 0 ? MessageId.decode(state) : null,\n      mailId: (flags & 16) !== 0 ? MessageId.decode(state) : null,\n      targetRoomKey: (flags & 32) !== 0 ? c.buffer.decode(state) : null,\n      receiverKey: (flags & 64) !== 0 ? c.buffer.decode(state) : null,\n      status: (flags & 128) !== 0 ? c.uint.decode(state) : null\n    }\n  }\n}\n\nconst DmIndexRecord = {\n  preencode (state, m) {\n    let flags = 0\n    if (m.roomKey) flags |= 1\n    if (m.status) flags |= 2\n    c.uint.preencode(state, flags)\n    MessageId.preencode(state, m.id) // private mailbox msg ID\n    if (m.roomKey) c.buffer.preencode(state, m.roomKey)\n    if (m.status) c.uint.preencode(state, m.status)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.roomKey) flags |= 1\n    if (m.status) flags |= 2\n    c.uint.encode(state, flags)\n    MessageId.encode(state, m.id)\n    if (m.roomKey) c.buffer.encode(state, m.roomKey)\n    if (m.status) c.uint.encode(state, m.status)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      id: MessageId.decode(state),\n      roomKey: (flags & 1) !== 0 ? c.buffer.decode(state) : null,\n      status: (flags & 2) !== 0 ? c.uint.decode(state) : null\n    }\n  }\n}\n\nmodule.exports = {\n  DmIndexRecord,\n  PrivateMailboxRecordId,\n  PrivateMailboxRecordData\n}\nconst c = require('compact-encoding')\nconst { PrivateMailboxRecordId } = require('./messages')\nconst { MessageId } = require('../chat/messages')\n\nconst AddPrivateMailboxRecordOperation = {\n  TYPE: 30,\n  preencode (state, m) {\n    let flags = 0\n    if (m.message) flags |= 1\n    if (m.invitation) flags |= 2\n    if (m.mailId) flags |= 4\n    if (m.targetRoomKey) flags |= 8\n    if (m.receiverKey) flags |= 16\n    c.uint.preencode(state, flags)\n    c.uint.preencode(state, m.type)\n    c.uint.preencode(state, m.seq)\n    c.uint.preencode(state, m.timestamp)\n    c.buffer.preencode(state, m.senderKey)\n    c.buffer.preencode(state, m.roomKey)\n    if (m.message) c.string.preencode(state, m.message)\n    if (m.invitation) c.string.preencode(state, m.invitation)\n    if (m.mailId) MessageId.preencode(state, m.mailId)\n    if (m.targetRoomKey) c.buffer.preencode(state, m.targetRoomKey)\n    if (m.receiverKey) c.buffer.preencode(state, m.receiverKey)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.message) flags |= 1\n    if (m.invitation) flags |= 2\n    if (m.mailId) flags |= 4\n    if (m.targetRoomKey) flags |= 8\n    if (m.receiverKey) flags |= 16\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.type)\n    c.uint.encode(state, m.seq)\n    c.uint.encode(state, m.timestamp)\n    c.buffer.encode(state, m.senderKey)\n    c.buffer.encode(state, m.roomKey)\n    if (m.message) c.string.encode(state, m.message)\n    if (m.invitation) c.string.encode(state, m.invitation)\n    if (m.mailId) MessageId.encode(state, m.mailId)\n    if (m.targetRoomKey) c.buffer.encode(state, m.targetRoomKey)\n    if (m.receiverKey) c.buffer.encode(state, m.receiverKey)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      type: c.uint.decode(state),\n      seq: c.uint.decode(state),\n      timestamp: c.uint.decode(state),\n      senderKey: c.buffer.decode(state),\n      roomKey: c.buffer.decode(state), // source room key\n      message: (flags & 1) !== 0 ? c.string.decode(state) : null,\n      invitation: (flags & 2) !== 0 ? c.string.decode(state) : null,\n      mailId: (flags & 4) !== 0 ? MessageId.decode(state) : null,\n      targetRoomKey: (flags & 8) !== 0 ? c.buffer.decode(state) : null,\n      receiverKey: (flags & 16) !== 0 ? c.buffer.decode(state) : null\n    }\n  }\n}\n\nconst UpdatePrivateMailboxRecordOperation = {\n  TYPE: 31,\n  preencode (state, m) {\n    let flags = 0\n    if (m.seen) flags |= 1\n    if (m.msgId) flags |= 2\n    if (m.targetRoomKey) flags |= 4\n    if (m.status) flags |= 8\n    c.uint.preencode(state, flags)\n    PrivateMailboxRecordId.preencode(state, m.id)\n    if (m.msgId) MessageId.preencode(state, m.msgId)\n    if (m.targetRoomKey) c.buffer.preencode(state, m.targetRoomKey)\n    if (m.status) c.uint.preencode(state, m.status)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.seen) flags |= 1\n    if (m.msgId) flags |= 2\n    if (m.targetRoomKey) flags |= 4\n    if (m.status) flags |= 8\n    c.uint.encode(state, flags)\n    PrivateMailboxRecordId.encode(state, m.id)\n    if (m.msgId) MessageId.encode(state, m.msgId)\n    if (m.targetRoomKey) c.buffer.encode(state, m.targetRoomKey)\n    if (m.status) c.uint.encode(state, m.status)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      id: PrivateMailboxRecordId.decode(state),\n      seen: (flags & 1) !== 0,\n      msgId: (flags & 2) !== 0 ? MessageId.decode(state) : null,\n      targetRoomKey: (flags & 4) !== 0 ? c.buffer.decode(state) : null,\n      status: (flags & 8) !== 0 ? c.uint.decode(state) : null\n    }\n  }\n}\n\nmodule.exports = {\n  AddPrivateMailboxRecordOperation,\n  UpdatePrivateMailboxRecordOperation\n}\nconst HyperIndex = require('@holepunchto/hyperindex')\nconst { PrivateRoomRecord } = require('./messages')\n\nconst {\n  AddPrivateRoomOperation,\n  RemovePrivateRoomOperation\n} = require('./ops')\n\nmodule.exports = class PrivateRoomSchema {\n  static Messages = {\n    //\n  }\n\n  static Operations = {\n    AddPrivateRoomOperation,\n    RemovePrivateRoomOperation\n  }\n\n  static RoomsCollection = {\n    keyEncoding: HyperIndex.BUFFER,\n    valueEncoding: PrivateRoomRecord\n  }\n}\nconst c = require('compact-encoding')\n\nconst PrivateRoomRecord = {\n  preencode (state, m) {\n    c.uint.preencode(state, 0) // flags\n    c.fixed32.preencode(state, m.key)\n  },\n  encode (state, m) {\n    c.uint.encode(state, 0) // flags\n    c.fixed32.encode(state, m.key)\n  },\n  decode (state) {\n    c.uint.decode(state) // flags\n    return {\n      key: c.fixed32.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  PrivateRoomRecord\n}\nconst c = require('compact-encoding')\n\nconst AddPrivateRoomOperation = {\n  TYPE: 34,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.key)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.key)\n  },\n  decode (state) {\n    return {\n      key: c.fixed32.decode(state)\n    }\n  }\n}\n\nconst RemovePrivateRoomOperation = {\n  TYPE: 35,\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.key)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.key)\n  },\n  decode (state) {\n    return {\n      key: c.fixed32.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  RemovePrivateRoomOperation,\n  AddPrivateRoomOperation\n}\nconst c = require('compact-encoding')\nconst HyperIndex = require('@holepunchto/hyperindex')\n\nconst { IndexEventId } = require('../chat/messages')\nconst { IndexMemberId } = require('../members/messages')\nconst { ReactionsDigest, MemberReactions } = require('./messages')\n\nconst {\n  AddReactionOperation,\n  RemoveReactionOperation\n} = require('./ops')\n\nmodule.exports = class ReactionSchema {\n  static Messages = {\n\n  }\n\n  static Operations = {\n    AddReactionOperation,\n    RemoveReactionOperation\n  }\n\n  static ReactionsCollection = {\n    keyEncoding: [...IndexEventId, IndexMemberId, HyperIndex.STRING],\n    valueEncoding: c.buffer\n  }\n\n  static ReactionsIndexes = [\n    {\n      keyEncoding: IndexEventId, // reactionDigests\n      valueEncoding: ReactionsDigest\n    },\n    {\n      keyEncoding: [...IndexEventId, IndexMemberId], // reactionsByMember\n      valueEncoding: MemberReactions\n    }\n  ]\n}\nconst c = require('compact-encoding')\n\nconst { MemberId } = require('../members/messages')\nconst MemberIds = c.array(MemberId)\nconst MemberReactions = c.array(c.string)\n\nconst ReactionSummary = {\n  preencode (state, m) {\n    c.string.preencode(state, m.text)\n    c.uint.preencode(state, m.count)\n    MemberIds.preencode(state, m.latest)\n  },\n  encode (state, m) {\n    c.string.encode(state, m.text)\n    c.uint.encode(state, m.count)\n    MemberIds.encode(state, m.latest)\n  },\n  decode (state) {\n    return {\n      text: c.string.decode(state),\n      count: c.uint.decode(state),\n      latest: MemberIds.decode(state)\n    }\n  }\n}\nconst Summaries = c.array(ReactionSummary)\n\nconst ReactionsDigest = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.total)\n    Summaries.preencode(state, m.reactions)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.total)\n    Summaries.encode(state, m.reactions)\n  },\n  decode (state) {\n    return {\n      total: c.uint.decode(state),\n      reactions: Summaries.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  ReactionsDigest,\n  MemberReactions\n}\nconst c = require('compact-encoding')\nconst { MessageId } = require('../chat/messages')\n\nconst AddReactionOperation = {\n  TYPE: 8,\n  preencode (state, m) {\n    MessageId.preencode(state, m.to)\n    c.string.preencode(state, m.text)\n  },\n  encode (state, m) {\n    MessageId.encode(state, m.to)\n    c.string.encode(state, m.text)\n  },\n  decode (state) {\n    return {\n      to: MessageId.decode(state),\n      text: c.string.decode(state)\n    }\n  }\n}\n\nconst RemoveReactionOperation = {\n  TYPE: 9,\n  preencode (state, m) {\n    MessageId.preencode(state, m.to)\n    c.string.preencode(state, m.text)\n  },\n  encode (state, m) {\n    MessageId.encode(state, m.to)\n    c.string.encode(state, m.text)\n  },\n  decode (state) {\n    return {\n      to: MessageId.decode(state),\n      text: c.string.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  AddReactionOperation,\n  RemoveReactionOperation\n}\nconst HyperIndex = require('@holepunchto/hyperindex')\nconst ChatSchema = require('./chat')\nconst ConfigSchema = require('./config')\nconst MemberSchema = require('./members')\nconst ReactionSchema = require('./reactions')\nconst InvitationSchema = require('./invitations')\nconst DeviceSchema = require('./devices')\nconst MailboxSchema = require('./mailbox')\nconst PrivateMailboxSchema = require('./private-mailbox')\nconst PrivateRoomSchema = require('./private-rooms')\nconst PrivateDeviceSchema = require('./private-devices')\n\nmodule.exports = class SchemaBuilder {\n  constructor ({ view, tx }) {\n    this.view = view\n    this.dex = tx || new HyperIndex(view.bee, { offset: 2 })\n  }\n\n  createCollections () {\n    if (this.view.collections) return\n\n    if (!this.view.isApplyView) {\n      this.dex.createCollections([\n        ChatSchema.ChatCollection,\n        ReactionSchema.ReactionsCollection,\n        InvitationSchema.InvitationsCollection,\n        DeviceSchema.DevicesCollection,\n        MemberSchema.PendingMembersCollection,\n        MemberSchema.MembersCollection,\n        MemberSchema.AvatarsCollection,\n        ConfigSchema.Collection,\n        MailboxSchema.MailboxCollection,\n        MailboxSchema.OpenMailboxesCollection,\n        MemberSchema.InactiveMembersCollection,\n        MailboxSchema.MailboxCollectionV2,\n        PrivateMailboxSchema.PrivateMailboxCollection,\n        PrivateMailboxSchema.SentPrivateMailboxCollection,\n        PrivateRoomSchema.RoomsCollection,\n        PrivateDeviceSchema.DeviceKeysCollection,\n        PrivateDeviceSchema.AttestationsCollection,\n        MemberSchema.MutedMembersCollection\n      ])\n    }\n\n    const [\n      chat,\n      reactions,\n      invitations,\n      devices,\n      pendingMembers,\n      members,\n      avatars,\n      config,\n      mailbox,\n      openMailboxes,\n      inactiveMembers,\n      mailboxV2,\n      privateMailbox,\n      sentPrivateMailbox,\n      privateRooms,\n      privateDeviceKeys,\n      privateDeviceAttestations,\n      mutedMembers\n    ] = this.dex.collections\n\n    return {\n      chat,\n      reactions,\n      invitations,\n      devices,\n      pendingMembers,\n      inactiveMembers,\n      members,\n      avatars,\n      config,\n      mailbox,\n      mailboxV2,\n      openMailboxes,\n      privateMailbox,\n      sentPrivateMailbox,\n      privateRooms,\n      privateDeviceKeys,\n      privateDeviceAttestations,\n      mutedMembers\n    }\n  }\n\n  _indexReactions (_, op) {\n    return this.view._applyView.reactions.autobaseIndex(op)\n  }\n\n  _indexDevices (_, op) {\n    return this.view._applyView.devices.autobaseIndex(op)\n  }\n\n  _indexMembers (_, op) {\n    return this.view._applyView.members.autobaseIndexMembers(op)\n  }\n\n  _indexInactiveMembers (_, op) {\n    return this.view._applyView.members.autobaseIndexInactiveMembers(op)\n  }\n\n  _indexChat (_, op) {\n    return this.view._applyView.chat.autobaseIndex(op)\n  }\n\n  _indexMailbox (_, op) {\n    return this.view._applyView.mailbox.autobaseIndex(op)\n  }\n\n  _indexPrivateMailbox (_, op) {\n    return this.view._applyView.privateProfile.privateMailbox.autobaseIndex(op)\n  }\n\n  _indexSentPrivateMailbox (_, op) {\n    return this.view._applyView.privateProfile.privateMailbox.autobaseIndexSent(op)\n  }\n\n  createIndexes () {\n    if (this.view.indexes) return\n\n    if (!this.view.isApplyView) {\n      this.view.collections.reactions.createIndexes(ReactionSchema.ReactionsIndexes, this._indexReactions.bind(this))\n      this.view.collections.devices.createIndexes(DeviceSchema.DevicesIndexes, this._indexDevices.bind(this))\n      this.view.collections.members.createIndexes(MemberSchema.MembersIndexes, this._indexMembers.bind(this))\n      this.view.collections.chat.createIndexes(ChatSchema.ChatIndexes, this._indexChat.bind(this))\n      this.view.collections.inactiveMembers.createIndexes(MemberSchema.InactiveMembersIndexes, this._indexInactiveMembers.bind(this))\n      this.view.collections.mailboxV2.createIndexes(MailboxSchema.MailboxIndexes, this._indexMailbox.bind(this))\n      this.view.collections.privateMailbox.createIndexes(PrivateMailboxSchema.PrivateMailboxIndexes, this._indexPrivateMailbox.bind(this))\n      this.view.collections.sentPrivateMailbox.createIndexes(PrivateMailboxSchema.PrivateMailboxIndexes, this._indexSentPrivateMailbox.bind(this))\n    }\n\n    const [\n      eventIdsByMessageId,\n      eventIdsByClock,\n      mentionsByMemberId,\n      drivesByPath\n    ] = this.view.collections.chat.indexes\n\n    const [\n      reactionDigests,\n      reactionsByMember\n    ] = this.view.collections.reactions.indexes\n\n    const [\n      deviceKeysByNoisePublicKey,\n      deviceCount,\n      mobileDeviceCount\n    ] = this.view.collections.devices.indexes\n\n    const [\n      memberKeysByMemberName,\n      membersByDeviceKey,\n      capabilitiesByDeviceKey,\n      moderatorsByMemberKey,\n      membersCount\n    ] = this.view.collections.members.indexes\n\n    const [\n      inactiveMembersByDeviceKey\n    ] = this.view.collections.inactiveMembers.indexes\n\n    const [\n      mailboxCounter,\n      mailByMessageId\n    ] = this.view.collections.mailboxV2.indexes\n\n    const [\n      dmByMember,\n      privateMailByMessageId,\n      privateMailByPublicMail,\n      privateMailboxCounter\n    ] = this.view.collections.privateMailbox.indexes\n\n    this.view.indexes = {\n      eventIdsByMessageId,\n      eventIdsByClock,\n      mentionsByMemberId,\n      drivesByPath,\n      reactionDigests,\n      reactionsByMember,\n      deviceCount,\n      mobileDeviceCount,\n      deviceKeysByNoisePublicKey,\n      memberKeysByMemberName,\n      membersByDeviceKey,\n      inactiveMembersByDeviceKey,\n      capabilitiesByDeviceKey,\n      moderatorsByMemberKey,\n      membersCount,\n      mailboxCounter,\n      mailByMessageId,\n      dmByMember,\n      privateMailByMessageId,\n      privateMailByPublicMail,\n      privateMailboxCounter\n    }\n\n    return this.view.indexes\n  }\n}\n{\n  \"name\": \"@holepunchto/keet-core-schemas\",\n  \"description\": \"Database schemas used by keet-indexing\",\n  \"version\": \"2.17.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"lint\": \"standard\",\n    \"test\": \"npm run lint\"\n  },\n  \"keywords\": [],\n  \"author\": \"Holepunch Inc\",\n  \"license\": \"UNLICENSED\",\n  \"devDependencies\": {\n    \"standard\": \"^17.1.0\"\n  },\n  \"dependencies\": {\n    \"@holepunchto/hyperindex\": \"^2.3.2\",\n    \"@holepunchto/keet-core-api\": \"^1.24.0\",\n    \"b4a\": \"^1.6.6\",\n    \"compact-encoding\": \"^2.15.0\",\n    \"sub-encoder\": \"^2.1.3\"\n  }\n}\nconst ReadyResource = require('ready-resource')\nconst HypercoreId = require('hypercore-id-encoding')\nconst BufferMap = require('tiny-buffer-map')\nconst Hypercore = require('hypercore')\nconst Hyperdrive = require('hyperdrive')\nconst ParallelTransform = require('parallel-transformx')\nconst xorDistance = require('xor-distance')\nconst safetyCatch = require('safety-catch')\nconst crypto = require('hypercore-crypto')\nconst debounce = require('debounceify')\nconst b4a = require('b4a')\nconst z32 = require('z32')\nconst mutex = require('mutexify/promise')\nconst Semaphore = require('promaphore')\nconst { Readable, pipeline } = require('streamx')\n\nconst KeetPush = require('@holepunchto/keet-push')\nconst BlindMirror = require('@holepunchto/blind-mirror/client')\nconst BlindPairing = require('blind-pairing')\n\nconst KeetIdentity = require('./lib/identity')\nconst KeetPairing = require('./lib/pairing')\nconst Room = require('./lib/room')\nconst RoomChat = require('./lib/room/chat')\nconst RoomInvitations = require('./lib/room/invitations')\n\nconst {\n  KeetError,\n  MemberCapabilities,\n  isValidConfigKey,\n  CURRENT_ABI,\n  DISPLAY_TYPES,\n  DM_STATUSES,\n  MAIL_STATUSES,\n  MAIL_TYPES,\n  CONFIG\n} = require('@holepunchto/keet-core-api')\nconst {\n  PairingStatus\n} = require('./lib/local/messages')\n\nconst CORE_MODULE_VERSIONS = {\n  'keet-core': require('./package.json').version,\n  'keet-indexing': require('@holepunchto/keet-indexing/package.json').version,\n  autobase: require('autobase/package.json').version,\n  hypercore: require('hypercore/package.json').version,\n  hyperbee: require('hyperbee/package.json').version,\n  hyperdrive: require('hyperdrive/package.json').version,\n  hyperindex: require('@holepunchto/hyperindex/package.json').version,\n  'keet-identity-key': require('@holepunchto/keet-identity-key/package.json').version,\n  'blind-pairing': require('blind-pairing/package.json').version,\n  'blind-mirror': require('@holepunchto/blind-mirror/package.json').version,\n  'keet-push': require('@holepunchto/keet-push/package.json').version,\n  corestore: require('corestore/package.json').version\n}\n\n// Singletons\nconst DriveServer = require('./lib/drives')\nconst LocalDatabase = require('./lib/local')\nconst ActivityTracker = require('./lib/activity')\n\nconst MAX_PARALLEL_ROOM_OPENS = 4\n\n// !!! Bump this whenever production should auto-upgrade rooms to a new ABI version\n// !!! This will lag behind the production ABI, so we can manually test upgrading prod rooms\nconst CURRENT_PRODUCTION_AUTOUPGRADE_ABI = 5\n\nlet DEBUG_LOG_ID = 0\n\nmodule.exports = class KeetCore extends ReadyResource {\n  constructor (store, swarm, opts = {}) {\n    super()\n    this.store = store\n    this.swarm = swarm\n    this.opts = opts\n    this.isMobile = !!opts.mobile\n    this.isExperimental = !!opts.experimental\n    this.testing = !!opts.testing\n    this.abi = opts.testingABI || {\n      max: this.isExperimental ? CURRENT_ABI.EXPERIMENTAL : CURRENT_ABI.STABLE,\n      autoupgrade: CURRENT_PRODUCTION_AUTOUPGRADE_ABI,\n      production: CURRENT_ABI.STABLE\n    }\n    this.gcDisabled = opts.gcDisabled === true\n    this.gcIntervalInMs = opts.gcIntervalInMs || 5000\n    this.gcLoopCount = opts.gcLoopCount || 3\n\n    this.local = new LocalDatabase(this.store)\n    this.identity = new KeetIdentity(this, opts)\n\n    this.drives = new DriveServer(this, opts)\n    this.activity = new ActivityTracker(this)\n    this.pairing = new KeetPairing(this, opts)\n\n    this.gatekeepers = opts.gatekeepers || []\n    this.push = this.gatekeepers.length > 0\n      ? new KeetPush(this.gatekeepers, { dht: this.swarm.dht })\n      : null\n\n    this.blindMirrorKeys = opts.blindMirrorKeys ? opts.blindMirrorKeys.map(HypercoreId.decode) : []\n    this.blindMediaMirrorKeys = opts.blindMediaMirrorKeys ? opts.blindMediaMirrorKeys.map(HypercoreId.decode) : []\n    this.blindMirrorsByKey = new BufferMap()\n    this.suspended = false\n\n    this._lock = mutex()\n    this._keysByDiscoveryId = new Map()\n    this._roomsByKey = new BufferMap()\n    this._activatedRooms = new BufferMap()\n    this._pairingRooms = new BufferMap()\n    this._connectedMembersSubscriptions = new Map()\n    this._onconnection = this._onConnection.bind(this)\n    this._bumpsubscriptions = this._bumpConnectedMemberSubscriptions.bind(this)\n    this._fastForward = opts.fastForward !== false\n    this._debugLog = !!opts.debugLog\n    this._stats = {\n      ops: 0,\n      appends: 0,\n      bytesAppended: 0,\n      uploaded: 0,\n      bytesUploaded: 0,\n      downloaded: 0,\n      bytesDownloaded: 0\n    }\n\n    // TODO: Remove after Autobase 6 migration\n    this.internalRoomSemaphore = new Semaphore(MAX_PARALLEL_ROOM_OPENS)\n\n    // The comment START/END is the section mark to auto parsing and generate API.\n    // Stateless API START\n\n    // Versioning\n    this.getVersion = this._getVersion.bind(this)\n    this.subscribeRoomVersion = this._roomSubscription(this._subscribeRoomVersion.bind(this))\n    this.upgradeRoom = this._roomMethod(this._upgradeRoom.bind(this))\n\n    // Identity Management\n    this.getIdentity = this._getIdentity.bind(this)\n    this.subscribeIdentity = this._subscribeIdentity.bind(this)\n    this.generateIdentity = this._generateIdentity.bind(this)\n    this.restoreIdentity = this._restoreIdentity.bind(this)\n    this.setRecoveryPhrase = this._setRecoveryPhrase.bind(this)\n    this.getRecoveryPhrase = this._getRecoveryPhrase.bind(this)\n    this.confirmIdentity = this._confirmIdentity.bind(this)\n    this.confirmPairingRequest = this._confirmPairingRequest.bind(this)\n    this.subscribeIdentityPairingRequests = this._subscribeIdentityPairingRequests.bind(this)\n    this.updateIdentityProfile = this._updateIdentityProfile.bind(this)\n    this.updateIdentityDevice = this._updateIdentityDevice.bind(this)\n    this.startPairingIdentity = this._startPairingIdentity.bind(this)\n    this.pairIdentity = this._compatPairIdentity.bind(this)\n\n    // Room Creation + Pairing\n    this.createRoom = this._createRoom.bind(this)\n    this.pairRoom = this._compatPairRoom.bind(this)\n    this.leaveRoom = this._leaveRoom.bind(this)\n    this.startPairingRoom = this._startPairingRoom.bind(this)\n    this.stopPairingRoom = this._stopPairingRoom.bind(this)\n    this.subscribePendingRooms = this._subscribePendingRooms.bind(this)\n\n    // Rooms\n    this.subscribeActivateRoom = this._roomSubscription(this._subscribeActivateRoom.bind(this))\n    this.getRoomKeys = this._getRoomKeys.bind(this)\n    this.getTipSize = this._roomMethod(this._getTipSize.bind(this))\n\n    // History + Bookmarking (disabled)\n    this.bookmark = this._bookmark.bind(this)\n    this.unbookmark = this._unbookmark.bind(this)\n    this.subscribeBookmarks = this._subscribeBookmarks.bind(this)\n    this.getRecentRooms = this._getRecentRooms.bind(this)\n    this.getLocalRoomMetadata = this._getLocalRoomMetadata.bind(this)\n    this.subscribeRecentRooms = this._subscribeRecentRooms.bind(this)\n    this.subscribeUnreadActivity = this._subscribeUnreadActivity.bind(this)\n\n    // Unread + Priority\n    this.setRoomUnread = this._setRoomUnread.bind(this)\n    this.bumpRoomPriority = this._bumpRoomPriority.bind(this)\n\n    // Devices\n    this.addDevice = this._roomMethod(this._addDevice.bind(this))\n    this.removeDevice = this._roomMethod(this._removeDevice.bind(this))\n    this.getDevice = this._roomMethod(this._getDevice.bind(this))\n    this.getDevices = this._roomMethod(this._getDevices.bind(this))\n    this.subscribeDevice = this._roomSubscription(this._subscribeDevice.bind(this))\n    this.subscribeDevices = this._roomSubscription(this._subscribeDevices.bind(this))\n\n    // Invitations\n    this.createIdentityInvitation = this._createIdentityInvitation.bind(this)\n    this.createInvitation = this._roomMethod(this._createInvitation.bind(this))\n\n    // Members\n    this.updateMember = this._roomMethod(this._updateMember.bind(this))\n    this.muteMember = this._roomMethod(this._muteMember.bind(this))\n    this.unmuteMember = this._roomMethod(this._unmuteMember.bind(this))\n    this.isMemberMuted = this._roomMethod(this._isMemberMuted.bind(this))\n    this.getMember = this._roomMethod(this._getMember.bind(this))\n    this.removeMember = this._roomMethod(this._removeMember.bind(this))\n    this.getMembers = this._roomMethod(this._getMembers.bind(this))\n    this.getModerators = this._roomMethod(this._getModerators.bind(this))\n    this.getMemberCount = this._roomMethod(this._getMemberCount.bind(this))\n    this.waitUntilJoined = this._roomMethod(this._waitUntilJoined.bind(this))\n    this.getMemberForDevice = this._roomMethod(this._getMemberForDevice.bind(this))\n    this.subscribeMemberCount = this._roomSubscription(this._subscribeMemberCount.bind(this))\n    this.subscribeMember = this._roomSubscription(this._subscribeMember.bind(this))\n    this.subscribeMembers = this._roomSubscription(this._subscribeMembers.bind(this))\n    this.subscribeModerators = this._roomSubscription(this._subscribeModerators.bind(this))\n    this.subscribeMemberForDevice = this._roomSubscription(this._subscribeMemberForDevice.bind(this))\n\n    // Member Roles\n    this.changeMemberRole = this._roomMethod(this._changeMemberRole.bind(this))\n\n    // Member Search\n    this.getSearchMembers = this._roomMethod(this._getSearchMembers.bind(this))\n    this.getPushNotificationMembers = this._roomMethod(this._getPushNotificationMembers.bind(this))\n    this.subscribeSearchMembers = this._roomSubscription(this._subscribeSearchMembers.bind(this))\n    this.subscribePushNotificationMembers = this._roomSubscription(this._subscribePushNotificationMembers.bind(this))\n\n    // Member Blocking\n    this.blockMember = this._roomMethod(this._blockMember.bind(this))\n    this.unblockMember = this._roomMethod(this._unblockMember.bind(this))\n    this.getBlockedMembers = this._getBlockedMembers.bind(this)\n    this.subscribeBlockedMembers = this._subscribeBlockedMembers.bind(this)\n\n    // Connected Members\n    this.getConnectedMembers = this._roomMethod(this._getConnectedMembers.bind(this))\n    this.subscribeConnectedMembers = this._roomSubscription(this._subscribeConnectedMembers.bind(this))\n\n    // Config\n    this.updateConfig = this._roomMethod(this._updateConfig.bind(this))\n    this.getConfig = this._roomMethod(this._getConfig.bind(this))\n    this.subscribeConfig = this._roomSubscription(this._subscribeConfig.bind(this))\n\n    // Chat\n    this.addChatMessage = this._roomMethod(this._addChatMessage.bind(this))\n    this.updateChatMessage = this._roomMethod(this._updateChatMessage.bind(this))\n    this.removeChatMessage = this._roomMethod(this._removeChatMessage.bind(this))\n    this.pinChatMessage = this._roomMethod(this._pinChatMessage.bind(this))\n    this.addCallStartedEvent = this._roomMethod(this._addCallStartedEvent.bind(this))\n    this.addRoomAvatarChangedEvent = this._roomMethod(this._addRoomAvatarChangedEvent.bind(this))\n    this.addEvent = this._roomMethod(this._addEvent.bind(this))\n    this.removeEvent = this._roomMethod(this._removeEvent.bind(this))\n    this.getChatMessage = this._roomMethod(this._getChatMessage.bind(this))\n    this.getChatMessageById = this._roomMethod(this._getChatMessageById.bind(this))\n    this.getChatMessages = this._roomMethod(this._getChatMessages.bind(this))\n    this.getPinnedChatMessages = this._roomMethod(this._getPinnedChatMessages.bind(this))\n    this.getChatLength = this._roomMethod(this._getChatLength.bind(this))\n    this.subscribeChatMessages = this._roomSubscription(this._subscribeChatMessages.bind(this))\n    this.subscribeChatLength = this._roomSubscription(this._subscribeChatLength.bind(this))\n\n    // Mailbox\n    this.sendInvitations = this._roomMethod(this._sendInvitations.bind(this))\n    // Private mailbox\n    this.updatePrivateMailboxRecord = this._updatePrivateMailboxRecord.bind(this)\n    this.getPrivateMailboxRecords = this._getPrivateMailboxRecords.bind(this)\n    this.subscribePrivateMailbox = this._subscribePrivateMailbox.bind(this)\n    // Private mailbox - sent\n    this.getSentPrivateMailboxRecords = this._getSentPrivateMailboxRecords.bind(this)\n    this.subscribeSentPrivateMailbox = this._subscribeSentPrivateMailbox.bind(this)\n    // Private mailbox - dm\n    this.getDmList = this._getDmList.bind(this)\n    this.getDmByMemberId = this._getDmByMemberId.bind(this)\n    this.subscribeDmList = this._subscribeDmList.bind(this)\n    this.acceptDmRequest = this._acceptDmRequest.bind(this)\n    this.rejectDmRequest = this._rejectDmRequest.bind(this)\n\n    // Reactions\n    this.addReaction = this._roomMethod(this._addReaction.bind(this))\n    this.removeReaction = this._roomMethod(this._removeReaction.bind(this))\n    this.getReactions = this._roomMethod(this._getReactions.bind(this))\n    this.subscribeReactions = this._roomSubscription(this._subscribeReactions.bind(this))\n\n    // Files\n    this.addFileBlob = this._roomMethod(this._addFileBlob.bind(this))\n    this.addFile = this._roomMethod(this._addFile.bind(this))\n    this.saveFileBlob = this._roomMethod(this._saveFileBlob.bind(this))\n    this.saveFile = this._roomMethod(this._saveFile.bind(this))\n    this.sendFile = this._roomMethod(this._sendFile.bind(this))\n    this.removeFile = this._roomMethod(this._removeFile.bind(this))\n    this.refreshFileLinks = this._refreshFileLinks.bind(this)\n    this.subscribeFileInfo = this._roomSubscription(this._subscribeFileInfo.bind(this))\n    this.clearAllFiles = this._clearAllFiles.bind(this)\n    this.getFileEntry = this._getFileEntry.bind(this)\n    this.getLocalFiles = this._getLocalFiles.bind(this)\n    this.startDownload = this._startDownload.bind(this)\n    this.cancelDownload = this._cancelDownload.bind(this)\n\n    // File Clearing\n    this.clearFile = this._clearFile.bind(this)\n    this.unclearFile = this._unclearFile.bind(this)\n    this.getFileCleared = this._getFileCleared.bind(this)\n    this.subscribeFileCleared = this._subscribeFileCleared.bind(this)\n\n    // Debugging + Stats\n    this.getStats = this._getStats.bind(this)\n    this.subscribeProgress = this._roomSubscription(this._subscribeProgress.bind(this))\n\n    // Stateless API END\n\n    this.swarm.on('connection', this._onconnection)\n    this.store.on('core-open', (core) => {\n      core.on('upload', (index, byteLength) => {\n        this._stats.uploaded++\n        this._stats.bytesUploaded += byteLength\n      })\n      core.on('download', (index, byteLength) => {\n        this._stats.downloaded++\n        this._stats.bytesDownloaded += byteLength\n      })\n      if (core.writable) {\n        let currentLength = core.length\n        let currentByteLength = core.byteLength\n        core.on('append', () => {\n          const newLength = core.length\n          const newByteLength = core.byteLength\n          this._stats.appends += (newLength - currentLength)\n          this._stats.bytesAppended += (newByteLength - currentByteLength)\n          currentLength = newLength\n          currentByteLength = newByteLength\n        })\n      }\n    })\n\n    this.ready().catch(safetyCatch)\n  }\n\n  async suspend () {\n    if (!this.opened) await this.ready()\n\n    if (this.suspended) return\n    this.suspended = true\n\n    const all = []\n\n    all.push(this.pairing.pairing.suspend())\n    for (const mirror of this.blindMirrorsByKey.values()) {\n      all.push(mirror.suspend())\n    }\n\n    await Promise.allSettled(all)\n    await this.swarm.suspend()\n    await this.drives.serve.suspend()\n    await this.store.suspend()\n  }\n\n  async resume () {\n    if (!this.suspended) return\n\n    await this.store.resume()\n    await this.drives.serve.resume()\n    await this.swarm.resume()\n\n    const all = []\n\n    all.push(this.pairing.pairing.resume())\n    for (const mirror of this.blindMirrorsByKey.values()) {\n      all.push(mirror.resume())\n    }\n\n    this.suspended = false // set this sync in case blind mirroring runs...\n    await Promise.allSettled(all)\n  }\n\n  async _open () {\n    await this.store.ready()\n    await this.local.ready()\n    await this.drives.ready()\n    await this.identity.ready()\n    await this.pairing.ready()\n    await this.activity.ready()\n\n    this._gcInterval = this.gcDisabled ? null : setInterval(this._gc.bind(this), this.gcIntervalInMs)\n  }\n\n  _gc () {\n    for (const status of this._roomsByKey.values()) {\n      if (status.refs > 0) continue\n      status.gcLoopCount -= 1\n      if (status.gcLoopCount > 0) continue\n\n      status.room.close().catch(safetyCatch)\n      this._roomsByKey.delete(status.room.key)\n      this._keysByDiscoveryId.delete(status.room.discoveryId)\n    }\n  }\n\n  async _close () {\n    this.swarm.removeListener('connection', this._onconnection)\n    for (const conn of this.swarm.connections) {\n      conn.removeListener('close', this._bumpsubscriptions)\n    }\n    await this.activity.close()\n\n    const infos = [...this._roomsByKey.values()]\n    await Promise.all(infos.map(i => i.room.close()))\n\n    if (this.push) await this.push.destroy()\n\n    await this.pairing.close()\n    await this.drives.close()\n    await this.local.close()\n    await this.identity.close()\n\n    for (const blindMirror of this.blindMirrorsByKey.values()) {\n      await blindMirror.close()\n    }\n\n    if (!this.opts.corestore) {\n      // If the corestore was passed in externally, do not close\n      await this.store.close()\n    }\n\n    clearInterval(this._gcInterval)\n  }\n\n  _onConnection (conn) {\n    conn.once('close', this._bumpsubscriptions)\n    this._bumpConnectedMemberSubscriptions()\n  }\n\n  // Internal Room Lifecycle Methods\n\n  internalOpenRoom (key, opts = {}) {\n    const existing = this._roomsByKey.get(key)\n    if (existing && !existing.room.closing) {\n      existing.gcLoopCount = this.gcLoopCount // reset\n      existing.refs++\n      existing.active = Date.now()\n      existing.room.leaving = opts?.resetLeaving === false ? existing.room.leaving : false\n      return existing.room\n    }\n\n    const room = new Room(this, key, {\n      ...opts,\n      fastForward: opts.fastForwardTo ? opts.fastForwardTo : this._fastForward,\n      ackThreshold: this.opts.ackThreshold,\n      ackInterval: this.opts.ackInterval\n    })\n\n    const status = {\n      room,\n      subscriptions: new Set(),\n      active: Date.now(),\n      refs: 1,\n      gcLoopCount: this.gcLoopCount\n    }\n\n    this._roomsByKey.set(room.key, status)\n    this._keysByDiscoveryId.set(room.discoveryId, room.key)\n\n    return room\n  }\n\n  async internalUpdateRoomMembers () {\n    const rooms = []\n    for (const [key, { room }] of this._roomsByKey) {\n      if (room.hidden || (room === this.identity.privateProfile)) continue\n      rooms.push(this.internalOpenRoom(key))\n    }\n\n    await Promise.all(rooms.map(async r => {\n      if (r.neverUpdateMember) return null\n      await r._onIdentityChanged()\n    }))\n    if (this.closing) return\n\n    for (const room of rooms) {\n      this.internalReleaseRoom(room)\n    }\n  }\n\n  internalCreateMirror (mirrorKey) {\n    let mirror = this.blindMirrorsByKey.get(mirrorKey)\n    if (!mirror) {\n      // TODO: GC these mirrors in the background eventually\n      mirror = new BlindMirror(mirrorKey, { dht: this.swarm.dht, suspended: this.suspended })\n      mirror.on('stream', stream => this.store.replicate(stream))\n      this.blindMirrorsByKey.set(mirrorKey, mirror)\n    }\n    return mirror\n  }\n\n  internalCreateClosestMediaMirrors (key, n) {\n    return this._createClosestMirror(key, n, this.blindMediaMirrorKeys)\n  }\n\n  internalCreateClosestMirrors (key, n) {\n    return this._createClosestMirror(key, n, this.blindMirrorKeys)\n  }\n\n  _createClosestMirror (key, n, list) {\n    if (!list || !list.length) return []\n\n    for (let i = 0; i < n; i++) {\n      let current = null\n      for (let j = i; j < list.length; j++) {\n        const next = xorDistance(list[j], key)\n        if (current && xorDistance.gt(next, current)) continue\n        const tmp = list[i]\n        list[i] = list[j]\n        list[j] = tmp\n        current = next\n      }\n    }\n\n    const mirrors = []\n    for (let i = 0; i < n; i++) {\n      const mirrorKey = list[i]\n      const mirror = this.internalCreateMirror(mirrorKey)\n      mirrors.push(mirror)\n    }\n\n    return mirrors\n  }\n\n  internalReleaseRoom (room) {\n    if (this.closing) return\n\n    const info = this._roomsByKey.get(room.key)\n    if (!info || (info.room !== room)) return\n\n    // The background garbage collector will close inactive rooms with 0 refs\n    info.refs -= 1\n  }\n\n  async internalCreateRoom (opts = {}) {\n    let key = null\n    if (!opts.keyPair) {\n      const ns = (opts._namespace || crypto.randomBytes(32))\n      key = await this._getLocalKey(ns)\n    } else {\n      key = Hypercore.key({\n        version: this.store.manifestVersion,\n        signers: [{ signature: 'ed25519', publicKey: opts.keyPair.publicKey }]\n      })\n    }\n\n    const room = this.internalOpenRoom(key, {\n      ...opts,\n      create: true,\n      encryptionKey: opts.encryptionKey || crypto.randomBytes(32)\n    })\n    await room.ready()\n\n    const core = room.base.view.core\n    if (room.base.writable && (core.length === 0)) {\n      await room.devices.addDevice({\n        key: room.base.key,\n        noisePublicKey: this.swarm.keyPair.publicKey,\n        capabilities: MemberCapabilities.ALL_CAPABILITIES\n      })\n    }\n\n    const tx = await this.local.writeTransaction()\n    await tx.addRoom(room.key, {\n      indexing: true,\n      unread: 1,\n      hidden: !!opts.hidden\n    })\n    await this.local.bumpRoomPriority(room.key, { tx })\n    await tx.commit()\n\n    if (!opts.hidden) {\n      await this.identity.addRoom(room.key)\n    }\n\n    if (opts.config) {\n      for (const [key, value] of Object.entries(opts.config)) {\n        await room.config.update(key, value)\n      }\n    }\n\n    return room\n  }\n\n  async _getLocalAutobaseKeys (discoveryKey) {\n    let key = null\n    let isBootstrap = false\n    try {\n      const core = this.store.get({ _discoveryKey: discoveryKey, active: false })\n      await core.ready()\n      isBootstrap = core.writable\n      key = core.key\n\n      await core.close()\n      if (this.closing) return null\n    } catch (err) {\n      safetyCatch(err)\n    }\n\n    if (isBootstrap) {\n      return { key, deviceKey: key }\n    } else {\n      return { key, deviceKey: await this._getLocalKey(discoveryKey) }\n    }\n  }\n\n  async _getLocalCore (ns) {\n    const namespace = this.store.namespace(ns)\n    const core = namespace.get({ name: 'local', compat: false })\n    await core.ready()\n    return { core, namespace }\n  }\n\n  async _getLocalKey (ns, { keyPair = false } = {}) {\n    const { core, namespace } = await this._getLocalCore(ns)\n    await namespace.close()\n    return keyPair ? core.keyPair : core.key\n  }\n\n  internalIsRoomActive (room) {\n    return this._activatedRooms.has(room.key) || this._pairingRooms.has(room.discoveryKey)\n  }\n\n  async internalPairRoom (invitation, { ignoreSensitive = false, ignoreExpiration = false, timeout, hidden, identity } = {}) {\n    if (!this.opened) await this.ready()\n\n    const buf = !b4a.isBuffer(invitation) ? z32.decode(invitation) : invitation\n    const decoded = BlindPairing.decodeInvite(buf)\n\n    let session = null\n    let timer = null\n    let sub = null\n\n    if (!ignoreSensitive && decoded.sensitive) throw KeetError.INVALID_INVITATION_TYPE()\n    if (!ignoreExpiration && (decoded.expires && (decoded.expires < Date.now()))) {\n      throw KeetError.INVITE_EXPIRED()\n    }\n\n    if (this.testing && !decoded.testInvitation) throw KeetError.INVALID_PRODUCTION_INVITATION()\n\n    let { key } = await this.pairing.client.startPairingRoom(decoded, {\n      hidden,\n      identity\n    })\n    if (key) return key\n\n    sub = this.pairing.client.subscribePairingStatus(decoded.seed)\n    if (timeout) {\n      timer = setTimeout(() => sub.destroy('Pairing attempt timed out'), timeout)\n    }\n\n    for await (const record of sub) {\n      if (this.closing) return null\n      if (record.status === PairingStatus.PAIRED) {\n        key = record.key\n        session = this.swarm.join(crypto.discoveryKey(key), { client: true, server: true })\n      }\n      if (record.status === PairingStatus.COMPLETED) {\n        key = record.key\n        break\n      }\n      if (record.status === PairingStatus.EXPIRED) {\n        throw KeetError.PAIRING_EXPIRED()\n      }\n    }\n\n    if (session) await session.destroy()\n    if (timer) clearTimeout(timer)\n\n    return key\n  }\n\n  // Stateless API\n\n  _roomMethod (fn) {\n    return async (roomId, ...args) => {\n      const debugId = this._startDebugLog(fn.name, { roomId, args })\n      const roomKey = HypercoreId.decode(roomId)\n      const room = this.internalOpenRoom(roomKey)\n      try {\n        if (!room.opened) await room.ready()\n        const res = await fn(room, ...args)\n        this._stopDebugLog(debugId, res)\n        return res\n      } finally {\n        this.internalReleaseRoom(room)\n      }\n    }\n  }\n\n  _roomSubscription (fn) {\n    return (roomId, ...args) => {\n      this._startDebugLog(fn.name, args)\n      const roomKey = HypercoreId.decode(roomId)\n      const room = this.internalOpenRoom(roomKey)\n      const stream = fn(room, ...args)\n\n      const record = this._roomsByKey.get(roomKey)\n      record.subscriptions.add(stream)\n\n      stream.once('close', () => {\n        record.subscriptions.delete(stream)\n        if (record.force) return // @TODO: remove once we've a better way to force close streams\n        this.internalReleaseRoom(room)\n      })\n      return stream\n    }\n  }\n\n  _startDebugLog (methodName, methodArgs) {\n    if (!this._debugLog) return null\n    const start = Date.now()\n    const tag = methodName + ':' + DEBUG_LOG_ID++\n    console.log('ENTER:', tag, methodArgs)\n    return { start, tag }\n  }\n\n  _stopDebugLog (id, result) {\n    if (!this._debugLog) return null\n    console.log('EXIT', id.tag, { duration: Date.now() - id.start, result })\n  }\n\n  // --- Identity Management ---\n\n  async _generateIdentity () {\n    const debugId = this._startDebugLog('_generateIdentity')\n    const result = await this.identity.generateIdentity()\n    this._stopDebugLog(debugId, result)\n    return result\n  }\n\n  async _restoreIdentity (mnemonic, opts) {\n    const debugId = this._startDebugLog('_restoreIdentity', { mnemonic, opts })\n    const result = await this.identity.restore(mnemonic, opts)\n    this._stopDebugLog(debugId, result)\n    return result\n  }\n\n  async _setRecoveryPhrase (mnemonic) {\n    return this.identity.setRecoveryPhrase(mnemonic)\n  }\n\n  async _getRecoveryPhrase () {\n    return this.identity.getRecoveryPhrase()\n  }\n\n  async _getIdentity () {\n    const debugId = this._startDebugLog('_getIdentity')\n    const result = await this.identity.getIdentity()\n    this._stopDebugLog(debugId, result)\n    return result\n  }\n\n  _subscribeIdentity () {\n    return this.identity.subscribeIdentity()\n  }\n\n  async _updateIdentityProfile (opts) {\n    const debugId = this._startDebugLog('_updateIdentityProfile', opts)\n    const avatar = opts?.avatar ? b4a.from(opts.avatar, 'base64') : null\n    const result = await this.identity.updateProfile({\n      ...opts,\n      avatar\n    })\n    this._stopDebugLog(debugId, result)\n    return result\n  }\n\n  async _updateIdentityDevice (opts) {\n    const debugId = this._startDebugLog('_updateIdentityDevice', opts)\n    const result = await this.identity.updateDevice(opts)\n    this._stopDebugLog(debugId, result)\n    return result\n  }\n\n  // --- Versioning ---\n\n  _getVersion () {\n    return {\n      experimental: this.isExperimental,\n      version: this.isExperimental ? this.abi.max : this.abi.production,\n      modules: CORE_MODULE_VERSIONS\n    }\n  }\n\n  // Room Subscription\n  _subscribeRoomVersion (room) {\n    return room.subscribeRoomVersion()\n  }\n\n  // Room Method\n  _upgradeRoom (room) {\n    return room.upgrade(CURRENT_ABI.STABLE)\n  }\n\n  // --- Room Creation + Pairing ---\n\n  async _createRoom (opts) {\n    if (!this.opened) await this.ready()\n\n    const room = await this.internalCreateRoom(opts)\n    this.internalReleaseRoom(room)\n\n    return HypercoreId.encode(room.key)\n  }\n\n  async _compatPairRoom (invitation, opts) {\n    const key = await this.internalPairRoom(z32.decode(invitation), opts)\n    return HypercoreId.encode(key)\n  }\n\n  async _compatPairIdentity (invitation, opts) {\n    const key = await this.internalPairRoom(z32.decode(invitation), { ...opts, ignoreSensitive: true })\n    return HypercoreId.encode(key)\n  }\n\n  async _leaveRoom (roomId, { identitySync = true, force = false, cleanup = false } = {}) {\n    const key = HypercoreId.decode(roomId)\n    const room = this.internalOpenRoom(key)\n\n    try {\n      // Mark the room's local core as inactive\n      await room.internalMarkInactive()\n      // Attempt to cleanly leave the room\n      if (!cleanup) await room.leave()\n    } catch (err) {\n      if (!force) throw err\n      safetyCatch(err)\n    } finally {\n      this.internalReleaseRoom(room)\n    }\n\n    // Remove the room from recents\n    await this.local.bumpRoomPriority(key, { remove: true })\n\n    // Remove the room from the shared rooms list in the current private profile\n    // If identitySync is false, then the room has already been removed from the ID\n    if (identitySync) {\n      await this.identity.removeRoom(key)\n    }\n\n    // In both clean/force leave, all records in the local database for this room should be removed\n    const tx = await this.local.writeTransaction()\n    try {\n      await this._clearAllFiles(roomId, { tx, removeRecords: true })\n      await tx.removeRoom(key)\n      await tx.commit()\n    } catch (err) {\n      await tx.close()\n      safetyCatch(err)\n    }\n\n    // In force-leave mode, the room should be forcefully closed\n    if (!force) return\n\n    // If we're force-closing, force the room close here\n    const record = this._roomsByKey.get(key)\n    if (!record) return\n\n    // Destroy any room subscriptions\n    // Note we only need to do this when force-closing, which circumvents ref-counting\n    const destroys = []\n    for (const sub of record.subscriptions) {\n      destroys.push(new Promise(resolve => sub.once('close', resolve)))\n      sub.destroy()\n    }\n    await Promise.allSettled(destroys)\n\n    // Do not await the close in case the room is borked\n    record.room.close().catch(safetyCatch)\n  }\n\n  async _startPairing (invitation) {\n    if (invitation.expires && (invitation.expires < Date.now())) {\n      throw KeetError.INVITE_EXPIRED()\n    }\n\n    let identity = null\n    if (!this.identity.anonymous) {\n      identity = identity || {}\n      const { deviceKey } = await this._getLocalAutobaseKeys(invitation.discoveryKey)\n      const profile = await this.identity.getProfile(deviceKey)\n      identity = { attestation: profile?.identity?.proof }\n    }\n\n    const { key, seed } = await this.pairing.client.startPairingRoom(invitation, { identity })\n    return {\n      key: key ? HypercoreId.encode(key) : null,\n      seedId: HypercoreId.encode(seed)\n    }\n  }\n\n  async _startPairingRoom (invitation, opts) {\n    const decoded = BlindPairing.decodeInvite(typeof invitation === 'string' ? z32.decode(invitation) : invitation)\n\n    if (decoded.sensitive) throw KeetError.INVALID_INVITATION_TYPE('Attempting to use a device sync link as a room link')\n\n    if (this.testing && !decoded.testInvitation) throw KeetError.INVALID_PRODUCTION_INVITATION('Attempting to use a production invitation in a test environment')\n\n    return this._startPairing(decoded, opts)\n  }\n\n  async _startPairingIdentity (invitation, opts) {\n    const decoded = BlindPairing.decodeInvite(typeof invitation === 'string' ? z32.decode(invitation) : invitation)\n\n    if (!decoded.sensitive) throw KeetError.INVALID_INVITATION_TYPE('Attempting to use a room link as a device sync link')\n\n    if (this.testing && !decoded.testInvitation) throw KeetError.INVALID_PRODUCTION_INVITATION('Attempting to use a production invitation in a test environment')\n\n    return this._startPairing(decoded, opts)\n  }\n\n  _stopPairingRoom (seedId) {\n    return this.pairing.client.stopPairingRoom(HypercoreId.decode(seedId))\n  }\n\n  _confirmIdentity (seedId) {\n    return this.pairing.client.confirmIdentityPairing(HypercoreId.decode(seedId))\n  }\n\n  _confirmPairingRequest (request, confirmed) {\n    return this.pairing.server.confirmIdentityPairingRequest(request, confirmed)\n  }\n\n  _subscribePendingRooms () {\n    return this.pairing.client.subscribePairingRooms()\n  }\n\n  _subscribeIdentityPairingRequests () {\n    return this.pairing.server.subscribeIdentityPairingRequests()\n  }\n\n  // --- Room Activation ---\n\n  // Room Subscription\n  _subscribeActivateRoom (room, { client = true, server = true } = {}) {\n    const self = this\n    let incremented = false\n    return new Readable({\n      eagerOpen: true,\n      async open (cb) {\n        try {\n          await room.ready()\n          let record = self._activatedRooms.get(room.key)\n          if (!record) {\n            record = { session: self.swarm.join(room.discoveryKey, { client, server }), refs: 1 }\n            self._activatedRooms.set(room.key, record)\n            self.pairing.server.refresh().catch(safetyCatch)\n            self.emit('activated-room', room.key, room.discoveryKey)\n          } else {\n            record.refs++\n          }\n          incremented = true\n          if (record.refs === 1) {\n            await self.local.maybeUpdateRoom(room.key, { unread: 0 })\n          }\n        } catch (err) {\n          return cb(err)\n        }\n        cb(null)\n      },\n      destroy (cb) {\n        if (!incremented) {\n          cb(null)\n          return\n        }\n        const record = self._activatedRooms.get(room.key)\n        if (--record.refs === 0) {\n          record.session.destroy().catch(safetyCatch)\n          self._activatedRooms.delete(room.key)\n          self.emit('deactivated-room', room.key, room.discoveryKey)\n        }\n        cb(null)\n      }\n    })\n  }\n\n  // --- Membership ---\n\n  async _createIdentityInvitation () {\n    const invitation = await this.identity.createInvitation()\n    return z32.encode(invitation)\n  }\n\n  // Room Mutation\n  async _createInvitation (room, opts = {}) {\n    if (!room.opened) await room.ready()\n\n    const [isMuted, iAmMod] = await Promise.all([\n      room.members.isDeviceMuted(room.deviceKey),\n      room.devices.isModerator(room.deviceKey)\n    ])\n\n    if (isMuted) {\n      throw KeetError.ROOM_LOCKED('Muted members can\\'t create invitations')\n    }\n\n    if ((opts.canModerate || opts.canIndex) && !iAmMod) {\n      throw KeetError.MODERATORS_ONLY('Only moderators can create moderator invitations')\n    }\n\n    const invitation = await room.invitations.createInvitation(opts)\n    return z32.encode(invitation)\n  }\n\n  // Room Mutation\n  async _addDevice (room, opts) {\n    const capabilities = RoomInvitations.getCapabilitiesFromOptions(opts)\n    const deviceOpts = {\n      capabilities,\n      key: HypercoreId.decode(opts.deviceId),\n      noisePublicKey: opts.swarmId ? HypercoreId.decode(opts.swarmId) : null,\n      invitation: opts.invitationId ? HypercoreId.decode(opts.invitationId) : null,\n      receipt: opts.receipt ? z32.decode(opts.receipt) : null\n    }\n    await room.devices.addDevice(deviceOpts)\n    return opts.memberId\n  }\n\n  // Room Mutation\n  async _removeDevice (room, deviceId) {\n    return room.devices.removeDevice(HypercoreId.decode(deviceId))\n  }\n\n  // Room Mutation\n  async _removeMember (room, memberId) {\n    return room.members.removeMember(HypercoreId.decode(memberId))\n  }\n\n  // Used to be a Room Query, but it doesn't actually require opening a room\n  async _getRoomKeys (roomId) {\n    try {\n      const roomKey = HypercoreId.decode(roomId)\n      const discoveryKey = b4a.toString(crypto.discoveryKey(roomKey), 'hex')\n      return { discoveryKey }\n    } catch {\n      return { discoveryKey: '' }\n    }\n  }\n\n  // Room Query\n  _getTipSize (room) {\n    return room.base.linearizer.size\n  }\n\n  // Room Query\n  async _waitUntilJoined (room) {\n    await room.joined()\n    if (room.closing) return null\n\n    return this._getMember(room, room.memberId)\n  }\n\n  // Room Query\n  async _getMemberCount (room) {\n    return room.members.count()\n  }\n\n  // Room Query\n  async _getDevice (room, deviceId) {\n    const deviceKey = HypercoreId.decode(deviceId)\n\n    const device = await room.devices.getDevice(deviceKey)\n    if (!device) return null\n\n    return formatDeviceRecord({\n      key: deviceKey,\n      noisePublicKey: device.noisePublicKey,\n      capabilities: device.capabilities\n    }, room)\n  }\n\n  // Room Query\n  async _getDevices (room, opts) {\n    const devices = []\n    const rangeOpts = formatRangeOptions(opts)\n    for await (const node of room.devices.collection.createReadStream(rangeOpts)) {\n      devices.push(formatDeviceRecord(node.value, room))\n    }\n    return devices\n  }\n\n  // Room Query\n  async _getMembers (room, opts) {\n    const members = []\n    const rangeOpts = opts ? formatRangeOptions(opts) : null\n    for await (const member of room.members.createMembersReadStream(rangeOpts)) {\n      members.push(formatMemberRecord(member, null, room))\n    }\n    return members\n  }\n\n  // Room Query\n  async _getModerators (room, opts) {\n    const members = []\n    for await (const member of room.members.createModeratorsReadStream(opts)) {\n      members.push(formatMemberRecord(member, null, room))\n    }\n    return members\n  }\n\n  // Room Subscription\n  _subscribeMemberCount (room, opts) {\n    return watchStream({\n      watch: () => room.members.collection.watch(null, watchOpts(opts)),\n      load: () => this._getMemberCount(room)\n    })\n  }\n\n  // Room Subscription\n  _subscribeDevice (room, deviceId, opts) {\n    const deviceKey = HypercoreId.decode(deviceId)\n    return watchStream({\n      watch: () => room.devices.watchDevice(deviceKey, watchOpts(opts)),\n      load: () => this._getDevice(room, deviceKey)\n    })\n  }\n\n  // Room Subscription\n  _subscribeDevices (room, opts) {\n    return watchStream({\n      watch: () => room.devices.watch(watchOpts(opts)),\n      load: () => this._getDevices(room, opts)\n    })\n  }\n\n  // Room Subscription\n  _subscribeMembers (room, opts) {\n    return watchStream({\n      watch: () => room.members.collection.watch(null, watchOpts(opts)),\n      load: () => this._getMembers(room, opts)\n    })\n  }\n\n  _subscribeModerators (room, opts) {\n    return watchStream({\n      watch: () => room.members.collection.watch(null, watchOpts(opts)),\n      load: () => this._getModerators(room, opts)\n    })\n  }\n\n  // --- Profiles ---\n\n  // Room Mutation\n  _updateMember (roomId, displayName, avatar) {\n    // TODO: Remove the roomId from this method\n    // TODO: handle updating incognito profiles\n    // TODO: Re-enable once the profiles are scoped per storage dir\n    if (avatar) avatar = b4a.from(avatar, 'base64')\n    return this.identity.updateProfile({ displayName, avatar })\n  }\n\n  // Room Mutation\n  _muteMember (room, memberId) {\n    const memberKey = HypercoreId.decode(memberId)\n    return room.members.mute(memberKey)\n  }\n\n  // Room Mutation\n  _unmuteMember (room, memberId) {\n    const memberKey = HypercoreId.decode(memberId)\n    return room.members.unmute(memberKey)\n  }\n\n  // Room Query\n  _isMemberMuted (room, memberId) {\n    const memberKey = HypercoreId.decode(memberId)\n    return room.members.isMemberMuted(memberKey)\n  }\n\n  // Room Mutation\n  async _changeMemberRole (room, { memberId, role }) {\n    const memberKey = HypercoreId.decode(memberId)\n    await room.members.changeRole({ memberKey, role })\n  }\n\n  // Room Query\n  async _getMemberForDevice (room, deviceId) {\n    const deviceKey = HypercoreId.decode(deviceId)\n\n    const [device, actualMember, deviceMember] = await Promise.all([\n      room.devices.getDevice(deviceKey),\n      room.members.getMember(deviceKey),\n      room.members.getMemberForDeviceKey(deviceKey)\n    ])\n\n    if (!device && !actualMember) return null\n    const member = deviceMember || actualMember\n\n    const avatar = member.hasAvatar ? await room.members.getAvatar(member.key) : null\n\n    if (device) member.key = device.key\n\n    return formatMemberRecord(member, avatar, room)\n  }\n\n  // Room Query\n  async _getMember (room, memberId, opts = {}) {\n    const memberKey = HypercoreId.decode(memberId)\n    let member = null\n    if (opts.swarmId === true) {\n      const deviceKey = await room.devices.getDeviceKeyForNoisePublicKey(memberKey)\n      if (!deviceKey) return null\n      member = await room.members.getMemberForDeviceKey(deviceKey, opts)\n    } else {\n      const [activeMember, inactiveMember] = await Promise.all([\n        room.members.getMember(memberKey, opts),\n        room.members.getInactiveMember(memberKey, opts)\n      ])\n      member = activeMember || inactiveMember\n    }\n    return formatMemberRecord(member, null, room)\n  }\n\n  // Room Query\n  async _getSearchMembers (room, keyword, opts) {\n    const members = await room.members.searchMembers(keyword, opts)\n    if (!members || !members.length) return null\n\n    const avatars = await Promise.all(members.map(p => p.hasAvatar ? room.members.getAvatar(p.key) : null))\n    const res = []\n    for (let i = 0; i < members.length; i++) {\n      res.push(formatMemberRecord(members[i], avatars[i], room))\n    }\n\n    return res\n  }\n\n  // Room Query\n  _getPushNotificationMembers (room) {\n    // TODO: Update this method\n    return room.devices.mobileCount()\n  }\n\n  // Room Subscription\n\n  _subscribeMember (room, memberId, opts = {}) {\n    const memberKey = HypercoreId.decode(memberId)\n    if (opts.swarmId) {\n      return watchStream({\n        // TODO: This will over-fire, but it's the simplest approach for now\n        watch: () => room.members.collection.watch(null, watchOpts(opts)),\n        load: () => this._getMember(room, memberKey, opts)\n      })\n    }\n    return watchStream({\n      watch: () => room.members.watchMember(memberKey, watchOpts(opts)),\n      load: () => this._getMember(room, memberKey)\n    })\n  }\n\n  _subscribeMemberForDevice (room, deviceId, opts) {\n    const deviceKey = HypercoreId.decode(deviceId)\n    const outer = room.members.watchDevice(deviceKey, watchOpts(opts))\n    let inner = null\n\n    const stream = new Readable({\n      destroy: cb => Promise.allSettled([outer?.close(), inner?.close()]).then(() => cb(null), err => cb(err))\n    })\n    observeDevice(outer)\n\n    return stream\n\n    async function observeDevice (watcher) {\n      try {\n        for await (const _ of watcher) { /* eslint-disable-line */\n          if (inner) await inner.close()\n\n          const record = await room.members.membersByDeviceKey.get(deviceKey)\n          const memberKey = record.value.key\n\n          inner = room.members.watchMember(record.value.key, watchOpts(opts))\n          observeMember(inner, memberKey)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n\n    async function observeMember (watcher, memberKey) {\n      try {\n        for await (const _ of watcher) { /* eslint-disable-line */\n          const member = await room.members.getMember(memberKey)\n          const record = formatMemberRecord(member, null, room)\n          if (record) stream.push(record)\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  }\n\n  // Room Subscription\n  _subscribeSearchMembers (room, keyword, opts) {\n    return watchStream({\n      watch: () => room.members.collection.watch(null, watchOpts(opts)),\n      load: () => this._getSearchMembers(room, keyword, opts)\n    })\n  }\n\n  // Room Subscription\n  _subscribePushNotificationMembers (room, opts) {\n    return watchStream({\n      watch: () => room.profiles.collection.watch(null, watchOpts(opts)),\n      load: () => this._getPushNotificationMembers(room)\n    })\n  }\n\n  // --- Chat ---\n\n  // Room Mutation\n  _addChatMessage (room, text, opts) {\n    if (room.commands.isCommand(text)) {\n      if (!room.commands.isValidCommand(text)) throw KeetError.UNKNOWN_ROOM_COMMAND()\n      return room.commands.handle(text)\n    }\n\n    if (opts?.mentions) {\n      opts.mentions = opts.mentions.map(mention => ({\n        ...mention,\n        memberId: HypercoreId.decode(mention.memberId)\n      }))\n    }\n\n    if (opts?.replyTo) {\n      opts.replyTo = { key: HypercoreId.decode(opts.replyTo.deviceId), seq: opts.replyTo.seq }\n    }\n\n    if (opts?.httpLinks) {\n      opts.httpLinks = opts.httpLinks.map(decodeLinkPreview)\n    }\n\n    if (opts?.pearLinks) {\n      opts.pearLinks = opts.pearLinks.map(decodeLinkPreview)\n    }\n\n    return room.chat.addMessage(text, opts)\n  }\n\n  // Room Mutation\n  _updateChatMessage (room, id, text, opts) {\n    id = { key: HypercoreId.decode(id.deviceId), seq: id.seq }\n    if (opts?.mentions) {\n      opts.mentions = opts.mentions.map(mention => ({\n        ...mention,\n        memberId: HypercoreId.decode(mention.memberId)\n      }))\n    }\n\n    if (opts?.replyTo) {\n      opts.replyTo = { key: HypercoreId.decode(opts.replyTo.deviceId), seq: opts.replyTo.seq }\n    }\n\n    if (opts?.httpLinks) {\n      opts.httpLinks = opts.httpLinks.map(decodeLinkPreview)\n    }\n\n    if (opts?.pearLinks) {\n      opts.pearLinks = opts.pearLinks.map(decodeLinkPreview)\n    }\n\n    return room.chat.updateMessage(id, text, opts)\n  }\n\n  // Room Mutation\n  async _removeChatMessage (room, id) {\n    id = { key: HypercoreId.decode(id.deviceId), seq: id.seq }\n\n    const message = await room.chat.getMessageById(id)\n    if (this.closing || !message) return\n\n    if (message.file) {\n      await room.files.removeFile(id)\n    }\n    await room.chat.removeMessage(id)\n  }\n\n  // Room Mutation\n  async _pinChatMessage (room, id) {\n    await room.config.togglePinnedMessage({\n      key: HypercoreId.decode(id.deviceId),\n      seq: id.seq\n    })\n  }\n\n  // Room Mutation\n  _addCallStartedEvent (room) {\n    return room.chat.addCallStartedEvent()\n  }\n\n  // Room Mutation\n  _addRoomAvatarChangedEvent (room) {\n    return room.chat.addRoomAvatarChangedEvent()\n  }\n\n  // Room Mutation\n  _addEvent (room, type, value) {\n    return room.chat.addEvent(type, value)\n  }\n\n  // Room Mutation\n  _removeEvent (room, id) {\n    id = { key: HypercoreId.decode(id.memberId), seq: id.seq }\n    return room.chat.removeEvent(id)\n  }\n\n  async _acceptDmRequest ({ deviceId, seq }) {\n    const id = { key: HypercoreId.decode(deviceId), seq }\n    const mail = await this.identity.privateProfile.privateMailbox.getReceivedMailboxRecord(id)\n    if (!mail && !mail.value) return\n    if (mail.value.status === DM_STATUSES.ACCEPTED) return\n\n    try {\n      const pairingResponse = await this._startPairingRoom(mail.value.invitation)\n      await this.identity.privateProfile.privateMailbox.acceptDmRequest(id)\n      return pairingResponse\n    } catch (error) {\n      safetyCatch(error)\n    }\n  }\n\n  async _rejectDmRequest ({ deviceId, seq }) {\n    const id = { key: HypercoreId.decode(deviceId), seq }\n    await this.identity.privateProfile.privateMailbox.rejectDmRequest(id)\n  }\n\n  // Room Mutation\n  async _sendInvitations (room, { receivers, message, timestamp = Date.now() }) {\n    let newRoom = null\n    const release = await this._lock()\n    try {\n      if (!receivers.length) return\n      if (this.identity.anonymous) return\n      const privateMailbox = this.identity.privateProfile.privateMailbox\n      const receiverKey = HypercoreId.decode(receivers[0])\n      if (await privateMailbox.dmByMember.get(receiverKey)) return\n\n      const box = await room.mailbox.getOpenMailbox(receiverKey)\n      if (!box || !box.blindingKey) return\n\n      await privateMailbox.addMailboxRecord({\n        type: MAIL_TYPES.DM_REQUEST,\n        status: MAIL_STATUSES.UNDELIVERED,\n        message,\n        receiverKey,\n        roomKey: room.key,\n        timestamp\n      })\n\n      // Create the DM room + invitation\n      const config = { [CONFIG.ROOM_TYPE]: '2' } // DM room type\n      newRoom = await this.internalCreateRoom({ config })\n\n      // @NOTE: This is a temporary fix to avoid issues with non-atomicity,\n      // and should not be needed once we're using hyperdb\n      this.pairing.server.refresh() // run in the bg\n\n      const invitation = await newRoom.invitations.createInvitation({ attestsTo: receiverKey })\n\n      // Send mail to the receiver\n      const sent = await room.mailbox.sendMailTo(receiverKey, {\n        type: MAIL_TYPES.DM_REQUEST,\n        message,\n        targetRoomKey: newRoom.key,\n        invitation: z32.encode(invitation),\n        timestamp\n      })\n\n      // Add the message in the mail as the first chat message in the room\n      if (message) await newRoom.chat.addMessage(message)\n\n      // Update the private mailbox record\n      const dm = await privateMailbox.dmByMember.get(receiverKey)\n      await privateMailbox.updateSentMailboxRecord(dm.value.id, {\n        targetRoomKey: newRoom.key,\n        status: sent === true ? MAIL_STATUSES.DELIVERED : MAIL_STATUSES.FAILED\n      })\n    } catch (error) {\n      safetyCatch(error)\n    } finally {\n      if (newRoom) this.internalReleaseRoom(newRoom)\n      release()\n    }\n    return newRoom ? newRoom.id : null\n  }\n\n  // Room Mutation\n  async _updatePrivateMailboxRecord ({ deviceId, seq }, values) {\n    const id = { key: HypercoreId.decode(deviceId), seq }\n    return this.identity.privateProfile.privateMailbox.updateMailboxRecord(id, values)\n  }\n\n  // Room Query\n  async _getChatMessage (room, seq) {\n    const msg = await room.chat.getMessage(seq)\n    return formatChatMessage(seq, msg)\n  }\n\n  // Room Query\n  async _getChatMessageById (room, { deviceId, seq }) {\n    const id = { key: HypercoreId.decode(deviceId), seq }\n    const msg = await room.chat.getMessageById(id)\n    return formatChatMessage(msg.seq, msg)\n  }\n\n  // Room Query\n  async _getChatMessages (room, opts) {\n    const messages = []\n    for await (const msg of room.chat.createReadStream(opts)) {\n      messages.push(formatChatMessage(msg._id, msg.value))\n    }\n    return messages\n  }\n\n  // Room Query\n  async _getPinnedChatMessages (room) {\n    const pins = []\n    for await (const msgId of (await room.config.getPinnedMessages())) {\n      const msg = await room.chat.getMessageById(msgId)\n      pins.push(formatChatMessage(msg.seq, msg))\n    }\n    return pins\n  }\n\n  // Room Query\n  async _getChatLength (room) {\n    return room.chat.length()\n  }\n\n  // Room Query\n  async _getPrivateMailboxRecords (opts = {}) {\n    return this.identity.privateProfile.privateMailbox.list(opts)\n  }\n\n  // Room Query\n  async _getSentPrivateMailboxRecords (opts = {}) {\n    return this._getPrivateMailboxRecords({ ...opts, sent: true })\n  }\n\n  // Room Query\n  async _getDmList (opts = {}) {\n    return this.identity.privateProfile.privateMailbox.dmList(formatRangeOptions(opts))\n  }\n\n  // Room Query\n  async _getDmByMemberId (memberId) {\n    return this.identity.privateProfile.privateMailbox.getDmByMemberId(memberId)\n  }\n\n  // Room Subscription\n  _subscribeChatMessages (room, opts) {\n    const rangeOpts = RoomChat.getRangeOptions({ ...opts, prefix: 0 })\n    return watchStream({\n      watch: () => room.chat.collection.watch(rangeOpts, watchOpts(opts)),\n      load: () => this._getChatMessages(room, opts)\n    })\n  }\n\n  // Room Subscription\n  _subscribePrivateMailbox (opts) {\n    return watchStream({\n      watch: () => this.identity.privateProfile.privateMailbox.collection.watch(opts, watchOpts(opts)),\n      load: () => this._getPrivateMailboxRecords(opts)\n    })\n  }\n\n  // Room Subscription\n  _subscribeSentPrivateMailbox (opts) {\n    return watchStream({\n      watch: () => this.identity.privateProfile.privateMailbox.sentPrivateMailbox.watch(opts, watchOpts(opts)),\n      load: () => this._getSentPrivateMailboxRecords(opts)\n    })\n  }\n\n  // Room Subscription\n  _subscribeDmList (opts) {\n    return watchStream({\n      watch: () => this.identity.privateProfile.privateMailbox.dmByMember.watch(opts, watchOpts(opts)),\n      load: () => this._getDmList(opts)\n    })\n  }\n\n  // Room Subscription\n  _subscribeChatLength (room, opts) {\n    const rangeOpts = RoomChat.getRangeOptions({ ...opts, prefix: 0 })\n    let prevFork = 0\n    return watchStream({\n      watch: () => room.chat.collection.watch(rangeOpts, watchOpts(opts)),\n      load: async () => {\n        if (!opts || !opts.reorders) return this._getChatLength(room)\n        const length = await this._getChatLength(room)\n        const reordered = room.base.view.core.fork !== prevFork\n        prevFork = room.base.view.core.fork\n        return { length, reordered }\n      }\n    })\n  }\n\n  // --- Reactions ---\n\n  // Room Mutation\n  _addReaction (room, to, text, opts) {\n    to = { key: HypercoreId.decode(to.deviceId), seq: to.seq }\n    return room.reactions.addReaction(to, text, opts)\n  }\n\n  // Room Mutation\n  _removeReaction (room, to, text, opts) {\n    to = { key: HypercoreId.decode(to.deviceId), seq: to.seq }\n    return room.reactions.removeReaction(to, text, opts)\n  }\n\n  // Room Query\n  async _getReactions (room, id) {\n    id = { key: HypercoreId.decode(id.deviceId), seq: id.seq }\n    const [digest, mine] = await Promise.all([\n      room.reactions.getReactions(id),\n      room.reactions.getMemberReactions(id, room.memberKey)\n    ])\n    if (digest) {\n      return {\n        digest: formatReactionsDigest(digest),\n        mine\n      }\n    }\n    return defaultReactions()\n  }\n\n  // Room Subscription\n  _subscribeReactions (room, id, opts) {\n    id = { key: HypercoreId.decode(id.deviceId), seq: id.seq }\n    const digestStream = room.reactions.createMessageDigestStream(id, { updateOnce: true, eager: true, ...opts })\n    return pipeline(digestStream, new ParallelTransform({\n      transform (raw, cb) {\n        const digest = formatReactionsDigest(raw)\n        if (!digest.total === 0) return { mine: [], digest }\n        return room.reactions.getMemberReactions(id, room.memberKey)\n          .then(reactions => cb(null, { mine: reactions || [], digest }), err => cb(err))\n      }\n    }))\n  }\n\n  // --- Files ---\n\n  _addFileBlob (room, path, bytes, opts) {\n    return room.files.addFileBlob(path, bytes, opts)\n  }\n\n  _addFile (room, fsPath, opts) {\n    return room.files.addFile(fsPath, opts)\n  }\n\n  _saveFileBlob (room, path, bytes, opts) {\n    return room.files.saveFileBlob(path, bytes, opts)\n  }\n\n  _saveFile (room, fsPath, opts) {\n    return room.files.saveFile(fsPath, opts)\n  }\n\n  // Room Mutation\n  _sendFile (room, opts = {}) {\n    return room.files.sendFile(opts)\n  }\n\n  // Room Mutation\n  _removeFile (room, id) {\n    return room.files.removeFile(id)\n  }\n\n  async _clearAllFiles (roomId, { removeRecords = false, tx = null } = {}) {\n    const key = HypercoreId.decode(roomId)\n    const shouldCommit = !tx\n    if (!tx) tx = await this.local.writeTransaction()\n    let bytesCleared = 0\n\n    for await (const file of tx.createLocalFilesStream(key)) {\n      const { bytes } = file.cleared ? { bytes: 0 } : await this.drives.clearFile(file.key, file.path, file.version)\n      bytesCleared += bytes\n\n      if (removeRecords) {\n        await tx.removeFileRecord(file.key, file.path, file.version)\n      } else {\n        await tx.clearFile(file.key, file.path, file.version)\n      }\n    }\n    if (shouldCommit) await tx.commit()\n    return { bytesCleared }\n  }\n\n  _refreshFileLinks (links) {\n    return this.drives.refreshLinks(links)\n  }\n\n  _getFileEntry (roomId, driveId, path, version) {\n    const roomKey = HypercoreId.decode(roomId)\n    const key = HypercoreId.decode(driveId)\n    return this.drives.getFileEntry(roomKey, key, path, version)\n  }\n\n  async _getLocalFiles (roomId) {\n    const files = []\n    for await (const record of this.local.createLocalFilesStream(HypercoreId.decode(roomId))) {\n      files.push({\n        roomId,\n        driveId: HypercoreId.encode(record.key),\n        path: record.path,\n        version: record.version,\n        cleared: record.cleared\n      })\n    }\n    return files\n  }\n\n  _startDownload (roomId, { key, path, version, cb }) {\n    const roomKey = HypercoreId.decode(roomId)\n    this.drives.startDownload({ roomKey, driveId: key, path, version, cb })\n  }\n\n  async _cancelDownload (roomId, { key, path, version }) {\n    const roomKey = HypercoreId.decode(roomId)\n    await this.drives.cancelDownload({ roomKey, driveId: key, path, version })\n  }\n\n  _subscribeFileInfo (room, { key, path, version }) {\n    const getDrive = async () => await this.drives._getDrive({ roomKey: room.key, key, version })\n    const releaseDrive = async () => await this.drives._releaseDrive({ key })\n    let monitor = null\n    let timer = null\n\n    let stats = {\n      key,\n      path,\n      version,\n      blob: null,\n      peers: 0,\n      uploadStats: {\n        peers: 0,\n        speed: 0,\n        blocks: 0\n      },\n      downloadStats: {\n        peers: 0,\n        speed: 0,\n        blocks: 0\n      }\n    }\n\n    return new Readable({\n      eagerOpen: true,\n      async open (cb) {\n        try {\n          const drive = await getDrive()\n          monitor = drive.monitor(path)\n          await monitor.ready()\n\n          // each interval, push stats\n          timer = setInterval(() => {\n            if (!monitor.entry || !monitor.entry.value) return\n\n            let changed = false\n\n            if (monitor.entry.value && !stats.blob) {\n              changed = true\n            }\n\n            const upSpeed = monitor.uploadSpeed()\n            const downSpeed = monitor.downloadSpeed()\n\n            if (upSpeed !== stats.uploadStats.speed || downSpeed !== stats.downloadStats.speed) {\n              changed = true\n            }\n\n            if (monitor.uploadStats.blocks !== stats.uploadStats.blocks || monitor.downloadStats.blocks !== stats.downloadStats.blocks) {\n              changed = true\n            }\n\n            if (monitor.peers !== stats.peers) {\n              changed = true\n            }\n\n            if (!changed) return\n\n            stats = {\n              key,\n              path,\n              version,\n              blob: monitor.entry.value,\n              peers: monitor.peers,\n              uploadStats: {\n                peers: monitor.peers,\n                speed: upSpeed,\n                blocks: monitor.uploadStats.blocks\n              },\n              downloadStats: {\n                peers: monitor.peers,\n                speed: downSpeed,\n                blocks: monitor.downloadStats.blocks\n              }\n            }\n\n            this.push(stats)\n          }, 1000)\n        } catch (err) {\n          return cb(err)\n        }\n        cb(null)\n      },\n      async destroy (cb) {\n        try {\n          if (monitor) {\n            if (timer) clearInterval(timer)\n            await monitor.close()\n          }\n        } catch (err) {\n          return cb(err)\n        } finally {\n          await releaseDrive()\n        }\n        cb(null)\n      }\n    })\n  }\n\n  // --- Config ---\n\n  // Room Mutation\n  _updateConfig (room, key, value) {\n    if (!isValidConfigKey(key)) throw KeetError.UNKNOWN_ROOM_CONFIG_KEY(key)\n\n    return room.config.update(key, value)\n  }\n\n  // Room Query\n  _getConfig (room, key) {\n    return room.config.get(key)\n  }\n\n  // Room Subscription\n  _subscribeConfig (room, opts) {\n    return watchStream({\n      watch: () => room.config.watch(watchOpts(opts)),\n      load: () => room.config.list()\n    })\n  }\n\n  // --- Swarm Status ---\n\n  _bumpConnectedMemberSubscriptions () {\n    for (const load of this._connectedMembersSubscriptions.values()) {\n      load()\n    }\n  }\n\n  // Room Query\n  async _getConnectedMembers (room) {\n    const allPromises = []\n    for (const conn of this.swarm.connections) {\n      allPromises.push(room.devices.deviceKeysByNoisePublicKey.get(conn.remotePublicKey))\n    }\n    const swarmIds = []\n    for (const device of await Promise.all(allPromises)) {\n      if (!device) continue\n      swarmIds.push(HypercoreId.encode(device.key))\n    }\n    return swarmIds\n  }\n\n  // Room Subscription\n  _subscribeConnectedMembers (room, opts) {\n    let stream = null\n    const load = debounce(async () => {\n      try {\n        const members = await this._getConnectedMembers(room)\n        stream.push(members)\n      } catch (err) {\n        safetyCatch(err)\n      }\n      return null\n    })\n    stream = watchStream({\n      watch: () => room.devices.collection.watch(null, { updateOnce: true, eager: true, signal: opts?.signal }),\n      load\n    })\n    this._connectedMembersSubscriptions.set(stream, load)\n    stream.once('close', () => {\n      this._connectedMembersSubscriptions.delete(stream)\n    })\n    return stream\n  }\n\n  // -- Firewall Hook for Keet Call ---\n\n  createFirewall () {\n    return callId => {\n      const key = this._keysByDiscoveryId.get(callId)\n      // Should never see this error, because the firewall will only be called for activated calls\n      if (!key) throw new Error('Room is not opened')\n      return this.subscribeConnectedMembers(key)\n    }\n  }\n\n  // --- Bookmarking + History ---\n\n  _bookmark () {\n    // TODO: Remove\n  }\n\n  _unbookmark () {\n    // TODO: Remove\n  }\n\n  _subscribeBookmarks () {\n    // TODO: Remove\n    return new Readable()\n  }\n\n  // Keet Query\n  _getLocalRoomMetadata (roomId) {\n    return this.local.getRoom(HypercoreId.decode(roomId))\n  }\n\n  // Keet Query\n  async _getRecentRooms (opts) {\n    return this.local.getRecentRooms(opts)\n  }\n\n  // Keet Subscription\n  _subscribeRecentRooms (opts) {\n    return watchStream({\n      watch: () => this.local.watchAll(),\n      load: () => this._getRecentRooms(opts)\n    })\n  }\n\n  // Keet Subscription\n  _subscribeUnreadActivity (opts) {\n    return this.activity.subscribeUnreadActivity(opts)\n  }\n\n  // --- File Clearing ---\n\n  async _clearFile (driveId, path, version) {\n    const key = HypercoreId.decode(driveId)\n    await this.drives.clearFile(key, path, version)\n    await this.local.clearFile(key, path, version)\n  }\n\n  _unclearFile (driveId, path, version) {\n    const key = HypercoreId.decode(driveId)\n    return this.local.unclearFile(key, path, version)\n  }\n\n  async _getFileCleared (driveId, path, version) {\n    const key = HypercoreId.decode(driveId)\n    return this.local.isFileCleared(key, path, version)\n  }\n\n  _subscribeFileCleared (driveId, path, version) {\n    const key = HypercoreId.decode(driveId)\n    const normalizedPath = Hyperdrive.normalizePath(path)\n    return getAndWatchStream({\n      watch: () => this.local.files.getAndWatch([key, normalizedPath, version]),\n      map: node => node ? { cleared: node.value.cleared } : null\n    })\n  }\n\n  // --- Unread Management + Room Priority ---\n\n  _bumpRoomPriority (roomId) {\n    return this.local.bumpRoomPriority(HypercoreId.decode(roomId))\n  }\n\n  _setRoomUnread (roomId, unread) {\n    return this.local.setRoomUnread(HypercoreId.decode(roomId), unread)\n  }\n\n  // --- Member Blocking ---\n\n  async _blockMember (room, memberId) {\n    const memberKey = HypercoreId.decode(memberId)\n    await this.local.blockMember(room.key, memberKey)\n\n    // set user data (name, blocked status), for keet-push\n    await room.members.ensureUserData(memberKey)\n  }\n\n  async _unblockMember (room, memberId) {\n    const memberKey = HypercoreId.decode(memberId)\n    await this.local.unblockMember(room.key, memberKey)\n\n    // set user data (name, blocked status), for keet-push\n    await room.members.ensureUserData(memberKey)\n  }\n\n  async _getBlockedMembers (roomId) {\n    const rangeOpts = getBlockedMembersRangeOptions(roomId)\n    const blocked = []\n    for await (const node of this.local.blockedMembersByRoom.createReadStream(rangeOpts)) {\n      blocked.push(HypercoreId.encode(node._id[1]))\n    }\n    return blocked\n  }\n\n  _subscribeBlockedMembers (roomId) {\n    const rangeOpts = getBlockedMembersRangeOptions(roomId)\n    return watchStream({\n      watch: () => this.local.blockedMembersByRoom.watch(rangeOpts),\n      load: () => this._getBlockedMembers(roomId)\n    })\n  }\n\n  // --- Debugging ---\n\n  debugTriggerGC () {\n    this._gc()\n  }\n\n  _getStats () {\n    return {\n      connections: this.swarm.connections.size,\n      openRooms: this._roomsByKey.size,\n      openCores: this.store.cores.size,\n      activeRooms: this._activatedRooms.size,\n      roomSubscriptions: [...this._roomsByKey.values()].map(r => r.subscriptions.size),\n      backgroundSwarmingRooms: [...this.pairing.server._pairingMembersByKey.keys()].map(HypercoreId.encode),\n      dht: this.swarm.dht.stats,\n      swarm: this.swarm.stats,\n      ops: this._stats.ops,\n      uploaded: this._stats.uploaded,\n      bytesUploaded: this._stats.bytesUploaded,\n      downloaded: this._stats.downloaded,\n      bytesDownloaded: this._stats.bytesDownloaded,\n      appends: this._stats.appends,\n      bytesAppended: this._stats.bytesAppended,\n      ipc: { sent: 0, recv: 0 }, // not populated here but on mobile so just for consistency\n      threads: [] // not populated here but on mobile so just for consistency\n    }\n  }\n\n  _subscribeProgress (room, { ms = 1000 } = {}) {\n    let timer = null\n\n    return new Readable({\n      eagerOpen: true,\n      async open (cb) {\n        try {\n          await room.ready()\n          timer = setInterval(() => {\n            this.push(room.base.progress())\n          }, ms)\n        } catch (err) {\n          return cb(err)\n        }\n        cb(null)\n      },\n      async destroy (cb) {\n        if (timer) clearInterval(timer)\n        cb(null)\n      }\n    })\n  }\n\n  internalReportOpLog = ops => {\n    this._stats.ops += ops.length\n  }\n\n  async debugFlushIdentityUpdates () {\n    if (this.closing) return\n    await this.identity.debugFlush()\n    await this.pairing.client.flushed()\n    for (const { room } of this._roomsByKey.values()) {\n      await room.debugFlushIdentityUpdates()\n    }\n    await this.pairing.server.flushed()\n  }\n}\n\nfunction watchOpts (opts) {\n  return { updateOnce: true, eager: true, signal: opts?.signal }\n}\n\nfunction watchStream ({ watch, load }) {\n  const watcher = watch()\n  const stream = new Readable({\n    open (cb) {\n      observe().catch(err => stream.destroy(err))\n      cb(null)\n    },\n    async destroy (cb) {\n      try {\n        // This is only needed when closing V1 \"subscribeConfig\" as it returns stream\n        if (!watcher.close && watcher.destroy) {\n          await watcher.destroy()\n        } else {\n          await watcher.close()\n        }\n      } catch (err) {\n        return cb(err)\n      }\n      cb(null)\n    }\n  })\n  return stream\n\n  async function observe () {\n    for await (const _ of watcher) { // eslint-disable-line\n      const msgs = await load()\n      if (msgs !== null) stream.push(msgs)\n    }\n  }\n}\n\nfunction getAndWatchStream ({ watch, map, asyncMap }) {\n  const debouncedBump = asyncMap ? debounce(bump) : null\n  const queue = asyncMap ? [] : null\n  let watcher = null\n\n  const stream = new Readable({\n    async open (cb) {\n      try {\n        watcher = await watch()\n        push(watcher.node)\n        watcher.on('update', () => push(watcher.node))\n      } catch (err) {\n        return cb(err)\n      }\n      cb(null)\n    },\n    destroy (cb) {\n      if (!watcher) return\n      watcher.close().catch(safetyCatch)\n      cb(null)\n    }\n  })\n\n  return stream\n\n  function push (node) {\n    // If map is defined, let it determine how to handle a deletion.\n    // Otherwise ignore the deletion\n    if (!map) return stream.push(node)\n    if (!asyncMap) {\n      const mapped = map(node)\n      if (mapped) stream.push(mapped)\n      return\n    }\n    queue.push(node)\n    return debouncedBump()\n  }\n\n  async function bump () {\n    if (stream.destroying || !queue.length) return\n    try {\n      while (queue.length) {\n        const mapped = await map(queue.shift())\n        if (stream.destroying) return\n        if (mapped) stream.push(mapped)\n      }\n    } catch (err) {\n      stream.destroy(err)\n    }\n  }\n}\n\n// TODO: All of these should live alongside the encodings, as \"stringified\" versions\n\nfunction formatRangeOptions ({ gt, gte, lt, lte, limit, reverse } = {}) {\n  return {\n    limit,\n    reverse,\n    gt: gt ? HypercoreId.decode(gt) : null,\n    gte: gte ? HypercoreId.decode(gte) : null,\n    lt: lt ? HypercoreId.decode(lt) : null,\n    lte: lte ? HypercoreId.decode(lte) : null\n  }\n}\n\nfunction formatDeviceRecord (record, room) {\n  if (!record) return null\n  return {\n    local: b4a.equals(record.key, room.deviceKey),\n    deviceId: HypercoreId.encode(record.key),\n    swarmId: record.noisePublicKey ? HypercoreId.encode(record.noisePublicKey) : null,\n    capabilities: record.capabilities,\n    pending: false\n  }\n}\n\nfunction formatMemberRecord (member, avatar, room) {\n  if (!member) return null\n  avatar = avatar || member.avatar\n  const memberId = HypercoreId.encode(member.key)\n  const deviceIds = (member.devices || []).map(HypercoreId.encode)\n\n  return {\n    memberId,\n    deviceIds,\n    local: b4a.equals(member.key, room.memberKey),\n    anonymous: deviceIds.length === 1 && deviceIds[0] === memberId,\n    name: member.displayName ? member.displayName.toLowerCase() : null,\n    displayName: member.displayName,\n    capabilities: member.capabilities,\n    inactive: !!member.inactive,\n    avatar: avatar ? b4a.toString(avatar, 'base64') : null,\n    // TODO: Keeping for compat\n    pushNotifications: true\n  }\n}\n\nfunction formatChatMessage (seq, message) {\n  const displays = formatDisplays(message)\n  return {\n    seq,\n    id: {\n      deviceId: HypercoreId.encode(message.id.key),\n      seq: message.id.seq\n    },\n    memberId: HypercoreId.encode(message.memberKey),\n    deleted: message.deleted,\n    timestamp: message.timestamp,\n    chat: message.chat\n      ? {\n          edited: message.chat.edited,\n          text: message.chat.text,\n          display: displays,\n          mentions: displays.filter(({ type }) => type === DISPLAY_TYPES.MENTION)\n        }\n      : null,\n    file: message.file ? formatFileMessage(message) : null,\n    event: message.event,\n    replyTo: formatReplyTo(message)\n  }\n}\n\nfunction formatFileMessage (message) {\n  const { file } = message\n  return {\n    ...file,\n    key: HypercoreId.encode(file.key),\n    preview: file.preview ? b4a.toString(file.preview, 'base64') : null,\n    previewPointer: file.previewPointer ? formatPreviewPointer(file) : null\n  }\n}\n\nfunction formatPreviewPointer (file) {\n  const { previewPointer } = file\n  if (!previewPointer) return null\n  const { key, path, version } = previewPointer\n  if (!key || !path || !version) return null\n  return { key: HypercoreId.encode(key), path, version }\n}\n\nfunction formatReactionsDigest (digest) {\n  return {\n    total: digest.total,\n    reactions: digest.reactions.map(reaction => {\n      return {\n        text: reaction.text,\n        count: reaction.count,\n        latest: reaction.latest.map(key => HypercoreId.encode(key))\n      }\n    })\n  }\n}\n\nfunction defaultReactionsDigest () {\n  return {\n    total: 0,\n    reactions: []\n  }\n}\n\nfunction defaultReactions () {\n  return {\n    mine: [],\n    digest: defaultReactionsDigest()\n  }\n}\n\nfunction getBlockedMembersRangeOptions (roomId) {\n  const roomKey = HypercoreId.decode(roomId)\n  return { gte: [roomKey], lte: [roomKey] }\n}\n\nfunction formatReplyTo (msg) {\n  const { replyTo } = msg\n  if (!replyTo) return null\n  return {\n    deviceId: HypercoreId.encode(replyTo.key),\n    seq: replyTo.seq\n  }\n}\n\nfunction formatLinkPreview (linkPreview) {\n  const key = linkPreview.preview?.file?.key\n  if (key && HypercoreId.isValid(key)) {\n    linkPreview.preview.file.driveId = HypercoreId.encode(key)\n  }\n  return linkPreview\n}\n\nfunction formatDisplays (msg) {\n  const { display } = msg\n  if (!display || !Array.isArray(display)) return []\n  return display.map(d => {\n    switch (d.type) {\n      case DISPLAY_TYPES.MENTION:\n        return { ...d.value, type: d.type, memberId: HypercoreId.encode(d.value.memberId) }\n      case DISPLAY_TYPES.HTTP_LINK:\n      case DISPLAY_TYPES.PEAR_LINK:\n        return { type: d.type, ...formatLinkPreview(d.value) }\n      default:\n        return { type: d.type, ...d.value }\n    }\n  })\n}\n\nfunction decodeLinkPreview (linkPreview) {\n  const driveId = linkPreview.preview?.file?.driveId\n  if (driveId && HypercoreId.isValid(driveId)) {\n    linkPreview.preview.file.key = HypercoreId.decode(driveId)\n  }\n  return linkPreview\n}\nconst Autobase = require('autobase')\nconst ReadyResource = require('ready-resource')\nconst debounce = require('debounceify')\nconst safetyCatch = require('safety-catch')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst { Readable } = require('streamx')\n\nconst CHAT_LENGTH_RESET_COUNT_KEY = '@holepunchto/keet-core/chat-length-resets'\nconst CHAT_LENGTH_METADATA_KEY = '@holepunchto/keet-core/chat-length'\n\nmodule.exports = class ActivityTracker extends ReadyResource {\n  constructor (keet) {\n    super()\n    this.keet = keet\n    this.local = keet.local\n    this.store = keet.store\n\n    this._pendingCores = new Set()\n    this._listenersByCore = new Map()\n\n    this._oncoreopen = this._handleCoreOpen.bind(this)\n    this._update = debounce(this._handleAppends.bind(this))\n\n    this._allUnreadSubscriptions = []\n    this._unreadSubscriptions = []\n\n    this.ready().catch(safetyCatch)\n  }\n\n  _open () {\n    this.store.on('core-open', this._oncoreopen)\n    for (const core of this.store.cores.values()) {\n      if (core.opened) this._oncoreopen(core)\n    }\n  }\n\n  _close () {\n    this.store.removeListener('core-open', this._oncoreopen)\n    for (const [core, listeners] of this._listenersByCore) {\n      for (const [name, listener] of listeners) {\n        core.removeListener(name, listener)\n      }\n    }\n  }\n\n  async _maybeUpdateRoomActivity (room) {\n    if (this.closing) return\n\n    // If the room has been left, do not update the activity\n    if (room.hidden || !(await room.internalIsActive())) return\n\n    // update the base to be sure we are on the LATEST view\n    await room.base.update()\n\n    const newLength = await room.chat.length()\n    if (this.closing) return\n\n    const oldLengthBuf = await room.base.getUserData(CHAT_LENGTH_METADATA_KEY)\n    if (this.closing) return\n\n    const oldLength = oldLengthBuf ? c.decode(c.uint, oldLengthBuf) : 0\n    // When there's a truncation, newLength might be less than oldLength briefly\n    if (this.closing || (oldLength >= newLength)) return\n\n    // TODO: Use public getter on Autobase when available\n    await room.base.setUserData(CHAT_LENGTH_METADATA_KEY, c.encode(c.uint, newLength))\n    if (this.closing) return\n\n    for (const { subscription, opts } of this._allUnreadSubscriptions) {\n      if (!opts.includeLength) subscription.push(room.id)\n      else subscription.push({ roomId: room.id, length: newLength })\n    }\n\n    const tx = await this.local.writeTransaction()\n\n    const topRecord = await tx.recentsBatch.peek({ reverse: true })\n    const isHighestPrio = topRecord && b4a.equals(topRecord.value[0], room.key)\n    const isActive = this.keet.internalIsRoomActive(room)\n\n    const inTheFuture = topRecord ? topRecord.key > Date.now() : false\n    let ignore = false\n    // If it is already at the top, and\n    // a) it is active, then nothing to be done\n    // b) it is not active, but is already unread, then nothing to be done\n    if (isHighestPrio) {\n      if (isActive) {\n        ignore = true\n      } else {\n        const record = await tx.getRoom(room.key)\n        if (record && record.unread) {\n          ignore = true\n        }\n      }\n    }\n    if (ignore && !inTheFuture) {\n      await tx.close()\n      return\n    }\n\n    const latestMsg = await room.chat.collection.peek({ gte: [0], lte: [0], reverse: true })\n    const latest = latestMsg ? latestMsg.value.timestamp : null\n    // TODO: Should migrate 'unread' to be a bit\n    const unread = isActive ? 0 : 1\n    await tx.maybeUpdateRoom(room.key, { unread })\n    await this.local.bumpRoomPriority(room.key, { latest, tx })\n    await tx.commit()\n\n    if (unread) {\n      for (const { subscription, opts } of this._unreadSubscriptions) {\n        if (!opts.includeLength) subscription.push(room.id)\n        else subscription.push({ roomId: room.id, length: newLength })\n      }\n    }\n  }\n\n  async _handleCoreAppend (core) {\n    if (core.closing) return // we don't own the core so it might be changed underneath us...\n\n    try {\n      const { referrer } = await Autobase.getUserData(core)\n      if (this.closing || !referrer) return\n\n      const record = await this.keet.local.getRoom(referrer)\n      if (this.closing || !record) return\n\n      const room = this.keet.internalOpenRoom(referrer, { resetLeaving: false })\n\n      try {\n        await room.ready()\n        if (!room.base.writable) return\n\n        await this._maybeUpdateRoomActivity(room)\n      } finally {\n        this.keet.internalReleaseRoom(room)\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _handleAppends () {\n    const pending = []\n    for (const core of this._pendingCores) {\n      pending.push(this._handleCoreAppend(core))\n    }\n    this._pendingCores.clear()\n    await Promise.all(pending)\n  }\n\n  _handleCoreOpen (core) {\n    const onappend = () => {\n      this._pendingCores.add(core)\n      // only trigger the debounce if there is something todo to avoid promise pressure\n      if (this._pendingCores.size === 1) this._update()\n    }\n    const ondownload = (index) => {\n      if (index === core.length - 1) onappend()\n    }\n    const onclose = () => {\n      this._listenersByCore.delete(core)\n    }\n    this._listenersByCore.set(core, [\n      ['append', onappend],\n      ['download', ondownload],\n      ['close', onclose]\n    ])\n    core.once('close', onclose)\n    core.on('download', ondownload)\n    core.on('append', onappend)\n  }\n\n  subscribeUnreadActivity (opts = {}) {\n    const arr = opts.all ? this._allUnreadSubscriptions : this._unreadSubscriptions\n    const record = { subscription: null, opts }\n    record.subscription = new Readable({\n      destroy: cb => {\n        const idx = arr.indexOf(record)\n        if (idx !== -1) arr.splice(idx, 1)\n        cb(null)\n      }\n    })\n    arr.push(record)\n    return record.subscription\n  }\n\n  async maybeResetLength (base) {\n    const resets = await base.getUserData(CHAT_LENGTH_RESET_COUNT_KEY)\n    if (resets) return\n\n    // TODO: Ideally would be atomic\n    await base.setUserData(CHAT_LENGTH_METADATA_KEY, c.encode(c.uint, 0))\n    await base.setUserData(CHAT_LENGTH_RESET_COUNT_KEY, c.encode(c.uint, 1))\n  }\n}\nconst Hyperdrive = require('hyperdrive')\nconst ServeDrive = require('serve-drive')\nconst ReadyResource = require('ready-resource')\nconst HypercoreId = require('hypercore-id-encoding')\nconst safetyCatch = require('safety-catch')\nconst b4a = require('b4a')\nconst { KeetError } = require('@holepunchto/keet-core-api')\n\nconst MAX_LINGERING_DRIVES = 5\n\nmodule.exports = class DriveServer extends ReadyResource {\n  constructor (keet, opts = {}) {\n    super()\n\n    this.maxLingeringDrives = opts.maxLingeringDrives == null\n      ? MAX_LINGERING_DRIVES\n      : opts.maxLingeringDrives\n\n    this.keet = keet\n    this.local = keet.local\n    this.corestore = keet.store\n\n    this.readonlys = new Map()\n    this.writables = new Map()\n    this.lingering = new Set()\n    this._activeDownloads = new Map()\n\n    // Set in _open\n    this.serve = null\n  }\n\n  async refreshLinks (links) {\n    await this.serve.ready()\n    const port = this.serve.port\n\n    const corrected = []\n    for (const l of links) corrected.push(l.replace(/:\\d+\\//, ':' + port + '/'))\n    return corrected\n  }\n\n  async _open () {\n    await this.corestore.ready()\n    const kp = await this.corestore.createKeyPair('serve-drive-token')\n    this.serve = new ServeDrive({\n      token: kp.publicKey,\n      anyPort: true,\n      host: '127.0.0.1',\n      get: this._getDrive.bind(this),\n      release: this._releaseDrive.bind(this)\n    })\n    await this.serve.ready()\n  }\n\n  async _close () {\n    await this.serve.close()\n\n    const all = []\n\n    for (const { drive } of this.readonlys.values()) {\n      all.push(drive.close())\n    }\n    for (const drive of this.writables.values()) {\n      all.push(drive.close())\n    }\n\n    this.readonlys.clear()\n    this.writables.clear()\n    this.lingering.clear()\n\n    await Promise.allSettled(all)\n  }\n\n  createWritableDrive (roomKey, opts) {\n    if (this.closing) throw KeetError.RESOURCE_CLOSING()\n\n    const id = b4a.toString(roomKey, 'hex')\n    if (this.writables.has(id)) throw KeetError.ONE_WRITABLE_DRIVE_PER_KEY()\n\n    const drive = new Hyperdrive(this.corestore.namespace(roomKey), {\n      ...opts,\n      compat: false,\n      active: false\n    })\n\n    this.writables.set(id, drive)\n    drive.on('close', () => {\n      this.writables.delete(id)\n    })\n\n    return drive\n  }\n\n  async _getDrive ({ roomKey, key, filename, version, _filter }) {\n    if (this.closing) throw KeetError.RESOURCE_CLOSING()\n\n    const fileRecord = filename ? await this.local.getFileRecord(key, filename, version) : null\n    if (!roomKey) {\n      if (!fileRecord) return null\n      if (_filter !== false && fileRecord.cleared) return null\n    }\n\n    const rKey = roomKey || (fileRecord ? fileRecord.roomKey : null)\n    const room = this.keet.internalOpenRoom(rKey)\n\n    try {\n      await room.ready()\n      // TODO: also only kick this in IF we dont have it fully locally\n      room.replicateDriveMirror()\n\n      const encryptionKey = room.base.encryptionKey\n      key = HypercoreId.decode(key)\n\n      const id = b4a.toString(key, 'hex')\n      this.lingering.delete(id)\n\n      if (!this.readonlys.has(id)) {\n        const drive = new Hyperdrive(this.corestore.session({ writable: false }), key, {\n          encryptionKey\n        })\n        this.readonlys.set(id, { refs: 0, drive })\n        this._gc(Math.max(0, this.maxLingeringDrives)).catch(safetyCatch)\n      }\n\n      const d = this.readonlys.get(id)\n      d.refs++\n\n      return d.drive\n    } finally {\n      this.keet.internalReleaseRoom(room)\n    }\n  }\n\n  async _gc (max) {\n    if (this.lingering.size <= max) return\n\n    for (const id of this.lingering) {\n      await this._closeDrive(id)\n      if (this.lingering.size <= max) return\n    }\n  }\n\n  async _closeDrive (id) {\n    const d = this.readonlys.get(id)\n    if (!d) return\n\n    this.lingering.delete(id)\n    this.readonlys.delete(id)\n\n    await d.drive.close()\n  }\n\n  async _releaseDrive ({ key, drive }) {\n    key = HypercoreId.decode(key)\n    if (this.closing) throw KeetError.RESOURCE_CLOSING()\n\n    const id = b4a.toString(key, 'hex')\n    const d = this.readonlys.get(id)\n\n    if (!d) return\n    if (--d.refs > 0) return\n\n    await this._gc(this.maxLingeringDrives - 1)\n    this.lingering.add(id)\n  }\n\n  // Public Methods\n\n  async clearFile (key, path, version) {\n    const drive = await this._getDrive({ key, filename: path, version, _filter: false })\n    const co = drive.checkout(version)\n    let bytes = 0\n\n    try {\n      const entry = await co.entry(path, { wait: false })\n      await co.clear(path)\n      bytes = entry.value.blob.byteLength\n    } catch {\n      // ignore\n    } finally {\n      await co.close()\n      await this._releaseDrive({ key })\n    }\n\n    return { bytes }\n  }\n\n  async getFileEntry (roomKey, key, path, version) {\n    if (!this.serve.opened) await this.serve.ready()\n\n    await this.local.addFileRecord(roomKey, key, path, version)\n    if (this.closing) return null\n\n    const drive = await this._getDrive({ key, filename: path, version, _filter: false })\n    const co = drive.checkout(version)\n\n    try {\n      const entry = await co.entry(path)\n      return {\n        ...entry,\n        httpLink: this.serve.getLink(path, { key: HypercoreId.encode(key), version })\n      }\n    } finally {\n      await co.close()\n      await this._releaseDrive({ key })\n    }\n  }\n\n  async cancelDownload ({ driveId, path, version }) {\n    const reqKey = makeKey({ driveId, path, version })\n    try {\n      const activeDownload = this._activeDownloads.get(reqKey)\n      if (!activeDownload) return\n      activeDownload.destroy()\n    } finally {\n      this._activeDownloads.delete(reqKey)\n    }\n  }\n\n  async startDownload ({ roomKey, driveId, path, version, cb }) {\n    const reqKey = makeKey({ driveId, path, version })\n    if (this._activeDownloads.get(reqKey)) return\n    const drive = await this._getDrive({ roomKey, key: driveId, version })\n    const co = drive.checkout(version)\n\n    try {\n      const entry = await co.entry(path)\n      if (!entry) return\n      if (!co.blobs) await co.getBlobs()\n      const { blockOffset, blockLength } = entry.value.blob\n      const download = co.blobs.core.download({ start: blockOffset, end: blockLength })\n      this._activeDownloads.set(reqKey, download)\n      download.downloaded().then(() => this._activeDownloads.delete(reqKey)).finally(cb)\n    } finally {\n      await co.close()\n      await this._releaseDrive({ key: driveId })\n    }\n  }\n}\n\nfunction makeKey ({ driveId, path, version }) {\n  return `${driveId}-${path}-${version}`\n}\nconst ReadyResource = require('ready-resource')\nconst HypercoreId = require('hypercore-id-encoding')\nconst Hypercore = require('hypercore')\nconst Hyperbee = require('hyperbee')\nconst sodium = require('sodium-universal')\nconst crypto = require('hypercore-crypto')\nconst safetyCatch = require('safety-catch')\nconst debounce = require('debounceify')\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\nconst { Readable } = require('streamx')\n\nconst DiffStream = require('hyperbee-diff-stream')\nconst BlindPairing = require('blind-pairing')\nconst IdentityKey = require('@holepunchto/keet-identity-key')\nconst {\n  LocalIdentityRecord,\n  ProfileDiscoveryRecord\n} = require('./messages.js')\nconst { KeetError, CONFIG } = require('@holepunchto/keet-core-api')\n\nconst IDENTITY_RECORD_KEY = b4a.from([1])\nconst LOCAL_IDENTITY_CORE_NAME = 'keet-local-identity'\nconst SYNC_POINTER_METADATA_KEY = 'keet-sync-pointer'\n\nconst PRIVATE_PROFILE_USERDATA_KEY = 'keet-private-profile'\n\nconst EMPTY = b4a.alloc(1)\n\nconst IDENTITIES_RELEASE_TIMESTAMP = 1711547109544\nconst MIGRATING_ROOMS_LIMIT = 256\nconst DEFAULT_PROFILE_DISCOVERY_TIMEOUT = 1000 * 10 // 10s\n\nconst [\n  SHARED_INVITE_NAMESPACE,\n  BLINDING_KEY_NAMESPACE\n] = crypto.namespace('keet/identity/seeded-invite', 2)\n\nmodule.exports = class KeetIdentity extends ReadyResource {\n  constructor (keet, opts = {}) {\n    super()\n    this.keet = keet\n    this.store = keet.store\n    this.local = keet.local\n    this.bee = new Hyperbee(this.store.get({ compat: false, name: LOCAL_IDENTITY_CORE_NAME }), {\n      alwaysDuplicate: false\n    })\n\n    this.privateProfile = null\n    this.discoveryCore = null\n    this.discoveryCoreSession = null\n    this.anonymous = true\n\n    this.sharedInviteSeed = null\n    this.deviceName = null\n    this.deviceKeyPair = null\n    this.deviceProof = null\n    this.memberKey = null\n    this.memberId = null\n    this.memberBlindingKeyPair = null\n\n    this._defaultAvatar = opts.identity?.avatar\n    this._defaultName = opts.identity?.profileName\n    this._defaultDeviceName = opts?.identity?.deviceName\n\n    this._migrating = null\n    this._migratingResolve = null\n    this._profileWatcher = null\n    this._devicesWatcher = null\n    this._roomsWatcher = null\n    this._deviceKeysWatcher = null\n    this._deviceAttestationsWatcher = null\n    this._pendingAttestations = []\n    this._roomSnapshot = null\n    this._profileDiscoveryTimeout = opts.profileDiscoveryTimeout || DEFAULT_PROFILE_DISCOVERY_TIMEOUT\n\n    this._identitySubscriptions = []\n\n    this._bumpsubscriptions = debounce(this._bumpSubscriptions.bind(this))\n    this._onprofilechanged = debounce(this._onProfileChanged.bind(this))\n    this._ondevicekeyschanged = debounce(this._onDeviceKeysChanged.bind(this))\n    this._onsharedroomschanged = debounce(this._onSharedRoomsChanged.bind(this))\n    this._ondeviceattestationschanged = debounce(this._onDeviceAttestationsChanged.bind(this))\n\n    this.ready().catch(safetyCatch)\n  }\n\n  async _createAnonymousProfile () {\n    // Create a private profile, but do not add a proven member until an identity is created\n    const privateProfile = await this._createPrivateProfile()\n\n    await privateProfile.devices.updateDevice({\n      name: this._defaultDeviceName\n    })\n    await privateProfile.members.updateMember({\n      displayName: this._defaultName,\n      avatar: this._defaultAvatar\n    })\n\n    await this._migrateToPrivateProfile(privateProfile)\n\n    await this.bee.put(IDENTITY_RECORD_KEY, {\n      privateProfileKey: this.privateProfile.key,\n      deviceName: this.deviceName\n    }, {\n      valueEncoding: LocalIdentityRecord\n    })\n  }\n\n  async _openProfile (privateProfileKey) {\n    this.privateProfile = this.keet.internalOpenRoom(privateProfileKey, {\n      hidden: true\n    })\n    await this.privateProfile.ready()\n  }\n\n  async _open () {\n    const recordNode = await this.bee.get(IDENTITY_RECORD_KEY, {\n      valueEncoding: LocalIdentityRecord\n    })\n    const record = recordNode ? recordNode.value : null\n    this.anonymous = !(record && record.identity)\n    this.deviceName = record ? record.deviceName : this._defaultDeviceName\n\n    if (this.anonymous) {\n      if (!record) {\n        await this._createAnonymousProfile()\n      } else {\n        await this._openProfile(record.privateProfileKey)\n      }\n\n      this.memberKey = this.privateProfile.deviceKey\n      this.memberId = HypercoreId.encode(this.memberKey)\n      this.deviceName = this._defaultDeviceName\n\n      await this._refreshPreMigrationWatchers()\n      await this._refreshPostMigrationWatchers()\n    } else {\n      await this._openProfile(record.privateProfileKey)\n\n      this.memberKey = record.identity.identityPublicKey\n      this.memberId = HypercoreId.encode(this.memberKey)\n      this.deviceProof = record.identity.deviceProof\n      this.sharedInviteSeed = record.identity.sharedInviteSeed\n      this.deviceKeyPair = await this.store.createKeyPair(this.memberKey)\n      this.memberBlindingKeyPair = deriveBlindingKeyPair(this.memberKey, this.sharedInviteSeed)\n\n      await this._refreshPreMigrationWatchers()\n      await this._refreshPostMigrationWatchers()\n      await this._refreshRoomWatchers()\n    }\n  }\n\n  async _close () {\n    if (this._profileWatcher) {\n      await this._profileWatcher.close()\n    }\n    if (this.privateProfile) {\n      this.keet.internalReleaseRoom(this.privateProfile)\n    }\n    if (this.discoveryCore) {\n      await this.discoveryCore.close()\n    }\n    await this.bee.close()\n  }\n\n  async _bumpSubscriptions () {\n    try {\n      const identity = await this.getIdentity()\n      for (const sub of this._identitySubscriptions) {\n        sub.push(identity)\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _maybeLeaveSharedRoom (key) {\n    const existing = await this.local.getRoom(key)\n    if (!existing) return\n\n    return this.keet._leaveRoom(HypercoreId.encode(key), {\n      identitySync: false,\n      force: true\n    })\n  }\n\n  async _maybePairSharedRoom (key, sharedInviteSeed) {\n    const existing = await this.local.getRoom(key)\n    if (existing) return\n\n    // Regenerate the shared invite that was added to the room by the first joiner\n    const { invite } = BlindPairing.createInvite(key, {\n      seed: KeetIdentity.computeInviteSeed(sharedInviteSeed || this.sharedInviteSeed, key),\n      testInvitation: this.keet.testing,\n      expires: 0\n    })\n\n    await this.keet.startPairingRoom(invite)\n  }\n\n  async _onProfileChanged () {\n    if (this._profileWatcher.closing || !this.memberKey) return\n    try {\n      const profile = await this.privateProfile.members.getMember(this.memberKey)\n      if (!profile || this._profileWatcher.closing) return\n\n      this._bumpsubscriptions()\n\n      // Update the members in all currently-opened rooms\n      // Rooms that aren't opened will be updated when they are opened later\n      await this.keet.internalUpdateRoomMembers()\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _onDevicesChanged () {\n    if (this._devicesWatcher.closing) return\n    try {\n      this._bumpsubscriptions()\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _collectSharedRoomChanges (leftSnapshot, rightSnapshot) {\n    const plugin = this.privateProfile.plugins.privateProfile\n    const keyEncoding = plugin.rooms.primary.encodings.keyEncoding\n\n    const ops = []\n    const diff = new DiffStream(leftSnapshot, rightSnapshot, {\n      ...keyEncoding.encodeRange({}),\n      closeSnapshots: false\n    })\n\n    for await (const op of diff) {\n      ops.push(op)\n    }\n\n    return ops\n  }\n\n  async _processSharedRoomChanges (ops) {\n    const plugin = this.privateProfile.plugins.privateProfile\n    const keyEncoding = plugin.rooms.primary.encodings.keyEncoding\n\n    const leaves = new Set()\n    const joins = new Set()\n\n    for (const { left, right } of ops) {\n      if (left && right) continue\n      if (left) {\n        const id = HypercoreId.encode(keyEncoding.decode(left.key))\n        leaves.delete(id)\n        joins.add(id)\n      } else if (right) {\n        const id = HypercoreId.encode(keyEncoding.decode(right.key))\n        joins.delete(id)\n        leaves.add(id)\n      }\n    }\n\n    for (const id of joins) {\n      try {\n        await this._maybePairSharedRoom(HypercoreId.decode(id))\n      } catch (err) {\n        safetyCatch(err)\n      }\n    }\n\n    for (const id of leaves) {\n      try {\n        await this._maybeLeaveSharedRoom(HypercoreId.decode(id))\n      } catch (err) {\n        safetyCatch(err)\n      }\n    }\n  }\n\n  async _onSharedRoomsChanged () {\n    if (this._roomsWatcher && this._roomsWatcher.closing) return\n\n    const view = this.privateProfile.base.view\n    const bee = view.bee\n    const core = view.core\n\n    try {\n      const buf = await view.base.getUserData(SYNC_POINTER_METADATA_KEY)\n      const last = buf ? c.decode(c.uint, buf) : 0\n      const changes = []\n\n      const length = core.length\n      const indexedLength = core.indexedLength\n\n      if (length === last) return\n\n      const lengthSnap = bee.checkout(length)\n      const indexedSnap = bee.checkout(indexedLength)\n\n      if (last < indexedLength) {\n        const lastSnap = bee.checkout(last)\n\n        changes.push(...(await this._collectSharedRoomChanges(lastSnap, indexedSnap)))\n        await view.base.setUserData(SYNC_POINTER_METADATA_KEY, c.encode(c.uint, indexedLength))\n\n        await lastSnap.close()\n      }\n\n      const prev = this._roomSnapshot\n\n      // If there was a truncation, wait for _onSharedRoomsChanged to re-trigger\n      if (!this._roomSnapshot || (this._roomSnapshot.version <= lengthSnap.version)) {\n        changes.push(...(await this._collectSharedRoomChanges(this._roomSnapshot || indexedSnap, lengthSnap)))\n\n        this._roomSnapshot = lengthSnap\n\n        if (prev) await prev.close()\n        await indexedSnap.close()\n      }\n\n      await this._processSharedRoomChanges(changes)\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _onDeviceKeysChanged () {\n    if (this.closing || !this._deviceKeysWatcher) return\n    const plugin = this.privateProfile.plugins.privateProfile\n\n    try {\n      const devices = []\n      for await (const { value: devicePublicKey } of plugin.deviceKeys.createReadStream()) {\n        devices.push(devicePublicKey)\n      }\n      const attestations = await Promise.all(devices.map(d => plugin.deviceAttestations.get(d)))\n\n      const missing = []\n      for (let i = 0; i < attestations.length; i++) {\n        if (attestations[i]) continue\n        missing.push(devices[i])\n      }\n\n      for (const devicePublicKey of missing) {\n        if (b4a.equals(devicePublicKey, this.deviceKeyPair.publicKey)) continue\n        const attestation = IdentityKey.attestDevice(devicePublicKey, this.deviceKeyPair, this.deviceProof)\n        await plugin.addDeviceAttestation(devicePublicKey, attestation)\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _onDeviceAttestationsChanged () {\n    if (this.closing || !this._deviceAttestationsWatcher || !this.deviceKeyPair) return\n    const plugin = this.privateProfile.plugins.privateProfile\n\n    try {\n      const attestation = await plugin.deviceAttestations.get(this.deviceKeyPair.publicKey)\n      if (!attestation) return\n\n      while (this._pendingAttestations.length) {\n        const prom = this._pendingAttestations.pop()\n        prom.resolve(attestation.value)\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _refreshRoomWatchers () {\n    if (this._roomsWatcher) {\n      await this._roomsWatcher.close()\n    }\n    const plugin = this.privateProfile.plugins.privateProfile\n    this._roomsWatcher = plugin.rooms.watch({}, {\n      eager: true,\n      onchange: this._onSharedRoomsChanged.bind(this)\n    })\n  }\n\n  async _refreshPostMigrationWatchers () {\n    if (this._profileWatcher) {\n      await this._profileWatcher.close()\n    }\n    this._profileWatcher = this.privateProfile.members.watchMember(this.memberKey, {\n      eager: true,\n      onchange: this._onProfileChanged.bind(this)\n    })\n\n    if (this._devicesWatcher) {\n      await this._devicesWatcher.close()\n    }\n    this._devicesWatcher = this.privateProfile.devices.watch({\n      eager: true,\n      onchange: this._onDevicesChanged.bind(this)\n    })\n  }\n\n  async _refreshPreMigrationWatchers () {\n    if (this._deviceKeysWatcher) {\n      await this._deviceKeysWatcher.close()\n    }\n    if (this._deviceAttestationsWatcher) {\n      await this._deviceAttestationsWatcher.close()\n    }\n\n    const plugin = this.privateProfile.plugins.privateProfile\n    this._deviceKeysWatcher = plugin.deviceKeys.watch({}, {\n      eager: true,\n      onchange: this._onDeviceKeysChanged.bind(this)\n    })\n    this._deviceAttestationsWatcher = plugin.deviceAttestations.watch({}, {\n      eager: true,\n      onchange: this._onDeviceAttestationsChanged.bind(this)\n    })\n  }\n\n  async _findDiscoveryCore () {\n    this.discoveryCoreSession = this.keet.swarm.join(this.discoveryCore.discoveryKey, {\n      server: true,\n      client: true\n    })\n\n    // Do a full flush here to be sure we're finding everyone\n    await this.keet.swarm.flush()\n\n    // Wait a fixed delay to make extra sure that an existing profile can't be discovered\n    await new Promise(resolve => setTimeout(resolve, this._profileDiscoveryTimeout))\n  }\n\n  async _createPrivateProfile (opts) {\n    const privateProfile = await this.keet.internalCreateRoom({\n      ...opts,\n      hidden: true\n    })\n    await privateProfile.members.updateMember({\n      displayName: this._defaultName,\n      avatar: this._defaultAvatar\n    })\n\n    await privateProfile.plugins.enable('@holepunchto/private-profile')\n    await privateProfile.base.setUserData(PRIVATE_PROFILE_USERDATA_KEY, EMPTY)\n\n    return privateProfile\n  }\n\n  async _restoreFromOldProfile (identity) {\n    const latest = await this.discoveryCore.get(this.discoveryCore.length - 1)\n\n    const oldProfile = this.keet.internalOpenRoom(latest.key, {\n      encryptionKey: identity.getEncryptionKey(latest.key),\n      hidden: true\n    })\n    await oldProfile.ready()\n\n    // Do a full swarm flush to ensure all peers are found\n    await this.keet.swarm.flush()\n    // Wait e bit extra to make doubly sure that all peers are discovered\n    await new Promise(resolve => setTimeout(resolve, this._profileDiscoveryTimeout))\n\n    const [oldMember, oldSeed] = await Promise.all([\n      oldProfile.members.getMember(identity.identityPublicKey),\n      oldProfile.config.get(CONFIG.ID_SHARED_INVITE_SEED)\n    ])\n    const oldInviteSeed = oldSeed ? HypercoreId.decode(oldSeed) : null\n\n    // If the old profile could not be loaded, do not attempt to migrate from it\n    if (!oldMember || !oldInviteSeed) return null\n\n    const roomKeys = []\n    for await (const node of oldProfile.plugins.privateProfile.rooms.createReadStream()) {\n      roomKeys.push(node.value.key)\n    }\n\n    if (oldMember) {\n      await this.updateProfile(oldMember)\n    }\n    if (roomKeys.length) {\n      await Promise.allSettled(roomKeys.map(key => this._maybePairSharedRoom(key, oldInviteSeed)))\n    }\n  }\n\n  async _migrateFromLocalDatabase (privateProfile) {\n    const allRooms = await this.local.getRecentRooms({ limit: MIGRATING_ROOMS_LIMIT })\n    const migratingRooms = allRooms.filter(metadata => !metadata.hidden)\n    const plugin = privateProfile.plugins.privateProfile\n\n    for (let i = migratingRooms.length - 1; i >= 0; i--) {\n      const metadata = migratingRooms[i]\n      if (!metadata.roomId) return Promise.resolve()\n\n      const key = HypercoreId.decode(metadata.roomId)\n      await this.local.bumpRoomPriority(key)\n      await plugin.addRoom(key)\n    }\n  }\n\n  async _migrateFromCurrentProfile (privateProfile) {\n    const oldPlugin = this.privateProfile.plugins.privateProfile\n    const newPlugin = privateProfile.plugins.privateProfile\n\n    const migratingRooms = []\n    for await (const { value } of oldPlugin.rooms.createReadStream({ limit: MIGRATING_ROOMS_LIMIT })) {\n      migratingRooms.push(value.key)\n    }\n\n    // TODO: Probably should not do all of this in parallel\n    await Promise.allSettled(migratingRooms.map(async key => {\n      const room = this.keet.internalOpenRoom(key, { hidden: true })\n      try {\n        await newPlugin.addRoom(key)\n      } finally {\n        this.keet.internalReleaseRoom(room)\n      }\n    }))\n  }\n\n  async _migrateToPrivateProfile (privateProfile) {\n    if (!this.privateProfile) await this._migrateFromLocalDatabase(privateProfile)\n    else await this._migrateFromCurrentProfile(privateProfile)\n\n    const oldPrivateProfile = this.privateProfile\n    this.privateProfile = privateProfile\n\n    if (this._roomSnapshot) {\n      await this._roomSnapshot.close()\n      this._roomSnapshot = null\n    }\n\n    await this._refreshPreMigrationWatchers()\n\n    if (oldPrivateProfile) this.keet.internalReleaseRoom(oldPrivateProfile)\n  }\n\n  async _waitForAttestation () {\n    const plugin = this.privateProfile.plugins.privateProfile\n\n    const existing = await plugin.deviceAttestations.get(this.deviceKeyPair.publicKey)\n    if (existing) return existing.value\n\n    const record = {\n      resolve: null\n    }\n\n    const attestedPromise = new Promise(resolve => {\n      record.resolve = resolve\n    })\n    this._pendingAttestations.push(record)\n\n    return attestedPromise\n  }\n\n  // Queries\n\n  async getProfile (deviceKey) {\n    if (!this.opened) await this.ready()\n\n    const member = await this.privateProfile.members.getMember(this.memberKey)\n    if (!member) return null\n\n    let identity = null\n    if (!this.anonymous) {\n      identity = {\n        memberKey: this.memberKey,\n        proof: IdentityKey.attestData(deviceKey, this.deviceKeyPair, this.deviceProof)\n      }\n    }\n\n    return {\n      displayName: member.displayName,\n      avatar: member.avatar,\n      identity\n    }\n  }\n\n  // Mutations\n\n  async restore (mnemonic, { create = false, quickSetup = false } = {}) {\n    if (!this.opened) await this.ready()\n\n    // If this throws due to an invalid mnemonic, don't continue with the migration\n    const identity = await IdentityKey.from({ mnemonic })\n\n    if (this._migrating) throw KeetError.ALREADY_MIGRATING()\n    this._migrating = new Promise(resolve => {\n      this._migratingResolve = resolve\n    })\n\n    // 1) Load the current profile (will be migrated into the new one)\n    const existing = await this.getIdentity({ waitForMigrating: false, encodeAvatar: false })\n\n    // 2) Generate the discovery core\n    // 3) Attempt to find and restore rooms/profile from an existing discovery core\n    this.discoveryCore = this.store.get({\n      ...identity.profileDiscoveryKeyPair,\n      encryptionKey: identity.getProfileDiscoveryEncryptionKey(),\n      valueEncoding: ProfileDiscoveryRecord\n    })\n    await this.discoveryCore.ready()\n\n    const mirrors = this.keet.internalCreateClosestMirrors(this.discoveryCore.key, 3)\n    // We're explicitly not awaiting this\n    Promise.allSettled(mirrors.map(m => m.add(this.discoveryCore.id)))\n\n    let restoreFoundRooms = false\n    if (!create) {\n      await this._findDiscoveryCore()\n      if (this.discoveryCore.length !== 0) {\n        restoreFoundRooms = true\n      }\n      // Set a new fork ID for the discovery core\n      const fork = Math.floor((Date.now() - IDENTITIES_RELEASE_TIMESTAMP) / 1000)\n      await this.discoveryCore.truncate(this.discoveryCore.length, fork)\n    }\n\n    // 4) Generate a device keypair for this identity\n    this.deviceKeyPair = await this.store.createKeyPair(identity.identityPublicKey)\n    this.deviceProof = await IdentityKey.bootstrap({ mnemonic }, this.deviceKeyPair.publicKey)\n\n    this.sharedInviteSeed = crypto.randomBytes(32)\n    this.memberKey = identity.identityPublicKey\n    this.memberId = HypercoreId.encode(this.memberKey)\n    this.memberBlindingKeyPair = deriveBlindingKeyPair(this.memberKey, this.sharedInviteSeed)\n    this.anonymous = false\n\n    // 5) Create a new private profile\n    const keyPair = crypto.keyPair()\n    const profileKey = Hypercore.key({\n      version: this.store.manifestVersion,\n      signers: [{ signature: 'ed25519', publicKey: keyPair.publicKey }]\n    })\n    const privateProfile = await this._createPrivateProfile({\n      keyPair,\n      encryptionKey: identity.getEncryptionKey(profileKey)\n    })\n    await privateProfile.config.update(CONFIG.ID_PUBLIC_KEY, HypercoreId.encode(identity.identityPublicKey))\n    await privateProfile.config.update(CONFIG.ID_SHARED_INVITE_SEED, HypercoreId.encode(this.sharedInviteSeed))\n\n    // 7) Add the device public key to the private profile\n    // The identity creator can attest to itself\n    await privateProfile.plugins.privateProfile.addDeviceKey(this.deviceKeyPair.publicKey)\n    await privateProfile.plugins.privateProfile.addDeviceAttestation(this.deviceKeyPair.publicKey, this.deviceProof)\n    if (quickSetup) {\n      await privateProfile.config.update(CONFIG.ID_RECOVERY_PHRASE, mnemonic)\n    }\n\n    const oplogAttestation = IdentityKey.attestData(privateProfile.deviceKey, this.deviceKeyPair, this.deviceProof)\n    await privateProfile.members.updateMember({\n      timestamp: existing.timestamp,\n      displayName: existing.displayName,\n      avatar: existing.avatar,\n      identity: {\n        memberKey: identity.identityPublicKey,\n        proof: oplogAttestation\n      }\n    })\n\n    // 8) Migrate the anonymous room list to the private profile (this will also link the member to the identity)\n    await this._migrateToPrivateProfile(privateProfile, this.sharedInviteSeed)\n\n    // 9) If a discovery core was found, try to migrate the rooms/profile from it\n    if (restoreFoundRooms && (this.discoveryCore.length !== 0)) {\n      await this._restoreFromOldProfile(identity)\n    }\n\n    // 6) Update your device name in the new private profile\n    await this.privateProfile.devices.updateDevice({ name: this.deviceName })\n\n    // 7) Restart the post-migration watchers and update any existing rooms in the room list\n    await this._refreshPostMigrationWatchers()\n    await this._refreshRoomWatchers()\n    await this._onsharedroomschanged()\n\n    // 8) Add the private profile key to the discovery core\n    await this.discoveryCore.append({ key: privateProfile.key, timestamp: Date.now() })\n\n    // 9) Update info in the local db\n    await this.bee.put(IDENTITY_RECORD_KEY, {\n      privateProfileKey: privateProfile.key,\n      deviceName: this.deviceName,\n      identity: {\n        identityPublicKey: identity.identityPublicKey,\n        deviceProof: this.deviceProof,\n        sharedInviteSeed: this.sharedInviteSeed\n      }\n    }, {\n      valueEncoding: LocalIdentityRecord\n    })\n\n    this.keet.pairing.server.refresh()\n\n    this._migratingResolve()\n    this._migrating = null\n    this._migratingResolve = null\n  }\n\n  async join (key) {\n    if (!this.opened) await this.ready()\n    this._migrating = new Promise(resolve => {\n      this._migratingResolve = resolve\n    })\n\n    // 1) Open the new private profile\n    const privateProfile = this.keet.internalOpenRoom(key, { hidden: true })\n    await privateProfile.ready()\n    if (this.closing) return\n\n    // 2) Extract the identity public key and the shared invite seed from the room config\n    const identityPublicKey = HypercoreId.decode(await privateProfile.config.get(CONFIG.ID_PUBLIC_KEY))\n    const sharedInviteSeed = HypercoreId.decode(await privateProfile.config.get(CONFIG.ID_SHARED_INVITE_SEED))\n    if (this.closing) return\n\n    // 3) Generate a device keypair corresponding to this new identity\n    const deviceKeyPair = await this.store.createKeyPair(identityPublicKey)\n\n    // 4) Update your device name\n    await privateProfile.devices.updateDevice({ name: this.deviceName })\n\n    this.memberKey = identityPublicKey\n    this.memberId = HypercoreId.encode(this.memberKey)\n    this.deviceKeyPair = deviceKeyPair\n    this.sharedInviteSeed = sharedInviteSeed\n    this.memberBlindingKeyPair = deriveBlindingKeyPair(this.memberKey, this.sharedInviteSeed)\n    this.anonymous = false\n\n    // 6) Swap private profiles (will release the old private profile and restart watchers)\n    await this._migrateToPrivateProfile(privateProfile, sharedInviteSeed)\n\n    // 5) Request an attestation from an existing device\n    const plugin = privateProfile.plugins.privateProfile\n    await plugin.addDeviceKey(deviceKeyPair.publicKey)\n\n    // 7) Wait for another device to send a device attestation for me\n    this.deviceProof = await this._waitForAttestation()\n\n    // 8) Link the device member (generated during pairing) to the primary member using the attesetation\n    const oplogProof = IdentityKey.attestData(this.privateProfile.deviceKey, this.deviceKeyPair, this.deviceProof)\n    await this.privateProfile.members.updateMember({\n      identity: {\n        memberKey: identityPublicKey,\n        proof: oplogProof\n      }\n    })\n\n    // 9) Once the device proof is received, can start listening for room/profile updates\n    await this._refreshPostMigrationWatchers()\n    await this._refreshRoomWatchers()\n\n    // 10) Update the local record\n    await this.bee.put(IDENTITY_RECORD_KEY, {\n      privateProfileKey: this.privateProfile.key,\n      deviceName: this.deviceName,\n      identity: {\n        identityPublicKey,\n        deviceProof: this.deviceProof,\n        sharedInviteSeed: this.sharedInviteSeed\n      }\n    }, {\n      valueEncoding: LocalIdentityRecord\n    })\n\n    this.keet.pairing.server.refresh()\n\n    this._migratingResolve()\n    this._migratingResolve = null\n    this._migrating = null\n  }\n\n  async updateProfile ({ displayName, avatar } = {}) {\n    if (!this.opened) await this.ready()\n\n    return this.privateProfile.members.updateMember({ displayName, avatar })\n  }\n\n  async updateDevice ({ name, save = true } = {}) {\n    if (!this.opened) await this.ready()\n    if (this._migrating) throw KeetError.CANNOT_UPDATE_DEVICE_DURING_MIGRATION('Cannot update device name while migrating')\n\n    // TODO: This should be atomic\n    const node = await this.bee.get(IDENTITY_RECORD_KEY, {\n      valueEncoding: LocalIdentityRecord\n    })\n    if (this._migrating) throw KeetError.CANNOT_UPDATE_DEVICE_DURING_MIGRATION('Cannot update device name while migrating')\n\n    if (save) {\n      await this.bee.put(IDENTITY_RECORD_KEY, { ...node.value, deviceName: name }, {\n        valueEncoding: LocalIdentityRecord\n      })\n    }\n    this.deviceName = name\n\n    await this.privateProfile.devices.updateDevice({ name })\n  }\n\n  async createInvitation () {\n    if (!this.opened) await this.ready()\n\n    if (this.anonymous) throw KeetError.IDENTITY_REQUIRED('Must create an identity before syncing new devices')\n\n    return this.privateProfile.invitations.createInvitation({\n      sensitive: true,\n      canModerate: true,\n      canIndex: true,\n      reusable: true,\n      expiration: '2h'\n    })\n  }\n\n  generateIdentity () {\n    return IdentityKey.generateMnemonic()\n  }\n\n  addRoom (key) {\n    const plugin = this.privateProfile.plugins.privateProfile\n    return plugin.addRoom(key)\n  }\n\n  removeRoom (key) {\n    const plugin = this.privateProfile.plugins.privateProfile\n    return plugin.removeRoom(key)\n  }\n\n  async getIdentity ({ waitForMigrating = true, encodeAvatar = true } = {}) {\n    if (!this.opened) await this.ready()\n    if (this._migrating && (waitForMigrating !== false)) {\n      await this._migrating\n    }\n\n    const [profile, allDevices] = await Promise.all([\n      this.privateProfile.members.getMember(this.memberKey),\n      this.privateProfile.devices.listDevices()\n    ])\n\n    const devices = []\n    for (const device of allDevices) {\n      devices.push({\n        deviceId: HypercoreId.encode(device.key),\n        isMobile: device.isMobile,\n        name: device.name,\n        confirmed: profile.devices.findIndex(k => b4a.equals(k, device.key)) !== -1\n      })\n    }\n\n    return {\n      anonymous: this.anonymous,\n      memberId: this.memberId,\n      timestamp: profile.timestamp,\n      displayName: profile.displayName,\n      avatar: profile.avatar ? encodeAvatar !== false ? b4a.toString(profile.avatar, 'base64') : profile.avatar : null,\n      devices,\n      local: {\n        deviceId: HypercoreId.encode(this.privateProfile.deviceKey)\n      }\n    }\n  }\n\n  subscribeIdentity () {\n    const self = this\n    const stream = new Readable({\n      async open (cb) {\n        try {\n          const identity = await self.getIdentity()\n          this.push(identity)\n          cb(null)\n        } catch (err) {\n          cb(err)\n        }\n      },\n      destroy (cb) {\n        const idx = self._identitySubscriptions.indexOf(this)\n        if (idx !== -1) self._identitySubscriptions.splice(idx, 1)\n        cb(null)\n      }\n    })\n    this._identitySubscriptions.push(stream)\n    return stream\n  }\n\n  async setRecoveryPhrase (mnemonic) {\n    if (!this.opened) await this.ready()\n\n    await this.privateProfile.ready()\n    await this.privateProfile.config.update(CONFIG.ID_RECOVERY_PHRASE, mnemonic)\n  }\n\n  async getRecoveryPhrase () {\n    if (!this.opened) await this.ready()\n\n    await this.privateProfile.ready()\n\n    return this.privateProfile.config.get(CONFIG.ID_RECOVERY_PHRASE)\n  }\n\n  debugFlush () {\n    return this._onsharedroomschanged()\n  }\n\n  static async isPrivateProfile (room) {\n    const userData = await room.base.getUserData(PRIVATE_PROFILE_USERDATA_KEY)\n    if (userData) return true\n\n    if (await room.config.get(CONFIG.ID_PUBLIC_KEY)) return true\n\n    return false\n  }\n\n  static computeInviteSeed (secret, roomKey) {\n    const seed = b4a.alloc(32)\n    sodium.crypto_generichash_batch(seed, [SHARED_INVITE_NAMESPACE, roomKey], secret)\n    return seed\n  }\n\n  static encryptMessage (data, memberBlindingPublicKey) {\n    const ciphertext = b4a.alloc(data.byteLength + sodium.crypto_box_SEALBYTES)\n    sodium.crypto_box_seal(ciphertext, data, memberBlindingPublicKey)\n\n    return ciphertext\n  }\n\n  static decryptMessage (data, keyPair) {\n    const plaintext = b4a.alloc(data.byteLength - sodium.crypto_box_SEALBYTES)\n    sodium.crypto_box_seal_open(plaintext, data, keyPair.publicKey, keyPair.secretKey)\n\n    return plaintext\n  }\n}\n\nfunction deriveBlindingKeyPair (memberKey, secret) {\n  const seed = b4a.alloc(32)\n  sodium.crypto_generichash_batch(seed, [BLINDING_KEY_NAMESPACE, memberKey], secret)\n\n  return encryptionKeyPair(seed)\n}\n\nfunction encryptionKeyPair (seed) {\n  const publicKey = b4a.alloc(sodium.crypto_box_PUBLICKEYBYTES)\n  const secretKey = b4a.alloc(sodium.crypto_box_SECRETKEYBYTES)\n\n  sodium.crypto_box_seed_keypair(publicKey, secretKey, seed)\n\n  return {\n    publicKey,\n    secretKey\n  }\n}\nconst c = require('compact-encoding')\n\nconst Identity = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.fixed32.preencode(state, m.identityPublicKey)\n    c.buffer.preencode(state, m.deviceProof)\n    c.buffer.preencode(state, m.sharedInviteSeed)\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.fixed32.encode(state, m.identityPublicKey)\n\n    let flags = 0\n    if (m.deviceProof) {\n      flags |= 1\n      c.buffer.encode(state, m.deviceProof)\n    }\n    if (m.sharedInviteSeed) {\n      flags |= 2\n      c.buffer.encode(state, m.sharedInviteSeed)\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      identityPublicKey: c.fixed32.decode(state),\n      deviceProof: (flags & 1) !== 0 ? c.buffer.decode(state) : null,\n      sharedInviteSeed: (flags & 2) !== 0 ? c.buffer.decode(state) : null\n    }\n  }\n}\n\nconst LocalIdentityRecord = {\n  preencode (state, m) {\n    c.uint.preencode(state, 2) // flags\n    c.fixed32.preencode(state, m.privateProfileKey)\n    if (m.deviceName) c.string.preencode(state, m.deviceName)\n    if (m.identity) Identity.preencode(state, m.identity)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.deviceName) flags |= 1\n    if (m.identity) flags |= 2\n\n    c.uint.encode(state, flags)\n    c.fixed32.encode(state, m.privateProfileKey)\n\n    if (m.deviceName) c.string.encode(state, m.deviceName)\n    if (m.identity) Identity.encode(state, m.identity)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      privateProfileKey: c.fixed32.decode(state),\n      deviceName: (flags & 1) !== 0 ? c.string.decode(state) : null,\n      identity: (flags & 2) !== 0 ? Identity.decode(state) : null\n    }\n  }\n}\n\nconst ProfileDiscoveryRecord = {\n  preencode (state, m) {\n    c.uint.preencode(state, 0) // flags\n    c.uint.preencode(state, m.timestamp)\n    c.fixed32.preencode(state, m.key)\n  },\n  encode (state, m) {\n    c.uint.encode(state, 0) // flags\n    c.uint.encode(state, m.timestamp)\n    c.fixed32.encode(state, m.key)\n  },\n  decode (state) {\n    c.uint.decode(state) // flags\n    return {\n      timestamp: c.uint.decode(state),\n      key: c.fixed32.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  ProfileDiscoveryRecord,\n  LocalIdentityRecord\n}\nconst c = require('compact-encoding')\n\nconst { KeetError } = require('@holepunchto/keet-core-api')\nconst { PrivateProfileSchema } = require('@holepunchto/keet-core-schemas')\nconst {\n  AddDeviceKeyOperation,\n  AddDeviceAttestationOperation,\n  AddRoomOperation,\n  RemoveRoomOperation\n} = PrivateProfileSchema.Operations\n\nmodule.exports = class PrivateProfilePlugin {\n  static NAME = '@holepunchto/private-profile'\n\n  constructor (room) {\n    this.room = room\n\n    this.deviceAttestations = null\n    this.deviceKeys = null\n    this.rooms = null\n\n    this._loaded = false\n  }\n\n  _send (msg) {\n    return this.room.plugins.internalSend(this.constructor.NAME, msg, true)\n  }\n\n  tryLoad () {\n    if (this._loaded) return\n\n    const plugins = this.room.base.view.plugins\n    const plugin = plugins.get(this.constructor.NAME)\n    if (!plugin) return\n\n    this.deviceAttestations = plugin.deviceAttestations\n    this.deviceKeys = plugin.deviceKeys\n    this.rooms = plugin.rooms\n\n    this._loaded = true\n  }\n\n  async getRoom (key) {\n    const node = await this.rooms.get(key)\n    return node ? node.value : null\n  }\n\n  async addDeviceKey (devicePublicKey) {\n    await this.room.plugins.ready()\n    if (!this._loaded) throw KeetError.PRIVATE_PROFILE_NOT_ENABLED()\n\n    return this._send({\n      type: AddDeviceKeyOperation.TYPE,\n      value: c.encode(AddDeviceKeyOperation, {\n        devicePublicKey\n      })\n    })\n  }\n\n  async addDeviceAttestation (devicePublicKey, attestation) {\n    await this.room.plugins.ready()\n    if (!this._loaded) throw KeetError.PRIVATE_PROFILE_NOT_ENABLED()\n\n    return this._send({\n      type: AddDeviceAttestationOperation.TYPE,\n      value: c.encode(AddDeviceAttestationOperation, {\n        devicePublicKey,\n        attestation\n      })\n    })\n  }\n\n  async addRoom (key) {\n    await this.room.plugins.ready()\n    if (!this._loaded) throw KeetError.PRIVATE_PROFILE_NOT_ENABLED()\n\n    const existing = await this.rooms.get(key)\n    if (existing) return\n\n    return this._send({\n      type: AddRoomOperation.TYPE,\n      value: c.encode(AddRoomOperation, {\n        key\n      })\n    })\n  }\n\n  async removeRoom (key) {\n    await this.room.plugins.ready()\n    if (!this._loaded) throw KeetError.PRIVATE_PROFILE_NOT_ENABLED()\n\n    const existing = await this.rooms.get(key)\n    if (!existing) return\n\n    return this._send({\n      type: RemoveRoomOperation.TYPE,\n      value: c.encode(RemoveRoomOperation, {\n        key\n      })\n    })\n  }\n}\nconst ReadyResource = require('ready-resource')\nconst HyperIndex = require('@holepunchto/hyperindex')\nconst Hyperbee = require('hyperbee')\nconst HypercoreId = require('hypercore-id-encoding')\nconst safetyCatch = require('safety-catch')\nconst mutex = require('mutexify/promise')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst { Readable } = require('streamx')\n\nconst LocalDatabaseTransaction = require('./transaction.js')\nconst {\n  RecentsKeyEncoding\n} = require('./messages.js')\n\nconst EMPTY = b4a.from([1])\nconst RECENTS_MIGRATION_USERDATA_KEY = '@holepunchto/keet-core/migration'\nconst RECENTS_MIGRATION_USERDATA_VALUE = b4a.from([1])\n\nmodule.exports = class LocalDatabase extends ReadyResource {\n  constructor (store) {\n    super()\n    this.store = store\n\n    this.bee = new Hyperbee(this.store.get({ name: 'local', compat: false, active: false }), {\n      alwaysDuplicate: false\n    })\n    this.recentsBee = new Hyperbee(this.store.get({ name: 'local-recents-3', compat: false, active: false }), {\n      keyEncoding: c.lexint,\n      valueEncoding: c.array(c.fixed32),\n      alwaysDuplicate: false\n    })\n\n    this.db = new HyperIndex(this.bee)\n    this.view = new LocalDatabaseTransaction(this, this.db, this.recentsBee)\n\n    this.rooms = this.view.rooms\n    this.files = this.view.files\n    this.bookmarks = this.view.bookmarks\n    this.invitations = this.view.invitations\n    this.clearedFiles = this.view.clearedFiles\n    this.blockedMembers = this.view.blockedMembers\n    this.blockedMembersByRoom = this.view.blockedMembersByRoom\n    this.roomsByPriority = this.view.roomsByPriority\n    this.filesByRoom = this.view.filesByRoom\n\n    this._recentsWriteLock = mutex()\n\n    this.ready().catch(safetyCatch)\n  }\n\n  async _open () {\n    await this.bee.ready()\n    await this.recentsBee.ready()\n\n    const migrated = await this.recentsBee.core.getUserData(RECENTS_MIGRATION_USERDATA_KEY)\n    if (!migrated) await this._migrateRecents()\n  }\n\n  async _close () {\n    const release = await this._recentsWriteLock()\n    try {\n      await this.recentsBee.close()\n      await this.bee.close()\n    } finally {\n      release()\n    }\n  }\n\n  async _migrateRecents () {\n    const release = await this._recentsWriteLock()\n    try {\n      const b = this.recentsBee.batch()\n\n      // just in case the 'local-recents-2' is empty, we should migrate the values from 'local-recents'\n      const core = this.store.get({ name: 'local-recents', compat: false, active: false })\n      const core2 = this.store.get({ name: 'local-recents-2', compat: false, active: false })\n      await Promise.all([core.ready(), core2.ready()])\n      const oldRecentsCore = core2.length ? core2 : core\n\n      const oldRecentsBee = new Hyperbee(oldRecentsCore, {\n        keyEncoding: core2.length ? c.lexint : RecentsKeyEncoding,\n        valueEncoding: c.fixed32,\n        alwaysDuplicate: false\n      })\n      const seen = new Set()\n      for await (const node of oldRecentsBee.createReadStream({ reverse: !!core2.length })) {\n        const roomId = HypercoreId.encode(node.value)\n        if (seen.has(roomId)) continue\n        await b.put(node.key, [node.value])\n        seen.add(roomId)\n      }\n      await b.flush()\n      await this.recentsBee.core.setUserData(RECENTS_MIGRATION_USERDATA_KEY, RECENTS_MIGRATION_USERDATA_VALUE)\n      await oldRecentsBee.close()\n    } finally {\n      release()\n    }\n  }\n\n  watchAll () {\n    const s = new Readable({\n      destroy: cb => {\n        Promise.allSettled([\n          watcher.close()\n        ]).then(cb, cb)\n      }\n    })\n    const watcher = this.bee.watch({}, {\n      eager: true,\n      onchange\n    })\n\n    return s\n\n    function onchange () {\n      if (s) s.push(EMPTY)\n    }\n  }\n\n  readTransaction (opts) {\n    return new LocalDatabaseTransaction(this, this.db.readTransaction(opts), this.recentsBee.batch())\n  }\n\n  async writeTransaction (opts) {\n    const tx = await this.db.writeTransaction(opts)\n    const recentsBatch = this.recentsBee.batch()\n    return new LocalDatabaseTransaction(this, tx, recentsBatch)\n  }\n\n  async bumpRoomPriority (key, { latest = Date.now(), tx = null, remove = false, lock = true, bee = this.recentsBee } = {}) {\n    const release = lock ? await this._recentsWriteLock() : null\n    const shouldCommit = !tx\n    if (!tx) tx = await this.writeTransaction()\n    const recents = tx && lock ? tx.recentsBatch : bee\n    let priority = null\n\n    try {\n      const metadata = await tx.getRoom(key)\n      // If latest timestamp is less than the currently indexed AND the indexed is not in the future, bail out\n      if (metadata && metadata.priority > latest && metadata.priority <= Date.now()) return\n      priority = Math.min(latest, Date.now()) // time should never be in the future\n\n      const prevNode = metadata?.priority ? await recents.get(metadata?.priority) : null\n      const node = await recents.get(priority)\n      if (prevNode?.seq !== node?.seq) await updatePrevNode()\n      await updateLatestNode()\n\n      async function updatePrevNode () {\n        if (!prevNode) return\n        const index = prevNode.value.findIndex(k => b4a.equals(k, key))\n        if (index === -1) return\n        prevNode.value.splice(index, 1)\n        if (!prevNode.value.length) return await recents.del(prevNode.key)\n        await recents.put(prevNode.key, prevNode.value)\n      }\n\n      async function updateLatestNode () {\n        if (!node && remove) return\n        if (!node) return await recents.put(priority, [key])\n\n        const index = node.value.findIndex(k => b4a.equals(k, key))\n        if (index !== -1) node.value.splice(index, 1) // remove the key\n        if (!remove) node.value.unshift(key) // bump the key to the 1st place\n        if (!node.value.length) return await recents.del(priority)\n        await recents.put(priority, node.value)\n      }\n    } catch (err) {\n      safetyCatch(err)\n    } finally {\n      if (!remove && priority) await tx.maybeUpdateRoom(key, { priority })\n      if (shouldCommit) await tx.commit()\n      if (release) release()\n    }\n  }\n\n  async updateRoom (a0, a1, a2) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.updateRoom(a0, a1, a2)\n\n    await tx.commit()\n  }\n\n  async maybeUpdateRoom (a0, a1) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.maybeUpdateRoom(a0, a1)\n\n    await tx.commit()\n  }\n\n  async addRoom (a0, a1) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.addRoom(a0, a1)\n\n    await tx.commit()\n  }\n\n  async removeRoom (a0) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.removeRoom(a0)\n\n    await tx.commit()\n  }\n\n  async getRoom (a0) {\n    const tx = new LocalDatabaseTransaction(this, this.db.readTransaction(), this.recentsBee.batch())\n\n    const res = await tx.getRoom(a0)\n    await tx.close()\n\n    return res\n  }\n\n  createReadStream (a0) {\n    const tx = new LocalDatabaseTransaction(this, this.db.readTransaction(), this.recentsBee.batch())\n\n    const stream = tx.createReadStream(a0)\n    stream.once('close', () => tx.close().catch(safetyCatch))\n\n    return stream\n  }\n\n  async getRecentRooms (a0) {\n    const tx = new LocalDatabaseTransaction(this, this.db.readTransaction(), this.recentsBee.batch())\n\n    const res = await tx.getRecentRooms(a0)\n    await tx.close()\n\n    return res\n  }\n\n  createIndexingRoomsReadStream (a0) {\n    const tx = new LocalDatabaseTransaction(this, this.db.readTransaction(), this.recentsBee.batch())\n\n    const stream = tx.createIndexingRoomsReadStream(a0)\n    stream.once('close', () => tx.close().catch(safetyCatch))\n\n    return stream\n  }\n\n  async blockMember (a0, a1) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.blockMember(a0, a1)\n\n    await tx.commit()\n  }\n\n  async unblockMember (a0, a1) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.unblockMember(a0, a1)\n\n    await tx.commit()\n  }\n\n  async getFileRecord (a0, a1, a2) {\n    const tx = new LocalDatabaseTransaction(this, this.db.readTransaction(), this.recentsBee.batch())\n\n    const res = await tx.getFileRecord(a0, a1, a2)\n    await tx.close()\n\n    return res\n  }\n\n  async addFileRecord (a0, a1, a2, a3) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.addFileRecord(a0, a1, a2, a3)\n\n    await tx.commit()\n  }\n\n  async removeFileRecord (a0, a1, a2) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.removeFileRecord(a0, a1, a2)\n\n    await tx.commit()\n  }\n\n  async clearFile (a0, a1, a2) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.clearFile(a0, a1, a2)\n\n    await tx.commit()\n  }\n\n  async unclearFile (a0, a1, a2) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.unclearFile(a0, a1, a2)\n\n    await tx.commit()\n  }\n\n  async isFileCleared (a0, a1, a2) {\n    const tx = new LocalDatabaseTransaction(this, this.db.readTransaction(), this.recentsBee.batch())\n\n    const res = await tx.isFileCleared(a0, a1, a2)\n    await tx.close()\n\n    return res\n  }\n\n  createLocalFilesStream (a0) {\n    const tx = new LocalDatabaseTransaction(this, this.db.readTransaction(), this.recentsBee.batch())\n\n    const stream = tx.createLocalFilesStream(a0)\n    stream.once('close', () => tx.close().catch(safetyCatch))\n\n    return stream\n  }\n\n  createPendingInvitationsReadStream () {\n    const tx = new LocalDatabaseTransaction(this, this.db.readTransaction(), this.recentsBee.batch())\n\n    const stream = tx.createPendingInvitationsReadStream()\n    stream.once('close', () => tx.close().catch(safetyCatch))\n\n    return stream\n  }\n\n  async listPendingInvitations () {\n    const tx = new LocalDatabaseTransaction(this, this.db.readTransaction(), this.recentsBee.batch())\n\n    const res = await tx.listPendingInvitations()\n    await tx.close()\n\n    return res\n  }\n\n  async getPendingInvitations () {\n    const tx = new LocalDatabaseTransaction(this, this.db.readTransaction(), this.recentsBee.batch())\n\n    const res = await tx.getPendingInvitations()\n    await tx.close()\n\n    return res\n  }\n\n  async getPendingInvitation (a0) {\n    const tx = new LocalDatabaseTransaction(this, this.db.readTransaction(), this.recentsBee.batch())\n\n    const res = await tx.getPendingInvitation(a0)\n    await tx.close()\n\n    return res\n  }\n\n  async addPendingInvitation (a0, a1) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.addPendingInvitation(a0, a1)\n\n    await tx.commit()\n  }\n\n  async removePendingInvitation (a0) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.removePendingInvitation(a0)\n\n    await tx.commit()\n  }\n\n  async updatePendingInvitation (a0, a1) {\n    const tx = new LocalDatabaseTransaction(this, await this.db.writeTransaction(), this.recentsBee.batch())\n\n    await tx.updatePendingInvitation(a0, a1)\n\n    await tx.commit()\n  }\n}\nconst HyperIndex = require('@holepunchto/hyperindex')\nconst BlindPairing = require('blind-pairing')\nconst c = require('compact-encoding')\n\nconst IndexFilePointer = [HyperIndex.BUFFER, HyperIndex.STRING, HyperIndex.UINT]\n\nconst IncognitoProfile = {\n  preencode (state, m) {\n    state.end++ // flags\n    if (m.displayName) c.string.preencode(state, m.displayName)\n    if (m.avatar) c.buffer.preencode(state, m.avatar)\n  },\n  encode (state, m) {\n    const start = state.start++\n    let flags = 0\n\n    if (m.displayName) {\n      flags |= 1\n      c.string.encode(state, m.displayName)\n    }\n    if (m.avatar) {\n      flags |= 2\n      c.buffer.encode(state, m.avatar)\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      displayName: (flags & 1) !== 0 ? c.string.decode(state) : null,\n      avatar: (flags & 2) !== 0 ? c.buffer.decode(state) : null\n    }\n  }\n}\n\nconst FileRecord = {\n  preencode (state, m) {\n    c.uint.preencode(state, 0) // flags\n    c.fixed32.preencode(state, m.roomKey)\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.fixed32.encode(state, m.roomKey)\n\n    let flags = 0\n    if (m.cleared) {\n      flags |= 1\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      roomKey: c.fixed32.decode(state),\n      cleared: (flags & 1) !== 0\n    }\n  }\n}\n\nconst RoomRecord = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.uint.preencode(state, m.unread)\n    c.uint.preencode(state, m.priority)\n    c.bool.preencode(state, m.bookmarked)\n    if (m.indexing) c.bool.preencode(state, m.indexing)\n  },\n  encode (state, m) {\n    const start = state.start++\n    c.uint.encode(state, m.unread)\n    c.uint.encode(state, m.priority)\n    c.bool.encode(state, m.bookmarked)\n\n    let flags = 0\n    if (m.indexing) {\n      flags |= 1\n      // TODO: Remove this silliness\n      c.bool.encode(state, m.indexing)\n    }\n    if (m.incognito) {\n      flags |= 2\n      IncognitoProfile.encode(state, m.incognito)\n    }\n    if (m.hidden) {\n      flags |= 4\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      unread: c.uint.decode(state),\n      priority: c.uint.decode(state),\n      bookmarked: c.bool.decode(state),\n      indexing: (flags & 1) !== 0 ? c.bool.decode(state) : false,\n      incognito: (flags & 2) !== 0 ? IncognitoProfile.decode(state) : null,\n      hidden: (flags & 4) !== 0\n    }\n  }\n}\n\nconst BookmarksRecord = c.array(c.fixed32)\n\nconst PairingStatus = {\n  NEW: 0,\n  PAIRED: 1,\n  COMPLETED: 2,\n  EXPIRED: 3,\n  NEEDS_CONFIRMATION: 4\n}\n\nconst PendingInvitationIdentity = {\n  preencode (state, m) {\n    state.end++ // flags\n    if (m.attestation) c.buffer.preencode(state, m.attestation)\n    if (m.incognito) IncognitoProfile.preencode(state, m.incognito)\n  },\n  encode (state, m) {\n    const start = state.start++\n\n    let flags = 0\n    if (m.attestation) {\n      flags |= 1\n      c.buffer.encode(state, m.attestation)\n    }\n    if (m.incognito) {\n      flags |= 2\n      IncognitoProfile.encode(state, m.incognito)\n    }\n    if (m.onlyAddDevice) {\n      flags |= 4\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      attestation: (flags & 1) !== 0 ? c.buffer.decode(state) : null,\n      incognito: (flags & 2) !== 0 ? IncognitoProfile.decode(state) : null,\n      onlyAddDevice: (flags & 4) !== 0\n    }\n  }\n}\n\nconst PendingInvitationRecord = {\n  preencode (state, m) {\n    let flags = 0\n    if (m.key) flags |= 1\n    if (m.encryptionKey) flags |= 2\n    if (m.completed) flags |= 4\n    if (m.expired) flags |= 8\n    if (m.needsConfirmation) flags |= 16\n    if (m.hidden) flags |= 32\n    if (m.identity) flags |= 64\n    if (m.deviceKey) flags |= 128\n    if (m.additional) flags |= 256\n    if (m.deviceName) flags |= 512\n    c.uint.preencode(state, flags)\n\n    c.uint.preencode(state, m.timestamp)\n    BlindPairing.Invite.preencode(state, m.invitation)\n\n    if (m.key) c.fixed32.preencode(state, m.key)\n    if (m.encryptionKey) c.fixed32.preencode(state, m.encryptionKey)\n    if (m.identity) PendingInvitationIdentity.preencode(state, m.identity)\n    if (m.deviceKey) c.fixed32.preencode(state, m.deviceKey)\n    if (m.additional) c.fixed32.preencode(state, m.additional)\n    if (m.deviceName) c.string.preencode(state, m.deviceName)\n  },\n  encode (state, m) {\n    let flags = 0\n    if (m.key) flags |= 1\n    if (m.encryptionKey) flags |= 2\n    if (m.completed) flags |= 4\n    if (m.expired) flags |= 8\n    if (m.needsConfirmation) flags |= 16\n    if (m.hidden) flags |= 32\n    if (m.identity) flags |= 64\n    if (m.deviceKey) flags |= 128\n    if (m.additional) flags |= 256\n    if (m.deviceName) flags |= 512\n    c.uint.encode(state, flags)\n\n    c.uint.encode(state, m.timestamp)\n    BlindPairing.Invite.encode(state, m.invitation)\n\n    if (m.key) c.fixed32.encode(state, m.key)\n    if (m.encryptionKey) c.fixed32.encode(state, m.encryptionKey)\n    if (m.identity) PendingInvitationIdentity.encode(state, m.identity)\n    if (m.deviceKey) c.fixed32.encode(state, m.deviceKey)\n    if (m.additional) c.fixed32.encode(state, m.additional)\n    if (m.deviceName) c.string.encode(state, m.deviceName)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    const timestamp = c.uint.decode(state)\n    const invitation = BlindPairing.Invite.decode(state)\n\n    let status = PairingStatus.NEW\n    if ((flags & 1) !== 0) {\n      status = PairingStatus.PAIRED\n    }\n    if ((flags & 4) !== 0) {\n      status = PairingStatus.COMPLETED\n    }\n    if ((flags & 8) !== 0) {\n      status = PairingStatus.EXPIRED\n    }\n    if ((flags & 16) !== 0) {\n      status = PairingStatus.NEEDS_CONFIRMATION\n    }\n    const hidden = (flags & 32) !== 0\n\n    return {\n      status,\n      timestamp,\n      invitation,\n      hidden,\n      key: (flags & 1) !== 0 ? c.fixed32.decode(state) : null,\n      encryptionKey: (flags & 2) !== 0 ? c.fixed32.decode(state) : null,\n      identity: (flags & 64) !== 0 ? PendingInvitationIdentity.decode(state) : null,\n      deviceKey: (flags & 128) !== 0 ? c.fixed32.decode(state) : null,\n      additional: (flags & 256) !== 0 ? c.fixed32.decode(state) : null,\n      deviceName: (flags & 512) !== 0 ? c.string.decode(state) : null\n    }\n  }\n}\n\n// TODO: This is a hack to avoid a local db migration because the key was originally a c.uint\nconst RecentsKeyEncoding = {\n  preencode (state, m) {\n    c.lexint.preencode(state, m)\n  },\n  encode (state, m) {\n    c.lexint.encode(state, m)\n  },\n  decode (state) {\n    const start = state.start\n    try {\n      return c.lexint.decode(state)\n    } catch {\n      state.start = start\n      return c.uint.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  RecentsKeyEncoding,\n  IndexFilePointer,\n  FileRecord,\n  RoomRecord,\n  BookmarksRecord,\n  PendingInvitationRecord,\n  PairingStatus\n}\nconst HyperIndex = require('@holepunchto/hyperindex')\nconst Hyperdrive = require('hyperdrive')\nconst HypercoreId = require('hypercore-id-encoding')\nconst ParallelTransform = require('parallel-transformx')\nconst safetyCatch = require('safety-catch')\nconst c = require('compact-encoding')\n\nconst { pipeline } = require('streamx')\n\nconst {\n  IndexFilePointer,\n  FileRecord,\n  RoomRecord,\n  BookmarksRecord,\n  PendingInvitationRecord\n} = require('./messages.js')\n\nmodule.exports = class LocalDatabaseTransaction {\n  constructor (local, tx, recentsBatch) {\n    this.local = local\n    this.tx = tx\n    this.recentsBatch = recentsBatch\n\n    const {\n      collections,\n      indexes\n    } = LocalDatabaseTransaction.createCollectionsAndIndexes(tx)\n\n    this.rooms = collections.rooms\n    this.files = collections.files\n    this.invitations = collections.invitations\n    this.blockedMembers = collections.blockedMembers\n    this.blockedMembersByRoom = collections.blockedMembersByRoom\n\n    this.indexingRooms = indexes.indexingRooms\n    this.roomsByPriority = indexes.roomsByPriority\n    this.filesByRoom = indexes.filesByRoom\n  }\n\n  // Rooms\n\n  async updateRoom (key, change, { quiet = false, upsert = false } = {}) {\n    const roomNode = await this.rooms.get(key)\n    if (this.local.closing) return\n\n    const room = roomNode ? roomNode.value : createRoomRecord()\n    const upd = { unread: 0, priority: 0, ...room, ...change }\n\n    try {\n      await this.rooms.update(key, upd, { upsert })\n    } catch (err) {\n      if (quiet) {\n        safetyCatch(err)\n        return\n      }\n      throw err\n    }\n  }\n\n  async maybeUpdateRoom (key, record) {\n    return this.updateRoom(key, record, { upsert: false, quiet: true })\n  }\n\n  addRoom (key, record) {\n    return this.updateRoom(key, record, { upsert: true })\n  }\n\n  removeRoom (key) {\n    return this.rooms.delete(key)\n  }\n\n  async getRoom (key) {\n    const roomNode = await this.rooms.get(key)\n    if (!roomNode) return null\n    return roomNode.value\n  }\n\n  createReadStream (opts) {\n    return this.rooms.createReadStream(opts)\n  }\n\n  async getRecentRooms (opts = {}) {\n    const { limit = +Infinity, _keys, ...range } = opts\n    const recents = []\n\n    // wait any running room priority bumps\n    const release = await this.local._recentsWriteLock()\n    for await (const node of this.recentsBatch.createReadStream({ ...range, reverse: true })) {\n      for await (const key of node.value) {\n        const id = HypercoreId.encode(key)\n        const metadata = await this.getRoom(key)\n        if (!metadata || metadata.hidden) continue\n\n        if (_keys) {\n          recents.push(key)\n        } else {\n          recents.push({\n            ...metadata,\n            priority: node.key,\n            roomId: id\n          })\n        }\n\n        if (recents.length >= limit) break\n      }\n      if (recents.length >= limit) break\n    }\n    release()\n\n    return recents\n  }\n\n  createIndexingRoomsReadStream (opts) {\n    return pipeline(this.indexingRooms.createReadStream(opts), new ParallelTransform({\n      transform: (node, cb) => {\n        return this.getRoom(node.key).then(record => cb(null, { ...record, key: node.key }), err => cb(err))\n      }\n    }))\n  }\n\n  // Blocked Members\n\n  blockMember (roomKey, key) {\n    return this.blockedMembersByRoom.update([roomKey, key], null, { upsert: true })\n  }\n\n  unblockMember (roomKey, key) {\n    return this.blockedMembersByRoom.delete([roomKey, key])\n  }\n\n  // File Management\n\n  async getFileRecord (key, path, version) {\n    const recordKey = [key, Hyperdrive.normalizePath(path), version]\n    const node = await this.files.get(recordKey)\n    return node ? { ...node.value, key, path, version } : null\n  }\n\n  getAndWatchFileRecord (key, path, version) {\n    const recordKey = [key, Hyperdrive.normalizePath(path), version]\n    return this.files.getAndWatch(recordKey)\n  }\n\n  async addFileRecord (roomKey, key, path, version) {\n    const recordKey = [key, Hyperdrive.normalizePath(path), version]\n\n    const existing = await this.getFileRecord(key, path, version)\n    if (existing) return\n\n    return this.files.update(recordKey, { roomKey, cleared: false }, { upsert: true })\n  }\n\n  removeFileRecord (key, path, version) {\n    const fullKey = [key, Hyperdrive.normalizePath(path), version]\n    return this.files.delete(fullKey)\n  }\n\n  async clearFile (key, path, version) {\n    const fullKey = [key, Hyperdrive.normalizePath(path), version]\n\n    const node = await this.files.get(fullKey)\n    if (!node) return\n\n    return this.files.update(fullKey, { ...node.value, cleared: true }, { upsert: true })\n  }\n\n  async unclearFile (key, path, version) {\n    const fullKey = [key, Hyperdrive.normalizePath(path), version]\n\n    const node = await this.files.get(fullKey)\n    if (!node) return\n\n    return this.files.update(fullKey, { ...node.value, cleared: false }, { upsert: true })\n  }\n\n  async isFileCleared (key, path, version) {\n    const fullKey = [key, Hyperdrive.normalizePath(path), version]\n    const node = await this.files.get(fullKey)\n    return !node || node.value.cleared\n  }\n\n  createLocalFilesStream (roomKey) {\n    return pipeline(this.filesByRoom.createReadStream({\n      gte: [roomKey],\n      lte: [roomKey]\n    }), new ParallelTransform({\n      transform: (node, cb) => {\n        this.getFileRecord(node.key[1], node.key[2], node.key[3])\n          .then(record => cb(null, record), err => cb(err))\n      }\n    }))\n  }\n\n  // Pending Invitations\n\n  createPendingInvitationsReadStream () {\n    return this.invitations.createReadStream()\n  }\n\n  async listPendingInvitations () {\n    const invitations = []\n    for await (const record of this.createPendingInvitationsReadStream()) {\n      invitations.push(record)\n    }\n    return invitations\n  }\n\n  getPendingInvitation (seed) {\n    return this.invitations.get(seed)\n  }\n\n  removePendingInvitation (seed) {\n    return this.invitations.delete(seed)\n  }\n\n  addPendingInvitation (invitation, { deviceKey, identity, hidden } = {}) {\n    return this.updatePendingInvitation(invitation.seed, {\n      timestamp: Date.now(),\n      deviceKey,\n      invitation,\n      hidden,\n      identity\n    })\n  }\n\n  async updatePendingInvitation (seed, change) {\n    const invitationNode = await this.invitations.get(seed)\n    if (this.local.closing) return\n\n    const existing = invitationNode ? invitationNode.value : change\n    const upd = { ...existing, ...change }\n\n    if (!upd.timestamp || !upd.invitation) {\n      // wasnt there and we are not upserting\n      return\n    }\n\n    await this.invitations.update(seed, upd, { upsert: true })\n  }\n\n  // Transactions\n\n  async commit () {\n    // TODO: These should be atomic\n    await this.recentsBatch.flush()\n    await this.tx.commit()\n  }\n\n  async close () {\n    // TODO: These should be atomic\n    await this.recentsBatch.close()\n    await this.tx.close()\n  }\n\n  // Indexing + Schemas\n\n  static createCollectionsAndIndexes (db) {\n    const [\n      rooms,\n      bookmarks,\n      files,\n      invitations,\n      blockedMembers,\n      blockedMembersByRoom\n    ] = db.collections || db.createCollections([\n      {\n        keyEncoding: HyperIndex.BUFFER, // rooms\n        valueEncoding: RoomRecord\n      },\n      {\n        keyEncoding: HyperIndex.UINT, // bookmarks\n        valueEncoding: BookmarksRecord\n      },\n      {\n        keyEncoding: IndexFilePointer, // files\n        valueEncoding: FileRecord\n      },\n      {\n        keyEncoding: HyperIndex.BUFFER, // invitations\n        valueEncoding: PendingInvitationRecord\n      },\n      {\n        keyEncoding: HyperIndex.BUFFER // blockedMembers\n      },\n      {\n        keyEncoding: [HyperIndex.BUFFER, HyperIndex.BUFFER]\n      }\n    ])\n\n    const [roomsByPriority, indexingRooms] = rooms.indexes || rooms.createIndexes([\n      {\n        keyEncoding: HyperIndex.UINT,\n        valueEncoding: HyperIndex.BUFFER\n      },\n      {\n        keyEncoding: HyperIndex.BUFFER,\n        valueEncoding: c.uint // noop\n      }\n    ], LocalDatabaseTransaction.indexRooms)\n\n    const [filesByRoom] = files.indexes || files.createIndexes([\n      {\n        keyEncoding: [HyperIndex.BUFFER, ...IndexFilePointer],\n        valueEncoding: c.uint // noop\n      }\n    ], LocalDatabaseTransaction.indexFiles)\n\n    return {\n      collections: {\n        rooms,\n        files,\n        bookmarks,\n        invitations,\n        blockedMembers,\n        blockedMembersByRoom\n      },\n      indexes: {\n        filesByRoom,\n        roomsByPriority,\n        indexingRooms\n      }\n    }\n  }\n\n  static async indexRoomsByPriority () {\n    // This is now disabled in favor of the separate recents database\n  }\n\n  static async indexIndexingRooms ({ indexingRooms: index }, { prev, next, id }) {\n    if (prev && next && (prev.indexing === next.indexing)) return\n    if (prev && prev.indexing) {\n      await index.delete(id)\n    }\n    if (next && next.indexing) {\n      await index.insert(id, 0)\n    }\n  }\n\n  static async indexFilesByRoom ({ filesByRoom: index }, { prev, next, id }) {\n    if (prev) {\n      await index.delete([prev.roomKey, ...id])\n    }\n    if (next) {\n      await index.insert([next.roomKey, ...id], 0)\n    }\n  }\n\n  static async indexRooms (batch, op) {\n    const { indexes } = LocalDatabaseTransaction.createCollectionsAndIndexes(batch)\n    await LocalDatabaseTransaction.indexRoomsByPriority(indexes, op)\n    await LocalDatabaseTransaction.indexIndexingRooms(indexes, op)\n  }\n\n  static async indexFiles (batch, op) {\n    const { indexes } = LocalDatabaseTransaction.createCollectionsAndIndexes(batch)\n    await LocalDatabaseTransaction.indexFilesByRoom(indexes, op)\n  }\n}\n\nfunction createRoomRecord () {\n  return {\n    unread: false,\n    key: null,\n    invitation: null\n  }\n}\nconst ReadyResource = require('ready-resource')\nconst HypercoreId = require('hypercore-id-encoding')\nconst BufferMap = require('tiny-buffer-map')\nconst debounce = require('debounceify')\nconst safetyCatch = require('safety-catch')\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\nconst { Readable } = require('streamx')\n\nconst BlindPairing = require('blind-pairing')\n\nconst KeetIdentity = require('../identity')\nconst RoomInvitations = require('../room/invitations')\nconst {\n  PairingStatus\n} = require('../local/messages')\nconst { KeetError } = require('@holepunchto/keet-core-api')\nconst { InvitationSchema } = require('@holepunchto/keet-core-schemas')\nconst { InvitationUserData } = InvitationSchema.Messages\n\nconst DEFAULT_GC_INTERVAL = 60 * 1000 // Clean up expired invitations every minute\nconst DEFAULT_TIMEOUT = 1000 * 60 * 60 * 24 * 2 // 48 hour pairing timeout\nconst EMPTY = b4a.alloc(0)\n\nmodule.exports = class KeetPairingClient extends ReadyResource {\n  constructor (keet, pairing, opts = {}) {\n    super()\n    const {\n      pairingGCInterval = DEFAULT_GC_INTERVAL,\n      pairingTimeout = DEFAULT_TIMEOUT,\n      onerror = safetyCatch\n    } = opts\n\n    this.keet = keet\n    this.pairing = pairing\n    this.swarm = keet.swarm\n    this.local = keet.local\n    this.identity = keet.identity\n\n    this._pairingGCInterval = pairingGCInterval\n    this._pairingTimeout = pairingTimeout\n\n    this._pairingCandidatesBySeed = new BufferMap()\n    this._pendingInvitationsBySeed = new BufferMap()\n\n    this._debouncedRefreshCandidates = debounce(safe(this._refresh.bind(this), { onerror }))\n\n    this._onerror = onerror\n    this._pairingSubscriptions = []\n    this._gcTimer = null\n\n    this._pendingInvitationWatcher = null\n  }\n\n  async _open () {\n    this._pendingInvitationWatcher = this.local.invitations.watch()\n    this._pendingInvitationWatcher.on('update', this._debouncedRefreshCandidates)\n\n    await this._debouncedRefreshCandidates()\n    await this._gc()\n  }\n\n  async _close () {\n    if (this._gcTimer) clearTimeout(this._gcTimer)\n\n    await this._pendingInvitationWatcher.destroy()\n\n    await Promise.all([...this._pairingCandidatesBySeed.values()].map(c => c.close()))\n  }\n\n  async _gc () {\n    try {\n      const expired = []\n      const pendingInvitations = await this.local.listPendingInvitations()\n      if (this.closing) return\n\n      const now = Date.now()\n      for (const { value: record } of pendingInvitations) {\n        const expires = record.invitation.expires\n        const pairingExpired = (now - record.timestamp) > this._pairingTimeout\n        const invitationExpired = expires && ((now - expires) > 0)\n        if (pairingExpired || invitationExpired) {\n          expired.push(record)\n        }\n      }\n      for (const record of expired) {\n        await this.local.updatePendingInvitation(record.invitation.seed, { expired: true })\n        if (this.closing) return\n      }\n    } catch (err) {\n      this._onerror(err)\n    }\n\n    this._gcTimer = setTimeout(this._gc.bind(this), this._pairingGCInterval)\n  }\n\n  async _stopPairingCandidate (record) {\n    const seed = record.invitation.seed\n    const candidate = this._pairingCandidatesBySeed.get(seed)\n    if (!candidate) return\n\n    this._pairingCandidatesBySeed.delete(seed)\n\n    await candidate.close()\n  }\n\n  async _onPairingCandidateResult (seed, { key, encryptionKey, data }) {\n    // If the pairing attempt has expired before the result is received, bail here\n    const stillNew = await this._ensureCandidateStatus(seed, PairingStatus.NEW)\n    if (!stillNew) return\n\n    await this.local.updatePendingInvitation(seed, { key, encryptionKey, additional: data })\n  }\n\n  async _ensureCandidateStatus (seed, status) {\n    const latest = await this.local.getPendingInvitation(seed)\n    return latest && (latest.value.status === status)\n  }\n\n  async _maybeUpdateRoomRecord (room, { tx } = {}) {\n    const transaction = tx || this.local\n    let indexing = false\n    if (room.me) {\n      const capabilities = RoomInvitations.getOptionsFromCapabilities(room.me.capabilities)\n      indexing = capabilities.canIndex\n    }\n\n    const existing = await transaction.getRoom(room.key)\n    if (existing && (existing.indexing === indexing)) return\n\n    await transaction.updateRoom(room.key, {\n      indexing\n    }, { upsert: true })\n  }\n\n  // Pairing Status Handlers\n\n  async _onNewPairingStatus (seed, discoveryKey, record) {\n    const { deviceKey } = await this.keet._getLocalAutobaseKeys(discoveryKey)\n    if (this.closing) return\n\n    const candidate = this.pairing.addCandidate({\n      onadd: result => this._onPairingCandidateResult(seed, result),\n      userData: c.encode(InvitationUserData, {\n        noisePublicKey: this.swarm.keyPair.publicKey,\n        attestation: record.identity?.attestation,\n        deviceKey,\n        deviceName: record.invitation.sensitive ? this.keet.identity?.deviceName : null\n      }),\n      invite: record.invitation\n    })\n\n    this._pairingCandidatesBySeed.set(seed, candidate)\n  }\n\n  async _finishSyncing (room, record, seed) {\n    // Wait for the local device to be added to the Autobase\n    await room.deviceJoined()\n    // Mark the room as hidden before waiting for joined, so that the member doesn't auto-update\n    const isPrivateProfile = await KeetIdentity.isPrivateProfile(room)\n\n    let indexing = false\n\n    if (room.me.device) {\n      const capabilities = RoomInvitations.getOptionsFromCapabilities(room.me.device.capabilities)\n      indexing = capabilities.canIndex\n    }\n\n    const tx = await this.local.writeTransaction()\n    if (this.closing) return\n\n    let shouldBumpPriority = false\n    if (isPrivateProfile) {\n      await tx.addRoom(record.key, {\n        hidden: true,\n        indexing\n      })\n      // get device that created the identity invite\n      const device = await room.devices.getDevice(record.key)\n      await tx.updatePendingInvitation(seed, { deviceName: device.name, needsConfirmation: true })\n    } else {\n      await tx.addRoom(record.key, {\n        hidden: false,\n        indexing\n      })\n      await tx.updatePendingInvitation(seed, { completed: true })\n      shouldBumpPriority = true\n    }\n    if (this.closing) return\n\n    // If the pairing attempt has expired while waiting for joined, bail here\n    const stillPairing = await this._ensureCandidateStatus(seed, PairingStatus.PAIRED)\n\n    if (stillPairing) {\n      // TODO: This cannot be atomic, so should prob be a bit safer\n      await tx.commit()\n      if (shouldBumpPriority) await this.local.bumpRoomPriority(record.key)\n      if (!isPrivateProfile) {\n        await this.identity.addRoom(record.key)\n      }\n    } else {\n      await tx.close()\n    }\n  }\n\n  async _onPairedPairingStatus (seed, record) {\n    const room = this.keet.internalOpenRoom(record.key, {\n      fastForwardTo: record.additional ? { key: record.additional } : null,\n      encryptionKey: record.encryptionKey,\n      incognito: record.identity?.incognito,\n      onlyAddDevice: record.identity?.onlyAddDevice\n    })\n\n    const session = this.keet.swarm.join(room.discoveryKey, { client: true, server: false })\n\n    try {\n      await this._finishSyncing(room, record, seed)\n    } finally {\n      this.keet.internalReleaseRoom(room)\n      await session.destroy()\n    }\n  }\n\n  _onCompletedPairingStatus (record) {\n    return this._stopPairingCandidate(record)\n  }\n\n  _onExpiredPairingStatus (record) {\n    return this._stopPairingCandidate(record)\n  }\n\n  _maybeUpdatePairing (seed, discoveryKey, record) {\n    const existing = this._pendingInvitationsBySeed.get(seed)\n    if (existing && (existing.status === record.status)) return\n\n    this._pendingInvitationsBySeed.set(seed, record)\n\n    let completed = false\n    let task = null\n\n    switch (record.status) {\n      case PairingStatus.NEW:\n        task = this._onNewPairingStatus(seed, discoveryKey, record)\n        break\n      case PairingStatus.PAIRED:\n        task = this._onPairedPairingStatus(seed, record)\n        break\n      case PairingStatus.COMPLETED:\n        task = this._onCompletedPairingStatus(record)\n        completed = true\n        break\n      case PairingStatus.EXPIRED:\n        task = this._onExpiredPairingStatus(record)\n        completed = true\n        break\n      default:\n        break\n    }\n\n    // Run the task asynchronously in the background\n    if (task) task.catch(this._onerror)\n\n    for (const sub of this._pairingSubscriptions) {\n      sub.push(formatInvitationRecord(record))\n    }\n\n    return completed\n  }\n\n  async _refresh () {\n    const tx = await this.local.writeTransaction()\n    const seen = new BufferMap()\n\n    const pendingInvitations = await this.local.listPendingInvitations()\n    if (this.closing) return\n\n    for (const record of pendingInvitations) {\n      const { seed, discoveryKey } = record.value.invitation\n      seen.set(seed, EMPTY)\n\n      const completed = this._maybeUpdatePairing(seed, discoveryKey, record.value)\n      if (completed) {\n        await tx.removePendingInvitation(seed)\n      }\n    }\n\n    for (const seedId of this._pendingInvitationsBySeed.keys()) {\n      if (seen.has(seedId)) continue\n      this._pendingInvitationsBySeed.delete(seedId)\n    }\n\n    await tx.commit()\n  }\n\n  subscribePairingRooms () {\n    const self = this\n\n    const s = new Readable({\n      // flag is not needed but just reduces the timing between the open and the push in the array\n      eagerOpen: true,\n      async open (cb) {\n        try {\n          if (!self.opened) {\n            await self.ready()\n          } else {\n            const allPendingInvitations = await self.local.listPendingInvitations()\n            if (!self.closing) {\n              for (const record of allPendingInvitations) {\n                this.push(formatInvitationRecord(record.value))\n              }\n            }\n          }\n        } catch (err) {\n          cb(err)\n          return\n        }\n        cb(null)\n      },\n      destroy: cb => {\n        const idx = this._pairingSubscriptions.indexOf(s)\n        if (idx !== -1) this._pairingSubscriptions.splice(idx, 1)\n        cb(null)\n      }\n    })\n    this._pairingSubscriptions.push(s)\n\n    return s\n  }\n\n  subscribePairingStatus (seed) {\n    const self = this\n    let watcher = null\n    return new Readable({\n      async open (cb) {\n        try {\n          watcher = await self.local.invitations.getAndWatch(seed)\n          if (watcher.node) this.push(watcher.node.value)\n          watcher.on('update', () => {\n            if (!watcher.node) return this.push(null)\n            this.push(watcher.node.value)\n          })\n        } catch (err) {\n          cb(err)\n          return\n        }\n        cb(null)\n      },\n      destroy (cb) {\n        if (!watcher) return\n        watcher.close().catch(self._onerror)\n        cb(null)\n      }\n    })\n  }\n\n  async startPairingRoom (invitation, opts) {\n    const { id } = BlindPairing.createInvite(null, invitation)\n    const { deviceKey, key } = await this.keet._getLocalAutobaseKeys(invitation.discoveryKey)\n\n    if (key) {\n      const room = this.keet.internalOpenRoom(key, opts)\n      try {\n        const shouldPair = await room.devices.shouldPair(deviceKey, id)\n        // If the member is already paired with the right capabilities, do not re-pair\n        if (!shouldPair) {\n          return { key, id, seed: invitation.seed }\n        }\n      } finally {\n        this.keet.internalReleaseRoom(room)\n      }\n    }\n\n    // Will trigger _refresh\n    await this.local.addPendingInvitation(invitation, { ...opts, deviceKey })\n\n    // Wait for the refresh to complete\n    await this._debouncedRefreshCandidates()\n\n    return { key: null, id, seed: invitation.seed }\n  }\n\n  async stopPairingRoom (id) {\n    if (!this.opened) await this.ready()\n\n    const pending = await this.local.getPendingInvitation(id)\n    if (!pending) return\n\n    await this._stopPairingCandidate(pending.value)\n    await this.local.removePendingInvitation(id)\n\n    for (const sub of this._pairingSubscriptions) {\n      sub.push({\n        ...formatInvitationRecord(pending.value),\n        status: 'cancelled'\n      })\n    }\n  }\n\n  async confirmIdentityPairing (seed) {\n    const tx = await this.local.writeTransaction()\n\n    const record = await tx.getPendingInvitation(seed)\n    if (!record) {\n      await tx.close()\n      return\n    }\n    if (this.closing) return\n\n    try {\n      await this.identity.join(record.value.key)\n      await tx.updatePendingInvitation(seed, { completed: true })\n    } catch {\n      await tx.close()\n    }\n    await tx.commit()\n  }\n\n  async flushed () {\n    const self = this\n    const allPending = await this.local.listPendingInvitations()\n    await Promise.all(allPending.map(r => flushInvitation(r.value.invitation.seed)))\n\n    async function flushInvitation (seed) {\n      for await (const record of self.subscribePairingStatus(seed)) {\n        if (self.closing) return null\n        if (record.status === PairingStatus.COMPLETED) {\n          break\n        }\n        if (record.status === PairingStatus.EXPIRED) {\n          throw KeetError.PAIRING_EXPIRED()\n        }\n      }\n    }\n  }\n}\n\nfunction formatInvitationRecord (record) {\n  const invitation = record.invitation\n\n  let status = 'unknown'\n  if (record.status === PairingStatus.NEW) {\n    status = 'new'\n  } else if (record.status === PairingStatus.PAIRED) {\n    status = 'paired'\n  } else if (record.status === PairingStatus.COMPLETED) {\n    status = 'completed'\n  } else if (record.status === PairingStatus.EXPIRED) {\n    status = 'expired'\n  } else if (record.status === PairingStatus.NEEDS_CONFIRMATION) {\n    status = 'confirm-sync'\n  }\n\n  return {\n    seedId: HypercoreId.encode(invitation.seed),\n    discoveryId: HypercoreId.encode(invitation.discoveryKey),\n    roomId: record.key ? HypercoreId.encode(record.key) : null,\n    deviceId: record.deviceKey ? HypercoreId.encode(record.deviceKey) : null,\n    deviceName: record.deviceName,\n    expires: invitation.expires,\n    status\n  }\n}\n\nfunction safe (fn, { onerror = safetyCatch }) {\n  return async function (...args) {\n    try {\n      await fn(...args)\n    } catch (err) {\n      onerror(err)\n    }\n  }\n}\nconst safetyCatch = require('safety-catch')\nconst ReadyResource = require('ready-resource')\nconst BlindPairing = require('blind-pairing')\n\nconst KeetPairingClient = require('./client')\nconst KeetPairingServer = require('./server')\n\nmodule.exports = class KeetPairing extends ReadyResource {\n  constructor (keet, opts) {\n    super()\n    this.pairing = new BlindPairing(keet.swarm, { onincoming: this._onincoming.bind(this), ...opts })\n    this.client = new KeetPairingClient(keet, this.pairing, opts)\n    this.server = new KeetPairingServer(keet, this.pairing, opts)\n  }\n\n  async _open () {\n    await this.pairing.ready()\n    await Promise.all([this.client.ready(), this.server.ready()])\n  }\n\n  async _close () {\n    await Promise.all([this.client.close(), this.server.close()])\n    await this.pairing.close()\n  }\n\n  async _onincoming (dkey) {\n    try {\n      const roomKey = this.server._roomKeyByDiscoveryKey.get(dkey)\n      if (!roomKey) return\n      const member = this.server._startSwarmingRoom(roomKey, { announce: false })\n      await member.ready()\n    } catch (error) {\n      safetyCatch(error)\n    }\n  }\n}\nconst ReadyResource = require('ready-resource')\nconst HypercoreId = require('hypercore-id-encoding')\nconst debounce = require('debounceify')\nconst BufferMap = require('tiny-buffer-map')\nconst safetyCatch = require('safety-catch')\nconst crypto = require('hypercore-crypto')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst { Readable } = require('streamx')\n\nconst KeetIdentity = require('../identity')\nconst RoomInvitations = require('../room/invitations')\nconst { KeetError } = require('@holepunchto/keet-core-api')\nconst { InvitationSchema } = require('@holepunchto/keet-core-schemas')\nconst { InvitationUserData } = InvitationSchema.Messages\n\nconst DEFAULT_ANNOUNCE_LIMIT = 15\nconst EMPTY = b4a.alloc(1)\n\nmodule.exports = class KeetPairingServer extends ReadyResource {\n  constructor (keet, pairing, { announceLimit = DEFAULT_ANNOUNCE_LIMIT, onerror = safetyCatch } = {}) {\n    super()\n    this.keet = keet\n    this.swarm = keet.swarm\n    this.local = keet.local\n    this.identity = keet.identity\n    this.pairing = pairing\n\n    this._announceLimit = announceLimit\n    this._onerror = onerror\n\n    this._roomKeyByDiscoveryKey = new BufferMap()\n    this._pairingMembersByKey = new BufferMap()\n    this._pairingCandidatesByUserData = new BufferMap()\n    this._roomsWatcher = null\n\n    this._pendingCandidates = new Map()\n    this._confirmationSubscriptions = []\n\n    this.refresh = debounce(safe(this._refreshRooms.bind(this), this._onerror))\n  }\n\n  async _open () {\n    this._roomsWatcher = this.local.recentsBee.watch()\n    this._roomsWatcher.on('update', this.refresh)\n\n    await this.refresh()\n  }\n\n  async _close () {\n    await this._roomsWatcher.destroy()\n    const promises = []\n    for (const pairingMember of this._pairingMembersByKey.values()) {\n      promises.push(pairingMember.close())\n    }\n    await Promise.all(promises)\n  }\n\n  _bumpConfirmationSubscriptions () {\n    for (const pending of this._pendingCandidates.values()) {\n      for (const sub of this._confirmationSubscriptions) {\n        sub.push({\n          inviteId: pending.inviteId,\n          deviceId: pending.deviceId,\n          swarmId: pending.swarmId,\n          roomId: pending.roomId,\n          deviceName: pending.deviceName\n        })\n      }\n    }\n  }\n\n  async _maybePairPrivateProfile (room, candidate, record) {\n    const inviteId = HypercoreId.encode(candidate.inviteId)\n    const deviceId = HypercoreId.encode(record.key)\n    const swarmId = HypercoreId.encode(record.noisePublicKey)\n\n    const pending = {\n      roomId: room.id,\n      resolve: null,\n      reject: null,\n      inviteId,\n      deviceId,\n      swarmId,\n      record,\n      deviceName: record.deviceName\n    }\n    const confirmed = new Promise((resolve, reject) => {\n      pending.resolve = resolve\n      pending.reject = reject\n    })\n\n    const pendingId = generateCandidateId(inviteId, deviceId)\n    this._pendingCandidates.set(pendingId, pending)\n\n    this._bumpConfirmationSubscriptions()\n\n    try {\n      await confirmed\n      candidate.confirm({\n        key: room.base.key,\n        encryptionKey: room.base.encryptionKey\n      })\n    } catch (err) {\n      candidate.deny()\n    }\n  }\n\n  async _onPairingCandidate (key, candidate) {\n    const room = this.keet.internalOpenRoom(key)\n    try {\n      // Wait for the room to fully-update\n      await room.base.update()\n\n      // Ensure that the shared invite has been written to the room\n      await room._debouncedOnIdentityChanged()\n\n      const [invitation, isPrivateProfile] = await Promise.all([\n        room.invitations.getInvitation(candidate.inviteId),\n        KeetIdentity.isPrivateProfile(room)\n      ])\n      if (this.closing || !invitation) return null\n\n      if ((invitation.expiration > 0) && (Date.now() >= invitation.expiration)) {\n        return null\n      }\n\n      // TODO: Re-enable when single-use invitations are exposed\n      /*\n      if (!invitation.reusable && (invitation.uses >= 1)) {\n        // If this is a single-use invitation, and it's already been used, reject\n        return null\n      }\n      */\n\n      const userData = candidate.open(invitation.publicKey)\n      if (userData === null) return null\n\n      const { deviceKey, deviceName, noisePublicKey } = c.decode(InvitationUserData, userData)\n      const [device, member] = await Promise.all([\n        room.devices.getDevice(deviceKey),\n        room.members.getMemberForDeviceKey(deviceKey, { includeAvatar: false })\n      ])\n\n      // Check if this invitation is a capability upgrade for the member. If not, short-circuit\n      let shouldAdd = true\n      if (device) {\n        if (!RoomInvitations.memberShouldPair(device.capabilities, invitation.capabilities)) {\n          shouldAdd = false\n        } else if (member && !RoomInvitations.memberShouldPair(member.capabilities, invitation.capabilities)) {\n          shouldAdd = false\n        }\n      }\n\n      const record = {\n        key: deviceKey,\n        noisePublicKey,\n        invitation: candidate.inviteId,\n        receipt: candidate.receipt,\n        capabilities: invitation.capabilities,\n        deviceName\n      }\n      if (shouldAdd) {\n        if (isPrivateProfile) {\n          await this._maybePairPrivateProfile(room, candidate, record)\n        } else {\n          await room.devices.addDevice(record)\n        }\n      }\n      candidate.confirm({\n        key: room.base.key,\n        encryptionKey: room.base.encryptionKey,\n        additional: invitation.additional\n      })\n    } catch (err) {\n      this._onerror(err)\n    } finally {\n      this.keet.internalReleaseRoom(room)\n    }\n  }\n\n  _startSwarmingRoom (key, { announce = true } = {}) {\n    const member = this._pairingMembersByKey.get(key)\n    if (member) return member\n\n    const pairingMember = this.pairing.addMember({\n      onadd: candidate => this._onPairingCandidate(key, candidate),\n      discoveryKey: crypto.discoveryKey(key),\n      announce\n    })\n\n    this._pairingMembersByKey.set(key, pairingMember)\n    return pairingMember\n  }\n\n  async _stopSwarmingRoom (key) {\n    this._roomKeyByDiscoveryKey.delete(crypto.discoveryKey(key))\n    if (!this._pairingMembersByKey.has(key)) return\n\n    const pairingMember = this._pairingMembersByKey.get(key)\n    this._pairingMembersByKey.delete(key)\n\n    return pairingMember.close()\n  }\n\n  async _refreshRooms () {\n    const adds = new BufferMap()\n    const removes = new BufferMap()\n\n    const recents = await this.local.getRecentRooms({\n      _keys: true\n    })\n\n    if (this.closing) return\n\n    // Always swarm the private profile\n    adds.set(this.identity.privateProfile.key, EMPTY)\n\n    for (const key of this.keet._activatedRooms.keys()) {\n      adds.set(key, EMPTY)\n    }\n    for (const key of recents) {\n      this._roomKeyByDiscoveryKey.set(crypto.discoveryKey(key), key)\n      if (adds.size < this._announceLimit) adds.set(key, EMPTY)\n    }\n    for (const key of this._pairingMembersByKey.keys()) {\n      if (adds.has(key)) continue\n      removes.set(key, EMPTY)\n    }\n\n    for (const key of adds.keys()) {\n      this._startSwarmingRoom(key).announce()\n    }\n\n    const stops = []\n\n    for (const key of removes.keys()) {\n      stops.push(this._stopSwarmingRoom(key))\n    }\n\n    await Promise.all(stops)\n  }\n\n  async flushed () {\n    if (!this.opening) await this.ready()\n    await this.refresh()\n    await Promise.all([...this._pairingMembersByKey.values()].map(m => m.flushed()))\n  }\n\n  subscribeIdentityPairingRequests () {\n    const self = this\n    const stream = new Readable({\n      destroy: cb => {\n        const idx = self._confirmationSubscriptions.indexOf(this)\n        if (idx !== -1) self._confirmationSubscriptions.splice(idx, 1)\n        cb(null)\n      }\n    })\n\n    this._confirmationSubscriptions.push(stream)\n    this._bumpConfirmationSubscriptions()\n\n    return stream\n  }\n\n  async confirmIdentityPairingRequest ({ roomId, inviteId, deviceId }, confirmed = true) {\n    const pendingId = generateCandidateId(inviteId, deviceId)\n    const key = HypercoreId.decode(roomId)\n\n    if (!this._pendingCandidates.has(pendingId)) throw KeetError.PAIRING_CANDIDATE_NOT_FOUND()\n    const { resolve, reject, record } = this._pendingCandidates.get(pendingId)\n\n    this._pendingCandidates.delete(pendingId)\n\n    if (confirmed) {\n      const room = this.keet.internalOpenRoom(key)\n      try {\n        await room.devices.addDevice(record)\n      } finally {\n        this.keet.internalReleaseRoom(room)\n      }\n      resolve()\n    } else {\n      reject(new Error('Identity pairing request was rejected'))\n    }\n  }\n}\n\nfunction safe (fn, { onerror = safetyCatch }) {\n  return async function (...args) {\n    try {\n      await fn(...args)\n    } catch (err) {\n      onerror(err)\n    }\n  }\n}\n\nfunction generateCandidateId (inviteId, deviceId) {\n  return inviteId + ':' + deviceId\n}\nconst { pipeline } = require('streamx')\nconst ParallelTransform = require('parallel-transformx')\n\nconst { GENERIC_EVENTS, DISPLAY_TYPES, isDisplaySupported } = require('@holepunchto/keet-core-api')\nconst { ChatSchema } = require('@holepunchto/keet-core-schemas')\nconst {\n  AddChatMessageOperation,\n  UpdateChatMessageOperation,\n  RemoveChatMessageOperation,\n  AddGenericEventOperation,\n  RemoveGenericEventOperation\n} = ChatSchema.Operations\n\nmodule.exports = class RoomChat {\n  constructor (room) {\n    this.room = room\n    this.collection = this.room.collections.chat\n    this.eventIdsByMessageId = this.room.indexes.eventIdsByMessageId\n    this.eventIdsByClock = this.room.indexes.eventIdsByClock\n    this.mentionsByMemberId = this.room.indexes.mentionsByMemberId\n  }\n\n  // Query Methods\n\n  async getThreadLength (threadId) {\n    if (!this.room.opened) await this.room.ready()\n\n    const maxNode = await this.collection.peek({\n      gte: [threadId],\n      lte: [threadId],\n      reverse: true\n    })\n    return maxNode ? maxNode._id[1] + 1 : 0\n  }\n\n  async length () {\n    if (!this.room.opened) await this.room.ready()\n\n    return this.getThreadLength(0)\n  }\n\n  createReadStream (opts) {\n    const rangeOpts = RoomChat.getRangeOptions(opts)\n    return pipeline(this.collection.createReadStream(rangeOpts), new ParallelTransform({\n      transform: async (data, cb) => {\n        let error = null\n        let memberKey = null\n        try {\n          const [member, inactiveMember] = await Promise.all([\n            this.room.members.getMemberForDeviceKey(data.value.id.key, { includeAvatar: false }),\n            this.room.members.getInactiveMemberForDeviceKey(data.value.id.key, { includeAvatar: false })\n          ])\n          // TODO: in case it got messed up just return the device key...\n          memberKey = member?.key || inactiveMember?.key || data.value.id.key\n        } catch (err) {\n          error = err\n        }\n        if (!error) {\n          cb(null, {\n            ...data,\n            _id: data._id[1],\n            value: {\n              ...data.value,\n              memberKey\n            }\n          })\n        } else {\n          cb(error)\n        }\n      }\n    }))\n  }\n\n  // TODO: Add support for getting threads\n  async getMessage (threadSeq) {\n    if (!this.room.opened) await this.room.ready()\n\n    // TODO: Only read from thread 0 for now\n    const record = await this.collection.get([0, threadSeq])\n    if (!record) return null\n\n    const [member, inactiveMember] = await Promise.all([\n      this.room.members.getMemberForDeviceKey(record.value.id.key, { includeAvatar: false }),\n      this.room.members.getInactiveMemberForDeviceKey(record.value.id.key, { includeAvatar: false })\n    ])\n    const memberKey = member?.key || inactiveMember?.key\n\n    return { ...record.value, memberKey, seq: threadSeq }\n  }\n\n  // TODO: Add support for getting threads\n  async getMessageById (id) {\n    if (!this.room.opened) await this.room.ready()\n\n    const eventId = await getValue(this.eventIdsByMessageId, [id.key, id.seq])\n    if (!eventId) return null\n\n    // TODO: Only read from thread 0 for now\n    return this.getMessage(eventId[1])\n  }\n\n  watch () {\n    return this.collection.watch()\n  }\n\n  // Mutation Methods\n\n  async addMessage (text, opts = {}) {\n    const abi = await this.room.getABI()\n    const display = formatDisplays(opts)\n\n    return this.room.sendAndNotify({\n      type: AddChatMessageOperation.TYPE,\n      value: {\n        text,\n        timestamp: opts.timestamp || null, // handy in tests\n        display: filterUnsupportedDisplays(display, abi),\n        replyTo: opts.replyTo || null\n      }\n    })\n  }\n\n  async updateMessage (id, text, opts = {}) {\n    const abi = await this.room.getABI()\n    const display = formatDisplays(opts)\n\n    return this.room.send({\n      type: UpdateChatMessageOperation.TYPE,\n      value: {\n        id,\n        text,\n        display: filterUnsupportedDisplays(display, abi),\n        replyTo: opts.replyTo || null\n      }\n    })\n  }\n\n  removeMessage (id) {\n    return this.room.send({\n      type: RemoveChatMessageOperation.TYPE,\n      value: {\n        id\n      }\n    })\n  }\n\n  addCallStartedEvent () {\n    return this.addEvent(GENERIC_EVENTS.CALL_STARTED)\n  }\n\n  addRoomAvatarChangedEvent () {\n    return this.addEvent(GENERIC_EVENTS.ROOM_AVATAR_CHANGED)\n  }\n\n  addEvent (type, value) {\n    return this.room.sendAndNotify({\n      type: AddGenericEventOperation.TYPE,\n      value: {\n        type,\n        value\n      }\n    })\n  }\n\n  removeEvent (id) {\n    return this.room.send({\n      type: RemoveGenericEventOperation.TYPE,\n      value: {\n        id\n      }\n    })\n  }\n\n  // Indexing\n\n  static getRangeOptions (opts) {\n    const rangeOpts = { ...opts }\n    // prefix all the range options\n    const prefix = rangeOpts.prefix || 0\n    if (Number.isInteger(rangeOpts.gt)) rangeOpts.gt = [prefix, opts.gt]\n    if (Number.isInteger(rangeOpts.gte)) rangeOpts.gte = [prefix, opts.gte]\n    if (Number.isInteger(rangeOpts.lt)) rangeOpts.lt = [prefix, opts.lt]\n    if (Number.isInteger(rangeOpts.lte)) rangeOpts.lte = [prefix, opts.lte]\n    if (!rangeOpts.gt && !rangeOpts.gte) {\n      rangeOpts.gte = [prefix]\n    }\n    if (!rangeOpts.lt && !rangeOpts.lte) {\n      rangeOpts.lte = [prefix]\n    }\n    return rangeOpts\n  }\n}\n\nasync function getValue (db, key) {\n  const node = await db.get(key)\n  return node ? node.value : null\n}\n\nfunction filterUnsupportedDisplays (displays, abi) {\n  return displays.filter(({ type }) => isDisplaySupported(abi, type))\n}\n\nfunction formatDisplays (opts = {}) {\n  const display = []\n  if (opts.mentions) opts.mentions.forEach(value => display.push({ type: DISPLAY_TYPES.MENTION, value }))\n  if (opts.httpLinks) opts.httpLinks.forEach(value => display.push({ type: DISPLAY_TYPES.HTTP_LINK, value }))\n  if (opts.pearLinks) opts.pearLinks.forEach(value => display.push({ type: DISPLAY_TYPES.PEAR_LINK, value }))\n  if (opts.bold) opts.bold.forEach(value => display.push({ type: DISPLAY_TYPES.BOLD, value }))\n  if (opts.italic) opts.italic.forEach(value => display.push({ type: DISPLAY_TYPES.ITALIC, value }))\n  if (opts.code) opts.code.forEach(value => display.push({ type: DISPLAY_TYPES.CODE, value }))\n  if (opts.emoji) opts.emoji.forEach(value => display.push({ type: DISPLAY_TYPES.EMOJI, value }))\n  if (opts.codeBlock) opts.codeBlock.forEach(value => display.push({ type: DISPLAY_TYPES.CODE_BLOCK, value }))\n  if (opts.strike) opts.strike.forEach(value => display.push({ type: DISPLAY_TYPES.STRIKE_THROUGH, value }))\n  return display\n}\nconst { KeetError } = require('@holepunchto/keet-core-api')\n\nmodule.exports = class RoomCommands {\n  constructor (room) {\n    this.room = room\n    this.commands = new Map()\n\n    // Register commands\n    this.commands.set('/join', this._join.bind(this))\n    this.commands.set('/leave', this._leave.bind(this))\n  }\n\n  isCommand (message) {\n    return !!message.startsWith('/')\n  }\n\n  isValidCommand (message) {\n    const [cmd] = message.split(' ')\n    return this.commands.has(cmd)\n  }\n\n  async handle (message) {\n    const [cmd, ...args] = message.split(' ')\n    const command = this.commands.get(cmd)\n    await command(args)\n  }\n\n  // Command handlers\n\n  async _leave () {\n    // @TODO: enable after self removal support\n    // await this.room.keet._leaveRoom(this.room.id)\n  }\n\n  async _join (args) {\n    if (!args || !args.length) throw KeetError.INVALID_ROOM_COMMAND_ARGUMENTS()\n    const invitation = args[0]\n      .replace(/\\[([^\\]]+)\\]\\((.*?)\\)/g, '$1') // Remove markdown link\n      .replace('pear://', '')\n      .replace('keet/', '')\n\n    await this.room.keet.startPairingRoom(invitation)\n  }\n}\nconst b4a = require('b4a')\nconst {\n  Readable,\n  Transform,\n  pipeline\n} = require('streamx')\nconst { CONFIG } = require('@holepunchto/keet-core-api')\nconst { ConfigSchema } = require('@holepunchto/keet-core-schemas')\nconst {\n  UpdateConfigOperationV1,\n  UpdateConfigOperationV2\n} = ConfigSchema.Operations\nconst {\n  FEATURES\n} = require('@holepunchto/keet-core-api')\nconst EMPTY = b4a.from([1])\n\nconst REINDEX_POLL_INTERVAL = 1000\n\nmodule.exports = class RoomConfig {\n  constructor (room) {\n    this.room = room\n    this.collection = this.room.collections.config\n\n    this.configV2 = room.base.view.bee\n\n    this._subscriptions = []\n    this._bumpTimer = null\n  }\n\n  _bumpSubscriptions () {\n    for (const sub of this._subscriptions) {\n      sub.push(EMPTY)\n    }\n  }\n\n  startReindexPolling () {\n    // Does not need to be unregistered because RoomConfig's lifecycle matches Room lifecycle\n    this.room.base.on('reindexing', () => {\n      this._bumpTimer = setInterval(() => {\n        this._bumpSubscriptions()\n      }, REINDEX_POLL_INTERVAL)\n      this._bumpSubscriptions()\n    })\n    this.room.base.on('reindexed', () => {\n      this._bumpSubscriptions()\n      if (this._bumpTimer) clearInterval(this._bumpTimer)\n    })\n  }\n\n  // Query Methods\n\n  createReadStream (opts = {}) {\n    const stream = this.configV2.createReadStream(opts, ConfigSchema.Encoding)\n    return pipeline(stream, new Transform({\n      transform (data, cb) {\n        cb(null, { key: data.key, value: ConfigSchema.getValue(data) })\n      }\n    }))\n  }\n\n  async isDmRoom () {\n    const node = await this.configV2.get(CONFIG.ROOM_TYPE, ConfigSchema.Encoding)\n    if (!node) return false\n    return ConfigSchema.getValue(node) === '2'\n  }\n\n  async getPinnedMessages () {\n    return await this.getV2(CONFIG.PINNED_MESSAGES) || []\n  }\n\n  async getV2 (key) {\n    if (!this.room.opened) await this.room.ready()\n\n    const node = await this.configV2.get(key, ConfigSchema.Encoding)\n\n    return ConfigSchema.getValue(node)\n  }\n\n  async getV1 (key) {\n    const record = await this.collection.get(CONFIG.V1_CONFIG_KEY)\n    const config = record?.value\n\n    if (key) {\n      if (!config) return null\n      if (!Object.hasOwn(config, key)) return null\n      return config[key]\n    }\n\n    return config || {}\n  }\n\n  async get (key, { legacy = false } = {}) {\n    // TODO: This is a hack to display a progress bar for the room title when migrating to v6 Autobase\n    // Should be removed once this migration is widely deployed\n    if (this.room.base.reindexing) {\n      const progress = this.room.base.progress()\n      return {\n        title: `Migrating: ${progress.processed}/${progress.total}`\n      }\n    }\n\n    if (!this.room.opened) await this.room.ready()\n\n    const v1 = legacy || !(await this.room.isFeatureSupported(FEATURES.V2_CONFIG))\n\n    if (v1) return this.getV1(key)\n    return key ? this.getV2(key) : this.list()\n  }\n\n  async list (opts = {}) {\n    if (!this.room.opened) await this.room.ready()\n\n    if (!(await this.room.isFeatureSupported(FEATURES.V2_CONFIG))) {\n      return this.getV1()\n    }\n\n    const configs = {}\n    for await (const { key, value } of this.createReadStream(opts)) {\n      configs[key] = value\n    }\n\n    return configs\n  }\n\n  watch (opts) {\n    let w1 = null\n    let w2 = null\n\n    const stream = new Readable({\n      eagerOpen: true,\n      open: async cb => {\n        let error = null\n        try {\n          if (!this.room.opened) await this.room.ready()\n          w1 = this.collection.watch({ gte: CONFIG.V1_CONFIG_KEY, lte: CONFIG.V1_CONFIG_KEY }, {\n            ...opts,\n            onchange\n          })\n          w2 = this.configV2.watch(null, {\n            ...opts,\n            onchange,\n            ...ConfigSchema.Encoding\n          })\n        } catch (err) {\n          error = err\n        }\n        cb(error)\n      },\n      destroy: cb => {\n        const idx = this._subscriptions.indexOf(stream)\n        if (idx !== -1) this._subscriptions.splice(idx, 1)\n        if (w1) w1.close().then(cb, cb)\n        if (w2) w2.close().then(cb, cb)\n      }\n    })\n    this._subscriptions.push(stream)\n\n    return stream\n\n    function onchange () {\n      if (!stream) return\n      stream.push(EMPTY)\n      if (opts?.onchange) userOnChange()\n    }\n\n    async function userOnChange () {\n      try {\n        await opts.onchange()\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  }\n\n  // Mutation Methods\n\n  async togglePinnedMessage (msgId) {\n    const pins = await this.getPinnedMessages()\n    const idx = pins.findIndex(pin => b4a.equals(pin.key, msgId.key) && pin.seq === msgId.seq)\n    if (idx === -1) {\n      pins.push(msgId)\n    } else {\n      pins.splice(idx, 1)\n    }\n\n    await this.updateV2(CONFIG.PINNED_MESSAGES, pins)\n  }\n\n  updateV1 (key, value) {\n    return this.room.send({\n      type: UpdateConfigOperationV1.TYPE,\n      value: {\n        key,\n        value\n      }\n    })\n  }\n\n  updateV2 (key, value) {\n    return this.room.send({\n      type: UpdateConfigOperationV2.TYPE,\n      value: {\n        key,\n        value: ConfigSchema.encodeValue(key, value)\n      }\n    })\n  }\n\n  async update (key, value, legacy = false) {\n    await this.room.ready()\n\n    const v1 = legacy || !(await this.room.isFeatureSupported(FEATURES.V2_CONFIG))\n\n    if (v1) return this.updateV1(key, value)\n    return this.updateV2(key, value)\n  }\n}\nconst RoomInvitations = require('./invitations.js')\nconst { DeviceSchema } = require('@holepunchto/keet-core-schemas')\nconst {\n  AddDeviceOperationV2,\n  UpdateDeviceOperation,\n  RemoveDeviceOperationV2\n} = DeviceSchema.Operations\nconst {\n  FEATURES,\n  KeetError,\n  isFeatureSupported\n} = require('@holepunchto/keet-core-api')\n\nconst DEVICE_COUNT_KEY = 0\nconst MOBILE_DEVICE_COUNT_KEY = 1\n\nmodule.exports = class RoomDevices {\n  constructor (room) {\n    this.room = room\n\n    this.collection = room.collections.devices\n    this.deviceCount = room.indexes.deviceCount\n    this.mobileDeviceCount = room.indexes.mobileDeviceCount\n    this.deviceKeysByNoisePublicKey = room.indexes.deviceKeysByNoisePublicKey\n  }\n\n  async shouldPair (deviceKey, invitationId) {\n    const [device, member, invitation] = await Promise.all([\n      this.room.devices.getDevice(deviceKey),\n      this.room.members.getMemberForDeviceKey(deviceKey),\n      this.room.invitations.getInvitation(invitationId)\n    ])\n\n    if (!device || !member || !invitation) return true\n\n    return RoomInvitations.memberShouldPair(member.capabilities, invitation.capabilities)\n  }\n\n  // Query Methods\n\n  async getDeviceKeyForNoisePublicKey (noisePublicKey) {\n    const keyNode = await this.deviceKeysByNoisePublicKey.get(noisePublicKey)\n    return keyNode ? keyNode.value : null\n  }\n\n  async isModerator (deviceKey) {\n    return this.room.members.isDeviceModerator(deviceKey)\n  }\n\n  async listDevices () {\n    const devices = []\n    for await (const node of this.collection.createReadStream()) {\n      devices.push(node.value)\n    }\n    return devices\n  }\n\n  async count () {\n    if (!this.room.opened) await this.room.ready()\n\n    const node = await this.deviceCount.get(DEVICE_COUNT_KEY)\n    return node ? node.value : 0\n  }\n\n  async mobileCount () {\n    if (!this.room.opened) await this.room.ready()\n\n    const node = await this.mobileDeviceCount.get(MOBILE_DEVICE_COUNT_KEY)\n    return node ? node.value : 0\n  }\n\n  async getDevice (deviceKey) {\n    if (!this.room.opened) await this.room.ready()\n\n    const node = await this.collection.get(deviceKey)\n    if (!node) return null\n\n    return node.value\n  }\n\n  async me () {\n    if (!this.room.opened) await this.room.ready()\n\n    const localKey = this.room.base.local.key\n\n    const node = await this.collection.get(localKey)\n    if (!node) return null\n\n    return node.value\n  }\n\n  watch (opts) {\n    return this.collection.watch({}, opts)\n  }\n\n  watchDevice (deviceKey, opts) {\n    return this.collection.watch({ gte: deviceKey, lte: deviceKey }, opts)\n  }\n\n  // Mutation Methods\n\n  addDevice ({ key, noisePublicKey, capabilities, invitation, receipt, identity } = {}) {\n    return this.room.send({\n      type: AddDeviceOperationV2.TYPE,\n      value: {\n        key,\n        identity,\n        noisePublicKey,\n        capabilities,\n        invitation,\n        receipt\n      }\n    })\n  }\n\n  async removeDevice ({ key } = {}) {\n    const abi = await this.room.getABI()\n\n    if (!isFeatureSupported(abi, FEATURES.LEAVE_ROOM)) {\n      throw KeetError.FEATURE_NOT_SUPPORTED()\n    }\n\n    return this.room.send({\n      type: RemoveDeviceOperationV2.TYPE,\n      value: {\n        key\n      }\n    })\n  }\n\n  async updateDevice ({ name } = {}) {\n    const existing = await this.getDevice(this.room.deviceKey)\n    if (existing && (existing.name === name)) return\n\n    return this.room.send({\n      type: UpdateDeviceOperation.TYPE,\n      value: {\n        name\n      }\n    })\n  }\n}\nconst p = require('path')\nconst fs = require('fs')\nconst { pipelinePromise } = require('streamx')\nconst HypercoreId = require('hypercore-id-encoding')\n\nconst { ChatSchema } = require('@holepunchto/keet-core-schemas')\nconst {\n  AddFileOperation,\n  RemoveFileOperation\n} = ChatSchema.Operations\n\nmodule.exports = class RoomFiles {\n  constructor (room) {\n    this.room = room\n    this.drives = this.room.keet.drives\n    this.collection = this.room.collections.chat\n    this.drivesByPath = this.room.indexes.drivesByPath\n    this.eventIdsByMessageId = this.room.indexes.eventIdsByMessageId\n  }\n\n  // Query Methods\n\n  async getDrivesWithPath (path) {\n    if (!this.room.opened) await this.room.ready()\n\n    const keys = []\n    for await (const { key } of this.drivesByPath.createReadStream({ gte: [path], lte: [path] })) {\n      keys.push(key[1])\n    }\n    return keys\n  }\n\n  // Mutation Methods\n\n  async sendFile ({ pointer, metadata = {} } = {}) {\n    const { driveId, path, version } = pointer\n    const driveKey = HypercoreId.decode(driveId)\n    await this.room.keet.local.addFileRecord(this.room.key, driveKey, path, version)\n    if (this.room.closing) return\n\n    const file = {\n      // pointer\n      key: driveKey,\n      path,\n      version,\n      // metadata\n      preview: metadata.preview || null,\n      type: metadata.type || null,\n      dimensions: metadata.dimensions || null\n    }\n\n    // temporarily\n    if ((await this.room._getABI()) >= 2) {\n      file.previewPointer = getPreviewPointer(metadata.previewPointer) // file pointer: { key, path, version }\n    }\n\n    return this.room.sendAndNotify({\n      type: AddFileOperation.TYPE,\n      value: {\n        file,\n        description: metadata.description || null\n      }\n    })\n  }\n\n  async saveFile (fsPath, opts) {\n    if (!this.room.opened) await this.room.ready()\n\n    const name = p.basename(fsPath)\n    const drive = this.room.drive\n    const rs = fs.createReadStream(fsPath)\n    const ws = drive.createWriteStream(name, opts)\n    await pipelinePromise(rs, ws)\n    if (this.room.closing) return\n\n    return {\n      driveId: HypercoreId.encode(drive.key),\n      path: name,\n      version: drive.version\n    }\n  }\n\n  async saveFileBlob (path, bytes, opts = {}) {\n    if (!this.room.opened) await this.room.ready()\n\n    const drive = this.room.drive\n    await drive.put(path, bytes, opts)\n    if (this.room.closing) return\n\n    return {\n      driveId: HypercoreId.encode(drive.key),\n      path,\n      version: drive.version\n    }\n  }\n\n  // compat\n  async addFileBlob (path, bytes, opts = {}) {\n    const pointer = await this.saveFileBlob(path, bytes, opts)\n    await this.sendFile({ pointer, metadata: opts })\n    return pointer\n  }\n\n  // compat\n  async addFile (fsPath, opts = {}) {\n    const pointer = await this.saveFile(fsPath, opts)\n    await this.sendFile({ pointer, metadata: opts })\n    return pointer\n  }\n\n  async removeFile (id) {\n    if (!this.room.opened) await this.room.ready()\n\n    const eventIdNode = await this.eventIdsByMessageId.get([id.key, id.seq])\n    if (!eventIdNode) return\n\n    const message = await this.collection.get(eventIdNode.value)\n    if (!message?.value?.file || this.room.closing) return\n    const file = message.value.file\n\n    await this.room.send({\n      type: RemoveFileOperation.TYPE,\n      value: {\n        id\n      }\n    })\n    if (this.room.closing) return\n\n    await this.drives.clearFile(file.key, file.path, file.version)\n    await this.room.keet.local.clearFile(file.key, file.path, file.version)\n  }\n}\n\nfunction getPreviewPointer (preview = {}) {\n  if (!preview) return null\n  const { driveId, path, version } = preview\n  if (!driveId || !path || typeof version !== 'number') return null\n  return {\n    key: HypercoreId.decode(driveId),\n    path,\n    version\n  }\n}\nconst ReadyResource = require('ready-resource')\nconst HypercoreId = require('hypercore-id-encoding')\nconst Autobase = require('autobase')\nconst crypto = require('hypercore-crypto')\nconst safetyCatch = require('safety-catch')\nconst debounce = require('debounceify')\nconst b4a = require('b4a')\nconst { Readable } = require('streamx')\n\nconst BlindPairing = require('blind-pairing')\nconst KeetIdentity = require('../identity')\nconst RoomFiles = require('./files')\nconst RoomMembers = require('./members')\nconst RoomDevices = require('./devices')\nconst RoomInvitations = require('./invitations')\nconst RoomConfig = require('./config')\nconst RoomChat = require('./chat')\nconst RoomMailbox = require('./mailbox')\nconst RoomPrivateMailbox = require('./private-mailbox')\nconst RoomReactions = require('./reactions')\nconst RoomPlugins = require('./plugins')\nconst RoomCommands = require('./commands')\n\nconst {\n  InternalSchema,\n  KeetSchema\n} = require('@holepunchto/keet-core-schemas')\nconst {\n  InternalOperation,\n  UpgradeOperation,\n  GenesisOperation\n} = InternalSchema.Operations\nconst {\n  CONFIG,\n  FEATURES,\n  MIN_ABIS,\n  KeetError,\n  MemberCapabilities,\n  isFeatureSupported\n} = require('@holepunchto/keet-core-api')\n\nconst KeetIndexing = require('@holepunchto/keet-indexing')\nconst { KeetOplogMessage } = KeetSchema.Messages\n\nconst ROOM_TITLE_USERDATA_KEY = '@holepunchto/keet-core/room-title'\nconst AUTOBASE_STATUS_USERDATA_KEY = '@holepunchto/keet-core/status'\nconst AUTOBASE_STATUS_ACTIVE = b4a.from([1])\nconst AUTOBASE_STATUS_INACTIVE = b4a.from([0])\n\nconst SELF_MEMBER_USERDATA_KEY = '@holepunchto/keet-core/self-member'\nconst SELF_MEMBER_USERDATA_VALUE = b4a.from([1])\n\nmodule.exports = class Room extends ReadyResource {\n  constructor (keet, key, opts) {\n    super()\n    this.keet = keet\n    this.incognito = opts.incognito\n    this.hidden = !!opts.hidden\n    this.neverUpdateMember = !!opts.onlyAddDevice\n    this.create = !!opts.create\n\n    this.key = key\n    this.id = HypercoreId.encode(this.key)\n    this.discoveryKey = crypto.discoveryKey(key)\n    // TODO: The discoveryId should be HypercoreId encoded -- this is just for compat\n    this.discoveryId = b4a.toString(this.discoveryKey, 'hex')\n    this.namespace = this.keet.store.namespace(this.discoveryKey)\n\n    // Set in leave\n    this.leaving = false\n\n    // Set in _open\n    this.me = { device: null, member: null }\n    this.deviceKey = null\n    this.deviceId = null\n    this.drive = null\n    this.push = null\n\n    this.isExperimental = false\n\n    const wait = !this.hidden ? () => this.keet.internalRoomSemaphore.wait() : null\n    this.base = new Autobase(this.namespace, !opts.keyPair ? [key] : null, {\n      valueEncoding: KeetOplogMessage,\n      close: KeetIndexing.autobaseClose,\n      open: this._autobaseOpen.bind(this),\n      apply: this._autobaseApply.bind(this),\n      encryptionKey: opts.encryptionKey,\n      fastForward: opts.fastForward,\n      ackThreshold: opts.ackThreshold,\n      ackInterval: opts.ackInterval,\n      keyPair: opts.keyPair,\n      encrypted: true,\n      wait\n    })\n\n    this._debouncedMaybeUpgradeRoom = debounce(this._maybeUpgradeRoom.bind(this))\n    this.base.on('unwritable', this._maybeLeaveRoom.bind(this))\n    this.base.on('is-indexer', this._debouncedMaybeUpgradeRoom)\n    this.base.on('interrupt', ({ unsupportedABI }) => {\n      for (const sub of this._abiSubscriptions) {\n        sub.push({ version: unsupportedABI, experimental: this.isExperimental })\n      }\n    })\n\n    if (!this.hidden) {\n      const release = () => this.keet.internalRoomSemaphore.signal()\n      this.base.update().then(release, release)\n    }\n\n    this.collections = this.base.view.collections\n    this.indexes = this.base.view.indexes\n\n    this.chat = new RoomChat(this)\n    this.mailbox = new RoomMailbox(this)\n    this.privateMailbox = new RoomPrivateMailbox(this)\n    this.reactions = new RoomReactions(this)\n    this.devices = new RoomDevices(this)\n    this.invitations = new RoomInvitations(this)\n    this.config = new RoomConfig(this)\n    this.files = new RoomFiles(this)\n    this.members = new RoomMembers(this)\n    this.plugins = new RoomPlugins(this)\n    this.commands = new RoomCommands(this)\n\n    this.internalPushNotify = debounce(this._pushNotify.bind(this))\n\n    this._debouncedOnIdentityChanged = debounce(this._onIdentityChanged.bind(this))\n    this._abiSubscriptions = []\n    this._joinedPromises = []\n    this._memberJoinedPromises = []\n    this._currentMirrors = new Set()\n\n    // Set in _open\n    this._abiWatcher = null\n    this._configWatcher = null\n    this._selfDeviceWatcher = null\n    this._selfMemberWatcher = null\n    this._selfMailboxWatcher = null\n    this._identitySubscription = null\n\n    this._replicatingDriveMirror = false\n\n    this.ready().catch(safetyCatch)\n  }\n\n  get memberKey () {\n    return !this.keet.identity.anonymous ? this.keet.identity.memberKey : this.deviceKey\n  }\n\n  get memberId () {\n    return !this.keet.identity.anonymous ? this.keet.identity.memberId : this.deviceId\n  }\n\n  async _openPostCreate () {\n    if (this.keet.blindMirrorKeys.length) this._mirrorInBackground()\n\n    this.drive = this.keet.drives.createWritableDrive(this.base.key, {\n      encryptionKey: this.base.encryptionKey\n    })\n\n    this._mirrorDriveInBackground()\n\n    this.deviceKey = this.base.local.key\n    this.deviceId = HypercoreId.encode(this.deviceKey)\n\n    // Will be populated with an up-to-date version of your local member record\n    this.me = { device: null, member: null }\n\n    if (this.keet.push) this.push = this.keet.push.room(this.key, this.discoveryKey)\n\n    await this.plugins.ready()\n\n    this._abiWatcher = this.base.view.bee.watch({\n      gte: InternalSchema.CodeVersionKey,\n      lte: InternalSchema.CodeVersionKey\n    }, {\n      ...InternalSchema.UpgraderEncoding,\n      eager: true,\n      updateOnce: true,\n      onchange: this._onABIChanged.bind(this)\n    })\n    this._configWatcher = this.config.watch({\n      eager: true,\n      updateOnce: true,\n      onchange: this._onConfigChanged.bind(this)\n    })\n    this._selfDeviceWatcher = this.devices.watchDevice(this.base.local.key, {\n      eager: true,\n      updateOnce: true,\n      onchange: this._onSelfDeviceChanged.bind(this)\n    })\n    await this._createSelfMemberWatcher()\n    await this._createSelfMailboxWatcher()\n\n    this._identitySubscription = this.keet.identity.subscribeIdentity()\n    this._observeIdentity().catch(safetyCatch)\n\n    // Mark this.base as active so that it will accept push notifications\n    await this.internalMarkActive()\n  }\n\n  async _openCreate () {\n    await this._send({\n      type: InternalOperation.TYPE,\n      value: {\n        subtype: GenesisOperation.SUBTYPE,\n        value: {\n          version: this.keet.isExperimental ? this.keet.abi.max : this.keet.abi.production,\n          experimental: this.keet.isExperimental,\n          bootstrap: {\n            noisePublicKey: this.keet.swarm.keyPair.publicKey\n          }\n        }\n      }\n    })\n    this.isExperimental = this.keet.isExperimental\n  }\n\n  async _open () {\n    // TODO: Remove after the v6 migration\n    this.config.startReindexPolling()\n\n    await this.base.ready()\n\n    if (this.create) await this._openCreate()\n\n    await this._openPostCreate()\n  }\n\n  async _close () {\n    if (this._configWatcher) {\n      this._configWatcher.destroy()\n    }\n    if (this._abiWatcher) {\n      await this._abiWatcher.destroy()\n    }\n    if (this._selfDeviceWatcher) {\n      await this._selfDeviceWatcher.close()\n    }\n    if (this._selfMemberWatcher) {\n      await this._selfMemberWatcher.close()\n    }\n    if (this._selfMailboxWatcher) {\n      await this._selfMailboxWatcher.close()\n    }\n    this._identitySubscription.destroy()\n\n    if (this.push) await this.push.destroy()\n\n    await this.drive.close()\n    await this.base.close()\n\n    const status = this.keet._roomsByKey.get(this.key)\n    if (!status) return\n\n    // Room is changed if the room is reopened during closing\n    if (status.room !== this) return\n\n    await this.keet.pairing.server._stopSwarmingRoom(this.key)\n\n    status.force = true // @TODO: remove once we've a better way to force close streams\n    for (const sub of status.subscriptions) {\n      sub.destroy()\n    }\n\n    this.keet._roomsByKey.delete(status.room.key)\n    this.keet._keysByDiscoveryId.delete(status.room.discoveryId)\n  }\n\n  async _createSelfMemberWatcher () {\n    if (this._selfMemberWatcher) {\n      // If the member watcher is already listening to the memberKey, bail out\n      if (b4a.equals(this._selfMemberWatcher.range.lte, this.memberKey)) return\n      await this._selfMemberWatcher.close()\n      if (b4a.equals(this._selfMemberWatcher.range.lte, this.memberKey)) return\n    }\n    this._selfMemberWatcher = this.members.watchMember(this.memberKey, {\n      eager: true,\n      updateOnce: true,\n      onchange: this._onSelfMemberChanged.bind(this)\n    })\n  }\n\n  async _createSelfMailboxWatcher () {\n    const privateProfile = this.keet.identity.privateProfile\n    if (privateProfile && b4a.equals(this.key, privateProfile.key)) return\n\n    if (this._selfMailboxWatcher) {\n      // If the watcher is already listening to the memberKey, bail out\n      if (b4a.equals(this._selfMailboxWatcher.range.lte[0], this.memberKey)) return\n      await this._selfMailboxWatcher.close()\n      if (b4a.equals(this._selfMailboxWatcher.range.lte[0], this.memberKey)) return\n    }\n\n    this._selfMailboxWatcher = this.mailbox.watch({\n      eager: true,\n      updateOnce: true,\n      onchange: this._onSelfMailboxChanged.bind(this)\n    })\n  }\n\n  async addMirror (m) {\n    const mirrors = await this.config.getV2(CONFIG.ROOM_MIRRORS) ?? []\n    mirrors.push(m)\n    await this.config.updateV2(CONFIG.ROOM_MIRRORS, mirrors)\n  }\n\n  async removeMirror (key) {\n    const mirrors = await this.config.getV2(CONFIG.ROOM_MIRRORS)\n    const index = mirrors.findIndex(m => b4a.equals(m.key, key))\n    if (index > -1) {\n      mirrors.splice(index, 1)\n      await this.config.updateV2(CONFIG.ROOM_MIRRORS, mirrors)\n    }\n  }\n\n  async _addToMirror (mirror) {\n    try {\n      this._currentMirrors.add(mirror)\n      await mirror.add(this.base.local.id, {\n        referrer: this.base.key,\n        autobase: {\n          // the system core is blinded as well, but we share the block key to the mirror can warmup the clock\n          // this is a feature, as we let the mirror know related cores - thats it\n          key: this.base.system.core.key,\n          blockEncryptionKey: this.base.system.core.getBackingCore().session.encryption.blockKey\n        }\n      })\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _mirrorInBackground () { // never throws\n    try {\n      await this.base.ready()\n    } catch {\n      return\n    }\n\n    const [mirror] = this.keet.internalCreateClosestMirrors(this.base.key, 1)\n\n    // when the base migrates, re-add to mirror\n    if (this.base.system) this.base.system.core.on('migrate', () => this._addToMirror(mirror))\n    await this._addToMirror(mirror)\n  }\n\n  async _mirrorDriveInBackground () { // never throws\n    try {\n      await this.base.ready()\n      await this.drive.ready()\n    } catch {\n      return\n    }\n\n    if (this.closing) return\n\n    // TODO: also only attach if the local one has changes, prop need the hyperdb refactor\n    if (this.drive.core.length >= 2) await this.replicateDriveMirror()\n    else this.drive.core.once('append', this.replicateDriveMirror.bind(this))\n  }\n\n  async replicateDriveMirror () {\n    if (this._replicatingDriveMirror) return\n    this._replicatingDriveMirror = true\n\n    const skip = this.hidden || !!(this.keet.identity.privateProfile && b4a.equals(this.key, this.keet.identity.privateProfile.key))\n    if (skip || !this.keet.blindMediaMirrorKeys || !this.keet.blindMediaMirrorKeys.length) return\n\n    try {\n      await this.base.ready()\n    } catch {\n      return\n    }\n\n    const [mirror] = this.keet.internalCreateClosestMediaMirrors(this.base.key, 1)\n    this._currentMirrors.add(mirror)\n\n    try {\n      await this.drive.ready()\n      await Promise.all([\n        mirror.add(this.drive.core.key),\n        mirror.add(this.drive.blobs.core.key)\n      ])\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _maybeLeaveRoom () {\n    await this.ready()\n    if (this.closing) return\n    if (this.leaving) return\n    await this.keet._leaveRoom(this.id, { force: true, cleanup: true })\n  }\n\n  async _maybeUpgradeRoom () {\n    await this.ready()\n    if (this.closing) return\n    await this.base.update()\n    if (this.closing) return\n\n    const [currentABI, isExperimental, isModerator] = await Promise.all([\n      this._getABI(),\n      this._getIsExperimental(),\n      this.members.isModerator(this.memberKey)\n    ])\n    if (this.closing) return\n\n    // In both production + experimental mode, rooms should be upgraded to the latest production ABI\n    const shouldUpgradeProduction = currentABI < this.keet.abi.autoupgrade\n    // In experimental mode, new rooms should be upgraded to the latest available ABI\n    const shouldUpgradeMax = isExperimental && (currentABI < this.keet.abi.max)\n\n    // Open mailbox only when version conditions are met\n    if (currentABI >= MIN_ABIS[FEATURES.DMS]) {\n      await this._maybeOpenMailbox()\n    }\n\n    // For now, only indexers & mods can send upgrade messages\n    if (!this.base.writable || !isModerator) return\n    // If the room is already up-to-date, do not send any more upgrade messages\n    const upgrades = []\n\n    if (shouldUpgradeProduction) {\n      upgrades.push(this.keet.abi.autoupgrade)\n    }\n    if (shouldUpgradeMax) {\n      upgrades.push(this.keet.abi.max)\n    }\n\n    for (const version of upgrades) {\n      // TODO: Logging this explicitly for now so that it's very visible when upgrades are sent\n      // Logging is disabled during testing\n      if (!this.keet.opts.testingABI) {\n        console.log(this.deviceId, `upgrading ${this.id} to ABI ${version} -- production: ${this.keet.abi.production}, max: ${this.keet.abi.max}, autoupgrade: ${this.keet.abi.autoupgrade}`)\n      }\n      await this.upgrade(version)\n    }\n  }\n\n  async _getABI (opts) {\n    const view = (opts && opts.view) || this.base.view\n    const node = await view.bee.get(InternalSchema.CodeVersionKey, InternalSchema.UpgraderEncoding)\n    return node ? node.value : 0\n  }\n\n  async _getIsExperimental () {\n    const node = await this.base.view.bee.get(InternalSchema.ExperimentalModeKey, InternalSchema.UpgraderEncoding)\n    this.isExperimental = !!node\n    return this.isExperimental\n  }\n\n  _autobaseOpen (store, base, opts) {\n    return KeetIndexing.autobaseOpen(store, base, {\n      ...opts\n    })\n  }\n\n  async _autobaseApply (nodes, view, base) {\n    let maxABI = await this._getABI({ view })\n    for (const node of nodes) {\n      maxABI = Math.max(maxABI, node.value.abi)\n      for (const op of node.value.ops) {\n        if ((op.type !== InternalOperation.TYPE) || (op.value.subtype !== UpgradeOperation.SUBTYPE)) continue\n        maxABI = Math.max(maxABI, op.value.value.version)\n      }\n    }\n\n    // If the latest ABI in the database is unsupported  *or* a node references an unsupported ABI, throw\n    if (maxABI > this.keet.abi.max) {\n      return base.interrupt({ unsupportedABI: maxABI })\n    }\n\n    await KeetIndexing.autobaseApply(nodes, view, base)\n  }\n\n  async _observeIdentity () {\n    for await (const _ of this._identitySubscription) { /* eslint-disable-line */\n      await this._debouncedOnIdentityChanged()\n    }\n  }\n\n  async _onABIChanged () {\n    try {\n      if (this.closing) return\n\n      await this.base.update()\n      if (this.closing) return\n\n      const [currentABI, isExperimental] = await Promise.all([\n        this._getABI(),\n        this._getIsExperimental()\n      ])\n      if (this.closing) return\n\n      // Open mailbox only when version conditions are met\n      if (currentABI >= MIN_ABIS[FEATURES.DMS]) {\n        await this._maybeOpenMailbox()\n      }\n\n      await this._debouncedMaybeUpgradeRoom()\n      if (this.closing) return\n\n      for (const sub of this._abiSubscriptions) {\n        const version = currentABI\n        sub.push({ version, experimental: isExperimental, latest: version === this.keet.abi.max })\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _onConfigChanged () {\n    try {\n      if (this.closing || !this._configWatcher) return\n\n      await this.base.update()\n      if (this.closing || !this._selfDeviceWatcher) return\n\n      // run room mirrors if any\n      const mirrors = await this.config.getV2(CONFIG.ROOM_MIRRORS) || []\n      for (const { key } of mirrors) {\n        const mirror = this.keet.internalCreateMirror(key)\n        // when the base migrates, re-add to mirror\n        if (this.base.system) this.base.system.core.on('migrate', () => this._addToMirror(mirror))\n        this._addToMirror(mirror)\n      }\n\n      const title = await this.config.get(CONFIG.ROOM_TITLE)\n      if (title) {\n        await this.base.setUserData(ROOM_TITLE_USERDATA_KEY, b4a.from(title))\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async isPrivateProfile () {\n    const privateProfile = this.keet.identity.privateProfile\n    if (privateProfile && b4a.equals(this.key, privateProfile.key)) return true\n\n    return KeetIdentity.isPrivateProfile(this)\n  }\n\n  async _onIdentityChanged () {\n    await this.base.update()\n\n    if (!this.base.writable) return\n\n    // If this is the private profile, do not update profile or create a shared invite\n    const isPrivateProfile = await this.isPrivateProfile()\n    if (isPrivateProfile || this.neverUpdateMember) return\n\n    // Ensure that your member record in the room is up-to-date and your device is linked\n    // Also ensure that the shared attested invitation has been created\n    await Promise.all([\n      this._maybeUpdateMember(),\n      this._maybeCreateSharedInvite(),\n      this._maybeOpenMailbox()\n    ])\n  }\n\n  async _maybeUpdateIndexingStatus (device) {\n    const tx = await this.keet.local.writeTransaction()\n    if (this.closing) {\n      await tx.close()\n      return\n    }\n\n    const record = await tx.getRoom(this.key)\n    if (this.closing || !record) {\n      await tx.close()\n      return\n    }\n    const isIndexer = (device.capabilities & MemberCapabilities.CAN_INDEX) !== 0\n\n    if (isIndexer && !record.indexing) {\n      await tx.updateRoom(this.key, { indexing: true })\n    } else if (!isIndexer && record.indexing) {\n      await tx.updateRoom(this.key, { indexing: false })\n    }\n    if (this.closing) {\n      await tx.close()\n    } else {\n      await tx.commit()\n    }\n  }\n\n  async _maybeCreateSharedInvite () {\n    if (this.keet.identity.anonymous) return\n\n    const seed = KeetIdentity.computeInviteSeed(this.keet.identity.sharedInviteSeed, this.key)\n    const { id } = BlindPairing.createInvite(this.key, {\n      seed,\n      expires: 0\n    })\n\n    const invitation = await this.invitations.getInvitation(id)\n    if (invitation) return\n\n    await this.invitations.createInvitation({\n      attestsTo: this.memberKey,\n      reusable: true,\n      expiration: 0,\n      seed\n    })\n  }\n\n  async _maybeOpenMailbox () {\n    if (this.keet.identity.anonymous || !this.keet.identity.memberBlindingKeyPair) return\n\n    const box = await this.mailbox.getOpenMailbox(this.memberKey)\n    if (box) return\n\n    await this.mailbox.open(this.keet.identity.memberBlindingKeyPair.publicKey)\n  }\n\n  async _maybeUpdateMember () {\n    if (this.closing) return\n    if (this._incognito) {\n      await this.members.updateProfile(this._incognito)\n      return\n    }\n\n    const profile = await this.keet.identity.getProfile(this.deviceKey)\n    if (!profile) return\n\n    await this.members.updateMember(profile)\n\n    const member = await this.members.getMember(this.memberKey)\n    if (!member) return\n\n    for (const deviceKey of member.devices) {\n      const core = this.keet.store.get({ key: deviceKey, active: false })\n      await core.setUserData(SELF_MEMBER_USERDATA_KEY, SELF_MEMBER_USERDATA_VALUE)\n      await core.close()\n    }\n\n    await this._createSelfMemberWatcher()\n    await this._createSelfMailboxWatcher()\n  }\n\n  async _onSelfMailboxChanged () {\n    try {\n      if (this.closing || !this._selfMailboxWatcher) return\n      await this.base.update()\n      if (this.closing || !this._selfMailboxWatcher) return\n\n      const privateProfile = this.keet.identity.privateProfile\n      if (!privateProfile) return\n\n      for await (const mail of this.mailbox.createReadStream()) {\n        await privateProfile.privateMailbox.addMailboxRecord({ ...mail, roomKey: this.key })\n        await this.mailbox.removeMailboxRecord(mail.id)\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _onSelfMemberChanged () {\n    try {\n      if (this.closing || !this._selfMemberWatcher) return\n      await this.base.update()\n      if (this.closing || !this._selfMemberWatcher) return\n\n      const member = await this.members.getMember(this.memberKey)\n      if (!member) return\n      this.me.member = member\n\n      while (this._memberJoinedPromises.length) {\n        const next = this._memberJoinedPromises.pop()\n        next.resolve()\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _onSelfDeviceChanged () {\n    try {\n      if (this.closing || !this._selfDeviceWatcher) return\n\n      await this.base.update()\n      if (this.closing || !this._selfDeviceWatcher) return\n\n      const myDevice = await this.devices.getDevice(this.base.local.key)\n      if (!myDevice) return\n\n      // If this is the private profile, do not update profile or create a shared invite\n      const isPrivateProfile = await this.isPrivateProfile()\n      if (!this.me.device && !isPrivateProfile && !this.neverUpdateMember) {\n        await this._debouncedOnIdentityChanged()\n        await this._maybeUpdateMember()\n      }\n\n      // Update dm list\n      if (!isPrivateProfile && await this.config.isDmRoom() && !this.keet.identity.anonymous) {\n        await this.keet.identity.privateProfile.privateMailbox._maybeUpdateDmList(this)\n      }\n\n      this.me.device = myDevice\n\n      // Ensure that the local set of indexing rooms is up-to-date\n      await this._maybeUpdateIndexingStatus(myDevice)\n      if (this.closing) return\n\n      while (this._joinedPromises.length) {\n        const next = this._joinedPromises.pop()\n        next.resolve()\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _pushNotify () {\n    try {\n      if (!this.push) return\n      if (!this.opened) await this.ready()\n\n      const count = await this.devices.mobileCount()\n      if (this.closing || (count === 0)) return\n      await this.push.send(this.base.local)\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  deviceJoined () {\n    if (this.me.device) return Promise.resolve(this.me.device)\n    const { promise, deferred } = createDeferredPromise()\n    this._joinedPromises.push(deferred)\n    return promise\n  }\n\n  memberJoined () {\n    if (this.me.member) return Promise.resolve(this.me.member)\n    const { promise, deferred } = createDeferredPromise()\n    this._memberJoinedPromises.push(deferred)\n    return promise\n  }\n\n  joined () {\n    const promises = []\n    if (!this.me.device) promises.push(this.deviceJoined())\n    if (!this.me.member) promises.push(this.memberJoined())\n    return Promise.all(promises)\n  }\n\n  async isFeatureSupported (feature) {\n    const abi = await this.getABI()\n    return isFeatureSupported(abi, feature)\n  }\n\n  async _send (op, sender) {\n    if (!this.base.writable) throw KeetError.AUTOBASE_IS_NOT_WRITEABLE()\n\n    const [abi, muted] = await Promise.all([\n      this._getABI(),\n      this.members.isMemberMuted(this.memberKey)\n    ])\n    if (muted) return\n\n    const ops = Array.isArray(op) ? op : [op]\n    this.keet.internalReportOpLog(ops)\n    const timestamp = op?.value?.timestamp || Date.now()\n\n    return this.base.append({\n      abi,\n      timestamp,\n      ops,\n      sender\n    })\n  }\n\n  async send (op, { sender } = {}) {\n    if (!this.opened) await this.ready()\n    return this._send(op, sender)\n  }\n\n  async sendAndNotify (msg) {\n    if (!this.opened) await this.ready()\n\n    await this.send(msg)\n    this.internalPushNotify()\n  }\n\n  async internalIsActive () {\n    const buf = await this.base.getUserData(AUTOBASE_STATUS_USERDATA_KEY)\n    return !buf || b4a.equals(buf, AUTOBASE_STATUS_ACTIVE)\n  }\n\n  internalMarkActive () {\n    return this.base.setUserData(AUTOBASE_STATUS_USERDATA_KEY, AUTOBASE_STATUS_ACTIVE)\n  }\n\n  internalMarkInactive () {\n    return this.base.setUserData(AUTOBASE_STATUS_USERDATA_KEY, AUTOBASE_STATUS_INACTIVE)\n  }\n\n  async getABI () {\n    if (!this.opened) await this.ready()\n    return this._getABI()\n  }\n\n  subscribeRoomVersion () {\n    const stream = new Readable({\n      eagerOpen: true,\n      open: cb => Promise.all([this._getABI(), this._getIsExperimental()]).then(([version, experimental]) => {\n        stream.push({ version, experimental, latest: version === this.keet.abi.max })\n        cb(null)\n      }, err => cb(err)),\n      destroy: cb => {\n        const idx = this._abiSubscriptions.indexOf(stream)\n        if (idx !== -1) this._abiSubscriptions.splice(idx, 1)\n        cb(null)\n      }\n    })\n    this._abiSubscriptions.push(stream)\n    return stream\n  }\n\n  async removeable (selfMember) {\n    for (const deviceKey of selfMember.devices) {\n      if (!this.base.removeable(deviceKey)) return false\n    }\n    return true\n  }\n\n  async leave () {\n    await this.ready()\n\n    const selfMember = await this.members.getMember(this.memberKey)\n    // If the selfMember is not present, we're not in the room\n    if (!selfMember) return\n\n    if (!(await this.removeable(selfMember))) throw KeetError.CANNOT_LEAVE_ROOM()\n\n    this.leaving = true\n    await this.devices.removeDevice({ key: this.deviceKey })\n\n    // If a rejoin occurs before this room is closed/reopened, this will re-send the UpdateMember op\n    this.me = { device: null, member: null }\n  }\n\n  async upgrade (target) {\n    const [current, isExperimental] = await Promise.all([\n      this._getABI(),\n      this._getIsExperimental()\n    ])\n    const max = isExperimental ? this.keet.abi.max : this.keet.abi.production\n\n    // Should not ever try to downgrade, or upgrade beyond the current allowable max\n    const version = Math.min(Math.max(target || 0, current), max)\n    if (version <= current) return\n\n    return this.send({\n      type: InternalOperation.TYPE,\n      value: {\n        subtype: UpgradeOperation.SUBTYPE,\n        value: {\n          version\n        }\n      }\n    })\n  }\n\n  async maybeUpgradeOnDemand (feature) {\n    const abi = await this.getABI()\n\n    if (isFeatureSupported(abi, feature)) return true\n    if (MIN_ABIS[feature] > this.keet.abi.production) return false\n\n    await this.upgrade(MIN_ABIS[feature])\n\n    return true\n  }\n\n  debugFlushIdentityUpdates () {\n    return this._debouncedOnIdentityChanged()\n  }\n}\n\nfunction createDeferredPromise () {\n  const deferred = { resolve: null, reject: null }\n  const promise = new Promise((resolve, reject) => {\n    deferred.resolve = resolve\n    deferred.reject = reject\n  })\n  return { promise, deferred }\n}\nconst BlindPairing = require('blind-pairing')\nconst { KeetError, MemberCapabilities } = require('@holepunchto/keet-core-api')\nconst { InvitationSchema } = require('@holepunchto/keet-core-schemas')\n\nconst {\n  AddInvitationOperationV2,\n  RemoveInvitationOperation\n} = InvitationSchema.Operations\n\nmodule.exports = class RoomInvitations {\n  constructor (room) {\n    this.room = room\n    this.collection = this.room.collections.invitations\n  }\n\n  // Query Methods\n\n  async getInvitation (id) {\n    if (!this.room.opened) await this.room.ready()\n\n    const node = await this.collection.get(id)\n    if (!node) return null\n\n    return node.value\n  }\n\n  // Mutation Methods\n\n  async createInvitation (opts = {}) {\n    if (!this.room.opened) await this.room.ready()\n    const capabilities = RoomInvitations.getCapabilitiesFromOptions(opts)\n    let {\n      sensitive = false,\n      includeId = false,\n      expiration = 0,\n      reusable = true,\n      attestsTo = null,\n      seed = null\n    } = opts\n\n    if (typeof expiration === 'string') {\n      if (expiration === '2h') expiration = Date.now() + 2 * 3600 * 1000\n      else if (expiration === '2d') expiration = Date.now() + 2 * 24 * 3600 * 1000\n      else if (expiration === '2w') expiration = Date.now() + 2 * 7 * 24 * 3600 * 1000\n      else throw KeetError.UNKNOWN_EXPIRATION(`Unknown expiration: ${expiration}`)\n    }\n\n    const testInvitation = this.room.keet.testing\n    const inviteOpts = seed ? { expires: expiration, seed, sensitive, testInvitation } : { expires: expiration, sensitive, testInvitation }\n    const systemKey = this.room.base.getSystemKey()\n\n    const { id, invite, publicKey, additional } = BlindPairing.createInvite(this.room.key, {\n      ...inviteOpts,\n      data: systemKey\n    })\n\n    // No need to append an oplog message if the invitation already exists (it can't be updated)\n    const existing = await this.collection.get(id)\n    if (existing) return\n\n    await this.room.send({\n      type: AddInvitationOperationV2.TYPE,\n      value: {\n        id,\n        publicKey,\n        capabilities,\n        expiration,\n        reusable,\n        attestsTo,\n        additional,\n        uses: 0\n      }\n    })\n\n    return includeId ? { id, invite } : invite\n  }\n\n  removeInvitation (id) {\n    return this.room.send({\n      type: RemoveInvitationOperation.TYPE,\n      value: {\n        id\n      }\n    })\n  }\n\n  static getCapabilitiesFromOptions ({\n    canModerate = false,\n    canIndex = false,\n    canShareFiles = true,\n    canReact = true,\n    canWrite = true\n  } = {}) {\n    let capabilities = 0\n\n    if (canModerate) capabilities |= MemberCapabilities.CAN_MODERATE\n    if (canIndex) capabilities |= MemberCapabilities.CAN_INDEX\n    if (canWrite) capabilities |= MemberCapabilities.CAN_WRITE\n    if (canShareFiles) capabilities |= MemberCapabilities.CAN_SHARE_FILES\n    if (canReact) capabilities |= MemberCapabilities.CAN_REACT\n\n    return capabilities\n  }\n\n  static getOptionsFromCapabilities (capabilities) {\n    return {\n      canModerate: (capabilities & MemberCapabilities.CAN_MODERATE) !== 0,\n      canIndex: (capabilities & MemberCapabilities.CAN_INDEX) !== 0,\n      canWrite: (capabilities & MemberCapabilities.CAN_WRITE) !== 0,\n      canShareFiles: (capabilities & MemberCapabilities.CAN_SHARE_FILES) !== 0,\n      canReact: (capabilities & MemberCapabilities.CAN_REACT) !== 0\n    }\n  }\n\n  static maskCapabilities (memberCapabilities, inviteCapabilities) {\n    return inviteCapabilities & memberCapabilities\n  }\n\n  static memberShouldPair (memberCapabilities, inviteCapabilities) {\n    return ((memberCapabilities | inviteCapabilities) & MemberCapabilities.ALL_CAPABILITIES) !== memberCapabilities\n  }\n}\nconst c = require('compact-encoding')\nconst HypercoreId = require('hypercore-id-encoding')\nconst { FEATURES, MAIL_TYPES } = require('@holepunchto/keet-core-api')\nconst { MailboxSchema } = require('@holepunchto/keet-core-schemas')\nconst { MailboxRecordData } = MailboxSchema.Messages\nconst { OpenMailboxOperation, AddMailboxRecordOperation, RemoveMailboxRecordOperation } = MailboxSchema.Operations\nconst KeetIdentity = require('../identity')\nconst { Transform, pipeline } = require('streamx')\nconst RoomChat = require('./chat')\nconst safetyCatch = require('safety-catch')\n\nmodule.exports = class RoomMailbox {\n  constructor (room) {\n    this.room = room\n    this.collection = this.room.collections.mailbox\n    this.openMailboxes = this.room.collections.openMailboxes\n    this.collectionV2 = this.room.collections.mailboxV2\n  }\n\n  _decryptRecord (record) {\n    const data = record?.value?.data\n    const decrypted = KeetIdentity.decryptMessage(data, this.room.keet.identity.memberBlindingKeyPair)\n    return c.decode(MailboxRecordData, decrypted)\n  }\n\n  // Query Methods\n\n  async list (opts = {}) {\n    const records = []\n    for await (const node of this.createReadStream(opts)) {\n      records.push(node)\n    }\n    return records\n  }\n\n  async length (receiverKey) {\n    if (!this.room.opened) await this.room.ready()\n    const maxNode = await this.collectionV2.peek({\n      gte: [receiverKey],\n      lte: [receiverKey],\n      reverse: true\n    })\n    return maxNode ? maxNode._id[1] + 1 : 0\n  }\n\n  createReadStream (opts = {}) {\n    const range = RoomChat.getRangeOptions({ ...opts, prefix: this.room.memberKey })\n    const stream = this.collectionV2.createReadStream(range)\n    return pipeline(stream, new Transform({\n      transform: (node, cb) => {\n        const { type, message, invitation, senderKey, timestamp } = this._decryptRecord(node)\n        cb(null, {\n          id: node.value.id,\n          seq: node._id[1],\n          type,\n          message,\n          invitation,\n          from: HypercoreId.encode(senderKey),\n          timestamp\n        })\n      }\n    }))\n  }\n\n  async getOpenMailbox (memberKey) {\n    if (!this.room.opened) await this.room.ready()\n\n    const node = await this.openMailboxes.get(memberKey)\n    if (!node) return null\n\n    return node.value\n  }\n\n  async getMailboxRecord (id) {\n    if (!this.room.opened) await this.room.ready()\n\n    const node = await this.collectionV2.get([id.key, id.seq])\n    if (!node) return null\n\n    return node.value\n  }\n\n  watch (opts) {\n    return this.collectionV2.watch({ gte: [this.room.memberKey], lte: [this.room.memberKey] }, opts)\n  }\n\n  // Mutations Methods\n\n  async open (blindingKey) {\n    if (!(await this.room.isFeatureSupported(FEATURES.DMS))) return\n\n    return this.room.send({\n      type: OpenMailboxOperation.TYPE,\n      value: { blindingKey }\n    })\n  }\n\n  async removeMailboxRecord (id) {\n    if (!(await this.room.isFeatureSupported(FEATURES.DMS))) return\n\n    return this.room.send({\n      type: RemoveMailboxRecordOperation.TYPE,\n      value: { id }\n    })\n  }\n\n  async addMailboxRecord ({ receiver, data }) {\n    if (!(await this.room.isFeatureSupported(FEATURES.DMS))) return\n\n    return this.room.send({\n      type: AddMailboxRecordOperation.TYPE,\n      value: {\n        receiver,\n        data\n      }\n    })\n  }\n\n  async sendMailTo (receiverKey, { type = MAIL_TYPES.DM_REQUEST, timestamp = Date.now(), message, invitation }) {\n    try {\n      const box = await this.getOpenMailbox(receiverKey)\n      if (!box || !box.blindingKey) return\n      const data = KeetIdentity.encryptMessage(c.encode(MailboxRecordData, {\n        type,\n        message,\n        invitation,\n        senderKey: this.room.memberKey,\n        timestamp\n      }), box.blindingKey)\n      await this.addMailboxRecord({ receiver: receiverKey, data })\n      return true\n    } catch (error) {\n      safetyCatch(error)\n    }\n  }\n}\nconst ParallelTransform = require('parallel-transformx')\nconst b4a = require('b4a')\nconst { pipeline } = require('streamx')\nconst { KeetError, MemberCapabilities } = require('@holepunchto/keet-core-api')\nconst { MemberSchema } = require('@holepunchto/keet-core-schemas')\nconst {\n  UpdateMemberOperationV1,\n  UpdateMemberOperationV2,\n  ChangeMemberRoleOperation,\n  MuteMemberOperation,\n  UnmuteMemberOperation,\n  RemoveMemberOperation\n} = MemberSchema.Operations\n\nconst MAX_DM_ROOM_MEMBERS = 2\nconst MAX_USERNAME_LENGTH = 64\nconst MAX_AVATAR_SIZE = 2 ** 15 // 32 kb\n\nconst MEMBER_COUNT_KEY = 0\n\nconst PROFILE_USERDATA_KEY = '@holepunchto/keet-core/profile-name'\nconst PROFILE_BLOCKED_KEY = '@holepunchto/keet-core/profile-blocked'\n\nmodule.exports = class RoomMembers {\n  constructor (room) {\n    this.room = room\n    this.local = room.keet.local\n    this.devices = this.room.devices\n\n    this.collection = this.room.collections.members\n    this.avatars = this.room.collections.avatars\n    this.pendingMembers = this.room.collections.pendingMembers\n    this.inactiveMembers = this.room.collections.inactiveMembers\n    this.mutedMembers = this.room.collections.mutedMembers\n\n    this.capabilitiesByDeviceKey = this.room.indexes.capabilitiesByDeviceKey\n    this.membersByDeviceKey = this.room.indexes.membersByDeviceKey\n    this.inactiveMembersByDeviceKey = this.room.indexes.inactiveMembersByDeviceKey\n    this.memberKeysByMemberName = this.room.indexes.memberKeysByMemberName\n    this.moderatorsByMemberKey = this.room.indexes.moderatorsByMemberKey\n    this.membersCount = this.room.indexes.membersCount\n  }\n\n  async _setDeviceUserData (deviceKey, name, blocked) {\n    const core = this.room.keet.store.get({ key: deviceKey, active: false })\n    await core.setUserData(PROFILE_USERDATA_KEY, name ? b4a.from(name) : null)\n    await core.setUserData(PROFILE_BLOCKED_KEY, blocked ? b4a.from([1]) : null)\n    await core.close()\n  }\n\n  // Query Methods\n\n  async me () {\n    if (!this.room.opened) await this.room.ready()\n\n    const node = await this.collection.get(this.room.memberKey)\n    if (!node) return null\n\n    return node.value\n  }\n\n  async count () {\n    if (!this.room.opened) await this.room.ready()\n\n    const node = await this.membersCount.get(MEMBER_COUNT_KEY)\n    return node ? node.value : 0\n  }\n\n  getInactiveMember (memberKey, opts) {\n    return this.getMember(memberKey, {\n      ...opts,\n      collection: this.inactiveMembers\n    })\n  }\n\n  getInactiveMemberForDeviceKey (deviceKey, opts) {\n    return this.getMemberForDeviceKey(deviceKey, {\n      ...opts,\n      index: this.inactiveMembersByDeviceKey\n    })\n  }\n\n  async getDmRecipient () {\n    if (!this.room.opened) await this.room.ready()\n    for await (const { value } of this.collection.createReadStream({ limit: MAX_DM_ROOM_MEMBERS })) {\n      if (!b4a.equals(value.key, this.room.memberKey)) return value\n    }\n    return null\n  }\n\n  async getMember (memberKey, opts = {}) {\n    const {\n      collection = this.collection,\n      includeAvatar = true\n    } = opts\n    if (!this.room.opened) await this.room.ready()\n\n    const [memberNode, avatarNode] = await Promise.all([\n      collection.get(memberKey),\n      includeAvatar ? this.avatars.get(memberKey) : Promise.resolve()\n    ])\n    if (!memberNode) return null\n\n    await this._ensureUserData(memberNode.value)\n\n    return includeAvatar ? { ...memberNode.value, avatar: avatarNode?.value } : memberNode.value\n  }\n\n  async getMemberForDeviceKey (deviceKey, opts = {}) {\n    const {\n      index = this.membersByDeviceKey,\n      includeAvatar = true\n    } = opts\n    if (!this.room.opened) await this.room.ready()\n\n    const memberNode = await index.get(deviceKey)\n    if (!memberNode) return null\n    const member = memberNode.value\n\n    let avatar = null\n    if (includeAvatar) {\n      const avatarNode = await this.avatars.get(member.key)\n      avatar = avatarNode ? avatarNode.value : null\n    }\n\n    return { ...member, avatar }\n  }\n\n  async isModerator (memberKey) {\n    if (!this.room.opened) await this.room.ready()\n\n    const node = await this.moderatorsByMemberKey.get(memberKey)\n    return !!node\n  }\n\n  async isDeviceModerator (deviceKey) {\n    if (!this.room.opened) await this.room.ready()\n\n    const node = await this.capabilitiesByDeviceKey.get(deviceKey)\n    return isModerator(node?.value)\n  }\n\n  async isBlocked (memberKey) {\n    const node = await this.local.blockedMembersByRoom.get([this.room.key, memberKey])\n    return !!node\n  }\n\n  async ensureUserData (memberKey) {\n    const memberNode = await this.room.members.collection.get(memberKey)\n    if (!memberNode) return\n\n    await this._ensureUserData(memberNode.value)\n  }\n\n  async _ensureUserData (member) {\n    const deviceKeys = member.devices\n    const displayName = member.displayName\n    const blocked = await this.isBlocked(member.key)\n\n    await Promise.allSettled(deviceKeys.map(deviceKey => this._setDeviceUserData(deviceKey, displayName, blocked)))\n  }\n\n  createMembersReadStream (opts) {\n    return pipeline(this.collection.createReadStream(opts), new ParallelTransform({\n      transform: async (node, cb) => {\n        try {\n          if (opts?.includeAvatar === false) {\n            cb(null, { ...node.value, avatar: null })\n          } else {\n            const avatar = node.value.hasAvatar ? await this.getAvatar(node.value.key) : null\n            cb(null, { ...node.value, avatar })\n          }\n        } catch (err) {\n          cb(err)\n        }\n      }\n    }))\n  }\n\n  createModeratorsReadStream (opts) {\n    return pipeline(this.moderatorsByMemberKey.createReadStream(opts), new ParallelTransform({\n      transform: async (node, cb) => {\n        try {\n          const member = await this.getMember(node.key)\n          cb(null, member)\n        } catch (err) {\n          cb(err)\n        }\n      }\n    }))\n  }\n\n  createReadStream (opts = {}) {\n    if (opts.gt) opts.gt = [opts.gt]\n    if (opts.gte) opts.gte = [opts.gte]\n    if (opts.lt) opts.lt = [opts.lt]\n    if (opts.lte) opts.lte = [opts.lte]\n\n    let count = 0\n    return pipeline(this.memberKeysByMemberName.createReadStream(opts), new ParallelTransform({\n      transform: ({ key }, cb) => {\n        this.getMember(key[1])\n          .then(member => {\n            if (opts.limit && ++count > opts.limit) {\n              cb(null, null)\n            } else {\n              cb(null, { ...member, key: key[1] })\n            }\n          }, err => cb(err))\n      }\n    }))\n  }\n\n  async listPendingMembers () {\n    if (!this.room.opened) await this.room.ready()\n\n    const members = []\n    for await (const member of this.pendingMembers.createReadStream()) {\n      members.push(member.value)\n    }\n\n    return members\n  }\n\n  async listMembers () {\n    if (!this.room.opened) await this.room.ready()\n\n    const members = []\n    for await (const member of this.collection.createReadStream()) {\n      members.push(member.value)\n    }\n    return members\n  }\n\n  async listInactiveMembers () {\n    if (!this.room.opened) await this.room.ready()\n\n    const members = []\n    for await (const member of this.inactiveMembers.createReadStream()) {\n      members.push(member.value)\n    }\n    return members\n  }\n\n  async listModerators () {\n    if (!this.room.opened) await this.room.ready()\n\n    const moderatorKeys = []\n    for await (const { key } of this.moderatorsByMemberKey.createReadStream()) {\n      moderatorKeys.push(key)\n    }\n\n    return Promise.all(moderatorKeys.map(k => this.getMember(k)))\n  }\n\n  async getAvatar (memberKey) {\n    const avatarNode = await this.avatars.get(memberKey)\n    return avatarNode ? avatarNode.value : null\n  }\n\n  async searchMembers (keyword, { limit = 50 } = {}) {\n    if (!this.room.opened) await this.room.ready()\n\n    keyword = keyword.toLowerCase()\n    const members = []\n    for await (const member of this.createReadStream({ gte: keyword, limit })) {\n      // We want only results which start with namesPrefix. Tricky to do\n      // directly with hyperbee, so we test on it here\n      if (member.displayName.toLowerCase().slice(0, keyword.length) !== keyword) break\n      members.push(member)\n    }\n\n    return members\n  }\n\n  watchDevice (deviceKey, opts) {\n    return this.membersByDeviceKey.watch({ gte: deviceKey, lte: deviceKey }, opts)\n  }\n\n  watchMember (memberKey, opts) {\n    return this.collection.watch({ gte: memberKey, lte: memberKey }, opts)\n  }\n\n  // Mutation Methods\n\n  async changeRole ({ memberKey, role } = {}) {\n    if (!(await this.isModerator(this.room.memberKey))) throw KeetError.MODERATORS_ONLY()\n\n    await this.room.send({\n      type: ChangeMemberRoleOperation.TYPE,\n      value: { memberKey, role }\n    })\n  }\n\n  async mute (memberKey) {\n    if (!(await this.isModerator(this.room.memberKey))) throw KeetError.MODERATORS_ONLY()\n    await this.room.send({\n      type: MuteMemberOperation.TYPE,\n      value: { memberKey }\n    })\n  }\n\n  async unmute (memberKey) {\n    if (!(await this.isModerator(this.room.memberKey))) throw KeetError.MODERATORS_ONLY()\n    await this.room.send({\n      type: UnmuteMemberOperation.TYPE,\n      value: { memberKey }\n    })\n  }\n\n  async isDeviceMuted (deviceKey) {\n    const [member, inactiveMember] = await Promise.all([\n      this.getMemberForDeviceKey(deviceKey),\n      this.getInactiveMemberForDeviceKey(deviceKey)\n    ])\n    if (!member && !inactiveMember) return false\n    return this.isMemberMuted(member?.key || inactiveMember?.key)\n  }\n\n  async isMemberMuted (memberKey) {\n    const memberNode = await this.mutedMembers.get(memberKey)\n    return !!memberNode\n  }\n\n  async updateMember ({ displayName, avatar, timestamp, identity } = {}) {\n    if (displayName?.length > MAX_USERNAME_LENGTH) throw KeetError.USERNAME_TOO_LONG()\n    if (avatar?.byteLength > MAX_AVATAR_SIZE) throw KeetError.AVATAR_TOO_LARGE()\n    const isMobile = this.room.keet.isMobile\n\n    if (!this.room.opened) await this.room.ready()\n\n    const [existingMember, existingDevice] = await Promise.all([\n      this.getMemberForDeviceKey(this.room.deviceKey),\n      this.room.devices.getDevice(this.room.deviceKey)\n    ])\n\n    if (existingMember) {\n      if (existingMember.avatar && !avatar) avatar = existingMember.avatar\n\n      const sameName = displayName === existingMember.displayName\n      const sameAvatar = compareAvatars(avatar, existingMember.avatar)\n      const sameIdentity = compareIdentities(identity, existingMember.key)\n      const sameMobile = !isMobile || (isMobile && existingDevice.isMobile)\n      if (sameName && sameAvatar && sameIdentity && sameMobile) return\n\n      // If the existing timestamp is greater than the one in the identity, do not proceed\n      if (timestamp && (existingMember.timestamp > timestamp)) return\n    }\n\n    const updated = {\n      displayName: displayName || existingMember?.displayName,\n      avatar: avatar || existingMember?.avatar,\n      identity: identity || existingMember?.identity,\n      isMobile\n    }\n    await this.room.send({\n      type: UpdateMemberOperationV2.TYPE,\n      value: updated\n    })\n  }\n\n  async removeMember (memberKey) {\n    if (!(await this.isModerator(this.room.memberKey))) throw KeetError.MODERATORS_ONLY()\n\n    await this.room.send({\n      type: RemoveMemberOperation.TYPE,\n      value: { memberKey }\n    })\n  }\n\n  linkMember (memberKey, proof) {\n    return this.updateMember({ identity: { memberKey, proof } })\n  }\n\n  debugUpdateMemberV1 ({ displayName, avatar, pushNotifications }) {\n    return this.room.send({\n      type: UpdateMemberOperationV1.TYPE,\n      value: {\n        displayName,\n        avatar,\n        pushNotifications\n      }\n    })\n  }\n}\n\nfunction isModerator (capabilities) {\n  return (capabilities & MemberCapabilities.CAN_MODERATE) !== 0\n}\n\nfunction compareAvatars (a1, a2) {\n  if (!a1 && !a2) return true\n  return a1 && a2 && b4a.equals(a1, a2)\n}\n\nfunction compareIdentities (identity, memberKey) {\n  if (!identity) return true\n  if (identity && !memberKey) return false\n  if (identity && memberKey && !b4a.equals(identity.memberKey, memberKey)) return false\n  return true\n}\nconst ReadyResource = require('ready-resource')\nconst SubEncoder = require('sub-encoder')\nconst safetyCatch = require('safety-catch')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst { Readable } = require('streamx')\n\nconst { InternalSchema, PluginSchema } = require('@holepunchto/keet-core-schemas')\nconst { InternalOperation, AddPluginOperation } = InternalSchema.Operations\nconst { PluginOperation } = PluginSchema.Operations\n\nconst PrivateProfilePlugin = require('../identity/plugin.js')\nconst { KeetError } = require('@holepunchto/keet-core-api')\n\nconst INTERNALS_PREFIX = b4a.from([0])\nconst PLUGINS_PREFIX = b4a.from([1])\n\nmodule.exports = class RoomPlugins extends ReadyResource {\n  constructor (room) {\n    super()\n    this.room = room\n    this.internal = room.base.view.internal\n    this.internalPlugins = room.base.view.plugins\n\n    this.kvStore = new KVStorePlugin(this, room)\n    this.wordCount = new WordCountPlugin(this, room)\n    this.privateProfile = new PrivateProfilePlugin(this.room)\n\n    this._plugins = [this.kvStore, this.wordCount, this.privateProfile]\n    this._enc = new SubEncoder(INTERNALS_PREFIX).sub(PLUGINS_PREFIX)\n\n    // Set in _open\n    this._pluginsWatcher = null\n\n    this.ready().catch(safetyCatch)\n  }\n\n  async _open () {\n    this._pluginsWatcher = this.internalPlugins.bee.watch(this._enc.encodeRange({}), {\n      updateOnce: true,\n      eager: true,\n      onchange: this._onPluginsChanged.bind(this)\n    })\n    await this._pluginsWatcher.ready()\n    await this._onPluginsChanged()\n  }\n\n  async _close () {\n    if (this._pluginsWatcher) {\n      await this._pluginsWatcher.close()\n    }\n  }\n\n  async _onPluginsChanged () {\n    try {\n      await this.internalPlugins.load()\n      for (const plugin of this._plugins) {\n        plugin.tryLoad()\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async internalGetPrefix (plugin) {\n    let record = this.internalPlugins.get(plugin.constructor.NAME)\n    if (!record) {\n      await this.internalPlugins.load()\n      record = this.internalPlugins.get(plugin.constructor.NAME)\n    }\n    return record ? record.prefix : null\n  }\n\n  // Writer Interface\n\n  internalSend (name, message, { encoded = false } = {}) {\n    return this.room.send({\n      type: PluginOperation.TYPE,\n      value: {\n        name,\n        encoded,\n        value: message\n      }\n    })\n  }\n\n  enable (name) {\n    return this.room.send({\n      type: InternalOperation.TYPE,\n      value: {\n        subtype: AddPluginOperation.SUBTYPE,\n        value: {\n          name\n        }\n      }\n    })\n  }\n\n  // Read Interface\n\n  list () {\n    return this.internal.listPlugins()\n  }\n}\n\n// TODO: These should eventually live in their respective modules when the interfaces are more well-defined\n\nclass KVStorePlugin {\n  static NAME = '@holepunchto/kv-store'\n\n  constructor (plugins, room) {\n    this.plugins = plugins\n    this.room = room\n    this.db = room.base.view.bee\n\n    // Lazily loaded inside the getters and only loaded once\n    this._encoding = null\n  }\n\n  tryLoad () {\n    // TODO: Implement?\n  }\n\n  // TODO: The _ensureLoaded style will need to be shared between plugins\n  async _ensureLoaded () {\n    if (!this.plugins.opened) await this.plugins.ready()\n    if (this._encoding) return\n\n    const prefix = await this.plugins.internalGetPrefix(this)\n    if (!prefix) throw KeetError.PLUGIN_NOT_ENABLED(`Plugin ${this.constructor.NAME} is not enabled for this room`)\n\n    this._encoding = {\n      keyEncoding: new SubEncoder(prefix, c.raw.string),\n      valueEncoding: c.raw.string\n    }\n  }\n\n  // Write Interface\n\n  _send (msg) {\n    return this.plugins.internalSend(this.constructor.NAME, msg, false)\n  }\n\n  async put (key, value) {\n    await this._ensureLoaded()\n\n    return this._send({ type: 'put', key, value })\n  }\n\n  async del (key) {\n    await this._ensureLoaded()\n\n    return this._send({ type: 'del', key })\n  }\n\n  // Read Interface\n\n  async get (key) {\n    await this._ensureLoaded()\n\n    return this.db.get(key, this._encoding)\n  }\n\n  // TODO: This read stream pattern will need to be used everywhere by plugins\n\n  createReadStream (opts = {}) {\n    const self = this\n    let inner = null\n\n    const outer = new Readable({\n      highWaterMark: 0,\n      async open (cb) {\n        try {\n          await self._ensureLoaded()\n          inner = self.db.createReadStream(opts, self._encoding)\n          observe(inner).catch(err => this.destroy(err))\n          cb(null)\n        } catch (err) {\n          cb(err)\n        }\n      },\n      destroy (cb) {\n        if (inner) inner.destroy(null)\n        cb(null)\n      }\n    })\n\n    return outer\n\n    async function observe (s) {\n      for await (const msg of s) {\n        outer.push(msg)\n      }\n      outer.push(null)\n    }\n  }\n}\n\nclass WordCountPlugin {\n  static NAME = '@holepunchto/word-count'\n\n  constructor (plugins, room) {\n    this.plugins = plugins\n    this.room = room\n    this.db = room.base.view.bee\n\n    // Lazily loaded inside the getters and only loaded once\n    this._encoding = null\n  }\n\n  tryLoad () {\n    // TODO: Implement?\n  }\n\n  // TODO: The _ensureLoaded style will need to be shared between plugins\n  async _ensureLoaded () {\n    if (!this.plugins.opened) await this.plugins.ready()\n    if (this._encoding) return\n\n    const prefix = await this.plugins.internalGetPrefix(this)\n    if (!prefix) throw KeetError.PLUGIN_NOT_ENABLED(`Plugin ${this.constructor.NAME} is not enabled for this room`)\n\n    this._encoding = {\n      keyEncoding: new SubEncoder(prefix, c.raw.string),\n      valueEncoding: c.uint\n    }\n  }\n\n  // Read Interface\n\n  async get (key) {\n    await this._ensureLoaded()\n\n    const node = await this.db.get(key, this._encoding)\n    return node ? node.value : 0\n  }\n}\nconst b4a = require('b4a')\nconst HypercoreId = require('hypercore-id-encoding')\nconst { FEATURES, DM_STATUSES } = require('@holepunchto/keet-core-api')\nconst { PrivateMailboxSchema } = require('@holepunchto/keet-core-schemas')\nconst {\n  AddPrivateMailboxRecordOperation,\n  UpdatePrivateMailboxRecordOperation\n} = PrivateMailboxSchema.Operations\n\nmodule.exports = class RoomPrivateMailbox {\n  constructor (room) {\n    this.room = room\n    this.collection = this.room.collections.privateMailbox\n    this.sentPrivateMailbox = this.room.collections.sentPrivateMailbox\n\n    this.privateMailByMessageId = this.room.indexes.privateMailByMessageId\n    this.dmByMember = this.room.indexes.dmByMember\n  }\n\n  async getDmByMemberId (memberId) {\n    const memberKey = HypercoreId.decode(memberId)\n    const node = await this.dmByMember.get(memberKey)\n    return node ? formatDm(node) : null\n  }\n\n  async dmList (opts = {}) {\n    const list = []\n    for await (const node of this.dmByMember.createReadStream({ ...opts })) {\n      list.push(formatDm(node))\n    }\n    return list\n  }\n\n  async list (opts = {}) {\n    const list = []\n    const collection = opts.sent ? this.sentPrivateMailbox : this.collection\n    for await (const { _id, value } of collection.createReadStream({ reverse: true, ...opts })) {\n      const [timestamp, roomKey, seq] = _id\n      const { id, type, status, seen, message, invitation, targetRoomKey, senderKey, receiverKey } = value\n      list.push({\n        id: { deviceId: HypercoreId.encode(id.key), seq: id.seq },\n        seq,\n        type,\n        seen,\n        status,\n        roomId: HypercoreId.encode(roomKey),\n        targetRoomId: targetRoomKey ? HypercoreId.encode(targetRoomKey) : targetRoomKey,\n        senderId: senderKey ? HypercoreId.encode(senderKey) : null,\n        receiverId: receiverKey ? HypercoreId.encode(receiverKey) : null,\n        invitation,\n        message,\n        timestamp\n      })\n    }\n    return list\n  }\n\n  async getReceivedMailboxRecord (id) {\n    const mail = await this.privateMailByMessageId.get([id.key, id.seq])\n    if (!mail) return null\n    const { timestamp, roomKey, seq } = mail.value\n    return await this.collection.get([timestamp, roomKey, seq])\n  }\n\n  async getSentMailboxRecord (id) {\n    const mail = await this.privateMailByMessageId.get([id.key, id.seq])\n    if (!mail) return null\n    const { timestamp, roomKey, seq } = mail.value\n    return await this.sentPrivateMailbox.get([timestamp, roomKey, seq])\n  }\n\n  async acceptDmRequest (id) {\n    await this.updateMailboxRecord(id, { status: DM_STATUSES.ACCEPTED })\n  }\n\n  async rejectDmRequest (id) {\n    await this.updateMailboxRecord(id, { status: DM_STATUSES.REJECTED })\n  }\n\n  async _maybeUpdateDmList (room) {\n    const recipient = await room.members.getDmRecipient()\n    if (!recipient) return\n    const dm = await this.dmByMember.get(recipient.key)\n    if (!dm || !dm.value) return\n    if (dm.value.roomKey) return\n    await this.updateMailboxRecord(dm.value.id, {\n      status: DM_STATUSES.ACCEPTED,\n      targetRoomKey: room.key\n    })\n  }\n\n  async addMailboxRecord (mail) {\n    const supported = await this.room.maybeUpgradeOnDemand(FEATURES.DMS)\n    if (!supported) return\n\n    return this.room.send({\n      type: AddPrivateMailboxRecordOperation.TYPE,\n      value: {\n        seq: 0, // This is unused, but must be included for compatibility\n        mailId: mail.id,\n        type: mail.type,\n        status: mail.status,\n        message: mail.message,\n        invitation: mail.invitation,\n        senderKey: mail.from ? HypercoreId.decode(mail.from) : null,\n        receiverKey: mail.receiverKey ? mail.receiverKey : null,\n        roomKey: mail.roomKey,\n        targetRoomKey: mail.targetRoomKey,\n        timestamp: mail.timestamp\n      }\n    })\n  }\n\n  async updateSentMailboxRecord (id, { status, targetRoomKey } = {}) {\n    const supported = await this.room.maybeUpgradeOnDemand(FEATURES.DMS)\n    if (!supported) return\n\n    const mail = await this.getSentMailboxRecord(id)\n    if (!mail) return\n\n    // compat, msgId is the correct id\n    const mailId = { timestamp: mail._id[0], roomKey: mail._id[1], seq: mail._id[2] }\n    return this.room.send({\n      type: UpdatePrivateMailboxRecordOperation.TYPE,\n      value: { id: mailId, msgId: id, status, targetRoomKey }\n    })\n  }\n\n  async updateMailboxRecord (id, { status, seen, targetRoomKey, cb } = {}) {\n    const supported = await this.room.maybeUpgradeOnDemand(FEATURES.DMS)\n    if (!supported) return\n\n    const mail = await this.getReceivedMailboxRecord(id)\n    if (!mail) return\n    if (!shouldUpdate(mail.value, { status, seen, targetRoomKey })) return\n    if (cb) cb()\n\n    // compat, msgId is the correct id\n    const mailId = {\n      timestamp: mail._id[0],\n      roomKey: mail._id[1],\n      seq: mail._id[2]\n    }\n\n    return this.room.send({\n      type: UpdatePrivateMailboxRecordOperation.TYPE,\n      value: {\n        id: mailId,\n        msgId: id,\n        status,\n        seen,\n        targetRoomKey\n      }\n    })\n  }\n}\n\nfunction shouldUpdate (current, newValues) {\n  const updated = {\n    status: typeof newValues.status === 'undefined' ? current.status : newValues.status,\n    seen: typeof newValues.seen === 'undefined' ? current.seen : newValues.seen,\n    targetRoomKey: typeof newValues.targetRoomKey === 'undefined' ? current.targetRoomKey : newValues.targetRoomKey\n  }\n\n  if (current.status && !updated.status) return true\n  if (!current.status && updated.status) return true\n  if (current.seen && !updated.seen) return true\n  if (!current.seen && updated.seen) return true\n  if (!current.targetRoomKey && updated.targetRoomKey) return true\n  if (current.targetRoomKey && !updated.targetRoomKey) return true\n  if (current.targetRoomKey && updated.targetRoomKey && !b4a.equals(current.targetRoomKey, updated.targetRoomKey)) return true\n\n  return false\n}\n\nfunction formatDm ({ key, value }) {\n  return {\n    id: {\n      deviceId: HypercoreId.encode(value.id.key),\n      seq: value.id.seq\n    },\n    recipient: HypercoreId.encode(key),\n    roomId: value.roomKey ? HypercoreId.encode(value.roomKey) : null,\n    status: value.status\n  }\n}\nconst { Readable } = require('streamx')\nconst { ReactionSchema } = require('@holepunchto/keet-core-schemas')\nconst {\n  AddReactionOperation,\n  RemoveReactionOperation\n} = ReactionSchema.Operations\n\nmodule.exports = class RoomReactions {\n  constructor (room) {\n    this.room = room\n\n    this.collection = this.room.collections.reactions\n    this.eventIdsByMessageId = this.room.indexes.eventIdsByMessageId\n    this.reactionDigests = this.room.indexes.reactionDigests\n    this.reactionsByMember = this.room.indexes.reactionsByMember\n  }\n\n  // Query Methods\n\n  async _getEventIdForMessageId (id) {\n    const eventIdNode = await this.eventIdsByMessageId.get([id.key, id.seq])\n    if (!eventIdNode) return null\n    return eventIdNode.value\n  }\n\n  async getMemberReactions (id, memberKey) {\n    const eventId = await this._getEventIdForMessageId(id)\n    if (eventId === null) return null\n\n    const reactionsNode = await this.reactionsByMember.get([...eventId, memberKey])\n    if (!reactionsNode) return null\n\n    return reactionsNode.value\n  }\n\n  async getReactions (id) {\n    const eventId = await this._getEventIdForMessageId(id)\n    if (eventId === null) return null\n\n    const digestNode = await this.reactionDigests.get(eventId)\n    if (!digestNode) return null\n\n    return digestNode.value\n  }\n\n  createMessageDigestStream (id, opts) {\n    const self = this\n    let watcher = null\n\n    const stream = new Readable({\n      open: async cb => {\n        let error = null\n        try {\n          const eventId = await this._getEventIdForMessageId(id)\n          watcher = this.reactionDigests.watch({ gte: eventId, lte: eventId }, opts)\n          observe(eventId)\n        } catch (err) {\n          error = err\n        } finally {\n          cb(error)\n        }\n      },\n      destroy: cb => watcher.close().then(cb, cb)\n    })\n    return stream\n\n    async function observe (eventId) {\n      try {\n        for await (const _ of watcher) { /* eslint-disable-line */\n          const node = await self.reactionDigests.get(eventId)\n          if (node) stream.push(node.value)\n          else stream.push({ total: 0, reactions: [] })\n        }\n      } catch (err) {\n        stream.destroy(err)\n      }\n    }\n  }\n\n  // Mutation Methods\n\n  addReaction (to, text) {\n    return this.room.send({\n      type: AddReactionOperation.TYPE,\n      value: {\n        to,\n        text\n      }\n    })\n  }\n\n  removeReaction (to, text) {\n    return this.room.send({\n      type: RemoveReactionOperation.TYPE,\n      value: {\n        to,\n        text\n      }\n    })\n  }\n}\n{\n  \"name\": \"@holepunchto/keet-core\",\n  \"version\": \"19.42.4\",\n  \"description\": \"Internal data structures and APIs powering Keet\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib/**/*.js\",\n    \"lib/*.js\"\n  ],\n  \"imports\": {\n    \"path\": {\n      \"bare\": \"bare-path\",\n      \"default\": \"path\"\n    },\n    \"fs\": {\n      \"bare\": \"bare-fs\",\n      \"default\": \"fs\"\n    },\n    \"fs/*\": {\n      \"bare\": \"bare-fs/*\",\n      \"default\": \"fs/*\"\n    }\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test/index.js --coverage\",\n    \"integration\": \"brittle test/integration.js\",\n    \"generate\": \"node scripts/generate-local-db.js\",\n    \"genapi\": \"node scripts/generate-apis.js > keet-mobile-core-backend.js\",\n    \"test:suspend\": \"node test/suspend.js\"\n  },\n  \"keywords\": [\n    \"autobase\",\n    \"holepunch\",\n    \"hyperchat\"\n  ],\n  \"author\": \"Holepunch\",\n  \"license\": \"UNLICENSED\",\n  \"dependencies\": {\n    \"@holepunchto/blind-mirror\": \"^4.2.0\",\n    \"@holepunchto/hyperindex\": \"^2.2.0\",\n    \"@holepunchto/keet-core-api\": \"^1.29.0\",\n    \"@holepunchto/keet-core-schemas\": \"^2.15.0\",\n    \"@holepunchto/keet-identity-key\": \"^3.0.0\",\n    \"@holepunchto/keet-indexing\": \"5.14.4\",\n    \"@holepunchto/keet-push\": \"^2.0.2\",\n    \"autobase\": \"^6.4.0\",\n    \"bare-fs\": \"^4.0.1\",\n    \"bare-path\": \"^3.0.0\",\n    \"blind-pairing\": \"^2.3.0\",\n    \"compact-encoding\": \"^2.11.0\",\n    \"corestore\": \"^6.7.0\",\n    \"debounceify\": \"^1.0.0\",\n    \"hyperbee\": \"2.20.7\",\n    \"hyperbee-diff-stream\": \"^1.0.3\",\n    \"hypercore-crypto\": \"^3.3.1\",\n    \"hypercore-id-encoding\": \"^1.0.2\",\n    \"hyperdrive\": \"^11.2.0\",\n    \"hyperswarm\": \"^4.4.0\",\n    \"index-encoder\": \"3.3.1\",\n    \"math-random-seed\": \"^2.0.0\",\n    \"mutexify\": \"^1.4.0\",\n    \"parallel-transformx\": \"^1.0.4\",\n    \"promaphore\": \"^1.0.0\",\n    \"ready-resource\": \"^1.0.0\",\n    \"safety-catch\": \"^1.0.2\",\n    \"serve-drive\": \"^5.2.0\",\n    \"streamx\": \"^2.13.2\",\n    \"sub-encoder\": \"^2.1.0\",\n    \"tiny-buffer-map\": \"^1.1.1\",\n    \"xor-distance\": \"^2.0.0\",\n    \"z32\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"@hyperswarm/testnet\": \"^3.1.1\",\n    \"autobase-test-helpers\": \"^2.0.1\",\n    \"axios\": \"^1.3.4\",\n    \"brittle\": \"^3.2.1\",\n    \"random-access-memory\": \"^6.1.0\",\n    \"standard\": \"^17.0.0\",\n    \"test-tmp\": \"^1.3.0\"\n  },\n  \"standard\": {\n    \"ignore\": [\n      \"bin.js\"\n    ]\n  }\n}\nmodule.exports = {\n  DEFAULT_BLIND_MEDIA_MIRROR_KEYS: [\n    'f9tozzw13oci593nswgc4jfmirabf6bko9srjpg5x3ux514is4iy',\n    '9knmjkw7g7y9i6ic38frsyoq6gmnckzg4wata1xpequxsmpwzezo',\n    '3u5fjdwu5d7cbtsbtypwjeiub6nc4pgpbmja41shjgdok7gp5xhy',\n    'p4dwzx8tky4ywoct7aoz5e54q6im79kywuermmooixr6zar5mwmo',\n    'g44fg85pri3spy7mws14drdp1sej8bp4mdzdxzpcrojgtsf1ym6y'\n  ],\n  DEFAULT_BLIND_MIRROR_KEYS: [\n    '1akd34po4c9aard3c89zsqasdgqgh7eackp9at8qzuixniobyhxo',\n    'ht1wysugucqex3ysjzby5m9aeh7thmymy78a637ap7pqzsd5ehbo',\n    'decsttfrj1mebehwnfk4gngu1ys93b6u9f1myz7nbgrpcaorr4uy',\n    'qgg95z1byy5np5wcer4g6dmiczp1bxb6k683rt3jjo8ncnc84sxo',\n    '71io9qo8t7ss4cmt6x944dh35efptk44yxfchx8ikjkt9jggzjfo',\n    'qot6ebm5aqzjt76qncj95jritftmjcpxeqewhwij7kegoymibjyo',\n    'sqxkenaepsyx14thx39oeoem4p4zt5qfbfazdzftxt3q75yk1a3o'\n  ],\n  DEV_BLIND_MIRROR_KEYS: [\n    'f8fsz5ww51jp1zbxt41rk47tbgncitcsuiqjxxi5hjxrfix5p3ry', // hp-dev-lin-0\n    'uehh3kr7tzq7ckzfjtn3k68kzs6ks3ptp5r17acjatxpzzzr4ajy', // hp-dev-eu\n    'dfzfz8bk5xizxzhkqinxegajjoerm8k64fdj559onjiahp5a7dqy', // hp-dev-us\n    'w119cy3dmy8aephky8orwk8s56qdxb977mfia18nugeieopgj3zo' // hp-dev-asia\n  ],\n  DEFAULT_BLIND_RELAY_KEYS: [\n    'eszrfraa6fddr5q7sjasow3cxti1d1sx5ifr8ij3hbi7kgf8tr7y',\n    'r5i1j1m6kxhw4qjeek3hbc9751ho8ere8mns18u8hur7g4xxrc3y',\n    'mt8qfwywy3amec6y9bnxhqbgjobnoospup5mmww8c64grwa7943y',\n    'taig1guqbc8ph3i7ei41symfkf8571rreho6syhxzunbfmaqs4eo',\n    'q16atydb6oczes6onr58qr8yzkcqbsakf6a1iapndqtpnxmiwcgy',\n    'dz94965h9arysfpq9m19wggns6sw86sctnbmmiow9in1cm3u78ro',\n    '6rkwz3shauha6qfmjs96qwkfxrd5nupc8t5pd5mfjkufa4ecffwy'\n  ],\n  DEV_BLIND_RELAY_KEYS: [\n    'w4erqpput9mppn9f6icosf84sg6g49cb77u1835pg783me3zizuy', // hp-dev-lin-0\n    'bj4983iyj4s551ohocx57k5kc3dbz8j49f8atej3cuf494sr31ay', // hp-dev-eu\n    'pj7phfxhhth83a6tgrfb6tcydkijdx8hj3ybfu5k5eb54g63uqno', // hp-dev-us\n    '5ftp9em9kpxhhw37tmun9jb94i6rfu7771jwjxhfji4uz1xoerxo' // hp-dev-asia\n  ],\n  DEFAULT_GATEKEEPERS: [\n    '39720256e9d51be850afe8596c2aca8c4ad1e2d539a16c1470652791b7be2d10'\n  ]\n}\n{\n  \"name\": \"@holepunchto/keet-default-config\",\n  \"version\": \"1.4.1\",\n  \"description\": \"Default config values for launching a Keep app\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/keet-default-config.git\"\n  },\n  \"author\": \"H. Degroote\",\n  \"license\": \"UNLICENSED\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/keet-default-config/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/keet-default-config#readme\",\n  \"devDependencies\": {\n    \"standard\": \"^17.1.0\"\n  }\n}\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\n\nconst KeyChain = require('./lib/keychain')\nconst { sign, verify, hash } = require('./lib/crypto')\n\nconst {\n  ProofEncoding,\n  AttestedData,\n  AttestedDevice,\n  ReceiptEncoding\n} = require('./lib/encoding')\n\nconst PROOF_VERSION = 1\nconst KEET_TYPE = 5338\n\nconst NS_PROFILE_DISC_ENC = hash(b4a.from('profile discovery'))\n\nmodule.exports = class IdentityKey {\n  constructor (keyChain) {\n    this.keyChain = keyChain\n\n    this.identityKeyPair = this.keyChain.get(identityKeyPath(0))\n    this.profileDiscoveryKeyPair = this.keyChain.get(discoveryCorePath(0))\n  }\n\n  static generateMnemonic () {\n    return KeyChain.generateMnemonic()\n  }\n\n  static deriveSeed (mnemonic) {\n    return KeyChain.deriveSeed(mnemonic)\n  }\n\n  get identityPublicKey () {\n    return this.identityKeyPair.publicKey\n  }\n\n  get profileDiscoveryPublicKey () {\n    return this.profileDiscoveryKeyPair.publicKey\n  }\n\n  getProfileDiscoveryEncryptionKey () {\n    return this.keyChain.getSymmetricKey(encryptionKeyPath(NS_PROFILE_DISC_ENC))\n  }\n\n  getEncryptionKey (profileKey) {\n    return this.keyChain.getSymmetricKey(encryptionKeyPath(profileKey))\n  }\n\n  bootstrap (device) {\n    return IdentityKey.bootstrap({ identity: this.identityKeyPair }, device)\n  }\n\n  clear () {\n    this.keyChain.clear()\n    this.identityKeyPair.secretKey.fill(0)\n    this.profileDiscoveryKeyPair.secretKey.fill(0)\n  }\n\n  static async bootstrap ({ identity, seed, mnemonic }, device) {\n    if (!identity) {\n      const identityPath = identityKeyPath(0) // accountIndex unused for now\n      identity = await KeyChain.from({ seed, mnemonic }, identityPath)\n    }\n\n    const proof = {\n      version: PROOF_VERSION,\n      epoch: Date.now(),\n      identity: identity.publicKey,\n      chain: []\n    }\n\n    return IdentityKey.attestDevice(device, identity, proof)\n  }\n\n  static attestDevice (publicKey, parent, proof) {\n    if (!proof) return IdentityKey.bootstrap({ identity: parent }, publicKey)\n\n    if (b4a.isBuffer(proof)) {\n      proof = c.decode(ProofEncoding, proof)\n    }\n\n    if (proof.version === 0) {\n      throw new Error('Version 0 proofs are not supported')\n    }\n\n    const signable = c.encode(AttestedDevice, {\n      epoch: proof.epoch,\n      identity: proof.identity,\n      device: publicKey\n    })\n\n    const signature = sign(signable, parent)\n\n    proof.chain.push({ publicKey, signature })\n\n    return c.encode(ProofEncoding, proof)\n  }\n\n  static attestData (attestedData, keyPair, proof) {\n    if (attestedData === null) throw new Error('Data is not attestable')\n\n    if (b4a.isBuffer(proof)) {\n      proof = c.decode(ProofEncoding, proof)\n    }\n\n    if (proof && proof.version === 0) {\n      throw new Error('Version 0 proofs are not supported')\n    }\n\n    if (!proof) {\n      proof = {\n        version: PROOF_VERSION,\n        epoch: Date.now(),\n        identity: keyPair.publicKey,\n        chain: []\n      }\n    }\n\n    const signable = c.encode(AttestedData, {\n      epoch: proof.epoch,\n      identity: proof.identity,\n      data: hash(attestedData)\n    })\n\n    proof.data = { signature: sign(signable, keyPair) }\n\n    return c.encode(ProofEncoding, proof)\n  }\n\n  static async from ({ seed, mnemonic }) {\n    const keyChain = await KeyChain.from({ seed, mnemonic })\n\n    return new IdentityKey(keyChain)\n  }\n\n  static verify (proof, attestedData, opts = {}) {\n    if (b4a.isBuffer(proof)) {\n      proof = c.decode(ProofEncoding, proof)\n    }\n\n    if (!validateProof(proof, attestedData, opts)) {\n      return null\n    }\n\n    const { epoch, identity, chain } = proof\n\n    const candidate = getLastKey(chain) || identity\n\n    if (opts.expectedDevice) {\n      if (!b4a.equals(candidate, opts.expectedDevice)) return null\n    }\n\n    let parent = identity\n\n    // verify chain\n    for (let i = 0; i < chain.length; i++) {\n      const { publicKey, signature } = chain[i]\n\n      const signable = c.encode(AttestedDevice, {\n        epoch,\n        identity,\n        device: publicKey\n      })\n\n      if (!verify(signable, signature, parent)) {\n        return null\n      }\n\n      parent = publicKey\n    }\n\n    if (proof.data) {\n      const signable = c.encode(AttestedData, {\n        epoch,\n        identity,\n        data: hash(attestedData)\n      })\n\n      if (!verify(signable, proof.data.signature, parent)) {\n        return null\n      }\n    }\n\n    const receipt = c.encode(ReceiptEncoding, { epoch })\n\n    return {\n      receipt,\n      identityPublicKey: identity,\n      devicePublicKey: candidate\n    }\n  }\n}\n\nfunction validateProof (proof, attestedData, opts = {}) {\n  // version 0 is ignored\n  if (proof.version === 0) return false\n\n  // validate version\n  if (proof.version > PROOF_VERSION) return false\n\n  // verify epoch\n  if (opts.receipt) {\n    const { epoch } = c.decode(ReceiptEncoding, opts.receipt)\n    if (proof.epoch < epoch) return false\n  }\n\n  // verify identity\n  if (opts.expectedIdentity) {\n    if (!b4a.equals(proof.identity, opts.expectedIdentity)) return false\n  }\n\n  return validateAttestedData(proof.data, attestedData)\n}\n\nfunction validateAttestedData (data, attestedData) {\n  if (!data && attestedData) return false\n  return true\n}\n\nfunction getLastKey (chain) {\n  if (!chain.length) return null\n\n  const last = chain[chain.length - 1]\n  return last.publicKey\n}\n\n// slip48 derivations:\n// https://github.com/satoshilabs/slips/blob/master/slip-0048.md\n\nfunction keyPath (accountIndex, index) {\n  // https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki\n  const purpose = 48 // SLIP-48 wallet\n  const role = 0 // owner\n\n  return [purpose, KEET_TYPE, role, accountIndex, index]\n}\n\n// identityKey -> m/48'/keet'/0'/0'\n\nfunction identityKeyPath (accountIndex) {\n  return keyPath(accountIndex, 0)\n}\n\n// identityKey -> m/48'/keet'/0'/1'\n\nfunction discoveryCorePath (accountIndex) {\n  return keyPath(accountIndex, 1)\n}\n\n// slip21 derivations\n// https://github.com/satoshilabs/slips/blob/master/slip-0021.md\n\nfunction symmetricPath (...path) {\n  const purpose = 'SLIP-0021' // SLIP-21 wallet\n  const namespace = 'keet-identity-key' // keet\n\n  return [purpose, namespace, ...path]\n}\n\n// encryptionKey  -> m/SLIP-10/keet-identity-key/account/\"encryption key\"\n\nfunction encryptionKeyPath (profileKey) {\n  return symmetricPath(b4a.toString(profileKey, 'hex'), 'encryption key')\n}\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\n\nmodule.exports = {\n  sign,\n  verify,\n  hash: blake2b\n}\n\nfunction sign (signable, keyPair) {\n  const signature = b4a.alloc(sodium.crypto_sign_BYTES)\n  sodium.crypto_sign_detached(signature, signable, keyPair.secretKey)\n\n  return signature\n}\n\nfunction verify (signable, signature, publicKey) {\n  return sodium.crypto_sign_verify_detached(signature, signable, publicKey)\n}\n\nfunction blake2b (data, output = b4a.alloc(32)) {\n  sodium.crypto_generichash(output, data)\n  return output\n}\nconst c = require('compact-encoding')\n\nconst ATTESTED_DEVICE = 0\nconst ATTESTED_DATA = 1\n\nconst Epoch = {\n  preencode (state, e) {\n    c.uint64.preencode(state, Math.floor(e / 1000))\n  },\n  encode (state, e) {\n    c.uint64.encode(state, Math.floor(e / 1000))\n  },\n  decode (state) {\n    return c.uint64.decode(state) * 1000\n  }\n}\n\nconst AttestedDevice = {\n  preencode (state, a) {\n    c.uint8.preencode(state, ATTESTED_DEVICE)\n    Epoch.preencode(state, a.epoch)\n    c.fixed32.preencode(state, a.identity)\n    c.fixed32.preencode(state, a.device)\n  },\n  encode (state, a) {\n    c.uint8.encode(state, ATTESTED_DEVICE)\n    Epoch.encode(state, a.epoch)\n    c.fixed32.encode(state, a.identity)\n    c.fixed32.encode(state, a.device)\n  },\n  decode (state) {\n    throw new Error('Signed data should only be encoded')\n  }\n}\n\nconst AttestedData = {\n  preencode (state, a) {\n    c.uint8.preencode(state, ATTESTED_DATA)\n    Epoch.preencode(state, a.epoch)\n    c.fixed32.preencode(state, a.identity)\n    c.fixed32.preencode(state, a.data)\n  },\n  encode (state, a) {\n    c.uint8.encode(state, ATTESTED_DATA)\n    Epoch.encode(state, a.epoch)\n    c.fixed32.encode(state, a.identity)\n    c.fixed32.encode(state, a.data)\n  },\n  decode (state) {\n    throw new Error('Signed data should only be encoded')\n  }\n}\n\nconst DeviceAttestation = {\n  preencode (state, a) {\n    c.fixed32.preencode(state, a.publicKey)\n    c.fixed64.preencode(state, a.signature)\n  },\n  encode (state, a) {\n    c.fixed32.encode(state, a.publicKey)\n    c.fixed64.encode(state, a.signature)\n  },\n  decode (state) {\n    return {\n      publicKey: c.fixed32.decode(state),\n      signature: c.fixed64.decode(state)\n    }\n  }\n}\n\nconst DeviceAttestationArray = c.array(DeviceAttestation)\n\nconst DataAttestation = {\n  preencode (state, a) {\n    c.fixed64.preencode(state, a.signature)\n  },\n  encode (state, a) {\n    c.fixed64.encode(state, a.signature)\n  },\n  decode (state) {\n    return {\n      signature: c.fixed64.decode(state)\n    }\n  }\n}\n\nconst ProofEncoding = {\n  preencode (state, proof) {\n    c.uint.preencode(state, proof.version)\n    Epoch.preencode(state, proof.epoch)\n    c.fixed32.preencode(state, proof.identity)\n    DeviceAttestationArray.preencode(state, proof.chain)\n\n    let flags = 0\n    if (proof.data) flags |= 1\n    c.uint.preencode(state, flags)\n\n    if (proof.data) DataAttestation.preencode(state, proof.data)\n  },\n  encode (state, proof) {\n    c.uint.encode(state, proof.version)\n    Epoch.encode(state, proof.epoch)\n    c.fixed32.encode(state, proof.identity)\n    DeviceAttestationArray.encode(state, proof.chain)\n\n    let flags = 0\n    if (proof.data) flags |= 1\n    c.uint.encode(state, flags)\n\n    if (proof.data) DataAttestation.encode(state, proof.data)\n  },\n  decode (state) {\n    const version = c.uint.decode(state)\n\n    // ignore v0 proofs\n    if (version === 0) {\n      return {\n        version: 0,\n        epoch: 0,\n        identity: null,\n        chain: [],\n        data: null\n      }\n    }\n\n    const epoch = Epoch.decode(state)\n    const identity = c.fixed32.decode(state)\n    const chain = DeviceAttestationArray.decode(state)\n\n    const flags = c.uint.decode(state)\n    const data = flags & 1 ? DataAttestation.decode(state) : null\n\n    return {\n      version,\n      epoch,\n      identity,\n      chain,\n      data\n    }\n  }\n}\n\nconst ReceiptEncoding = {\n  preencode (state, receipt) {\n    Epoch.preencode(state, receipt.epoch)\n  },\n  encode (state, receipt) {\n    Epoch.encode(state, receipt.epoch)\n  },\n  decode (state) {\n    return {\n      epoch: Epoch.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  ATTESTED_DEVICE,\n  ATTESTED_DATA,\n  AttestedDevice,\n  AttestedData,\n  ProofEncoding,\n  ReceiptEncoding\n}\nconst sodium = require('sodium-universal')\nconst c = require('compact-encoding')\nconst assert = require('nanoassert')\nconst b4a = require('b4a')\nconst { HMAC } = require('@holepunchto/hmac')\nconst bip39 = require('@holepunchto/bip39')\n\nconst { sign } = require('./crypto')\n\nconst MASTER_CHAIN_CODE = b4a.from('ed25519 seed')\nconst MASTER_SYMMETRIC_CODE = b4a.from('Symmetric key seed')\n\nconst HARDENED_OFFSET = 0x80000000\n\nclass KeyChain {\n  constructor (seed) {\n    this.seed = seed\n\n    this._buffer = b4a.alloc(64)\n\n    this.chainKey = this._buffer.subarray(0, 32)\n    this.chainCode = this._buffer.subarray(32)\n\n    this.publicKey = b4a.alloc(sodium.crypto_sign_PUBLICKEYBYTES)\n    this.secretKey = b4a.alloc(sodium.crypto_sign_SECRETKEYBYTES)\n\n    this._initialise()\n  }\n\n  static generateMnemonic () {\n    return bip39.generateMnemonic()\n  }\n\n  static deriveSeed (mnemonic) {\n    return bip39.mnemonicToSeed(mnemonic)\n  }\n\n  static async from ({ mnemonic, seed }, path) {\n    assert(mnemonic || seed, 'No mnemonic or seed was passed.')\n\n    if (!seed) seed = await KeyChain.deriveSeed(mnemonic)\n\n    const key = new KeyChain(seed)\n\n    if (!path) return key\n\n    return key.get(path)\n  }\n\n  getSymmetricKey (path) {\n    const buffer = b4a.alloc(64)\n\n    const chainKey = buffer.subarray(0, 32)\n    const key = buffer.subarray(32)\n\n    HMAC.sha512(this.seed, MASTER_SYMMETRIC_CODE, buffer)\n\n    for (const step of path) {\n      const label = b4a.alloc(step.length + 1)\n      b4a.write(label, step, 1, 'utf8')\n\n      HMAC.sha512(label, chainKey, buffer)\n    }\n\n    return key\n  }\n\n  get isKeychain () {\n    return true\n  }\n\n  _initialise () {\n    HMAC.sha512(this.seed, MASTER_CHAIN_CODE, this._buffer)\n    sodium.crypto_sign_seed_keypair(this.publicKey, this.secretKey, this.chainKey)\n  }\n\n  clear () {\n    this.secretKey.fill(0)\n    this.chainKey.fill(0)\n    this.chainCode.fill(0)\n  }\n\n  get (path) {\n    return this.derive(path)\n  }\n\n  sign (signable) {\n    return sign(signable, this)\n  }\n\n  derive (path) {\n    const buffer = b4a.from(this._buffer)\n\n    const chainKey = buffer.subarray(0, 32)\n    const chainCode = buffer.subarray(32)\n\n    for (const step of path) {\n      const index = ensureHardened(step) // hardened indices are >= 2^31\n      HMAC.sha512(encodeDerivationData(chainKey, index), chainCode, buffer)\n    }\n\n    return createKeyPair(chainKey)\n  }\n}\n\nmodule.exports = KeyChain\n\nfunction createKeyPair (seed) {\n  if (!seed) throw new Error('No seed provided')\n\n  const publicKey = b4a.alloc(sodium.crypto_sign_PUBLICKEYBYTES)\n  const secretKey = b4a.alloc(sodium.crypto_sign_SECRETKEYBYTES)\n\n  sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)\n\n  return {\n    publicKey,\n    secretKey\n  }\n}\n\nfunction encodeDerivationData (key, step) {\n  const state = { buffer: b4a.alloc(37), start: 0, end: 37 }\n\n  c.uint8.encode(state, 0)\n  c.fixed32.encode(state, key)\n  state.buffer.writeUInt32BE(step, state.start)\n\n  state.buffer[33] |= 0x80\n\n  return state.buffer\n}\n\nfunction ensureHardened (n) {\n  if (n >= HARDENED_OFFSET) return n\n  return n + HARDENED_OFFSET\n}\n{\n  \"name\": \"@holepunchto/keet-identity-key\",\n  \"version\": \"3.0.0\",\n  \"description\": \"Hierarchical Deterministic Keys for Keet Identities\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"author\": \"\",\n  \"license\": \"Apache-2.0\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"hypercore-crypto\": \"^3.4.0\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"dependencies\": {\n    \"@holepunchto/bip39\": \"^2.1.1\",\n    \"@holepunchto/hmac\": \"^2.0.1\",\n    \"b4a\": \"^1.6.4\",\n    \"compact-encoding\": \"^2.13.0\",\n    \"nanoassert\": \"^2.0.0\",\n    \"sodium-universal\": \"^4.0.1\"\n  },\n  \"files\": [\n    \"lib/*\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/keet-identity-key.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/keet-identity-key/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/keet-identity-key#readme\"\n}\nconst Hyperbee = require('hyperbee')\nconst { SchemaBuilder } = require('@holepunchto/keet-core-schemas')\nconst { isFeatureSupported } = require('@holepunchto/keet-core-api')\n\nconst Internal = require('./lib/internal')\nconst Plugins = require('./lib/plugins')\nconst Chat = require('./lib/chat')\nconst Mailbox = require('./lib/mailbox')\nconst PrivateProfile = require('./lib/private-profile')\nconst Reactions = require('./lib/reactions')\nconst Invitations = require('./lib/invitations')\nconst Devices = require('./lib/devices')\nconst Members = require('./lib/members')\nconst Config = require('./lib/config')\n\nclass KeetView {\n  constructor (base, bee, { tx, primary } = {}) {\n    this.base = base\n    this.bee = bee\n    this.core = bee.core\n    this.isApplyView = !!primary\n\n    // Instantiated dynamically depending on the operation type\n    // The internal index has prefix 0\n    this.internal = new Internal(this)\n    // The plugins indexes have prefix 1\n    this.plugins = new Plugins(this)\n\n    const builder = new SchemaBuilder({ view: this, tx })\n    this.collections = builder.createCollections()\n\n    // The other indexes begin at prefix 2\n    this.indexes = builder.createIndexes()\n    this.dex = builder.dex\n\n    this.chat = new Chat(this)\n    this.mailbox = new Mailbox(this)\n    this.privateProfile = new PrivateProfile(this)\n    this.reactions = new Reactions(this)\n    this.devices = new Devices(this)\n    this.invitations = new Invitations(this)\n    this.members = new Members(this)\n    this.config = new Config(this)\n    this._initialize()\n\n    this._primaryView = primary\n    this._applyView = null\n  }\n\n  _initialize () {\n    this.internal.initialize()\n    this.plugins.initialize()\n    this.chat.initialize()\n    this.mailbox.initialize()\n    this.privateProfile.initialize()\n    this.reactions.initialize()\n    this.devices.initialize()\n    this.invitations.initialize()\n    this.members.initialize()\n    this.config.initialize()\n  }\n\n  _shouldSkipOperation (op) {\n    switch (op.type) {\n      // OpenMailboxOperationV1\n      case 24:\n        return true\n      // AddPrivateRoomOperation\n      case 34:\n        return true\n      // RemovePrivateRoomOperation\n      case 35:\n        return true\n      // AddDeviceKeyOperation\n      case 36:\n        return true\n      // AddDeviceAttestationOperation\n      case 37:\n        return true\n      default:\n        return false\n    }\n  }\n\n  async isFeatureSupported (feature) {\n    const abi = await this.internal.getCodeVersion()\n    return isFeatureSupported(abi, feature)\n  }\n\n  async isUnsupportedFeature (feature) {\n    return !(await this.isFeatureSupported(feature))\n  }\n\n  async applyOperation (op, opts) {\n    if (!this.isApplyView) throw new Error('Only the apply view should handle operations')\n\n    // !!! Skip over the unsupported op types, as they were not ABI-safe\n    if (this._shouldSkipOperation(op)) return\n\n    if (Internal.Operations.has(op.type)) {\n      await this.internal.autobaseApply(op, opts)\n    }\n    if (Devices.Operations.has(op.type)) {\n      await this.devices.autobaseApply(op, opts)\n    }\n    if (Invitations.Operations.has(op.type)) {\n      await this.invitations.autobaseApply(op, opts)\n    }\n    if (Members.Operations.has(op.type)) {\n      await this.members.autobaseApply(op, opts)\n    }\n    if (Config.Operations.has(op.type)) {\n      await this.config.autobaseApply(op, opts)\n    }\n    if (Chat.Operations.has(op.type)) {\n      await this.chat.autobaseApply(op, opts)\n    }\n    if (Mailbox.Operations.has(op.type)) {\n      await this.mailbox.autobaseApply(op, opts)\n    }\n    if (PrivateProfile.Operations.has(op.type)) {\n      await this.privateProfile.autobaseApply(op, opts)\n    }\n    if (Reactions.Operations.has(op.type)) {\n      await this.reactions.autobaseApply(op, opts)\n    }\n    if (Plugins.Operations.has(op.type)) {\n      await this.plugins.autobaseApply(op, opts)\n    }\n  }\n\n  async apply (nodes) {\n    if (this.isApplyView) throw new Error('An apply view cannot be created from an apply view')\n\n    const applyView = await this.createApplyView()\n\n    await applyView.plugins.load()\n\n    for (const node of nodes) {\n      const id = { key: node.from.key, seq: node.length - 1 }\n      const { timestamp, ops } = node.value\n      const opts = { id, timestamp }\n\n      for (const op of ops) {\n        await applyView.applyOperation(op, opts)\n      }\n    }\n\n    await applyView.commit()\n  }\n\n  async createApplyView () {\n    if (this._applyView) throw new Error('Can only have one apply view active at a time')\n    const tx = await this.dex.writeTransaction({ update: false })\n\n    this._applyView = new this.constructor(this.base, tx.bee, { tx, primary: this })\n\n    return this._applyView\n  }\n\n  async commit () {\n    if (!this.isApplyView) throw new Error('Can only commit an apply view')\n\n    await this.dex.commit()\n\n    this._primaryView._applyView = null\n  }\n\n  close () {\n    return this.bee.close()\n  }\n}\n\n// Autobase Handlers\n\n/*\n * Autobase Open Handler\n */\nfunction autobaseOpen (store, base) {\n  const core = store.get('keet')\n  const bee = new Hyperbee(core, {\n    alwaysDuplicate: false,\n    extension: false\n  })\n  return new KeetView(base, bee)\n}\n\n/*\n * Autobase Close Handler\n */\nfunction autobaseClose (view) {\n  return view.close()\n}\n\n/*\n * Autobase Apply Handler\n */\nfunction autobaseApply (nodes, view) {\n  return view.apply(nodes)\n}\n\nmodule.exports = {\n  KeetView,\n  autobaseApply,\n  autobaseOpen,\n  autobaseClose\n}\nconst b4a = require('b4a')\nconst { ChatSchema } = require('@holepunchto/keet-core-schemas')\nconst { FEATURES, GENERIC_EVENTS, DISPLAY_TYPES, isDisplaySupported } = require('@holepunchto/keet-core-api')\n\nconst {\n  PRIMARY_THREAD_ID\n} = ChatSchema.Messages\n\nconst {\n  AddChatMessageOperation,\n  AddFileOperation,\n  AddGenericEventOperation,\n  RemoveChatMessageOperation,\n  RemoveFileOperation,\n  RemoveGenericEventOperation,\n  UpdateChatMessageOperation\n} = ChatSchema.Operations\n\n/*\n\nprimary key: { threadId, threadSeq }\n\n// secondary index (eventIdsByMessageId)\n/eventIdsByMessageId/(key)/(seq) -> { threadId, threadSeq }\n\n// secondary index (eventIdsByClock)\n/eventIdsByClock/(clock) ->  { threadId, threadSeq }\n\n// primary index\n/primary/(threadId)/(threadSeq) -> (message)\n\n0: /primary/0/0 -> message\n1: /primary/0/1 -> message\n2: /primary/0/2 -> message\n3: /primary/1/0 -> message\n\n*/\n\nconst AllowedGenericEventOpTypes = new Set([\n  GENERIC_EVENTS.CALL_STARTED,\n  GENERIC_EVENTS.ROOM_AVATAR_CHANGED\n])\n\nmodule.exports = class Chat {\n  static Operations = new Set([\n    AddChatMessageOperation.TYPE,\n    UpdateChatMessageOperation.TYPE,\n    RemoveChatMessageOperation.TYPE,\n    AddGenericEventOperation.TYPE,\n    RemoveGenericEventOperation.TYPE,\n    AddFileOperation.TYPE,\n    RemoveFileOperation.TYPE\n  ])\n\n  constructor (view) {\n    this.view = view\n    this.members = null\n    this.config = null\n\n    this.chat = null\n\n    this.mentionsByMemberId = null\n    this.eventIdsByMemberId = null\n    this.eventIdsByMessageid = null\n    this.eventIdsByClock = null\n    this.drivesByPath = null\n  }\n\n  initialize () {\n    this.members = this.view.members\n    this.config = this.view.config\n\n    this.chat = this.view.collections.chat\n\n    this.mentionsByMemberId = this.view.indexes.mentionsByMemberId\n    this.eventIdsByMessageId = this.view.indexes.eventIdsByMessageId\n    this.eventIdsByClock = this.view.indexes.eventIdsByClock\n    this.drivesByPath = this.view.indexes.drivesByPath\n  }\n\n  async _ensureMemberCanChat ({ id }) {\n    const isBroadcastRoom = await this.config.isBroadcastRoom()\n    if (isBroadcastRoom) {\n      const isModerator = await this.members.isModerator(id.key)\n      if (!isModerator) return false\n    }\n    return true\n  }\n\n  _applyAddChatMessageOperation (op, { id, timestamp }) {\n    const { replyTo, parent, display, ...chatValue } = op.value\n    return this.addMessage({\n      // addMessage will set the clock\n      id,\n      timestamp,\n      clock: 0,\n      chat: chatValue,\n      parent,\n      display,\n      replyTo\n    })\n  }\n\n  _applyAddFileOperation (op, { id, timestamp }) {\n    const record = {\n      // addMessage will set the clock\n      id,\n      timestamp,\n      clock: 0,\n      parent: op.value.parent,\n      file: op.value.file,\n      chat: op.value.description ? { text: op.value.description } : null\n    }\n    return this.addMessage(record)\n  }\n\n  _applyAddGenericEventOperation (op, { id, timestamp }) {\n    if (!AllowedGenericEventOpTypes.has(op.value.type)) return\n    return this.addMessage({\n      // addMessage will set the clock\n      id,\n      timestamp,\n      clock: 0,\n      event: op.value\n    })\n  }\n\n  async _applyUpdateChatMessageOperation (op, { id }) {\n    if (isReply(op.value) && await this.view.isUnsupportedFeature(FEATURES.REPLY_TO)) return\n\n    const targetId = op.value.id\n    const eventId = await getValue(this.eventIdsByMessageId, [targetId.key, targetId.seq])\n    if (!eventId) return\n\n    const message = await getValue(this.chat, eventId)\n    if (!message) return\n\n    const [isModerator, sourceMember, targetMember] = await Promise.all([\n      this.members.isModerator(id.key),\n      this.members.getMemberForDeviceKey(id.key),\n      this.members.getMemberForDeviceKey(targetId.key)\n    ])\n    const sameMember = b4a.equals(sourceMember.key, targetMember.key)\n\n    if (sameMember || isModerator) {\n      const update = op.value\n      if (update.display) {\n        const abi = await this.view.internal.getCodeVersion()\n        update.display = update.display.filter(d => isDisplaySupported(abi, d.type))\n      }\n      await this.chat.update(eventId, {\n        ...message,\n        replyTo: update.replyTo,\n        display: update.display,\n        chat: {\n          text: update.text,\n          edited: true\n        }\n      })\n    }\n  }\n\n  async _applyRemovalOperation (op, { id }) {\n    const targetId = op.value.id\n    const eventId = await getValue(this.eventIdsByMessageId, [targetId.key, targetId.seq])\n    if (!eventId) return\n\n    const messageNode = await this.chat.get(eventId)\n    if (!messageNode) return\n    const message = messageNode.value\n\n    const [isModerator, sourceMember, targetActiveMember, targetInactiveMember] = await Promise.all([\n      this.members.isModerator(id.key),\n      this.members.getMemberForDeviceKey(id.key),\n      this.members.getMemberForDeviceKey(targetId.key),\n      this.members.getInactiveMemberForDeviceKey(targetId.key)\n    ])\n    const targetMember = targetActiveMember || targetInactiveMember\n    const sameMember = b4a.equals(sourceMember.key, targetMember.key)\n\n    if (sameMember || isModerator) {\n      // If the message is pinned, drop it from pins\n      await this.config.deletePinnedMessageIfExists(targetId)\n\n      await this.chat.update(eventId, {\n        ...message,\n        chat: null,\n        file: null,\n        event: null,\n        deleted: true\n      })\n    }\n  }\n\n  _applyRemoveChatMessageOperation (op, opts) {\n    return this._applyRemovalOperation(op, opts)\n  }\n\n  _applyRemoveFileOperation (op, opts) {\n    return this._applyRemovalOperation(op, opts)\n  }\n\n  _applyRemoveGenericEventOperation (op, opts) {\n    return this._applyRemovalOperation(op, opts)\n  }\n\n  async _indexClocks (prev, next, id) {\n    // Never remove clocks, and only add if this is the first time the message is indexed\n    if (next && !prev) {\n      await this.eventIdsByClock.insert(next.clock, id)\n      await this.eventIdsByMessageId.insert([next.id.key, next.id.seq], id)\n    }\n  }\n\n  async _indexMentions (prev, next, id) {\n    const prevMentions = prev?.display && getMentions(prev.display)\n    const nextMentions = next?.display && getMentions(next.display)\n\n    if (prevMentions) {\n      for (const { value } of prevMentions) {\n        await this.mentionsByMemberId.delete([value.memberId, ...id])\n      }\n    }\n    if (nextMentions) {\n      for (const { value } of nextMentions) {\n        await this.mentionsByMemberId.insert([value.memberId, ...id])\n      }\n    }\n  }\n\n  async _indexDrivesByPath (prev, next) {\n    if (prev && next && sameFile(prev.file, next.file)) {\n      if (prev?.file) {\n        await this.drivesByPath.delete([prev.file.path, prev.file.key, prev.file.version])\n      }\n    }\n    if (next?.file) {\n      await this.drivesByPath.insert([next.file.path, next.file.key, next.file.version])\n    }\n  }\n\n  // Internal API\n\n  async getThreadLength (threadId) {\n    const maxNode = await this.chat.peek({\n      gte: [threadId],\n      lte: [threadId],\n      reverse: true\n    })\n    return maxNode ? maxNode._id[1] + 1 : 0\n  }\n\n  async messageExists (messageId) {\n    const msg = await this.getMessageById(messageId)\n    return msg && msg?.value?.deleted !== true\n  }\n\n  async getMessageById (messageId) {\n    const eventId = await this.getEventId(messageId)\n    if (!eventId) return null\n    return await this.chat.get(eventId)\n  }\n\n  async getEventId (messageId) {\n    const node = await this.eventIdsByMessageId.get([messageId.key, messageId.seq])\n    return node ? node.value : null\n  }\n\n  async addMessage (msg) {\n    // Frontload all the reads in parallel for max perf\n    const [abi, replyToUnsupported, parent, lastClockNode, isMuted] = await Promise.all([\n      this.view.internal.getCodeVersion(),\n      this.view.isUnsupportedFeature(FEATURES.REPLY_TO),\n      msg.parent ? getValue(this.eventIdsByMessageId, msg.parent) : null,\n      this.eventIdsByClock.peek({ reverse: true }),\n      this.view.members.isDeviceMuted(msg.id.key)\n    ])\n    if ((isReply(msg) && replyToUnsupported) || isMuted) return\n\n    let threadId = PRIMARY_THREAD_ID\n    if (parent) {\n      threadId = parent.clock + 1\n    }\n    // We should really move this into the first load because we don't use threads currently\n    const threadLength = await this.getThreadLength(threadId)\n\n    msg.clock = lastClockNode ? lastClockNode.key + 1 : 0\n\n    if (msg.display) {\n      msg.display = msg.display.filter(d => isDisplaySupported(abi, d.type))\n    }\n\n    await this.chat.update([threadId, threadLength], msg, { upsert: true })\n  }\n\n  // Autobase API\n\n  async autobaseApply (op, opts) {\n    const allowed = await this._ensureMemberCanChat(opts)\n    if (!allowed) return\n\n    switch (op.type) {\n      case AddChatMessageOperation.TYPE:\n        return this._applyAddChatMessageOperation(op, opts)\n      case AddFileOperation.TYPE:\n        return this._applyAddFileOperation(op, opts)\n      case AddGenericEventOperation.TYPE:\n        return this._applyAddGenericEventOperation(op, opts)\n      case RemoveChatMessageOperation.TYPE:\n        return this._applyRemoveChatMessageOperation(op, opts)\n      case RemoveFileOperation.TYPE:\n        return this._applyRemoveFileOperation(op, opts)\n      case RemoveGenericEventOperation.TYPE:\n        return this._applyRemoveGenericEventOperation(op, opts)\n      case UpdateChatMessageOperation.TYPE:\n        return this._applyUpdateChatMessageOperation(op, opts)\n      default:\n    }\n  }\n\n  async autobaseIndex ({ prev, next, id }) {\n    await this._indexClocks(prev, next, id)\n    await this._indexMentions(prev, next, id)\n    await this._indexDrivesByPath(prev, next, id)\n  }\n}\n\n// Helpers\n\nfunction getMentions (display) {\n  return display.filter(d => d.type === DISPLAY_TYPES.MENTION)\n}\n\nfunction isReply (msg) {\n  return !!msg.replyTo\n}\n\nfunction sameFile (f1, f2) {\n  if (!f1 && !f2) return true\n  return f1 && f2 && b4a.equals(f1.key, f2.key) && (f1.path === f2.path) && (f1.version === f2.version)\n}\n\nasync function getValue (db, key) {\n  const node = await db.get(key)\n  return node ? node.value : null\n}\nconst { Transform, pipeline } = require('streamx')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\n\nconst { ConfigSchema } = require('@holepunchto/keet-core-schemas')\nconst {\n  UpdateConfigOperationV1,\n  UpdateConfigOperationV2\n} = ConfigSchema.Operations\nconst {\n  CONFIG,\n  VALIDATION,\n  FEATURES,\n  GENERIC_EVENTS,\n  isFeatureSupported\n} = require('@holepunchto/keet-core-api')\n\nmodule.exports = class Config {\n  static Operations = new Set([\n    UpdateConfigOperationV1.TYPE,\n    UpdateConfigOperationV2.TYPE\n  ])\n\n  constructor (view) {\n    this.view = view\n    this.chat = null\n    this.members = null\n    this.config = null\n    this.configV2 = null\n  }\n\n  initialize () {\n    this.chat = this.view.chat\n    this.members = this.view.members\n    this.chat = this.view.chat\n    this.config = this.view.collections.config\n    this.configV2 = this.view.bee\n  }\n\n  // Internal API\n\n  async get (key) {\n    const node = await this.configV2.get(key, ConfigSchema.Encoding)\n    return ConfigSchema.getValue(node)\n  }\n\n  async getAll (opts = {}) {\n    const configs = {}\n    for await (const { key, value } of this.createReadStream(opts)) {\n      configs[key] = value\n    }\n    return configs\n  }\n\n  async put (key, value) {\n    await this.configV2.put(key, value, ConfigSchema.Encoding)\n  }\n\n  createReadStream (opts = {}) {\n    const stream = this.configV2.createReadStream(opts, ConfigSchema.Encoding)\n    return pipeline(stream, new Transform({\n      transform (data, cb) {\n        cb(null, { key: data.key, value: ConfigSchema.getValue(data) })\n      }\n    }))\n  }\n\n  async getConfig () {\n    const node = await this.config.get(CONFIG.V1_CONFIG_KEY)\n\n    // for compat\n    const v1 = node ? node.value : {}\n    const v2 = await this.getAll()\n\n    return { ...v1, ...v2 }\n  }\n\n  async isBroadcastRoom () {\n    const config = await this.getConfig()\n    if (!config) return false\n    return config.roomType === '1'\n  }\n\n  async deletePinnedMessageIfExists (msgId) {\n    const pins = await this.get(CONFIG.PINNED_MESSAGES) || []\n    const idx = pins.findIndex(pin => b4a.equals(pin.key, msgId.key) && pin.seq === msgId.seq)\n    if (idx !== -1) {\n      pins.splice(idx, 1)\n      await this.put(CONFIG.PINNED_MESSAGES, ConfigSchema.encodeValue(CONFIG.PINNED_MESSAGES, pins))\n    }\n  }\n\n  // Validation\n\n  async _validate (key, v) {\n    const value = ConfigSchema.decodeValue(key, v)\n    switch (key) {\n      case CONFIG.PINNED_MESSAGES:\n        if (await this.view.isUnsupportedFeature(FEATURES.PINNED_MESSAGES)) return false\n        return (await Promise.all([\n          this._pinLimitNotExceeded(key, value),\n          this._pinnedMessageExists(key, value)\n        ])).every(res => res === true)\n      default:\n        return true\n    }\n  }\n\n  _pinLimitNotExceeded (key, value) {\n    return value.length <= VALIDATION.PINNED_MESSAGES_LIMIT\n  }\n\n  async _pinnedMessageExists (key, value) {\n    // Note: this validates only the latest added pin,\n    // assuming pins are added one-by-one.\n    const latestPin = value.length ? value[value.length - 1] : null\n    if (!latestPin) return true\n    return await this.chat.messageExists(latestPin)\n  }\n\n  async _maybeTrackChange ({ id, timestamp, from, to }) {\n    if (!(await this.view.isFeatureSupported(FEATURES.ROOM_RENAME_EVENT))) return\n    if (from === null || from === to) return\n\n    await this.chat.addMessage({\n      id,\n      timestamp,\n      event: {\n        type: GENERIC_EVENTS.ROOM_TITLE_CHANGED,\n        value: { from, to }\n      }\n    })\n  }\n\n  // Autobase API\n\n  async _applyUpdateConfigOperationV1 (op, { id }) {\n    const { key, value } = op.value\n\n    // The room config can only be updated by moderators.\n    const isModerator = await this.members.isModerator(id.key)\n    if (!isModerator) return\n\n    // If we've already migrated to V2 configs, and we get a legacy update message, insert into new db\n    const abi = await this.view.internal.getCodeVersion()\n    if (isFeatureSupported(abi, FEATURES.V2_CONFIG)) {\n      return this.put(key, c.encode(c.string, value))\n    }\n\n    const current = await this.getConfig()\n\n    if (value) {\n      current[key] = value\n    } else {\n      delete current[key]\n    }\n\n    await this.config.update(CONFIG.V1_CONFIG_KEY, current, { upsert: true })\n  }\n\n  async _applyUpdateConfigOperationV2 (op, opts) {\n    const { id } = opts\n    const { key, value } = op.value\n\n    // The room config can only be updated by moderators.\n    const isModerator = await this.members.isModerator(id.key)\n    if (!isModerator) return\n\n    const isValid = await this._validate(key, value)\n    if (!isValid) return\n\n    if (key === CONFIG.ROOM_TITLE) {\n      const from = await this.get(key)\n      const to = ConfigSchema.decodeValue(key, value)\n      await this._maybeTrackChange({ ...opts, from, to })\n    }\n\n    await this.put(key, value)\n  }\n\n  autobaseApply (op, opts) {\n    switch (op.type) {\n      case UpdateConfigOperationV1.TYPE:\n        return this._applyUpdateConfigOperationV1(op, opts)\n      case UpdateConfigOperationV2.TYPE:\n        return this._applyUpdateConfigOperationV2(op, opts)\n      default:\n    }\n  }\n\n  // Migrate from V1 -> V2\n  async migrate () {\n    const node = await this.config.get(CONFIG.V1_CONFIG_KEY)\n    if (!node || !node.value) return\n\n    for await (const key of Object.keys(node.value)) {\n      const value = node.value[key]\n      await this.put(key, c.encode(c.string, value))\n    }\n  }\n}\nconst IdentityKey = require('@holepunchto/keet-identity-key')\nconst { DeviceSchema, MemberSchema, InvitationSchema } = require('@holepunchto/keet-core-schemas')\nconst { MemberCapabilities } = require('@holepunchto/keet-core-api')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\n\nconst Invitations = require('../invitations')\nconst {\n  AddDeviceOperationV1,\n  AddDeviceOperationV2,\n  UpdateDeviceOperation,\n  RemoveDeviceOperationV1,\n  RemoveDeviceOperationV2\n} = DeviceSchema.Operations\nconst {\n  UpdateMemberOperationV1,\n  UpdateMemberOperationV2\n} = MemberSchema.Operations\nconst { InvitationUserData } = InvitationSchema.Messages\n\nconst DEVICE_COUNT_KEY = 0\nconst MOBILE_DEVICE_COUNT_KEY = 1\n\nmodule.exports = class Devices {\n  static Operations = new Set([\n    AddDeviceOperationV1.TYPE,\n    AddDeviceOperationV2.TYPE,\n    UpdateDeviceOperation.TYPE,\n    RemoveDeviceOperationV1.TYPE,\n    RemoveDeviceOperationV2.TYPE,\n    // Member OPs\n    UpdateMemberOperationV1.TYPE,\n    UpdateMemberOperationV2.TYPE\n  ])\n\n  constructor (view) {\n    this.view = view\n    this.members = null\n    this.invitations = null\n    this.attestations = null\n\n    this.devices = null\n    this.deviceCount = null\n    this.mobileDeviceCount = null\n    this.deviceKeysByNoisePublicKey = null\n  }\n\n  initialize () {\n    this.members = this.view.members\n    this.invitations = this.view.invitations\n    this.attestations = this.view.attestations\n\n    this.devices = this.view.collections.devices\n    this.deviceCount = this.view.indexes.deviceCount\n    this.mobileDeviceCount = this.view.indexes.mobileDeviceCount\n    this.deviceKeysByNoisePublicKey = this.view.indexes.deviceKeysByNoisePublicKey\n  }\n\n  _verifyInvitationReceipt (newDevice, invitation) {\n    const userData = Invitations.verifyReceipt(invitation, newDevice.receipt, {\n      checkExpiration: false\n    })\n    if (!userData) return null\n\n    // Confirm that the info in the new device record matches the receipt\n    const decodedUserData = c.decode(InvitationUserData, userData)\n    if (!b4a.equals(decodedUserData.deviceKey, newDevice.key)) return null\n    if (!b4a.equals(decodedUserData.noisePublicKey, newDevice.noisePublicKey)) return null\n\n    return decodedUserData\n  }\n\n  _verifyAttestation (invitation, deviceKey, attestation, latestReceipt) {\n    if (!attestation) return null\n\n    const verification = IdentityKey.verify(attestation, deviceKey, {\n      receipt: latestReceipt,\n      expectedIdentity: invitation.attestsTo\n    })\n\n    return verification ? verification.receipt : null\n  }\n\n  async _addDeviceFromInvitation (op) {\n    const newDevice = op.value\n    // The request is not valid unless it comes with an invitation ID and receipt.\n    if (!newDevice.receipt || !newDevice.invitation) return\n\n    const [device, invitation] = await Promise.all([\n      this.getDevice(newDevice.key),\n      this.invitations.getInvitation(newDevice.invitation)\n    ])\n    if (!invitation) return\n\n    let attestationReceipt = null\n    if (invitation.attestsTo) {\n      const member = await this.members.getMember(invitation.attestsTo)\n      attestationReceipt = member?.latestReceipt\n    }\n\n    // If this returns userData, then newDevice.key matches the key in the receipt\n    const userData = this._verifyInvitationReceipt(newDevice, invitation)\n    if (!userData) return\n\n    // The key/attestation must solely come from the receipt here\n    let attestedReceipt = null\n    if (invitation.attestsTo) {\n      attestedReceipt = this._verifyAttestation(invitation, userData.deviceKey, userData.attestation, attestationReceipt)\n      if (!attestedReceipt) return\n    }\n\n    let member = null\n    if (invitation.attestsTo) {\n      member = await this.members.getMember(invitation.attestsTo)\n    } else {\n      member = await this.members.getMemberForDeviceKey(userData.deviceKey, { full: true })\n    }\n\n    // If we got this far, the request can be accepted\n    // If the invitation has already been used once, ensure its indexing capability is stripped\n    // TODO: When we enable pairing feedback, we can remove this downgrading\n    if (invitation.uses >= 1) {\n      invitation.capabilities &= ~MemberCapabilities.CAN_INDEX\n      invitation.capabilities &= ~MemberCapabilities.CAN_MODERATE\n    }\n\n    // Strip the indexing capabilities from the list of capabilities that can be inherited\n    const inheritedCapabilities = (member?.capabilities || 0) & ~MemberCapabilities.CAN_INDEX\n    newDevice.capabilities = inheritedCapabilities | invitation.capabilities\n\n    await this.view.base.addWriter(newDevice.key, {\n      indexer: (newDevice.capabilities & MemberCapabilities.CAN_INDEX) !== 0\n    })\n    await this.devices.update(newDevice.key, newDevice, { upsert: true })\n\n    if (!device) {\n      const attestation = attestedReceipt ? { memberKey: invitation.attestsTo, receipt: attestationReceipt } : null\n      await this.members.addPendingMember({\n        ...newDevice,\n        attestation\n      })\n    } else {\n      await this.members.updateExistingMember(newDevice)\n    }\n\n    invitation.uses++\n    await this.invitations.updateInvitation(newDevice.invitation, invitation)\n  }\n\n  async _manuallyAddDevice (op, { id }) {\n    const newDevice = op.value\n\n    // A moderator (or the bootstrapper) can add anybody\n    const isModerator = await this.members.isModerator(id.key)\n    if (!isModerator) return\n\n    await this.view.base.addWriter(newDevice.key, {\n      indexer: (newDevice.capabilities & MemberCapabilities.CAN_INDEX) !== 0\n    })\n    await this.devices.update(newDevice.key, newDevice, { upsert: true })\n    await this.members.addPendingMember(newDevice)\n  }\n\n  _applyAddDeviceOperation (op, opts) {\n    if (op.value.invitation) {\n      return this._addDeviceFromInvitation(op, opts)\n    } else {\n      return this._manuallyAddDevice(op, opts)\n    }\n  }\n\n  async _applyUpdateDeviceOperation (op, { id }) {\n    const device = await this.getDevice(id.key)\n    if (!device) return\n\n    await this.devices.update(device.key, {\n      ...device,\n      name: op.value.name || device.name\n    })\n  }\n\n  async _applyUpdateMemberOperation (op, { id }) {\n    const device = await this.getDevice(id.key)\n    if (!device) return\n\n    const isMobile = op.value.pushNotifications || op.value.isMobile\n    // The isMobile flag can only be toggled on once (it is always true thereafter)\n    if (device.isMobile || !isMobile) return\n\n    await this.devices.update(device.key, {\n      ...device,\n      isMobile\n    }, { upsert: true })\n  }\n\n  async _applyRemoveDeviceOperationV1 () {\n    // Not implemented for safety (operation has been released/supported as a no-op)\n  }\n\n  async _applyRemoveDeviceOperationV2 (op, { id, timestamp }) {\n    // Currently only self-removal is supported\n    // Also cannot remove the device if it is the last indexer (removeable check)\n    if (!b4a.equals(op.value.key, id.key) || !this.view.base.removeable(id.key)) return\n\n    await this.members.removeMemberForDeviceKey(id, timestamp)\n    await this.devices.delete(id.key)\n\n    await this.view.base.removeWriter(id.key)\n  }\n\n  async _indexDevicesKeysByNoisePublicKey (prev, next, id) {\n    if (prev && next && b4a.equals(prev.noisePublicKey, next.noisePublicKey)) return\n\n    if (prev?.noisePublicKey) {\n      await this.deviceKeysByNoisePublicKey.delete(prev.noisePublicKey, id)\n    }\n    if (next?.noisePublicKey) {\n      await this.deviceKeysByNoisePublicKey.insert(next.noisePublicKey, id)\n    }\n  }\n\n  async _indexDeviceCount (prev, next) {\n    if (prev && next) return\n\n    const countNode = await this.deviceCount.get(DEVICE_COUNT_KEY)\n    let count = countNode ? countNode.value : 0\n    if (prev) count -= 1\n    if (next) count += 1\n    await this.deviceCount.insert(DEVICE_COUNT_KEY, count)\n  }\n\n  async _indexMobileDeviceCount (prev, next) {\n    if (prev && next && (prev.isMobile === next.isMobile)) return\n\n    const countNode = await this.mobileDeviceCount.get(MOBILE_DEVICE_COUNT_KEY)\n    let count = countNode ? countNode.value : 0\n    if (prev?.isMobile) count -= 1\n    if (next?.isMobile) count += 1\n    await this.mobileDeviceCount.insert(MOBILE_DEVICE_COUNT_KEY, count)\n  }\n\n  // Internal Module API\n\n  // Called from inside _applyGenesisOperation\n  async addBootstrapMember (key, noisePublicKey) {\n    const device = {\n      key,\n      noisePublicKey,\n      capabilities: MemberCapabilities.ALL_CAPABILITIES\n    }\n    await this.view.base.addWriter(key, { indexer: true })\n    await this.devices.update(key, device, { upsert: true })\n    await this.members.addPendingMember(device)\n  }\n\n  async getDevice (key) {\n    const node = await this.devices.get(key)\n    return node?.value\n  }\n\n  async updateDevice (key, device) {\n    return this.devices.update(key, device, { upsert: true })\n  }\n\n  async maybeDeleteDevice (key) {\n    if (!this.view.base.removeable(key)) return false\n    await this.view.base.removeWriter(key)\n    await this.devices.delete(key)\n    return true\n  }\n\n  // Autobase API\n\n  autobaseApply (op, opts) {\n    switch (op.type) {\n      case AddDeviceOperationV1.TYPE:\n        return this._applyAddDeviceOperation(op, opts)\n      case AddDeviceOperationV2.TYPE:\n        return this._applyAddDeviceOperation(op, opts)\n      case UpdateDeviceOperation.TYPE:\n        return this._applyUpdateDeviceOperation(op, opts)\n      case RemoveDeviceOperationV1.TYPE:\n        return this._applyRemoveDeviceOperationV1(op, opts)\n      case RemoveDeviceOperationV2.TYPE:\n        return this._applyRemoveDeviceOperationV2(op, opts)\n      case UpdateMemberOperationV1.TYPE:\n        return this._applyUpdateMemberOperation(op, opts)\n      case UpdateMemberOperationV2.TYPE:\n        return this._applyUpdateMemberOperation(op, opts)\n      default:\n    }\n  }\n\n  async autobaseIndex ({ prev, next, id }) {\n    await this._indexDevicesKeysByNoisePublicKey(prev, next, id)\n    await this._indexDeviceCount(prev, next, id)\n    await this._indexMobileDeviceCount(prev, next, id)\n  }\n}\nconst c = require('compact-encoding')\nconst { InternalSchema } = require('@holepunchto/keet-core-schemas')\nconst {\n  InternalOperation,\n  UpgradeOperation,\n  GenesisOperation,\n  AddPluginOperation\n} = InternalSchema.Operations\nconst {\n  FEATURES,\n  isFeatureSupported,\n  CURRENT_ABI,\n  MIN_ABIS\n} = require('@holepunchto/keet-core-api')\n\nmodule.exports = class RoomInternals {\n  static Operations = new Set([\n    InternalOperation.TYPE\n  ])\n\n  constructor (view) {\n    this.view = view\n    this.members = null\n    this.config = null\n    this._bee = null\n  }\n\n  initialize () {\n    this.members = this.view.members\n    this.config = this.view.config\n    this._bee = this.view.bee\n  }\n\n  // Code Versioning\n\n  async _getCodeVersion (bee) {\n    const node = await bee.get(InternalSchema.CodeVersionKey, InternalSchema.UpgraderEncoding)\n    if (!node) return 0\n    return node.value\n  }\n\n  async getCodeVersion (length = -1) {\n    if (length === -1) return this._getCodeVersion(this._bee)\n    const co = this._bee.checkout(length)\n    try {\n      return await this._getCodeVersion(co)\n    } finally {\n      await co.close()\n    }\n  }\n\n  updateCodeVersion (version) {\n    return this._bee.put(InternalSchema.CodeVersionKey, version, InternalSchema.UpgraderEncoding)\n  }\n\n  setExperimentalMode () {\n    return this._bee.put(InternalSchema.ExperimentalModeKey, 1, InternalSchema.UpgraderEncoding)\n  }\n\n  getExperimentalMode () {\n    return this._bee.get(InternalSchema.ExperimentalModeKey, InternalSchema.UpgraderEncoding)\n  }\n\n  async isExperimentalMode () {\n    const node = await this.getExperimentalMode()\n    if (!node) return false\n    return node.value === 1\n  }\n\n  // Plugin Management\n\n  async listPlugins () {\n    const plugins = []\n    for await (const { value } of this._bee.createReadStream(InternalSchema.PluginsEncoding)) {\n      plugins.push(value)\n    }\n    return plugins\n  }\n\n  async updatePlugin (name, { key, length, fork }) {\n    const plugins = await this.listPlugins()\n\n    let alias = -1\n    for (let i = 0; i < plugins.length; i++) {\n      if (plugins[i].name !== name) continue\n      alias = i\n      break\n    }\n\n    if (alias === -1) {\n      const rangeOpts = {\n        ...InternalSchema.PluginsEncoding.keyEncoding.encodeRange({}),\n        reverse: true\n      }\n      const last = await this._bee.peek(rangeOpts)\n      if (last) {\n        alias = InternalSchema.PluginsEncoding.keyEncoding.decode(last.key) + 1\n      } else {\n        alias = 0\n      }\n    }\n\n    await this._bee.put(alias, { name, key, length, fork }, InternalSchema.PluginsEncoding)\n  }\n\n  async _applyGenesisOperation (op, { id }) {\n    // !!! The genesis operation must always be the first operation to be applied !!!\n    if (this.view.core.length > 0) return\n\n    // TODO: set the title/room-type as part of the genesis step too (can happen after config V2)\n    const { experimental, bootstrap, version } = op.value.value\n\n    await this.view.devices.addBootstrapMember(id.key, bootstrap.noisePublicKey)\n    await this.updateCodeVersion(version)\n\n    if (experimental) {\n      await this.setExperimentalMode()\n    }\n  }\n\n  async _applyUpgradeOperation (op) {\n    const { version: newVersion } = op.value.value\n\n    const currentVersion = await this.getCodeVersion()\n    const max = await this.isExperimentalMode() ? CURRENT_ABI.EXPERIMENTAL : CURRENT_ABI.STABLE\n    if (newVersion > max) return\n    if (currentVersion && (currentVersion >= newVersion)) return\n\n    // Migrate configs only when version conditions are met\n    // Will always be atomic with the following code version bump\n    if (currentVersion < MIN_ABIS[FEATURES.V2_CONFIG] && isFeatureSupported(newVersion, FEATURES.V2_CONFIG)) {\n      await this.config.migrate()\n    }\n\n    // Migrate plugin data only when version conditions are met\n    if (currentVersion < MIN_ABIS[FEATURES.V2_PRIVATE_PROFILE] && isFeatureSupported(newVersion, FEATURES.V2_PRIVATE_PROFILE)) {\n      await this.view.privateProfile.migrate()\n    }\n\n    await this.updateCodeVersion(newVersion)\n  }\n\n  async _applyAddPluginOperation (op, { id }) {\n    const { name, key, length, fork } = op.value.value\n    // An plugin can only be installed by a moderator\n    const isModerator = await this.members.isModerator(id.key)\n    if (!isModerator) return\n\n    await this.updatePlugin(name, { key, length, fork })\n  }\n\n  async autobaseApply (op, opts) {\n    switch (op.value.subtype) {\n      case GenesisOperation.SUBTYPE:\n        return this._applyGenesisOperation(op, opts)\n      case UpgradeOperation.SUBTYPE:\n        return this._applyUpgradeOperation(op, opts)\n      case AddPluginOperation.SUBTYPE:\n        return this._applyAddPluginOperation(op, opts)\n      default:\n    }\n  }\n}\nconst BlindPairingCore = require('blind-pairing-core')\nconst { InvitationSchema } = require('@holepunchto/keet-core-schemas')\n\nconst {\n  AddInvitationOperationV1,\n  AddInvitationOperationV2,\n  RemoveInvitationOperation\n} = InvitationSchema.Operations\n\nmodule.exports = class Invitations {\n  static Operations = new Set([\n    AddInvitationOperationV1.TYPE,\n    AddInvitationOperationV2.TYPE,\n    RemoveInvitationOperation.TYPE\n  ])\n\n  constructor (view) {\n    this.view = view\n    this.members = null\n    this.invitations = null\n  }\n\n  initialize () {\n    this.members = this.view.members\n    this.invitations = this.view.collections.invitations\n  }\n\n  async _applyAddInvitationOperation (op, { id }) {\n    const [member, isMuted] = await Promise.all([\n      this.members.getMemberForDeviceKey(id.key),\n      this.members.isDeviceMuted(id.key)\n    ])\n    if (isMuted || !member) return\n\n    const invitation = op.value\n    const masked = maskCapabilities(member.capabilities, invitation.capabilities)\n\n    await this.invitations.update(invitation.id, {\n      ...invitation,\n      capabilities: masked\n    }, { upsert: true })\n  }\n\n  async _applyRemoveInvitationOperation (op, opts) {\n    // TODO: Implement\n  }\n\n  // Internal API\n\n  async getInvitation (invitationId) {\n    const node = await this.invitations.get(invitationId)\n    return node?.value\n  }\n\n  updateInvitation (invitationId, invitation) {\n    return this.invitations.update(invitationId, invitation, { upsert: true })\n  }\n\n  // Autobase API\n\n  autobaseApply (op, opts) {\n    switch (op.type) {\n      case AddInvitationOperationV1.TYPE:\n        return this._applyAddInvitationOperation(op, opts)\n      case AddInvitationOperationV2.TYPE:\n        return this._applyAddInvitationOperation(op, opts)\n      case RemoveInvitationOperation.TYPE:\n        return this._applyRemoveInvitationOperation(op, opts)\n      default:\n    }\n  }\n\n  // Exported because it must be used by the pairing member\n  static verifyReceipt (invitation, receipt, { checkExpiration = true } = {}) {\n    if (!invitation || !receipt) return false\n\n    if (checkExpiration && invitation.expiration && (invitation.expiration < Date.now())) {\n      // If we should check expiration, and the invitation is expired, reject\n      return false\n    }\n\n    if (!invitation.reusable && invitation.uses >= 1) {\n      // If this is a single-use invitation, and it's already been used, reject\n      return false\n    }\n\n    return BlindPairingCore.verifyReceipt(receipt, invitation.publicKey)\n  }\n}\n\nfunction maskCapabilities (memberCapabilities, inviteCapabilities) {\n  return inviteCapabilities & memberCapabilities\n}\nconst b4a = require('b4a')\nconst { MailboxSchema } = require('@holepunchto/keet-core-schemas')\nconst { FEATURES } = require('@holepunchto/keet-core-api')\n\nconst {\n  AddDmRequestOperation,\n  RemoveDmRequestOperation,\n  OldOpenMailboxOperation,\n  // V2\n  OpenMailboxOperation,\n  AddMailboxRecordOperation,\n  RemoveMailboxRecordOperation\n} = MailboxSchema.Operations\n\nmodule.exports = class Mailbox {\n  static Operations = new Set([\n    AddDmRequestOperation.TYPE,\n    RemoveDmRequestOperation.TYPE,\n    OldOpenMailboxOperation.TYPE,\n    OpenMailboxOperation.TYPE,\n    AddMailboxRecordOperation.TYPE,\n    RemoveMailboxRecordOperation.TYPE\n  ])\n\n  constructor (view) {\n    this.view = view\n    this.members = null\n    this.mailbox = null\n    this.openMailboxes = null\n    this.mailboxV2 = null\n\n    this.mailboxCounter = null\n    this.mailByMessageId = null\n  }\n\n  initialize () {\n    this.members = this.view.members\n    this.mailbox = this.view.collections.mailbox\n    this.openMailboxes = this.view.collections.openMailboxes\n    this.mailboxV2 = this.view.collections.mailboxV2\n\n    this.mailboxCounter = this.view.indexes.mailboxCounter\n    this.mailByMessageId = this.view.indexes.mailByMessageId\n  }\n\n  async _applyAddDmRequestOperation (op, { id, timestamp }) {\n    const member = await this.members.getMemberForDeviceKey(id.key)\n    if (!member) return\n\n    const { value } = op\n    const key = [value.receiver, member.key]\n\n    // Confirm the receiver's mailbox is open\n    if (!(await this.openMailboxes.get(value.receiver))) return null\n\n    // Check the mailbox + the other way around. One item allowed per member\n    if (await this.mailbox.get(key) || await this.mailbox.get([key[1], key[0]])) return null\n\n    await this.mailbox.update(key, { timestamp, link: value.link }, { upsert: true })\n  }\n\n  async _applyRemoveDmRequestOperation (op, { id }) {\n    const member = await this.members.getMemberForDeviceKey(id.key)\n    if (!member) return\n\n    const { value } = op\n\n    const [m1, m2] = await Promise.all([\n      this.mailbox.get([value.receiver, member.key]),\n      this.mailbox.get([member.key, value.receiver])\n    ])\n\n    if (m1) await this.mailbox.delete([value.receiver, member.key])\n    if (m2) await this.mailbox.delete([member.key, value.receiver])\n  }\n\n  async _applyOpenMailboxOperation (op, { id }) {\n    const member = await this.members.getMemberForDeviceKey(id.key)\n    if (!member) return\n\n    const { value } = op\n    const key = member.key\n\n    if (await this.openMailboxes.get(key)) return null\n\n    await this.openMailboxes.update(key, { blindingKey: value.blindingKey }, { upsert: true })\n  }\n\n  async _applyAddMailboxRecordOperation (op, { id }) {\n    const member = await this.members.getMemberForDeviceKey(id.key)\n    if (!member) return\n\n    const { value } = op\n    const { receiver, data } = value\n    const receiverKey = receiver\n\n    const nextId = await this.getNextMailboxId()\n    const key = [receiverKey, nextId]\n\n    // Confirm the receiver's mailbox is open\n    if (!(await this.openMailboxes.get(receiverKey))) return null\n\n    await this.mailboxV2.update(key, { id, data }, { upsert: true })\n  }\n\n  async _applyRemoveMailboxRecordOperation (op, { id }) {\n    const member = await this.members.getMemberForDeviceKey(id.key)\n    if (!member) return\n\n    const { value } = op\n    const msgId = value.id\n    const mail = await this.mailByMessageId.get([msgId.key, msgId.seq])\n    if (!mail) return\n    const { value: mailId } = mail\n    const key = [mailId.key, mailId.seq]\n    const record = await this.mailboxV2.get(key)\n    if (!record) return\n    // only the member who received the mail can delete\n    if (!b4a.equals(mailId.key, member.key)) return\n\n    await this.mailboxV2.delete(key)\n  }\n\n  async _indexCounter (prev, next, id) {\n    // Never remove counter, and only add if this is the first time the record is indexed\n    if (next && !prev) {\n      await this.mailboxCounter.insert(id[1])\n      await this.mailByMessageId.insert([next.id.key, next.id.seq], { key: id[0], seq: id[1] })\n    }\n  }\n\n  // Internal API\n\n  async getNextMailboxId () {\n    const latest = await this.mailboxCounter.peek({ reverse: true })\n    return latest ? latest.key + 1 : 0\n  }\n\n  // Autobase API\n\n  async autobaseApply (op, opts) {\n    if (!(await this.view.isFeatureSupported(FEATURES.DMS))) return null\n\n    switch (op.type) {\n      case AddDmRequestOperation.TYPE:\n        return this._applyAddDmRequestOperation(op, opts)\n      case RemoveDmRequestOperation.TYPE:\n        return this._applyRemoveDmRequestOperation(op, opts)\n      case OpenMailboxOperation.TYPE:\n        return this._applyOpenMailboxOperation(op, opts)\n      case AddMailboxRecordOperation.TYPE:\n        return this._applyAddMailboxRecordOperation(op, opts)\n      case RemoveMailboxRecordOperation.TYPE:\n        return this._applyRemoveMailboxRecordOperation(op, opts)\n      default:\n    }\n  }\n\n  async autobaseIndex ({ prev, next, id }) {\n    await this._indexCounter(prev, next, id)\n  }\n}\nconst IdentityKey = require('@holepunchto/keet-identity-key')\nconst BufferMap = require('tiny-buffer-map')\nconst b4a = require('b4a')\nconst { MemberSchema } = require('@holepunchto/keet-core-schemas')\nconst { MemberCapabilities, MemberRoles, getCapabilitiesForRole, GENERIC_EVENTS, FEATURES } = require('@holepunchto/keet-core-api')\n\nconst {\n  UpdateMemberOperationV1,\n  UpdateMemberOperationV2,\n  RemoveMemberOperation,\n  ChangeMemberRoleOperation,\n  MuteMemberOperation,\n  UnmuteMemberOperation\n} = MemberSchema.Operations\n\nconst MEMBER_COUNT_KEY = 0\nconst EMPTY = b4a.alloc(0)\n\nmodule.exports = class Members {\n  static Operations = new Set([\n    UpdateMemberOperationV1.TYPE,\n    UpdateMemberOperationV2.TYPE,\n    RemoveMemberOperation.TYPE,\n    ChangeMemberRoleOperation.TYPE,\n    MuteMemberOperation.TYPE,\n    UnmuteMemberOperation.TYPE\n  ])\n\n  constructor (view) {\n    this.view = view\n    this.chat = null\n    this.devices = null\n    this.config = null\n\n    this.members = null\n    this.avatars = null\n    this.pendingMembers = null\n    this.inactiveMembers = null\n    this.mutedMembers = null\n\n    this.membersKeysByMemberName = null\n    this.membersByDeviceKey = null\n    this.inactiveMembersByDeviceKey = null\n    this.capabilitiesByDeviceKey = null\n    this.moderatorsByMemberKey = null\n    this.membersCount = null\n  }\n\n  initialize () {\n    this.chat = this.view.chat\n    this.devices = this.view.devices\n    this.config = this.view.config\n\n    this.members = this.view.collections.members\n    this.avatars = this.view.collections.avatars\n    this.pendingMembers = this.view.collections.pendingMembers\n    this.inactiveMembers = this.view.collections.inactiveMembers\n    this.mutedMembers = this.view.collections.mutedMembers\n\n    this.memberKeysByMemberName = this.view.indexes.memberKeysByMemberName\n    this.membersByDeviceKey = this.view.indexes.membersByDeviceKey\n    this.inactiveMembersByDeviceKey = this.view.indexes.inactiveMembersByDeviceKey\n    this.capabilitiesByDeviceKey = this.view.indexes.capabilitiesByDeviceKey\n    this.moderatorsByMemberKey = this.view.indexes.moderatorsByMemberKey\n    this.membersCount = this.view.indexes.membersCount\n  }\n\n  _migratePendingMember (pendingMember, identityMember, identity) {\n    if (pendingMember.attestation) {\n      if (!identity || !b4a.equals(identity.memberKey, pendingMember.attestation.memberKey)) return null\n      return mergeMembers(identity.memberKey, pendingMember, identityMember, {\n        latestReceipt: pendingMember.attestation.receipt\n      })\n    }\n    if (identity) {\n      if (!identity.proof) return null\n\n      const verification = verifyIdentity(identity, pendingMember.key, identityMember?.latestReceipt)\n\n      const memberKey = verification ? identity.memberKey : pendingMember.key\n      const targetMember = verification ? identityMember : null\n\n      return mergeMembers(memberKey, pendingMember, targetMember, {\n        latestReceipt: verification ? verification.receipt : null\n      })\n    }\n    return mergeMembers(pendingMember.key, pendingMember, null)\n  }\n\n  _migrateExistingMember (deviceMember, identityMember, identity) {\n    if (!identity.proof || b4a.equals(deviceMember.key, identity.memberKey)) return null\n\n    const verification = verifyIdentity(identity, deviceMember.key, identityMember?.latestReceipt)\n    if (!verification) return null\n\n    return mergeMembers(identity.memberKey, deviceMember, identityMember, {\n      latestReceipt: verification.receipt\n    })\n  }\n\n  async _maybeReactivateMember (deviceKey) {\n    const inactiveMember = await this.getInactiveMemberForDeviceKey(deviceKey, { full: true })\n    if (inactiveMember) {\n      // If there's an inactive member, splice out the new device key from the inactive device list\n      // If there are no more inactive devices, delete the inactive member\n      const idx = inactiveMember.devices.findIndex(key => b4a.equals(key, deviceKey))\n      if (idx !== -1) {\n        inactiveMember.devices.splice(idx, 1)\n        if (inactiveMember.devices.length > 0) {\n          await this.inactiveMembers.update(inactiveMember.key, inactiveMember, { upsert: true })\n        } else {\n          await this.inactiveMembers.delete(inactiveMember.key)\n        }\n      }\n    }\n  }\n\n  async _applyUpdateMemberOperation (op, { id, timestamp }) {\n    const { displayName, avatar, identity } = op.value\n\n    const [pendingMember, deviceMember, identityMember, abi] = await Promise.all([\n      this.getPendingMemberForDeviceKey(id.key),\n      this.getMemberForDeviceKey(id.key, { full: true }),\n      identity ? this.getMember(identity.memberKey) : Promise.resolve(),\n      this.view.internal.getCodeVersion()\n    ])\n\n    let mergedMember = deviceMember\n    if (pendingMember) {\n      // Can only do the reactivation after ABI 2 for compatibility\n      if (abi >= 2) await this._maybeReactivateMember(id.key)\n      mergedMember = this._migratePendingMember(pendingMember, identityMember, identity)\n      if (!mergedMember) return\n\n      await this.pendingMembers.delete(id.key)\n    } else if (identity && isUnlinked(identityMember, id.key)) {\n      mergedMember = this._migrateExistingMember(deviceMember, identityMember, identity)\n      if (!mergedMember) return\n\n      await this.members.delete(deviceMember.key)\n    }\n\n    if (avatar) {\n      await this.avatars.update(mergedMember.key, avatar, { upsert: true })\n    }\n    const finalMember = {\n      ...mergedMember,\n      timestamp,\n      displayName: displayName || mergedMember.displayName,\n      hasAvatar: !!avatar || mergedMember.hasAvatar\n    }\n\n    await this.members.update(finalMember.key, finalMember, { upsert: true })\n\n    if (pendingMember && !identityMember) {\n      const isBroadcastRoom = await this.config.isBroadcastRoom()\n      if (!isBroadcastRoom) {\n        const joined = {\n          id,\n          timestamp,\n          event: {\n            type: GENERIC_EVENTS.MEMBER_JOINED\n          }\n        }\n        await this.chat.addMessage(joined)\n      }\n    }\n  }\n\n  async _applyRemoveMemberOperation (op, { id, timestamp }) {\n    const { memberKey } = op.value\n\n    const [sourceIsMod, sourceMember, targetMember, removeSupported] = await Promise.all([\n      this.isModerator(id.key),\n      this.getMemberForDeviceKey(id.key),\n      // target\n      this.getMember(memberKey),\n      // feature\n      this.view.isFeatureSupported(FEATURES.REMOVE_MEMBER)\n    ])\n    if (!sourceMember || !targetMember || !removeSupported) return\n\n    // Only mods and admins can remove members\n    if (!sourceIsMod) return\n\n    // Only admins can remove admins\n    const sourceIsAdmin = (sourceMember.capabilities & MemberCapabilities.CAN_INDEX) !== 0\n    const targetIsAdmin = (targetMember.capabilities & MemberCapabilities.CAN_INDEX) !== 0\n    if (targetIsAdmin && !sourceIsAdmin) return\n\n    const inactivated = new BufferMap()\n    for (const key of (targetMember.inactive || [])) inactivated.set(key, EMPTY)\n\n    // Remove devices and writers\n    let removed = false\n    for await (const key of targetMember.devices) {\n      if (inactivated.get(key)) continue\n      const deleted = await this.devices.maybeDeleteDevice(key)\n      if (deleted) await this.removeMemberForDeviceKey({ key }, timestamp, { sendLeftEvent: false })\n      removed = deleted\n    }\n\n    // Send event if all devices were deleted\n    if (!removed) return\n\n    await this.chat.addMessage({\n      id,\n      timestamp,\n      event: {\n        type: GENERIC_EVENTS.MEMBER_REMOVED,\n        value: { memberKey }\n      }\n    })\n  }\n\n  async _applyChangeMemberRoleOperation (op, { id, timestamp }) {\n    const { memberKey, role } = op.value\n    const allowedMemberRoles = [MemberRoles.MODERATOR, MemberRoles.PEER]\n    if (!allowedMemberRoles.includes(role)) return\n\n    const [sourceIsMod, sourceMember, targetMod, targetMember, isSupported] = await Promise.all([\n      this.isModerator(id.key),\n      this.getMemberForDeviceKey(id.key),\n      // target\n      this.moderatorsByMemberKey.get(memberKey),\n      this.getMember(memberKey),\n      // feature\n      this.view.isFeatureSupported(FEATURES.PERMISSION_DOWNGRADE)\n    ])\n    if (!sourceMember || !targetMember || !isSupported) return\n    const targetIsMod = !!targetMod\n\n    // Only mods and admins can change roles\n    if (!sourceIsMod) return\n\n    // Only admins can downgrade admins\n    const sourceIsAdmin = (sourceMember.capabilities & MemberCapabilities.CAN_INDEX) !== 0\n    const targetIsAdmin = (targetMember.capabilities & MemberCapabilities.CAN_INDEX) !== 0\n    if (targetIsAdmin && !sourceIsAdmin) return\n\n    // Admins and mods can only be downgraded\n    if (!targetIsAdmin && targetIsMod && MemberRoles.PEER !== role) return\n\n    // Peers can be upgraded to mods\n    const targetIsPeer = !targetIsAdmin && !targetIsMod\n    if (targetIsPeer && role !== MemberRoles.MODERATOR) return\n\n    // Update device/writer\n    const newCapabilities = getCapabilitiesForRole(role)\n    const devices = await Promise.all(targetMember.devices.map(dkey => this.devices.getDevice(dkey)))\n\n    const unremovableIndexer = devices.some(device => {\n      const isIndexer = (device.capabilities & MemberCapabilities.CAN_INDEX) !== 0\n      return isIndexer && !this.view.base.removeable(device.key)\n    })\n    // if at least one device is an unremovable indexer, we should not change any capabilities\n    if (unremovableIndexer) return\n\n    for await (const targetDevice of devices) {\n      const { key } = targetDevice\n      const isIndexer = (targetDevice.capabilities & MemberCapabilities.CAN_INDEX) !== 0\n      if (isIndexer && this.view.base.removeable(key)) await this.view.base.addWriter(key, { indexer: false })\n      await this.devices.updateDevice(key, {\n        ...targetDevice,\n        capabilities: newCapabilities\n      })\n    }\n\n    // Update member\n    await this.members.update(targetMember.key, {\n      ...targetMember,\n      timestamp,\n      capabilities: newCapabilities\n    }, { upsert: true })\n  }\n\n  async _applyMuteMemberOperation (op, { id, timestamp }) {\n    const { memberKey } = op.value\n\n    const [isSupported, isModerator] = await Promise.all([\n      this.view.isFeatureSupported(FEATURES.MUTE_MEMBER),\n      this.isModerator(id.key)\n    ])\n    if (!isSupported || !isModerator) return\n\n    await this.mutedMembers.update(memberKey, EMPTY, { upsert: true })\n  }\n\n  async _applyUnmuteMemberOperation (op, { id, timestamp }) {\n    const { memberKey } = op.value\n\n    const [isSupported, isModerator] = await Promise.all([\n      this.view.isFeatureSupported(FEATURES.MUTE_MEMBER),\n      this.isModerator(id.key)\n    ])\n    if (!isSupported || !isModerator) return\n\n    const mutedMember = await this.mutedMembers.get(memberKey)\n    if (!mutedMember) return\n\n    await this.mutedMembers.delete(memberKey)\n  }\n\n  async _indexMembersCount (prev, next) {\n    if (prev && next) return\n\n    const countNode = await this.membersCount.get(MEMBER_COUNT_KEY)\n    let count = countNode ? countNode.value : 0\n    if (prev) count -= 1\n    if (next) count += 1\n\n    await this.membersCount.insert(MEMBER_COUNT_KEY, count)\n  }\n\n  async _indexMemberKeysByMemberName (prev, next, id) {\n    if (prev && next && (prev.displayName === next.displayName)) return\n    if (prev && prev.displayName) {\n      await this.memberKeysByMemberName.delete([prev.displayName.toLowerCase(), id])\n    }\n    if (next && next.displayName) {\n      await this.memberKeysByMemberName.insert([next.displayName.toLowerCase(), id])\n    }\n  }\n\n  async _indexMembersByDeviceKey (prev, next) {\n    // TODO: Should be able to diff these before writing\n    // TODO: Can just update the pointers vs. deleting the old ones\n    if (prev) {\n      for (const key of prev.devices) {\n        await this.membersByDeviceKey.delete(key)\n      }\n    }\n    if (next) {\n      for (const key of next.devices) {\n        await this.membersByDeviceKey.insert(key, next)\n      }\n    }\n  }\n\n  async _indexInactiveMembersByDeviceKey (prev, next) {\n    // TODO: Should be able to diff these before writing\n    // TODO: Can just update the pointers vs. deleting the old ones\n    if (prev) {\n      for (const key of prev.devices) {\n        await this.inactiveMembersByDeviceKey.delete(key)\n      }\n    }\n    if (next) {\n      for (const key of next.devices) {\n        await this.inactiveMembersByDeviceKey.insert(key, next)\n      }\n    }\n  }\n\n  async _indexCapabilitiesByDeviceKey (prev, next) {\n    if (next && prev && (prev.capabilities === next.capabilities) && sameDevices(prev.devices, next.devices)) return\n    if (prev) {\n      for (const key of prev.devices) {\n        await this.capabilitiesByDeviceKey.delete(key)\n      }\n    }\n    if (next) {\n      for (const key of next.devices) {\n        await this.capabilitiesByDeviceKey.insert(key, next.capabilities)\n      }\n    }\n  }\n\n  async _indexModeratorsByMemberKey (prev, next) {\n    if (prev && next && isModerator(prev.capabilities) && isModerator(next.capabilities)) return\n    if (prev && isModerator(prev.capabilities)) {\n      await this.moderatorsByMemberKey.delete(prev.key)\n    }\n    if (next && isModerator(next.capabilities)) {\n      await this.moderatorsByMemberKey.insert(next.key, EMPTY)\n    }\n  }\n\n  // Internal API\n\n  async addPendingMember (device) {\n    // For compat, we need to do this for ABI < 2, but this is a bug\n    const abi = await this.view.internal.getCodeVersion()\n    if (abi < 2) {\n      await this._maybeReactivateMember(device.key)\n    }\n    await this.pendingMembers.update(device.key, {\n      invitation: device.invitation,\n      capabilities: device.capabilities,\n      attestation: device.attestation\n    }, { upsert: true })\n  }\n\n  async updateExistingMember (device) {\n    const member = await this.getMemberForDeviceKey(device.key, { full: true })\n    if (!member) return\n\n    return this.members.update(member.key, {\n      ...member,\n      capabilities: member.capabilities | device.capabilities\n    }, { upsert: true })\n  }\n\n  async getPendingMemberForDeviceKey (deviceKey) {\n    const node = await this.pendingMembers.get(deviceKey)\n    return node ? { key: node._id, ...node.value } : null\n  }\n\n  async getMemberForDeviceKey (deviceKey, { full = false } = {}) {\n    const memberNode = await this.membersByDeviceKey.get(deviceKey)\n\n    if (!memberNode) return null\n    const member = memberNode.value\n\n    if (!full) return { ...member, deviceKey }\n\n    return this.getMember(member.key)\n  }\n\n  async getInactiveMemberForDeviceKey (deviceKey, { full = false } = {}) {\n    const memberNode = await this.inactiveMembersByDeviceKey.get(deviceKey)\n\n    if (!memberNode) return null\n    const member = memberNode.value\n\n    if (!full) return { ...member, deviceKey }\n\n    return this.getInactiveMember(member.key)\n  }\n\n  async removeMemberForDeviceKey (id, timestamp, { sendLeftEvent = true } = {}) {\n    const deviceKey = id.key\n\n    const [member, inactiveMember, pendingMember] = await Promise.all([\n      this.getMemberForDeviceKey(deviceKey, { full: true }),\n      this.getInactiveMemberForDeviceKey(deviceKey, { full: true }),\n      this.getPendingMemberForDeviceKey(deviceKey)\n    ])\n\n    if (inactiveMember || !member) {\n      // If the member is already inactive, then there is no more work to do\n      return\n    }\n    if (pendingMember) {\n      await this.pendingMembers.delete(deviceKey)\n    }\n\n    if (member.inactive) {\n      const idx = member.inactive.findIndex(k => b4a.equals(k, deviceKey))\n      if (idx === -1) {\n        member.inactive.push(deviceKey)\n      }\n    } else {\n      member.inactive = [deviceKey]\n    }\n\n    // Ensure that member.inactive remains sorted so it can be compared against member.devices\n    member.inactive.sort(b4a.compare)\n\n    await this.members.update(member.key, member, { upsert: true })\n    // If some devices have left yet, the member is still not fully inactive\n    if (!isFullyInactive(member)) return\n\n    await this.members.delete(member.key)\n    await this.inactiveMembers.update(member.key, member, { upsert: true })\n\n    const [isBroadcastRoom, version] = await Promise.all([\n      this.config.isBroadcastRoom(),\n      this.view.internal.getCodeVersion()\n    ])\n    if (((version < 2) || !isBroadcastRoom) && sendLeftEvent) {\n      const left = {\n        id,\n        timestamp,\n        event: {\n          type: GENERIC_EVENTS.MEMBER_LEFT\n        }\n      }\n      await this.chat.addMessage(left)\n    }\n  }\n\n  async getMember (memberKey) {\n    const memberNode = await this.members.get(memberKey)\n    return memberNode?.value\n  }\n\n  async getInactiveMember (memberKey) {\n    const memberNode = await this.inactiveMembers.get(memberKey)\n    return memberNode?.value\n  }\n\n  async isDeviceMuted (deviceKey) {\n    const [member, inactiveMember] = await Promise.all([\n      this.getMemberForDeviceKey(deviceKey),\n      this.getInactiveMemberForDeviceKey(deviceKey)\n    ])\n    if (!member && !inactiveMember) return false\n    return this.isMemberMuted(member?.key || inactiveMember?.key)\n  }\n\n  async isMemberMuted (memberKey) {\n    const memberNode = await this.mutedMembers.get(memberKey)\n    return !!memberNode\n  }\n\n  async isModerator (deviceKey) {\n    // This is needed because v1 keet treated the bootstrap writer as a moderator before non-pending\n    if (b4a.equals(deviceKey, this.view.base.bootstraps[0])) return true\n    const node = await this.capabilitiesByDeviceKey.get(deviceKey)\n    return isModerator(node?.value)\n  }\n\n  // Autobase API\n\n  autobaseApply (op, opts) {\n    switch (op.type) {\n      case UpdateMemberOperationV1.TYPE:\n        return this._applyUpdateMemberOperation(op, opts)\n      case UpdateMemberOperationV2.TYPE:\n        return this._applyUpdateMemberOperation(op, opts)\n      case RemoveMemberOperation.TYPE:\n        return this._applyRemoveMemberOperation(op, opts)\n      case ChangeMemberRoleOperation.TYPE:\n        return this._applyChangeMemberRoleOperation(op, opts)\n      case MuteMemberOperation.TYPE:\n        return this._applyMuteMemberOperation(op, opts)\n      case UnmuteMemberOperation.TYPE:\n        return this._applyUnmuteMemberOperation(op, opts)\n      default:\n    }\n  }\n\n  async autobaseIndexMembers ({ prev, next, id }) {\n    await this._indexMemberKeysByMemberName(prev, next, id)\n    await this._indexMembersByDeviceKey(prev, next, id)\n    await this._indexCapabilitiesByDeviceKey(prev, next, id)\n    await this._indexModeratorsByMemberKey(prev, next, id)\n    await this._indexMembersCount(prev, next)\n  }\n\n  async autobaseIndexInactiveMembers ({ prev, next, id }) {\n    await this._indexInactiveMembersByDeviceKey(prev, next, id)\n  }\n}\n\nfunction verifyIdentity (identity, deviceKey, receipt) {\n  const verification = IdentityKey.verify(identity.proof, deviceKey, {\n    expectedIdentity: identity.memberKey,\n    receipt\n  })\n  if (!verification) return null\n  return verification\n}\n\nfunction mergeMembers (memberKey, source, target, { latestReceipt } = {}) {\n  return {\n    key: memberKey,\n    hasAvatar: !!source?.hasAvatar || !!target?.hasAvatar,\n    displayName: source?.displayName || target?.displayName,\n    latestReceipt: target?.latestReceipt || latestReceipt,\n    devices: mergeDevices(source, target),\n    capabilities: mergeCapabilities(source, target)\n  }\n}\n\nfunction mergeDevices (source, target) {\n  if (!source && !target) return []\n  if (!target) return source.devices ? source.devices : [source.key]\n  if (!source) return target.devices ? target.devices : [target.key]\n\n  const devices = new BufferMap()\n  if (source.devices) {\n    for (const key of source.devices) {\n      devices.set(key, EMPTY)\n    }\n    for (const key of target.devices) {\n      devices.set(key, EMPTY)\n    }\n  } else {\n    for (const key of target.devices) {\n      devices.set(key, EMPTY)\n    }\n    devices.set(source.key, EMPTY)\n  }\n\n  const keys = [...devices.keys()]\n  keys.sort(b4a.compare)\n\n  return keys\n}\n\nfunction mergeCapabilities (source, target) {\n  if (!source && !target) return 0\n  if (!source) return target.capabilities\n  if (!target) return source.capabilities\n  return source.capabilities | target.capabilities\n}\n\nfunction isModerator (capabilities) {\n  return (capabilities & MemberCapabilities.CAN_MODERATE) !== 0\n}\n\nfunction isUnlinked (member, key) {\n  if (!member) return true\n  return member.devices.findIndex(d => b4a.equals(d, key)) === -1\n}\n\nfunction isFullyInactive (member) {\n  if (!member.inactive) return false\n  if (member.inactive.length !== member.devices.length) return false\n  for (let i = 0; i < member.inactive.length; i++) {\n    if (!b4a.equals(member.inactive[i], member.devices[i])) return false\n  }\n  return true\n}\n\nfunction sameDevices (d1, d2) {\n  if (d1.length !== d2.length) return false\n  for (let i = 0; i < d1.length; i++) {\n    if (!b4a.equals(d1[i], d2[i])) return false\n  }\n  return true\n}\nconst b4a = require('b4a')\nconst { KeetSchema, PluginSchema } = require('@holepunchto/keet-core-schemas')\n\nconst AUTHORIZED_PLUGINS_BY_NAME = new Map([\n  ['@holepunchto/kv-store', require('../../plugins/kv-store/apply.js')],\n  ['@holepunchto/word-count', require('../../plugins/word-count/apply.js')],\n  ['@holepunchto/private-profile', require('../../plugins/private-profile/apply.js')]\n])\n\nmodule.exports = class RoomPlugins {\n  static Operations = new Set(KeetSchema.AllOperations.map(o => o.TYPE))\n\n  constructor (view) {\n    this.view = view\n    this.internal = null\n    this.bee = null\n\n    this._plugins = new Map()\n    this._pluginsEncoding = PluginSchema.Encoding\n  }\n\n  initialize () {\n    this.internal = this.view.internal\n    this.bee = this.view.bee\n  }\n\n  async load () {\n    const plugins = await this.internal.listPlugins()\n    for (let i = 0; i < plugins.length; i++) {\n      const { name } = plugins[i]\n\n      const Plugin = AUTHORIZED_PLUGINS_BY_NAME.get(name)\n      if (!Plugin || this._plugins.has(name)) continue\n\n      // Each plugin is passed the view and the prefixed key encoding it should use\n      const prefix = this._pluginsEncoding.sub(b4a.from([i])).prefix\n      const plugin = new Plugin(this.view, prefix)\n\n      this._plugins.set(name, { plugin, name, prefix })\n    }\n  }\n\n  list () {\n    return [...this._plugins.values()]\n  }\n\n  get (name) {\n    const record = this._plugins.get(name)\n    return record ? record.plugin : null\n  }\n\n  async autobaseApply (op, opts) {\n    await this.load()\n    for (const { plugin } of this.list()) {\n      await plugin.apply(op, opts)\n    }\n  }\n}\nconst PrivateMailbox = require('./private-mailbox')\nconst PrivateRooms = require('./private-rooms')\nconst PrivateDevices = require('./private-devices')\n\nmodule.exports = class PrivateProfile {\n  static Operations = new Set([\n    ...PrivateMailbox.Operations,\n    ...PrivateRooms.Operations,\n    ...PrivateDevices.Operations\n  ])\n\n  constructor (view) {\n    this.view = view\n\n    this.privateMailbox = new PrivateMailbox(this)\n    this.privateRooms = new PrivateRooms(this)\n    this.privateDevices = new PrivateDevices(this)\n  }\n\n  initialize () {\n    this.privateMailbox.initialize()\n    this.privateRooms.initialize()\n    this.privateDevices.initialize()\n  }\n\n  // Migrate data from private profile plugin\n  async migrate () {\n    const profilePlugin = this.view.plugins.get('@holepunchto/private-profile')\n    if (!profilePlugin) return\n\n    // migrate rooms\n    for await (const { _id: key } of profilePlugin.rooms.createReadStream()) {\n      await this.privateRooms.rooms.update(key, { key }, { upsert: true })\n    }\n\n    // migrate device keys\n    for await (const { _id: deviceKey, value: devicePublicKey } of profilePlugin.deviceKeys.createReadStream()) {\n      await this.privateDevices.keys.update(deviceKey, devicePublicKey, { upsert: true })\n    }\n\n    // migrate device attestations\n    for await (const { _id: devicePublicKey, value: attestation } of profilePlugin.deviceAttestations.createReadStream()) {\n      await this.privateDevices.attestations.update(devicePublicKey, attestation, { upsert: true })\n    }\n  }\n\n  // Autobase API\n\n  async autobaseApply (op, opts) {\n    if (PrivateRooms.Operations.has(op.type)) {\n      return this.privateRooms.autobaseApply(op, opts)\n    }\n\n    if (PrivateDevices.Operations.has(op.type)) {\n      return this.privateDevices.autobaseApply(op, opts)\n    }\n\n    if (PrivateMailbox.Operations.has(op.type)) {\n      return this.privateMailbox.autobaseApply(op, opts)\n    }\n  }\n}\nconst { PrivateDeviceSchema } = require('@holepunchto/keet-core-schemas')\n\nconst {\n  AddDeviceKeyOperation,\n  AddDeviceAttestationOperation\n} = PrivateDeviceSchema.Operations\n\nmodule.exports = class PrivateDevices {\n  static Operations = new Set([\n    AddDeviceKeyOperation.TYPE,\n    AddDeviceAttestationOperation.TYPE\n  ])\n\n  constructor (profile) {\n    this.profile = profile\n\n    this.keys = null\n    this.attestations = null\n  }\n\n  initialize () {\n    this.keys = this.profile.view.collections.privateDeviceKeys\n    this.attestations = this.profile.view.collections.privateDeviceAttestations\n  }\n\n  async _applyAddDeviceKeyOperation (op, { id }) {\n    const { devicePublicKey } = op.value\n    const existing = await this.keys.get(id.key)\n    if (existing) return\n\n    await this.keys.update(id.key, devicePublicKey, { upsert: true })\n  }\n\n  async _applyAddDeviceAttestationOperation (op) {\n    const { devicePublicKey, attestation } = op.value\n\n    const existing = await this.attestations.get(devicePublicKey)\n    if (existing) return\n\n    await this.attestations.update(devicePublicKey, attestation, { upsert: true })\n  }\n\n  // Autobase API\n\n  async autobaseApply (op, opts) {\n    switch (op.type) {\n      case AddDeviceKeyOperation.TYPE:\n        return this._applyAddDeviceKeyOperation(op, opts)\n      case AddDeviceAttestationOperation.TYPE:\n        return this._applyAddDeviceAttestationOperation(op, opts)\n      default:\n    }\n  }\n}\nconst { PrivateMailboxSchema } = require('@holepunchto/keet-core-schemas')\nconst { FEATURES } = require('@holepunchto/keet-core-api')\n\nconst {\n  AddPrivateMailboxRecordOperation,\n  UpdatePrivateMailboxRecordOperation\n} = PrivateMailboxSchema.Operations\n\nmodule.exports = class PrivateMailbox {\n  static Operations = new Set([\n    AddPrivateMailboxRecordOperation.TYPE,\n    UpdatePrivateMailboxRecordOperation.TYPE\n  ])\n\n  constructor (profile) {\n    this.profile = profile\n\n    this.privateMailbox = null\n    this.sentPrivateMailbox = null\n\n    this.privateMailboxCounter = null\n    this.privateMailByMessageId = null\n    this.privateMailByPublicMail = null\n    this.dmByMember = null\n  }\n\n  initialize () {\n    this.privateMailbox = this.profile.view.collections.privateMailbox\n    this.sentPrivateMailbox = this.profile.view.collections.sentPrivateMailbox\n\n    this.privateMailboxCounter = this.profile.view.indexes.privateMailboxCounter\n    this.privateMailByMessageId = this.profile.view.indexes.privateMailByMessageId\n    this.privateMailByPublicMail = this.profile.view.indexes.privateMailByPublicMail\n    this.dmByMember = this.profile.view.indexes.dmByMember\n  }\n\n  async _indexCounter (prev, next, id) {\n    if (next && !prev) {\n      await this.privateMailboxCounter.insert(id[2])\n      await this.privateMailByMessageId.insert([next.id.key, next.id.seq], { timestamp: id[0], roomKey: id[1], seq: id[2] })\n    }\n  }\n\n  async _indexPublicMail (prev, next, id) {\n    if (next && next.mailId && !prev) {\n      await this.privateMailByPublicMail.insert([id[1], next.mailId.key, next.mailId.seq], { timestamp: id[0], roomKey: id[1], seq: id[2] })\n    }\n  }\n\n  async _indexReceiverDm (prev, next, id) {\n    // Index reciever's DM\n    if (!prev && next && next.senderKey && next.invitation) {\n      await this.dmByMember.insert(next.senderKey, { id: next.id, roomKey: null })\n    }\n\n    // Update receiver's DM\n    if (prev && next && next.senderKey) {\n      const { id, targetRoomKey: roomKey, status } = next\n      await this.dmByMember.insert(next.senderKey, { id, roomKey, status })\n    }\n  }\n\n  async _indexSenderDm (prev, next, id) {\n    // Index sender's DM\n    if (!prev && next && next.receiverKey) {\n      await this.dmByMember.insert(next.receiverKey, { id: next.id, roomKey: null })\n    }\n\n    // Update sender's DM\n    if (prev && next && next.receiverKey && next.targetRoomKey) {\n      await this.dmByMember.insert(next.receiverKey, { id: next.id, roomKey: next.targetRoomKey })\n    }\n  }\n\n  async _applyAddPrivateMailboxRecordOperation (op, { id }) {\n    const { value } = op\n    const key = [value.timestamp, value.roomKey, await this.getNextPrivateMailboxId()]\n    const { mailId } = value\n    const sentMail = !!value.receiverKey\n    const record = {\n      id,\n      mailId: value.mailId || null,\n      seen: sentMail,\n      type: value.type || null,\n      status: value.status || null,\n      senderKey: value.senderKey || null,\n      receiverKey: value.receiverKey || null,\n      targetRoomKey: value.targetRoomKey || null,\n      message: value.message || null,\n      invitation: value.invitation || null\n    }\n\n    if (!sentMail) {\n      if (await this.dmByMember.get(value.senderKey)) return\n      if (await this.privateMailByPublicMail.get([value.roomKey, mailId.key, mailId.seq])) return\n      return await this.privateMailbox.update(key, record, { upsert: true })\n    }\n\n    // Sent mail\n    if (await this.dmByMember.get(value.receiverKey)) return\n    await this.sentPrivateMailbox.update(key, record, { upsert: true })\n  }\n\n  async _applyUpdatePrivateMailboxRecordOperation (op) {\n    const { msgId, ...newValues } = op.value\n    const node = await this.privateMailByMessageId.get([msgId.key, msgId.seq])\n    if (!node || !node.value) return\n\n    const mail = node.value\n    const key = [mail.timestamp, mail.roomKey, mail.seq]\n\n    // Received mail\n    const current = await this.privateMailbox.get(key)\n    if (current) {\n      return await this.privateMailbox.update(key, {\n        ...current.value,\n        status: typeof newValues.status === 'undefined' ? current.value.status : newValues.status,\n        seen: typeof newValues.seen === 'undefined' ? current.value.seen : newValues.seen,\n        targetRoomKey: typeof newValues.targetRoomKey === 'undefined' ? current.value.targetRoomKey : newValues.targetRoomKey\n      }, { upsert: true })\n    }\n\n    // Sent mail\n    const sent = await this.sentPrivateMailbox.get(key)\n    if (sent) {\n      return await this.sentPrivateMailbox.update(key, {\n        ...sent.value,\n        targetRoomKey: typeof newValues.targetRoomKey === 'undefined' ? sent.value.targetRoomKey : newValues.targetRoomKey,\n        status: typeof newValues.status === 'undefined' ? sent.value.status : newValues.status\n      }, { upsert: true })\n    }\n  }\n\n  // Internal API\n\n  async getNextPrivateMailboxId () {\n    const latest = await this.privateMailboxCounter.peek({ reverse: true })\n    return latest ? latest.key + 1 : 0\n  }\n\n  // Autobase API\n\n  async autobaseApply (op, opts) {\n    if (!(await this.profile.view.isFeatureSupported(FEATURES.DMS))) return null\n\n    switch (op.type) {\n      case AddPrivateMailboxRecordOperation.TYPE:\n        return this._applyAddPrivateMailboxRecordOperation(op, opts)\n      case UpdatePrivateMailboxRecordOperation.TYPE:\n        return this._applyUpdatePrivateMailboxRecordOperation(op, opts)\n      default:\n    }\n  }\n\n  async autobaseIndex ({ prev, next, id }) {\n    await this._indexCounter(prev, next, id)\n    await this._indexPublicMail(prev, next, id)\n    await this._indexReceiverDm(prev, next, id)\n  }\n\n  async autobaseIndexSent ({ prev, next, id }) {\n    await this._indexCounter(prev, next, id)\n    await this._indexSenderDm(prev, next, id)\n  }\n}\nconst safetyCatch = require('safety-catch')\nconst { PrivateRoomSchema } = require('@holepunchto/keet-core-schemas')\n\nconst {\n  AddPrivateRoomOperation,\n  RemovePrivateRoomOperation\n} = PrivateRoomSchema.Operations\n\nmodule.exports = class PrivateRooms {\n  static Operations = new Set([\n    AddPrivateRoomOperation.TYPE,\n    RemovePrivateRoomOperation.TYPE\n  ])\n\n  constructor (profile) {\n    this.profile = profile\n\n    this.rooms = null\n  }\n\n  initialize () {\n    this.rooms = this.profile.view.collections.privateRooms\n  }\n\n  async _applyAddPrivateRoomOperation (op) {\n    const { key } = op.value\n\n    await this.rooms.update(key, { key }, { upsert: true })\n  }\n\n  async _applyRemovePrivateRoomOperation (op) {\n    const { key } = op.value\n    try {\n      // TODO: Would ideally be a hyperindex change but this is quicker until we use hyperdb\n      await this.rooms.delete(key)\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  // Autobase API\n\n  async autobaseApply (op, opts) {\n    switch (op.type) {\n      case AddPrivateRoomOperation.TYPE:\n        return this._applyAddPrivateRoomOperation(op, opts)\n      case RemovePrivateRoomOperation.TYPE:\n        return this._applyRemovePrivateRoomOperation(op, opts)\n      default:\n    }\n  }\n}\nconst b4a = require('b4a')\nconst { ReactionSchema } = require('@holepunchto/keet-core-schemas')\n\nconst {\n  AddReactionOperation,\n  RemoveReactionOperation\n} = ReactionSchema.Operations\n\nconst MAX_DIGEST_COUNTS = 32\nconst MAX_LATEST_REACTIONS = 3\n\nconst EMPTY = b4a.alloc(1)\n\nmodule.exports = class Reactions {\n  static Operations = new Set([\n    AddReactionOperation.TYPE,\n    RemoveReactionOperation.TYPE\n  ])\n\n  constructor (view) {\n    this.view = view\n    this.chat = null\n    this.members = null\n\n    this.reactions = null\n    this.reactionDigests = null\n    this.reactionsByMember = null\n  }\n\n  initialize () {\n    this.chat = this.view.chat\n    this.members = this.view.members\n\n    this.reactions = this.view.collections.reactions\n    this.reactionDigests = this.view.indexes.reactionDigests\n    this.reactionsByMember = this.view.indexes.reactionsByMember\n  }\n\n  async _applyAddReactionOperation (op, { id }) {\n    const { to, text } = op.value\n\n    const [member, eventId, isMuted] = await Promise.all([\n      this.members.getMemberForDeviceKey(id.key),\n      this.chat.getEventId(to),\n      this.members.isDeviceMuted(id.key)\n    ])\n    if (isMuted || !member || !eventId) return\n\n    await this.reactions.update([...eventId, member.key, text], EMPTY, { upsert: true })\n  }\n\n  async _applyRemoveReactionOperation (op, { id }) {\n    const { to, text } = op.value\n\n    const [member, eventId, isMuted] = await Promise.all([\n      this.members.getMemberForDeviceKey(id.key),\n      this.chat.getEventId(to),\n      this.members.isDeviceMuted(id.key)\n    ])\n    if (isMuted) return\n    if (!member || !eventId) return\n    if (!member || !eventId) return\n\n    const existing = await this.reactions.get([...eventId, member.key, text])\n    if (!existing) return\n\n    await this.reactions.delete([...eventId, member.key, text])\n  }\n\n  async _indexReactionDigests (prev, next, id) {\n    const [chatThread, chatSeq, fromKey, text] = id\n    const memberIndexKey = [chatThread, chatSeq, fromKey]\n    const digestIndexKey = [chatThread, chatSeq]\n\n    const memberReactionsNode = await this.reactionsByMember.get(memberIndexKey)\n    const reactions = memberReactionsNode?.value\n\n    const digestNode = await this.reactionDigests.get(digestIndexKey)\n    const digest = digestNode ? digestNode.value : createDigest()\n\n    if (prev && next) return\n    if (prev) {\n      deleteReaction(digest, fromKey, text)\n      if (reactions && (reactions.length <= 1)) {\n        digest.total -= 1\n      }\n    }\n    if (next) {\n      insertReaction(digest, fromKey, text)\n      if (!reactions) {\n        digest.total += 1\n      }\n    }\n\n    if (digest.total > 0) {\n      await this.reactionDigests.insert(digestIndexKey, digest)\n    } else {\n      await this.reactionDigests.delete(digestIndexKey)\n    }\n  }\n\n  async _indexReactionsByMember (prev, next, id) {\n    const [chatThread, chatSeq, fromKey, text] = id\n    const memberIndexKey = [chatThread, chatSeq, fromKey]\n\n    const reactionsNode = await this.reactionsByMember.get(memberIndexKey)\n    const reactions = reactionsNode?.value\n\n    // Need to check for reactions also here due to a reactions corruption bug on v1\n    if (prev && reactions) {\n      const idx = reactions.indexOf(text)\n      if (idx !== -1) {\n        reactions.splice(idx, 1)\n        if (reactions.length > 0) {\n          await this.reactionsByMember.insert(memberIndexKey, reactions)\n        } else {\n          await this.reactionsByMember.delete(memberIndexKey)\n        }\n      }\n    }\n    if (next) {\n      if (!reactions) {\n        await this.reactionsByMember.insert(memberIndexKey, [text])\n      } else if (reactions.indexOf(text) === -1) {\n        reactions.push(text)\n        reactions.sort()\n        await this.reactionsByMember.insert(memberIndexKey, reactions)\n      }\n    }\n  }\n\n  // Autobase API\n\n  autobaseApply (op, opts) {\n    switch (op.type) {\n      case AddReactionOperation.TYPE:\n        return this._applyAddReactionOperation(op, opts)\n      case RemoveReactionOperation.TYPE:\n        return this._applyRemoveReactionOperation(op, opts)\n      default:\n    }\n  }\n\n  async autobaseIndex ({ prev, next, id }) {\n    // These must be run serially, because the digest indexing depends on the member count\n    await this._indexReactionDigests(prev, next, id)\n    await this._indexReactionsByMember(prev, next, id)\n  }\n}\n\nfunction insertReaction (digest, key, text) {\n  const idx = digest.reactions.findIndex(r => r.text === text)\n  if (idx !== -1) {\n    const reaction = digest.reactions[idx]\n    reaction.count += 1\n    reaction.latest.unshift(key)\n    if (reaction.latest.length > MAX_LATEST_REACTIONS) {\n      reaction.latest.pop()\n    }\n  } else {\n    digest.reactions.push({\n      text,\n      count: 1,\n      latest: [key]\n    })\n  }\n\n  if (digest.reactions.length > MAX_DIGEST_COUNTS) {\n    digest.reactions.pop()\n  }\n\n  digest.reactions.sort()\n}\n\nfunction deleteReaction (digest, key, text) {\n  const idx = digest.reactions.findIndex(r => r.text === text)\n  if (idx === -1) return\n\n  const reaction = digest.reactions[idx]\n  reaction.count -= 1\n\n  if (reaction.count > 0) {\n    const latestIdx = reaction.latest.findIndex(k => equalMemberIds(k, key))\n    if (latestIdx !== -1) {\n      reaction.latest.splice(latestIdx, 1)\n    }\n  } else {\n    digest.reactions.splice(idx, 1)\n  }\n\n  digest.reactions.sort()\n}\n\nfunction createDigest () {\n  return { total: 0, reactions: [] }\n}\n\nfunction equalMemberIds (id1, id2) {\n  return b4a.equals(id1, id2)\n}\n{\n  \"name\": \"@holepunchto/keet-indexing\",\n  \"version\": \"5.14.4\",\n  \"description\": \"Indexing logic for Keet's Autobase DB\",\n  \"main\": \"index.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/keet-core-indexing.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"UNLICENSED\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/keet-core-indexing/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/keet-core-indexing#readme\",\n  \"dependencies\": {\n    \"blind-pairing-core\": \"^2.0.0\",\n    \"@holepunchto/hyperindex\": \"^2.2.0\",\n    \"@holepunchto/keet-core-api\": \"^1.28.0\",\n    \"@holepunchto/keet-core-schemas\": \"^2.13.0\",\n    \"@holepunchto/keet-identity-key\": \"^3.0.0\",\n    \"b4a\": \"^1.6.4\",\n    \"compact-encoding\": \"^2.12.0\",\n    \"hyperbee\": \"^2.19.0\",\n    \"sub-encoder\": \"^2.1.3\",\n    \"tiny-buffer-map\": \"^1.1.1\"\n  },\n  \"obfs\": {\n    \"exclude\": [\n      \"node_modules\",\n      \"scripts\"\n    ],\n    \"include\": [\n      \"index.js\",\n      \"lib\",\n      \"node_modules/@holepunchto/hyperindex\",\n      \"node_modules/@holepunchto/keet-default-config\"\n    ]\n  },\n  \"devDependencies\": {\n    \"standard\": \"^17.1.0\"\n  }\n}\nconst SubEncoder = require('sub-encoder')\nconst c = require('compact-encoding')\n\nconst { PluginSchema } = require('@holepunchto/keet-core-schemas')\nconst { PluginOperation } = PluginSchema.Operations\n\nmodule.exports = class KVStorePlugin {\n  static PLUGIN_NAME = '@holepunchto/kv-store'\n\n  constructor (view, prefix) {\n    this.view = view\n    this.prefix = prefix\n\n    this._enc = {\n      keyEncoding: new SubEncoder(prefix, c.raw.string),\n      valueEncoding: c.raw.string\n    }\n  }\n\n  _put (key, value) {\n    return this.view.bee.put(key, value, this._enc)\n  }\n\n  _del (key) {\n    return this.view.bee.del(key, this._enc)\n  }\n\n  apply (op) {\n    if ((op.type !== PluginOperation.TYPE) || (op.value.name !== this.constructor.PLUGIN_NAME)) return\n    const { type, key, value } = op.value.value\n\n    if (type === 'put') {\n      return this._put(key, value)\n    } else if (type === 'del') {\n      return this._del(key, value)\n    }\n  }\n}\nconst HyperIndex = require('@holepunchto/hyperindex')\nconst SubEncoder = require('sub-encoder')\nconst c = require('compact-encoding')\nconst safetyCatch = require('safety-catch')\n\nconst { PluginSchema, PrivateProfileSchema } = require('@holepunchto/keet-core-schemas')\nconst { PluginOperation } = PluginSchema.Operations\nconst {\n  AddDeviceAttestationOperation,\n  AddDeviceKeyOperation,\n  RemoveRoomOperation,\n  AddRoomOperation\n} = PrivateProfileSchema.Operations\n\nmodule.exports = class PrivateProfilePlugin {\n  static PLUGIN_NAME = '@holepunchto/private-profile'\n\n  constructor (view, prefix) {\n    this.view = view\n    this.prefix = prefix\n\n    this.dex = new HyperIndex(view.bee, {\n      writable: true,\n      sub: new SubEncoder(prefix)\n    })\n\n    this.dex.createCollections([\n      PrivateProfileSchema.AttestationsCollection,\n      PrivateProfileSchema.DeviceKeysCollection,\n      PrivateProfileSchema.RoomsCollection\n    ])\n    this.deviceAttestations = this.dex.collections[0]\n    this.deviceKeys = this.dex.collections[1]\n    this.rooms = this.dex.collections[2]\n  }\n\n  // Autobase Operations\n\n  async _applyAddDeviceAttestationOperation ({ devicePublicKey, attestation }, opts) {\n    const existing = await this.deviceAttestations.get(devicePublicKey)\n    if (existing) return\n\n    await this.deviceAttestations.update(devicePublicKey, attestation, { upsert: true })\n  }\n\n  async _applyAddDeviceKeyOperation ({ devicePublicKey }, opts) {\n    const existing = await this.deviceKeys.get(opts.id.key)\n    if (existing) return\n\n    await this.deviceKeys.update(opts.id.key, devicePublicKey, { upsert: true })\n  }\n\n  async _applyAddRoomOperation (op) {\n    await this.rooms.update(op.key, { key: op.key }, { upsert: true })\n  }\n\n  async _applyRemoveRoomOperation (op) {\n    try {\n      // TODO: Would ideally be a hyperindex change but this is quicker until we use hyperdb\n      await this.rooms.delete(op.key)\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async apply (op, opts) {\n    if ((op.type !== PluginOperation.TYPE) || (op.value.name !== this.constructor.PLUGIN_NAME)) return\n    const { type, value } = op.value.value\n    switch (type) {\n      case AddDeviceAttestationOperation.TYPE:\n        return this._applyAddDeviceAttestationOperation(c.decode(AddDeviceAttestationOperation, value), opts)\n      case AddDeviceKeyOperation.TYPE:\n        return this._applyAddDeviceKeyOperation(c.decode(AddDeviceKeyOperation, value), opts)\n      case AddRoomOperation.TYPE:\n        return this._applyAddRoomOperation(c.decode(AddRoomOperation, value), opts)\n      case RemoveRoomOperation.TYPE:\n        return this._applyRemoveRoomOperation(c.decode(RemoveRoomOperation, value), opts)\n      default:\n    }\n  }\n}\nconst SubEncoder = require('sub-encoder')\nconst c = require('compact-encoding')\n\nconst { ChatSchema } = require('@holepunchto/keet-core-schemas')\nconst { AddChatMessageOperation } = ChatSchema.Operations\n\nmodule.exports = class WordCountPlugin {\n  static PLUGIN_NAME = '@holepunchto/word-count'\n\n  constructor (view, prefix) {\n    this.view = view\n    this.prefix = prefix\n\n    this._enc = {\n      keyEncoding: new SubEncoder(prefix, c.raw.string),\n      valueEncoding: c.uint\n    }\n  }\n\n  async apply (op) {\n    if ((op.type !== AddChatMessageOperation.TYPE) || !op.value.text) return\n    const { text } = op.value\n\n    for (const word of text.split(' ')) {\n      const lower = word.toLowerCase()\n      const prev = await this.view.bee.get(word, this._enc)\n      await this.view.bee.put(lower, prev ? prev.value + 1 : 1, this._enc)\n    }\n  }\n}\nconst RPC = require('@hyperswarm/rpc')\nconst crypto = require('hypercore-crypto')\nconst idEncoding = require('hypercore-id-encoding')\n\nconst notifications = require('./lib/notifications')\nconst encoding = require('./lib/encoding')\n\nclass KeetRoomPush {\n  constructor (push, roomKey, roomDiscoveryKey) {\n    this.push = push\n    this.roomKey = roomKey\n    this.roomDiscoveryKey = roomDiscoveryKey\n    this.destroyed = false\n  }\n\n  async send (sender) {\n    try {\n      await this.push.send(sender, this.roomKey, this.roomDiscoveryKey)\n    } catch (err) {\n      if (this.destroyed) return\n      throw err\n    }\n  }\n\n  destroy () {\n    this.destroyed = true\n  }\n}\n\nmodule.exports = class KeetPush {\n  constructor (gatewayKeys = [], opts = {}) {\n    this.rpc = null\n    this.dht = opts.dht || null\n    this.gatewayKeys = gatewayKeys.map(idEncoding.decode)\n    this.destroyed = false\n  }\n\n  setDHT (dht) {\n    this.dht = dht\n  }\n\n  setGatewayKeys (keys) {\n    this.gatewayKeys = keys.map(idEncoding.decode)\n  }\n\n  room (roomKey, roomDiscoveryKey = crypto.discoveryKey(roomKey)) {\n    return new KeetRoomPush(this, roomKey, roomDiscoveryKey)\n  }\n\n  async send (sender, roomKey, roomDiscoveryKey = crypto.discoveryKey(roomKey)) {\n    if (this.destroyed) throw new Error('Destroyed')\n\n    const n = await notifications.send(sender, roomKey, roomDiscoveryKey)\n\n    if (this.destroyed) throw new Error('Destroyed')\n    if (this.gatewayKeys.length === 0) throw new Error('No server keys set')\n\n    const rpc = this._getRPC()\n    const offset = Math.floor(Math.random() * this.gatewayKeys.length)\n\n    let error = null\n\n    // try each twice!\n    for (let i = 0; i < 2 * this.gatewayKeys.length; i++) {\n      const gatewayKey = this.gatewayKeys[(i + offset) % this.gatewayKeys.length]\n\n      try {\n        return await rpc.request(gatewayKey, 'notify', n, {\n          timeout: 60000,\n          requestEncoding: encoding\n        })\n      } catch (err) {\n        error = err\n      }\n\n      if (this.destroyed) throw new Error('Destroyed')\n    }\n\n    throw error\n  }\n\n  _getRPC () {\n    if (this.rpc) return this.rpc\n    this.rpc = new RPC({ dht: this.dht, poolLinger: 60000 })\n    return this.rpc\n  }\n\n  destroy () {\n    this.destroyed = true\n    if (!this.rpc) return Promise.resolve()\n    return this.rpc.destroy()\n  }\n\n  static requestEncoding = encoding\n\n  static receive (corestoreStoragePath, buffer, opts = {}) {\n    return notifications.receive(corestoreStoragePath, buffer, opts)\n  }\n}\nconst ce = require('compact-encoding')\nconst defaultAppId = 'io.keet.app'\nconst appId = (global.Pear ? global.Pear.config.appId : null) || defaultAppId\n\nmodule.exports = {\n  preencode (state, value) {\n    ce.uint.preencode(state, value.version)\n    ce.fixed32.preencode(state, value.roomDiscoveryKey)\n    ce.buffer.preencode(state, value.payload)\n    if (appId !== defaultAppId) ce.string.preencode(state, appId)\n  },\n  encode (state, value) {\n    ce.uint.encode(state, value.version)\n    ce.fixed32.encode(state, value.roomDiscoveryKey)\n    ce.buffer.encode(state, value.payload)\n    if (appId !== defaultAppId) ce.string.encode(state, appId)\n  },\n  decode (state) {\n    const version = ce.uint.decode(state)\n    if (version !== 0) throw new Error('Unknown version: ' + version)\n\n    const roomDiscoveryKey = ce.fixed32.decode(state)\n    const payload = ce.buffer.decode(state)\n    const appId = state.start < state.end ? ce.string.decode(state) : defaultAppId\n\n    return { version, roomDiscoveryKey, payload, appId }\n  }\n}\nconst Hypercore = require('hypercore')\nconst b4a = require('b4a')\nconst sodium = require('sodium-native')\nconst crypto = require('hypercore-crypto')\nconst ce = require('compact-encoding')\nconst path = require('path')\nconst encoding = require('./encoding')\n\nconst BlockEncryption = require('hypercore/lib/block-encryption.js')\nconst messages = require('hypercore/lib/messages.js')\nconst { OplogMessage } = require('autobase/lib/messages.js')\n\nconst { KeetSchema, ChatSchema } = require('@holepunchto/keet-core-schemas')\nconst { GENERIC_EVENTS } = require('@holepunchto/keet-core-api')\nconst { KeetOplogMessage } = KeetSchema.Messages\nconst { AddChatMessageOperation, AddGenericEventOperation, AddFileOperation } = ChatSchema.Operations\n\nconst [NS_BLINDING] = crypto.namespace('keet/notications', 1)\n\n// firebase limit is 4000, apple is 4096\n// leave room for discoveryKey + version + wiggle room for safety\nconst MAX_PAYLOAD_SIZE = 4000 - 32 - 1 - 16\n\nexports.send = async function send (sender, roomKey, roomDiscoveryKey) {\n  if (sender.length === 0) return\n  const index = sender.length - 1\n  const block = await sender.core.blocks.get(index, null)\n\n  let payload = await encryptNotificationProof(sender, roomKey, block, index)\n  if (payload.byteLength > MAX_PAYLOAD_SIZE) {\n    payload = await encryptNotificationProof(sender, roomKey, null, 0)\n  }\n\n  return { version: 0, roomDiscoveryKey, payload }\n}\n\nexports.receive = async function receive (corestoreStoragePath, buffer, opts = {}) {\n  const log = opts.log || noop\n\n  try {\n    const { version, roomDiscoveryKey, payload } = ce.decode(encoding, buffer)\n    if (version !== 0) {\n      log('version is not 0')\n      return null\n    }\n\n    const info = await getRoomInfo(corestoreStoragePath, roomDiscoveryKey)\n    if (info === null) {\n      log('info is null')\n      return null\n    }\n\n    const msg = decrypt(info.roomKey, payload)\n    if (msg === null) {\n      log('decrypt is null')\n      return null\n    }\n\n    const result = await verifyNotificationProof(corestoreStoragePath, msg, info)\n    if (!result) {\n      log('result is null')\n      return null\n    }\n\n    result.id = result.sender.id + (result.index !== -1 ? '/b' + result.index : '/l' + result.sender.length)\n    result.room = {\n      key: info.roomKey,\n      title: info.roomTitle\n    }\n\n    return result\n  } catch (err) {\n    log(`error=${err.message} at\\n${err.stack}`)\n  }\n\n  return null\n}\n\nfunction createCore (corestoreStoragePath, discoveryKey) {\n  const a = discoveryKey[0].toString(16).padStart(2, '0')\n  const b = discoveryKey[1].toString(16).padStart(2, '0')\n\n  const corePath = path.join(corestoreStoragePath, 'cores', a, b, b4a.toString(discoveryKey, 'hex'))\n  return new Hypercore(corePath, { unlocked: true, createIfMissing: false })\n}\n\nasync function getRoomInfo (corestoreStoragePath, roomDiscoveryKey) {\n  const coreRoom = createCore(corestoreStoragePath, roomDiscoveryKey)\n\n  try {\n    await coreRoom.ready()\n\n    if (!(await isActive(coreRoom))) return null\n    const roomKey = coreRoom.key\n    const title = await coreRoom.getUserData('@holepunchto/keet-core/room-title') || await coreRoom.getUserData('room-title')\n    const encryptionKey = await coreRoom.getUserData('autobase/encryption')\n    const roomTitle = title ? b4a.toString(title) : null\n\n    return { roomKey, encryptionKey, roomTitle }\n  } finally {\n    await coreRoom.close()\n  }\n}\n\nasync function isActive (core) {\n  const status = await core.getUserData('@holepunchto/keet-core/status')\n  if (!status) return true\n  return status.byteLength !== 1 || status[0] !== 0\n}\n\nfunction generateBlindingKey (roomKey) {\n  const blindingKey = b4a.allocUnsafe(sodium.crypto_aead_xchacha20poly1305_ietf_KEYBYTES)\n  sodium.crypto_generichash(blindingKey, b4a.concat([NS_BLINDING, roomKey]))\n  return blindingKey\n}\n\nfunction encrypt (roomKey, msg) {\n  const secretKey = generateBlindingKey(roomKey)\n  const buffer = b4a.allocUnsafe(msg.byteLength + sodium.crypto_secretbox_MACBYTES + sodium.crypto_secretbox_NONCEBYTES)\n  const nonce = buffer.subarray(0, sodium.crypto_secretbox_NONCEBYTES)\n  const box = buffer.subarray(nonce.byteLength)\n\n  sodium.randombytes_buf(nonce)\n  sodium.crypto_secretbox_easy(box, msg, nonce, secretKey)\n\n  return buffer\n}\n\nfunction decrypt (roomKey, buffer) {\n  const secretKey = generateBlindingKey(roomKey)\n  const nonce = buffer.subarray(0, sodium.crypto_secretbox_NONCEBYTES)\n  const box = buffer.subarray(nonce.byteLength)\n  const msg = b4a.allocUnsafe(box.byteLength - sodium.crypto_secretbox_MACBYTES)\n\n  if (!sodium.crypto_secretbox_open_easy(msg, box, nonce, secretKey)) {\n    return null\n  }\n\n  return msg\n}\n\nasync function encryptNotificationProof (sender, roomKey, block, index) {\n  const proof = await sender.core.tree.proof({\n    block: block ? { index, nodes: 0 } : null,\n    upgrade: { start: 0, length: sender.length }\n  })\n\n  if (block) proof.block.value = block\n  proof.manifest = sender.core.header.manifest\n\n  const state = { buffer: null, start: 0, end: 0 }\n  const data = { request: 0, ...proof }\n\n  ce.fixed32.preencode(state, sender.discoveryKey)\n  messages.wire.data.preencode(state, data)\n\n  state.buffer = b4a.allocUnsafe(state.end)\n\n  ce.fixed32.encode(state, sender.discoveryKey)\n  messages.wire.data.encode(state, data)\n\n  return encrypt(roomKey, state.buffer)\n}\n\nasync function verifyNotificationProof (corestoreStoragePath, buffer, { roomKey, encryptionKey }) {\n  const state = { buffer, start: 0, end: buffer.byteLength }\n\n  const senderDiscoveryKey = ce.fixed32.decode(state)\n  const proof = messages.wire.data.decode(state)\n\n  const result = {\n    id: null, // set upstream\n    sender: {\n      id: null,\n      length: 0,\n      blocked: false,\n      self: false,\n      name: null\n    },\n    room: null, // set upstream\n    proof: {\n      discoveryKey: senderDiscoveryKey,\n      data: proof\n    },\n    index: -1,\n    message: null\n  }\n\n  let verified = false\n\n  const coreSender = createCore(corestoreStoragePath, senderDiscoveryKey)\n\n  try {\n    await coreSender.ready()\n\n    // if this is ourself skip\n    if (await coreSender.getUserData('@holepunchto/keet-core/self-member')) {\n      result.sender.self = true\n    }\n\n    // if blocked skip\n    if (await coreSender.getUserData('@holepunchto/keet-core/profile-blocked')) {\n      result.sender.blocked = true\n    }\n\n    result.sender.length = coreSender.length\n    result.sender.id = coreSender.id\n\n    const batch = await coreSender.core.tree.verifyFullyRemote(proof)\n    await coreSender.core._verifyBatchUpgrade(batch, proof.manifest)\n\n    if (proof.block) result.index = proof.block.index\n    const expectedRoomKey = await coreSender.getUserData('referrer')\n\n    if (expectedRoomKey !== null && b4a.equals(expectedRoomKey, roomKey) && batch.length > coreSender.length) {\n      // TODO: when rocks no need to filter out for the newness part proof wise\n      verified = true\n    }\n\n    const profileNameBuf = await coreSender.getUserData('@holepunchto/keet-core/profile-name')\n    if (profileNameBuf) result.sender.name = b4a.toString(profileNameBuf)\n\n    if (encryptionKey && proof.block.value && proof.manifest) {\n      result.message = decodeMessage(coreSender, encryptionKey, proof)\n    }\n  } finally {\n    await coreSender.close()\n  }\n\n  if (!verified) return null\n\n  return result\n}\n\nfunction getFirstOp (proof, senderKey, encryptionKey) {\n  const encryption = new BlockEncryption(encryptionKey, senderKey, { compat: false })\n  try {\n    const value = b4a.from(proof.block.value) // copy cause we wanna preserve the proof\n    encryption.decrypt(proof.block.index, value)\n\n    const baseOplogMsg = ce.decode(OplogMessage, value.subarray(8))\n    const keetOplogMsg = ce.decode(KeetOplogMessage, baseOplogMsg.node.value)\n    // only look at the first op (we don't send batches currently)\n    if (keetOplogMsg.ops.length === 0) return null\n\n    return keetOplogMsg.ops[0]\n  } catch {\n    return null\n  }\n}\n\nfunction decodeMessage (sender, encryptionKey, proof) {\n  const op = getFirstOp(proof, sender.key, encryptionKey)\n  if (op === null) return null\n\n  if (op.type === AddFileOperation.TYPE) { // file\n    return {\n      type: 'file',\n      chatText: null,\n      fileType: op.value.file.type\n    }\n  }\n\n  if (op.type === AddChatMessageOperation.TYPE) {\n    return {\n      type: 'text',\n      chatText: op.value.text,\n      fileType: null\n    }\n  }\n\n  if (op.type === AddGenericEventOperation.TYPE && op.value.type === GENERIC_EVENTS.CALL_STARTED) {\n    return {\n      type: 'call',\n      chatText: null,\n      fileType: null\n    }\n  }\n\n  return null\n}\n\nfunction noop () {}\n{\n  \"name\": \"@holepunchto/keet-push\",\n  \"version\": \"2.2.1\",\n  \"description\": \"Push notifications for Keet\",\n  \"scripts\": {\n    \"test\": \"standard && node test.js\"\n  },\n  \"imports\": {\n    \"path\": {\n      \"bare\": \"bare-path\",\n      \"default\": \"path\"\n    }\n  },\n  \"files\": [\n    \"index.d.ts\",\n    \"index.js\",\n    \"lib/**\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/keet-push.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/keet-push/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/keet-push\",\n  \"dependencies\": {\n    \"@holepunchto/keet-core-api\": \"^1.12.0\",\n    \"@holepunchto/keet-core-schemas\": \"^2.0.0\",\n    \"@hyperswarm/rpc\": \"^3.2.0\",\n    \"autobase\": \"^6.0.0\",\n    \"b4a\": \"^1.6.4\",\n    \"compact-encoding\": \"^2.11.0\",\n    \"hypercore\": \"^10.28.4\",\n    \"hypercore-crypto\": \"^3.3.1\",\n    \"hypercore-id-encoding\": \"^1.2.0\",\n    \"sodium-native\": \"^4.0.3\"\n  },\n  \"optionalDependencies\": {\n    \"bare-path\": \"^3.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.0\",\n    \"corestore\": \"^6.8.2\",\n    \"hyperdht\": \"^6.6.0\",\n    \"standard\": \"^17.1.0\"\n  }\n}\nconst EventEmitter = require('events')\nconst DHT = require('hyperdht')\nconst ProtomuxRPC = require('protomux-rpc')\nconst b4a = require('b4a')\n\nconst POOL_LINGER = 10000\n\nmodule.exports = class HyperswarmRPC {\n  constructor (options = {}) {\n    const {\n      valueEncoding,\n      seed,\n      keyPair = DHT.keyPair(seed),\n      bootstrap,\n      debug,\n      dht,\n      poolLinger = POOL_LINGER\n    } = options\n\n    this._dht = dht || new DHT({ keyPair, bootstrap, debug })\n    this._defaultKeyPair = keyPair\n    this._defaultValueEncoding = valueEncoding\n    this._autoDestroy = !dht\n    this._poolLinger = poolLinger\n\n    this._clients = new Set()\n    this._servers = new Set()\n\n    this._pool = new Map()\n  }\n\n  get dht () {\n    return this._dht\n  }\n\n  get defaultKeyPair () {\n    return this._defaultKeyPair\n  }\n\n  createServer (options = {}) {\n    const server = new Server(\n      this._dht,\n      this._defaultKeyPair,\n      this._defaultValueEncoding,\n      options\n    )\n\n    this._servers.add(server)\n    server.on('close', () => this._servers.delete(server))\n\n    return server\n  }\n\n  async request (publicKey, method, value, options) {\n    const ref = this._getCachedClient(publicKey, options)\n\n    ref.active()\n\n    try {\n      return ref.client.request(method, value, options)\n    } finally {\n      await ref.inactive()\n    }\n  }\n\n  event (publicKey, method, value, options) {\n    const ref = this._getCachedClient(publicKey, options)\n\n    ref.active()\n\n    try {\n      ref.client.event(method, value, options)\n    } finally {\n      ref.inactive()\n    }\n  }\n\n  connect (publicKey, options = {}) {\n    const client = new Client(\n      this._dht,\n      this._defaultValueEncoding,\n      publicKey,\n      options\n    )\n\n    this._clients.add(client)\n    client.on('close', () => this._clients.delete(client))\n\n    return client\n  }\n\n  async destroy (options = {}) {\n    if (!options.force) {\n      const closing = []\n\n      for (const server of this._servers) {\n        closing.push(server.close())\n      }\n\n      await Promise.allSettled(closing)\n    }\n\n    for (const client of this._clients.values()) {\n      client.destroy()\n    }\n\n    for (const ref of this._pool.values()) {\n      ref.destroy()\n    }\n\n    if (this._autoDestroy) await this._dht.destroy()\n  }\n\n  _getCachedClient (publicKey, options) {\n    const id = b4a.toString(publicKey, 'hex')\n    let ref = this._pool.get(id)\n\n    if (ref) return ref\n\n    ref = new ClientRef(this.connect(publicKey, options), this._poolLinger, () => {\n      if (this._pool.get(id) === ref) this._pool.delete(id)\n      ref.destroy()\n    })\n\n    this._pool.set(id, ref)\n\n    return ref\n  }\n}\n\nclass ClientRef {\n  constructor (client, poolLinger, oninactive) {\n    this.activity = 0\n    this.client = client\n    this.poolLinger = poolLinger\n    this.oninactive = oninactive\n    this.timeout = null\n    this.client.on('close', oninactive)\n  }\n\n  clear () {\n    if (this.timeout) clearTimeout(this.timeout)\n    this.timeout = null\n  }\n\n  destroy () {\n    if (this.destroyed) return\n    this.clear()\n    this.destroyed = true\n    this.client.destroy()\n  }\n\n  active () {\n    if (this.destroyed) return\n    this.clear()\n    this.activity++\n  }\n\n  inactive () {\n    if (this.destroyed) return\n    this.activity--\n    if (this.activity === 0) {\n      this.timeout = setTimeout(this.oninactive, this.poolLinger)\n    }\n  }\n}\n\nclass Client extends EventEmitter {\n  constructor (dht, defaultValueEncoding, publicKey, options = {}) {\n    super()\n\n    this._dht = dht\n    this._defaultValueEncoding = defaultValueEncoding\n    this._publicKey = publicKey\n\n    this._stream = this._dht.connect(publicKey, options)\n    this._stream.setKeepAlive(5000)\n\n    this._rpc = new ProtomuxRPC(this._stream, {\n      id: publicKey,\n      valueEncoding: this._defaultValueEncoding\n    })\n    this._rpc\n      .on('open', this._onopen.bind(this))\n      .on('close', this._onclose.bind(this))\n      .on('destroy', this._ondestroy.bind(this))\n\n    // For Hypercore replication\n    this._stream.userData = this._rpc.mux\n  }\n\n  _onopen () {\n    this.emit('open')\n  }\n\n  _onclose () {\n    this._stream.destroy()\n    this.emit('close')\n  }\n\n  _ondestroy () {\n    this.emit('destroy')\n  }\n\n  get dht () {\n    return this._dht\n  }\n\n  get rpc () {\n    return this._rpc\n  }\n\n  get closed () {\n    return this._rpc.closed\n  }\n\n  get mux () {\n    return this._rpc.mux\n  }\n\n  get stream () {\n    return this._rpc.stream\n  }\n\n  async request (method, value, options = {}) {\n    return this._rpc.request(method, value, options)\n  }\n\n  event (method, value, options = {}) {\n    this._rpc.event(method, value, options)\n  }\n\n  async end () {\n    await this._rpc.end()\n  }\n\n  destroy (err) {\n    this._rpc.destroy(err)\n  }\n}\n\nclass Server extends EventEmitter {\n  constructor (dht, defaultKeyPair, defaultValueEncoding, options = {}) {\n    super()\n\n    this._dht = dht\n    this._defaultKeyPair = defaultKeyPair\n    this._defaultValueEncoding = defaultValueEncoding\n\n    this._connections = new Set()\n    this._responders = new Map()\n\n    this._server = this._dht.createServer(options)\n    this._server\n      .on('close', this._onclose.bind(this))\n      .on('listening', this._onlistening.bind(this))\n      .on('connection', this._onconnection.bind(this))\n  }\n\n  _onclose () {\n    this._connections.clear()\n    this._responders.clear()\n\n    this.emit('close')\n  }\n\n  _onlistening () {\n    this.emit('listening')\n  }\n\n  _onconnection (stream) {\n    const rpc = new ProtomuxRPC(stream, {\n      id: this.publicKey,\n      valueEncoding: this._defaultValueEncoding\n    })\n\n    // For Hypercore replication\n    stream.userData = rpc.mux\n    stream.setKeepAlive(5000)\n\n    this._connections.add(rpc)\n    rpc.on('close', () => {\n      stream.destroy()\n      this._connections.delete(rpc)\n    })\n\n    for (const [method, { options, handler }] of this._responders) {\n      rpc.respond(method, options, wrap(handler, rpc))\n    }\n\n    this.emit('connection', rpc)\n  }\n\n  get dht () {\n    return this._dht\n  }\n\n  get closed () {\n    return this._server.closed\n  }\n\n  get publicKey () {\n    return this._server.publicKey\n  }\n\n  get connections () {\n    return this._connections\n  }\n\n  address () {\n    return this._server.address()\n  }\n\n  async listen (keyPair = this._defaultKeyPair) {\n    await this._server.listen(keyPair)\n  }\n\n  async close () {\n    await this._server.close()\n  }\n\n  respond (method, options, handler) {\n    if (handler === undefined) {\n      handler = options\n      options = {}\n    }\n\n    this._responders.set(method, { options, handler })\n\n    for (const rpc of this._connections) {\n      rpc.respond(method, options, wrap(handler, rpc))\n    }\n\n    return this\n  }\n\n  unrespond (method) {\n    this._responders.delete(method)\n\n    for (const rpc of this._connections) {\n      rpc.unrespond(method)\n    }\n\n    return this\n  }\n}\n\nfunction wrap (handler, rpc) {\n  return (request) => handler(request, rpc)\n}\n{\n  \"name\": \"@hyperswarm/rpc\",\n  \"version\": \"3.3.2\",\n  \"description\": \"RPC over the Hyperswarm DHT\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/rpc.git\"\n  },\n  \"author\": \"Kasper Isager Dalsgar <kasper@funktionel.co>\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/rpc/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/rpc#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.4\",\n    \"hyperdht\": \"^6.6.0\",\n    \"protomux-rpc\": \"^1.3.0\"\n  },\n  \"optionalDependencies\": {\n    \"bare-events\": \"^2.2.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.0\",\n    \"compact-encoding\": \"^2.6.1\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst { Pull, Push, HEADERBYTES, KEYBYTES, ABYTES } = require('sodium-secretstream')\nconst sodium = require('sodium-universal')\nconst crypto = require('hypercore-crypto')\nconst { Duplex, Writable, getStreamError } = require('streamx')\nconst b4a = require('b4a')\nconst Timeout = require('timeout-refresh')\nconst unslab = require('unslab')\nconst Bridge = require('./lib/bridge')\nconst Handshake = require('./lib/handshake')\n\nconst IDHEADERBYTES = HEADERBYTES + 32\nconst [NS_INITIATOR, NS_RESPONDER, NS_SEND] = crypto.namespace('hyperswarm/secret-stream', 3)\nconst MAX_ATOMIC_WRITE = 256 * 256 * 256 - 1\n\nmodule.exports = class NoiseSecretStream extends Duplex {\n  constructor (isInitiator, rawStream, opts = {}) {\n    super({ mapWritable: toBuffer })\n\n    if (typeof isInitiator !== 'boolean') {\n      throw new Error('isInitiator should be a boolean')\n    }\n\n    this.noiseStream = this\n    this.isInitiator = isInitiator\n    this.rawStream = null\n\n    this.publicKey = opts.publicKey || null\n    this.remotePublicKey = opts.remotePublicKey || null\n    this.handshakeHash = null\n    this.connected = false\n    this.keepAlive = opts.keepAlive || 0\n    this.timeout = 0\n    this.enableSend = opts.enableSend !== false\n\n    // pointer for upstream to set data here if they want\n    this.userData = null\n\n    let openedDone = null\n    this.opened = new Promise((resolve) => { openedDone = resolve })\n\n    this.rawBytesWritten = 0\n    this.rawBytesRead = 0\n\n    // metadata used by 'hyperdht'\n    this.relay = null\n    this.puncher = null\n\n    // unwrapped raw stream\n    this._rawStream = null\n\n    // handshake state\n    this._handshake = null\n    this._handshakePattern = opts.pattern || null\n    this._handshakeDone = null\n\n    // message parsing state\n    this._state = 0\n    this._len = 0\n    this._tmp = 1\n    this._message = null\n\n    this._openedDone = openedDone\n    this._startDone = null\n    this._drainDone = null\n    this._outgoingPlain = null\n    this._outgoingWrapped = null\n    this._utp = null\n    this._setup = true\n    this._ended = 2\n    this._encrypt = null\n    this._decrypt = null\n    this._timeoutTimer = null\n    this._keepAliveTimer = null\n    this._sendState = null\n\n    if (opts.autoStart !== false) this.start(rawStream, opts)\n\n    // wiggle it to trigger open immediately (TODO add streamx option for this)\n    this.resume()\n    this.pause()\n  }\n\n  static keyPair (seed) {\n    return Handshake.keyPair(seed)\n  }\n\n  static id (handshakeHash, isInitiator, id) {\n    return streamId(handshakeHash, isInitiator, id)\n  }\n\n  setTimeout (ms) {\n    if (!ms) ms = 0\n\n    this._clearTimeout()\n    this.timeout = ms\n\n    if (!ms || this.rawStream === null) return\n\n    this._timeoutTimer = Timeout.once(ms, destroyTimeout, this)\n    this._timeoutTimer.unref()\n  }\n\n  setKeepAlive (ms) {\n    if (!ms) ms = 0\n\n    this._clearKeepAlive()\n\n    this.keepAlive = ms\n\n    if (!ms || this.rawStream === null) return\n\n    this._keepAliveTimer = Timeout.on(ms, sendKeepAlive, this)\n    this._keepAliveTimer.unref()\n  }\n\n  sendKeepAlive () {\n    const empty = this.alloc(0)\n    this.write(empty)\n  }\n\n  start (rawStream, opts = {}) {\n    if (rawStream) {\n      this.rawStream = rawStream\n      this._rawStream = rawStream\n      if (typeof this.rawStream.setContentSize === 'function') {\n        this._utp = rawStream\n      }\n    } else {\n      this.rawStream = new Bridge(this)\n      this._rawStream = this.rawStream.reverse\n    }\n\n    this.rawStream.on('error', this._onrawerror.bind(this))\n    this.rawStream.on('close', this._onrawclose.bind(this))\n\n    this._startHandshake(opts.handshake, opts.keyPair || null)\n    this._continueOpen(null)\n\n    if (this.destroying) return\n\n    if (opts.data) this._onrawdata(opts.data)\n    if (opts.ended) this._onrawend()\n\n    if (this.keepAlive > 0 && this._keepAliveTimer === null) {\n      this.setKeepAlive(this.keepAlive)\n    }\n\n    if (this.timeout > 0 && this._timeoutTimer === null) {\n      this.setTimeout(this.timeout)\n    }\n  }\n\n  async flush () {\n    if ((await this.opened) === false) return false\n    if ((await Writable.drained(this)) === false) return false\n    if (this.destroying) return false\n\n    if (this.rawStream !== null && this.rawStream.flush) {\n      return await this.rawStream.flush()\n    }\n\n    return true\n  }\n\n  _continueOpen (err) {\n    if (err) this.destroy(err)\n    if (this._startDone === null) return\n    const done = this._startDone\n    this._startDone = null\n    this._open(done)\n  }\n\n  _onkeypairpromise (p) {\n    const self = this\n    const cont = this._continueOpen.bind(this)\n\n    p.then(onkeypair, cont)\n\n    function onkeypair (kp) {\n      self._onkeypair(kp)\n      cont(null)\n    }\n  }\n\n  _onkeypair (keyPair) {\n    const pattern = this._handshakePattern || 'XX'\n    const remotePublicKey = this.remotePublicKey\n\n    this._handshake = new Handshake(this.isInitiator, keyPair, remotePublicKey, pattern)\n    this.publicKey = this._handshake.keyPair.publicKey\n  }\n\n  _startHandshake (handshake, keyPair) {\n    if (handshake) {\n      const { tx, rx, hash, publicKey, remotePublicKey } = handshake\n      this._setupSecretStream(tx, rx, hash, publicKey, remotePublicKey)\n      return\n    }\n\n    if (!keyPair) keyPair = Handshake.keyPair()\n\n    if (typeof keyPair.then === 'function') {\n      this._onkeypairpromise(keyPair)\n    } else {\n      this._onkeypair(keyPair)\n    }\n  }\n\n  _onrawerror (err) {\n    this.destroy(err)\n  }\n\n  _onrawclose () {\n    if (this._ended !== 0) this.destroy()\n  }\n\n  _onrawdata (data) {\n    let offset = 0\n\n    if (this._timeoutTimer !== null) {\n      this._timeoutTimer.refresh()\n    }\n\n    do {\n      switch (this._state) {\n        case 0: {\n          while (this._tmp !== 0x1000000 && offset < data.byteLength) {\n            const v = data[offset++]\n            this._len += this._tmp * v\n            this._tmp *= 256\n          }\n\n          if (this._tmp === 0x1000000) {\n            this._tmp = 0\n            this._state = 1\n            const unprocessed = data.byteLength - offset\n            if (unprocessed < this._len && this._utp !== null) this._utp.setContentSize(this._len - unprocessed)\n          }\n\n          break\n        }\n\n        case 1: {\n          const missing = this._len - this._tmp\n          const end = missing + offset\n\n          if (this._message === null && end <= data.byteLength) {\n            this._message = data.subarray(offset, end)\n            offset += missing\n            this._incoming()\n            break\n          }\n\n          const unprocessed = data.byteLength - offset\n\n          if (this._message === null) {\n            this._message = b4a.allocUnsafe(this._len)\n          }\n\n          b4a.copy(data, this._message, this._tmp, offset)\n          this._tmp += unprocessed\n\n          if (end <= data.byteLength) {\n            offset += missing\n            this._incoming()\n          } else {\n            offset += unprocessed\n          }\n\n          break\n        }\n      }\n    } while (offset < data.byteLength && !this.destroying)\n  }\n\n  _onrawend () {\n    this._ended--\n    this.push(null)\n  }\n\n  _onrawdrain () {\n    const drain = this._drainDone\n    if (drain === null) return\n    this._drainDone = null\n    drain()\n  }\n\n  _read (cb) {\n    this.rawStream.resume()\n    cb(null)\n  }\n\n  _incoming () {\n    const message = this._message\n\n    this._state = 0\n    this._len = 0\n    this._tmp = 1\n    this._message = null\n\n    if (this._setup === true) {\n      if (this._handshake) {\n        this._onhandshakert(this._handshake.recv(message))\n      } else {\n        if (message.byteLength !== IDHEADERBYTES) {\n          this.destroy(new Error('Invalid header message received'))\n          return\n        }\n\n        const remoteId = message.subarray(0, 32)\n        const expectedId = streamId(this.handshakeHash, !this.isInitiator)\n        const header = message.subarray(32)\n\n        if (!b4a.equals(expectedId, remoteId)) {\n          this.destroy(new Error('Invalid header received'))\n          return\n        }\n\n        this._decrypt.init(header)\n        this._setup = false // setup is now done\n      }\n      return\n    }\n\n    if (message.byteLength < ABYTES) {\n      this.destroy(new Error('Invalid message received'))\n      return\n    }\n\n    this.rawBytesRead += message.byteLength\n\n    const plain = message.subarray(1, message.byteLength - ABYTES + 1)\n\n    try {\n      this._decrypt.next(message, plain)\n    } catch (err) {\n      this.destroy(err)\n      return\n    }\n\n    // If keep alive is selective, eat the empty buffers (ie assume the other side has it enabled also)\n    if (plain.byteLength === 0 && this.keepAlive !== 0) return\n\n    if (this.push(plain) === false) {\n      this.rawStream.pause()\n    }\n  }\n\n  _onhandshakert (h) {\n    if (this._handshakeDone === null) return\n\n    if (h !== null) {\n      if (h.data) this._rawStream.write(h.data)\n      if (!h.tx) return\n    }\n\n    const done = this._handshakeDone\n    const publicKey = this._handshake.keyPair.publicKey\n\n    this._handshakeDone = null\n    this._handshake = null\n\n    if (h === null) return done(new Error('Noise handshake failed'))\n\n    this._setupSecretStream(h.tx, h.rx, h.hash, publicKey, h.remotePublicKey)\n    this._resolveOpened(true)\n    done(null)\n  }\n\n  _setupSecretStream (tx, rx, handshakeHash, publicKey, remotePublicKey) {\n    const buf = b4a.allocUnsafeSlow(3 + IDHEADERBYTES)\n    writeUint24le(IDHEADERBYTES, buf)\n\n    this._encrypt = new Push(unslab(tx.subarray(0, KEYBYTES)), undefined, buf.subarray(3 + 32))\n    this._decrypt = new Pull(unslab(rx.subarray(0, KEYBYTES)))\n\n    this.publicKey = publicKey\n    this.remotePublicKey = remotePublicKey\n    this.handshakeHash = handshakeHash\n\n    const id = buf.subarray(3, 3 + 32)\n    streamId(handshakeHash, this.isInitiator, id)\n\n    // initialize secretbox state for unordered messages\n    this._setupSecretSend(handshakeHash)\n\n    this.emit('handshake')\n    // if rawStream is a bridge, also emit it there\n    if (this.rawStream !== this._rawStream) this.rawStream.emit('handshake')\n\n    if (this.destroying) return\n\n    this._rawStream.write(buf)\n  }\n\n  _setupSecretSend (handshakeHash) {\n    this._sendState = b4a.allocUnsafeSlow(32 + 32 + 8 + 8)\n    const encrypt = this._sendState.subarray(0, 32) // secrets\n    const decrypt = this._sendState.subarray(32, 64)\n    const counter = this._sendState.subarray(64, 72) // nonce\n    const initial = this._sendState.subarray(72)\n\n    const inputs = this.isInitiator\n      ? [[NS_INITIATOR, NS_SEND], [NS_RESPONDER, NS_SEND]]\n      : [[NS_RESPONDER, NS_SEND], [NS_INITIATOR, NS_SEND]]\n\n    sodium.crypto_generichash_batch(encrypt, inputs[0], handshakeHash)\n    sodium.crypto_generichash_batch(decrypt, inputs[1], handshakeHash)\n\n    sodium.randombytes_buf(initial)\n    counter.set(initial)\n  }\n\n  _open (cb) {\n    // no autostart or no handshake yet\n    if (this._rawStream === null || (this._handshake === null && this._encrypt === null)) {\n      this._startDone = cb\n      return\n    }\n\n    this._rawStream.on('data', this._onrawdata.bind(this))\n    this._rawStream.on('end', this._onrawend.bind(this))\n    this._rawStream.on('drain', this._onrawdrain.bind(this))\n\n    if (this.enableSend) this._rawStream.on('message', this._onmessage.bind(this))\n\n    if (this._encrypt !== null) {\n      this._resolveOpened(true)\n      return cb(null)\n    }\n\n    this._handshakeDone = cb\n\n    if (this.isInitiator) this._onhandshakert(this._handshake.send())\n  }\n\n  _predestroy () {\n    if (this.rawStream) {\n      const error = getStreamError(this)\n      this.rawStream.destroy(error)\n    }\n\n    if (this._startDone !== null) {\n      const done = this._startDone\n      this._startDone = null\n      done(new Error('Stream destroyed'))\n    }\n\n    if (this._handshakeDone !== null) {\n      const done = this._handshakeDone\n      this._handshakeDone = null\n      done(new Error('Stream destroyed'))\n    }\n\n    if (this._drainDone !== null) {\n      const done = this._drainDone\n      this._drainDone = null\n      done(new Error('Stream destroyed'))\n    }\n  }\n\n  _write (data, cb) {\n    let wrapped = this._outgoingWrapped\n\n    if (data !== this._outgoingPlain) {\n      wrapped = b4a.allocUnsafe(data.byteLength + 3 + ABYTES)\n      wrapped.set(data, 4)\n    } else {\n      this._outgoingWrapped = this._outgoingPlain = null\n    }\n\n    if (wrapped.byteLength - 3 > MAX_ATOMIC_WRITE) {\n      return cb(new Error('Message is too large for an atomic write. Max size is ' + MAX_ATOMIC_WRITE + ' bytes.'))\n    }\n    this.rawBytesWritten += wrapped.byteLength\n\n    writeUint24le(wrapped.byteLength - 3, wrapped)\n    // offset 4 so we can do it in-place\n    this._encrypt.next(wrapped.subarray(4, 4 + data.byteLength), wrapped.subarray(3))\n\n    if (this._keepAliveTimer !== null) this._keepAliveTimer.refresh()\n\n    if (this._rawStream.write(wrapped) === false) {\n      this._drainDone = cb\n    } else {\n      cb(null)\n    }\n  }\n\n  _final (cb) {\n    this._clearKeepAlive()\n    this._ended--\n    this._rawStream.end()\n    cb(null)\n  }\n\n  _resolveOpened (val) {\n    if (this._openedDone === null) return\n    const opened = this._openedDone\n    this._openedDone = null\n    opened(val)\n    if (!val) return\n    this.connected = true\n    this.emit('connect')\n  }\n\n  _clearTimeout () {\n    if (this._timeoutTimer === null) return\n    this._timeoutTimer.destroy()\n    this._timeoutTimer = null\n    this.timeout = 0\n  }\n\n  _clearKeepAlive () {\n    if (this._keepAliveTimer === null) return\n    this._keepAliveTimer.destroy()\n    this._keepAliveTimer = null\n    this.keepAlive = 0\n  }\n\n  _destroy (cb) {\n    this._clearKeepAlive()\n    this._clearTimeout()\n    this._resolveOpened(false)\n    cb(null)\n  }\n\n  _boxMessage (buffer) {\n    const MB = sodium.crypto_secretbox_MACBYTES // 16\n    const NB = sodium.crypto_secretbox_NONCEBYTES // 24\n\n    const counter = this._sendState.subarray(64, 72)\n    sodium.sodium_increment(counter)\n    if (b4a.equals(counter, this._sendState.subarray(72))) {\n      this.destroy(new Error('udp send nonce exchausted'))\n      return\n    }\n\n    const secret = this._sendState.subarray(0, 32)\n    const envelope = b4a.allocUnsafe(8 + MB + buffer.byteLength)\n    const nonce = envelope.subarray(0, NB)\n    const ciphertext = envelope.subarray(8)\n\n    b4a.fill(nonce, 0) // pad suffix\n    nonce.set(counter)\n\n    sodium.crypto_secretbox_easy(ciphertext, buffer, nonce, secret)\n    return envelope\n  }\n\n  send (buffer) {\n    if (!this._sendState) return\n    if (!this.rawStream?.send) return // udx-stream expected\n\n    const message = this._boxMessage(buffer)\n    return this.rawStream.send(message)\n  }\n\n  trySend (buffer) {\n    if (!this._sendState) return\n    if (!this.rawStream?.trySend) return // udx-stream expected\n\n    const message = this._boxMessage(buffer)\n    this.rawStream.trySend(message)\n  }\n\n  _onmessage (buffer) {\n    if (!this._sendState) return // messages before handshake are dropped\n\n    const MB = sodium.crypto_secretbox_MACBYTES // 16\n    const NB = sodium.crypto_secretbox_NONCEBYTES // 24\n\n    if (buffer.byteLength < NB) return // Invalid message\n\n    const nonce = b4a.allocUnsafe(NB)\n    b4a.fill(nonce, 0)\n    nonce.set(buffer.subarray(0, 8))\n\n    const secret = this._sendState.subarray(32, 64)\n    const ciphertext = buffer.subarray(8)\n    const plain = buffer.subarray(8, buffer.byteLength - MB)\n\n    if (ciphertext.byteLength < MB) return // invalid message\n\n    const success = sodium.crypto_secretbox_open_easy(plain, ciphertext, nonce, secret)\n\n    if (success) this.emit('message', plain)\n  }\n\n  alloc (len) {\n    const buf = b4a.allocUnsafe(len + 3 + ABYTES)\n    this._outgoingWrapped = buf\n    this._outgoingPlain = buf.subarray(4, buf.byteLength - ABYTES + 1)\n    return this._outgoingPlain\n  }\n\n  toJSON () {\n    return {\n      isInitiator: this.isInitiator,\n      publicKey: this.publicKey && b4a.toString(this.publicKey, 'hex'),\n      remotePublicKey: this.remotePublicKey && b4a.toString(this.remotePublicKey, 'hex'),\n      connected: this.connected,\n      destroying: this.destroying,\n      destroyed: this.destroyed,\n      rawStream: this.rawStream && this.rawStream.toJSON ? this.rawStream.toJSON() : null\n    }\n  }\n}\n\nfunction writeUint24le (n, buf) {\n  buf[0] = (n & 255)\n  buf[1] = (n >>> 8) & 255\n  buf[2] = (n >>> 16) & 255\n}\n\nfunction streamId (handshakeHash, isInitiator, out = b4a.allocUnsafe(32)) {\n  sodium.crypto_generichash(out, isInitiator ? NS_INITIATOR : NS_RESPONDER, handshakeHash)\n  return out\n}\n\nfunction toBuffer (data) {\n  return typeof data === 'string' ? b4a.from(data) : data\n}\n\nfunction destroyTimeout () {\n  this.destroy(new Error('Stream timed out'))\n}\n\nfunction sendKeepAlive () {\n  const empty = this.alloc(0)\n  this.write(empty)\n}\nconst { Duplex, Writable } = require('streamx')\n\nclass ReversePassThrough extends Duplex {\n  constructor (s) {\n    super()\n    this._stream = s\n    this._ondrain = null\n  }\n\n  _write (data, cb) {\n    if (this._stream.push(data) === false) {\n      this._stream._ondrain = cb\n    } else {\n      cb(null)\n    }\n  }\n\n  _final (cb) {\n    this._stream.push(null)\n    cb(null)\n  }\n\n  _read (cb) {\n    const ondrain = this._ondrain\n    this._ondrain = null\n    if (ondrain) ondrain()\n    cb(null)\n  }\n}\n\nmodule.exports = class Bridge extends Duplex {\n  constructor (noiseStream) {\n    super()\n\n    this.noiseStream = noiseStream\n\n    this._ondrain = null\n    this.reverse = new ReversePassThrough(this)\n  }\n\n  get publicKey () {\n    return this.noiseStream.publicKey\n  }\n\n  get remotePublicKey () {\n    return this.noiseStream.remotePublicKey\n  }\n\n  get handshakeHash () {\n    return this.noiseStream.handshakeHash\n  }\n\n  flush () {\n    return Writable.drained(this)\n  }\n\n  _read (cb) {\n    const ondrain = this._ondrain\n    this._ondrain = null\n    if (ondrain) ondrain()\n    cb(null)\n  }\n\n  _write (data, cb) {\n    if (this.reverse.push(data) === false) {\n      this.reverse._ondrain = cb\n    } else {\n      cb(null)\n    }\n  }\n\n  _final (cb) {\n    this.reverse.push(null)\n    cb(null)\n  }\n}\nconst sodium = require('sodium-universal')\nconst curve = require('noise-curve-ed')\nconst Noise = require('noise-handshake')\nconst b4a = require('b4a')\n\nconst EMPTY = b4a.alloc(0)\n\nmodule.exports = class Handshake {\n  constructor (isInitiator, keyPair, remotePublicKey, pattern) {\n    this.isInitiator = isInitiator\n    this.keyPair = keyPair\n    this.noise = new Noise(pattern, isInitiator, keyPair, { curve })\n    this.noise.initialise(EMPTY, remotePublicKey)\n    this.destroyed = false\n  }\n\n  static keyPair (seed) {\n    const publicKey = b4a.alloc(32)\n    const secretKey = b4a.alloc(64)\n    if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)\n    else sodium.crypto_sign_keypair(publicKey, secretKey)\n    return { publicKey, secretKey }\n  }\n\n  recv (data) {\n    try {\n      this.noise.recv(data)\n      if (this.noise.complete) return this._return(null)\n      return this.send()\n    } catch {\n      this.destroy()\n      return null\n    }\n  }\n\n  // note that the data returned here is framed so we don't have to do an extra copy\n  // when sending it...\n  send () {\n    try {\n      const data = this.noise.send()\n      const wrap = b4a.allocUnsafe(data.byteLength + 3)\n\n      writeUint24le(data.byteLength, wrap)\n      wrap.set(data, 3)\n\n      return this._return(wrap)\n    } catch {\n      this.destroy()\n      return null\n    }\n  }\n\n  destroy () {\n    if (this.destroyed) return\n    this.destroyed = true\n  }\n\n  _return (data) {\n    const tx = this.noise.complete ? b4a.toBuffer(this.noise.tx) : null\n    const rx = this.noise.complete ? b4a.toBuffer(this.noise.rx) : null\n    const hash = this.noise.complete ? b4a.toBuffer(this.noise.hash) : null\n    const remotePublicKey = this.noise.complete ? b4a.toBuffer(this.noise.rs) : null\n\n    return {\n      data,\n      remotePublicKey,\n      hash,\n      tx,\n      rx\n    }\n  }\n}\n\nfunction writeUint24le (n, buf) {\n  buf[0] = (n & 255)\n  buf[1] = (n >>> 8) & 255\n  buf[2] = (n >>> 16) & 255\n}\n{\n  \"name\": \"@hyperswarm/secret-stream\",\n  \"version\": \"6.7.1\",\n  \"description\": \"Secret stream backed by Noise and libsodium's secretstream\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib/**.js\"\n  ],\n  \"dependencies\": {\n    \"b4a\": \"^1.1.0\",\n    \"hypercore-crypto\": \"^3.3.1\",\n    \"noise-curve-ed\": \"^2.0.1\",\n    \"noise-handshake\": \"^3.0.2\",\n    \"sodium-secretstream\": \"^1.1.0\",\n    \"sodium-universal\": \"^4.0.0\",\n    \"streamx\": \"^2.14.0\",\n    \"timeout-refresh\": \"^2.0.0\",\n    \"unslab\": \"^1.3.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.0\",\n    \"standard\": \"^17.1.0\",\n    \"udx-native\": \"^1.13.2\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/hyperswarm-secret-stream.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hyperswarm-secret-stream/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hyperswarm-secret-stream\"\n}\nconst b4a = require('b4a')\nconst ReadyResource = require('ready-resource')\nconst debounceify = require('debounceify')\nconst c = require('compact-encoding')\nconst safetyCatch = require('safety-catch')\nconst hypercoreId = require('hypercore-id-encoding')\nconst assert = require('nanoassert')\nconst SignalPromise = require('signal-promise')\nconst CoreCoupler = require('core-coupler')\nconst mutexify = require('mutexify/promise')\n\nconst Linearizer = require('./lib/linearizer')\nconst AutoStore = require('./lib/store')\nconst SystemView = require('./lib/system')\nconst messages = require('./lib/messages')\nconst Timer = require('./lib/timer')\nconst Writer = require('./lib/writer')\nconst ActiveWriters = require('./lib/active-writers')\nconst CorePool = require('./lib/core-pool')\nconst AutoWakeup = require('./lib/wakeup')\n\nconst WakeupExtension = require('./lib/extension')\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\nconst INTERRUPT = new Error('Apply interrupted')\n\nconst AUTOBASE_VERSION = 1\n\n// default is to automatically ack\nconst DEFAULT_ACK_INTERVAL = 10_000\nconst DEFAULT_ACK_THRESHOLD = 4\n\nconst FF_THRESHOLD = 16\nconst DEFAULT_FF_TIMEOUT = 10_000\n\nconst REMOTE_ADD_BATCH = 64\n\nmodule.exports = class Autobase extends ReadyResource {\n  constructor (store, bootstrap, handlers = {}) {\n    if (Array.isArray(bootstrap)) bootstrap = bootstrap[0] // TODO: just a quick compat, lets remove soon\n\n    if (bootstrap && typeof bootstrap !== 'string' && !b4a.isBuffer(bootstrap)) {\n      handlers = bootstrap\n      bootstrap = null\n    }\n\n    super()\n\n    this.bootstrap = bootstrap ? toKey(bootstrap) : null\n    this.keyPair = handlers.keyPair || null\n    this.valueEncoding = c.from(handlers.valueEncoding || 'binary')\n    this.store = store\n    this.globalCache = store.globalCache || null\n    this.encrypted = handlers.encrypted || !!handlers.encryptionKey\n    this.encrypt = !!handlers.encrypt\n    this.encryptionKey = handlers.encryptionKey || null\n\n    this._tryLoadingLocal = true\n    this._primaryBootstrap = null\n    if (this.bootstrap) {\n      this._primaryBootstrap = this.store.get({ key: this.bootstrap, compat: false, active: false, encryptionKey: this.encryptionKey })\n      this.wakeupExtension = new WakeupExtension(this, this._primaryBootstrap, true)\n      this.store = this.store.namespace(this._primaryBootstrap, { detach: false })\n    }\n\n    this.local = null\n    this.localWriter = null\n    this.isIndexer = false\n\n    this.activeWriters = new ActiveWriters()\n    this.corePool = new CorePool()\n    this.linearizer = null\n    this.updating = false\n\n    this.fastForwardEnabled = handlers.fastForward !== false\n    this.fastForwarding = 0\n    this.fastForwardTo = null\n\n    if (this.fastForwardEnabled && isObject(handlers.fastForward)) {\n      this.fastForwardTo = handlers.fastForward\n    }\n\n    this._bootstrapWriters = [] // might contain dups, but thats ok\n    this._bootstrapWritersChanged = false\n\n    this._checkWriters = []\n    this._appending = null\n    this._wakeup = new AutoWakeup(this)\n    this._wakeupHints = new Map()\n    this._wakeupPeerBound = this._wakeupPeer.bind(this)\n    this._coupler = null\n\n    this._queueViewReset = false\n    this._lock = mutexify()\n\n    this._applying = null\n    this._updatingCores = false\n    this._localDigest = null\n    this._needsWakeup = true\n    this._needsWakeupHeads = true\n    this._addCheckpoints = false\n    this._firstCheckpoint = true\n    this._hasPendingCheckpoint = false\n    this._completeRemovalAt = null\n    this._systemPointer = 0\n    this._maybeStaticFastForward = false // writer bumps this\n\n    this._updates = []\n    this._handlers = handlers || {}\n    this._warn = emitWarning.bind(this)\n\n    this._draining = false\n    this._advancing = null\n    this._advanced = null\n    this._interrupting = false\n\n    this.reindexing = false\n    this.paused = false\n\n    this._bump = debounceify(() => {\n      this._advancing = this._advance()\n      return this._advancing\n    })\n\n    this._onremotewriterchangeBound = this._onremotewriterchange.bind(this)\n\n    this.maxSupportedVersion = AUTOBASE_VERSION // working version\n\n    this._presystem = null\n    this._prebump = null\n\n    this._hasApply = !!this._handlers.apply\n    this._hasOpen = !!this._handlers.open\n    this._hasClose = !!this._handlers.close\n\n    this.onindex = handlers.onindex || noop\n\n    this._viewStore = new AutoStore(this)\n\n    this.view = null\n    this.system = null\n    this.version = -1\n    this.interrupted = null\n\n    const {\n      ackInterval = DEFAULT_ACK_INTERVAL,\n      ackThreshold = DEFAULT_ACK_THRESHOLD\n    } = handlers\n\n    this._ackInterval = ackInterval\n    this._ackThreshold = ackThreshold\n    this._ackTickThreshold = ackThreshold\n    this._ackTick = 0\n\n    this._ackTimer = null\n    this._acking = false\n\n    this._initialHeads = []\n    this._initialSystem = null\n    this._initialViews = null\n\n    this._waiting = new SignalPromise()\n\n    const sysCore = this._viewStore.get({ name: '_system', exclusive: true })\n\n    this.system = new SystemView(sysCore, {\n      checkout: 0\n    })\n\n    this.view = this._hasOpen ? this._handlers.open(this._viewStore, this) : null\n\n    this.ready().catch(safetyCatch)\n  }\n\n  [inspect] (depth, opts) {\n    let indent = ''\n    if (typeof opts.indentationLvl === 'number') {\n      while (indent.length < opts.indentationLvl) indent += ' '\n    }\n\n    return indent + 'Autobase { ... }'\n  }\n\n  // TODO: compat, will be removed\n  get bootstraps () {\n    return [this.bootstrap]\n  }\n\n  get writable () {\n    return this.localWriter !== null && !this.localWriter.isRemoved\n  }\n\n  get ackable () {\n    return this.localWriter !== null // prop should add .isIndexer but keeping it simple for now\n  }\n\n  get key () {\n    return this._primaryBootstrap === null ? this.local.key : this._primaryBootstrap.key\n  }\n\n  get discoveryKey () {\n    return this._primaryBootstrap === null ? this.local.discoveryKey : this._primaryBootstrap.discoveryKey\n  }\n\n  _isActiveIndexer () {\n    return this.localWriter ? this.localWriter.isActiveIndexer : false\n  }\n\n  replicate (init, opts) {\n    return this.store.replicate(init, opts)\n  }\n\n  heads () {\n    const nodes = new Array(this.system.heads.length)\n    for (let i = 0; i < this.system.heads.length; i++) nodes[i] = this.system.heads[i]\n    return nodes.sort(compareNodes)\n  }\n\n  // any pending indexers\n  hasPendingIndexers () {\n    if (this.system.pendingIndexers.length > 0) return true\n    return this.hasUnflushedIndexers()\n  }\n\n  // confirmed indexers that aren't in linearizer yet\n  hasUnflushedIndexers () {\n    if (this.linearizer.indexers.length !== this.system.indexers.length) return true\n\n    for (let i = 0; i < this.system.indexers.length; i++) {\n      const w = this.linearizer.indexers[i]\n      if (!b4a.equals(w.core.key, this.system.indexers[i].key)) return true\n    }\n\n    return false\n  }\n\n  hintWakeup (hints) {\n    if (!Array.isArray(hints)) hints = [hints]\n    for (const { key, length } of hints) {\n      const hex = b4a.toString(key, 'hex')\n      const prev = this._wakeupHints.get(hex)\n      if (!prev || length === -1 || prev < length) this._wakeupHints.set(hex, length)\n    }\n    this._queueBump()\n  }\n\n  _queueBump () {\n    this._bump().catch(safetyCatch)\n  }\n\n  async _openPreSystem () {\n    if (this._handlers.wait) await this._handlers.wait()\n    await this.store.ready()\n\n    const opts = {\n      valueEncoding: this.valueEncoding,\n      keyPair: this.keyPair,\n      key: this._primaryBootstrap ? await this._primaryBootstrap.getUserData('autobase/local') : null\n    }\n\n    this.local = Autobase.getLocalCore(this.store, opts, this.encryptionKey)\n\n    await this.local.ready()\n\n    if (this.encryptionKey) {\n      await this.local.setUserData('autobase/encryption', this.encryptionKey)\n    } else {\n      this.encryptionKey = await this.local.getUserData('autobase/encryption')\n      if (this.encrypt && this.encryptionKey === null) {\n        this.encryptionKey = (await this.store.createKeyPair('autobase/encryption')).secretKey.subarray(0, 32)\n        await this.local.setUserData('autobase/encryption', this.encryptionKey)\n      }\n      if (this.encryptionKey) {\n        await this.local.setEncryptionKey(this.encryptionKey)\n        // not needed but, just for good meassure\n        if (this._primaryBootstrap) this._primaryBootstrap.setEncryptionKey(this.encryptionKey)\n      }\n    }\n\n    if (this.encrypted) {\n      assert(this.encryptionKey !== null, 'Encryption key is expected')\n    }\n\n    // stateless open\n    const ref = await this.local.getUserData('referrer')\n    if (ref && !b4a.equals(ref, this.local.key) && !this._primaryBootstrap) {\n      this._primaryBootstrap = this.store.get({ key: ref, compat: false, active: false, encryptionKey: this.encryptionKey })\n      this.wakeupExtension = new WakeupExtension(this, this._primaryBootstrap, true)\n      this.store = this.store.namespace(this._primaryBootstrap, { detach: false })\n    }\n\n    await this.local.setUserData('referrer', this.key)\n\n    if (this._primaryBootstrap) {\n      await this._primaryBootstrap.ready()\n      this._primaryBootstrap.setUserData('autobase/local', this.local.key)\n      if (this.encryptionKey) await this._primaryBootstrap.setUserData('autobase/encryption', this.encryptionKey)\n    } else {\n      this.local.setUserData('autobase/local', this.local.key)\n      this.wakeupExtension = new WakeupExtension(this, this.local, true)\n    }\n\n    const { bootstrap, system, heads } = await this._loadSystemInfo()\n\n    this.version = system\n      ? system.version\n      : this.bootstrap && !b4a.equals(this.bootstrap, this.local.key)\n        ? -1\n        : this.maxSupportedVersion\n\n    this.bootstrap = bootstrap\n\n    this._initialSystem = system\n    this._initialHeads = heads\n\n    await this._makeLinearizer(system)\n  }\n\n  async _loadSystemInfo () {\n    const pointer = await this.local.getUserData('autobase/boot')\n    const bootstrap = this.bootstrap || (await this.local.getUserData('referrer')) || this.local.key\n    if (!pointer) return { bootstrap, system: null, heads: [] }\n\n    const { indexed, views, heads } = c.decode(messages.BootRecord, pointer)\n    const { key, length } = indexed\n\n    this._systemPointer = length\n\n    if (!length) return { bootstrap, system: null, heads: [] }\n\n    const encryptionKey = AutoStore.getBlockKey(bootstrap, this.encryptionKey, '_system')\n    const actualCore = this.store.get({ key, exclusive: false, compat: false, encryptionKey, isBlockKey: true })\n\n    await actualCore.ready()\n\n    const core = actualCore.batch({ checkout: length, session: false })\n\n    // safety check the batch is not corrupt\n    if (length === 0 || !(await core.has(length - 1))) {\n      await this.local.setUserData('autobase/boot', null)\n      this._systemPointer = 0\n      return { bootstrap, system: null, heads: [] }\n    }\n\n    const system = new SystemView(core, {\n      checkout: length\n    })\n\n    await system.ready()\n\n    if (system.version > this.maxSupportedVersion) {\n      throw new Error('Autobase upgrade required')\n    }\n\n    this._initialViews = [{ name: '_system', key, length }]\n\n    for (let i = 0; i < system.views.length; i++) {\n      this._initialViews.push({ name: views[i], ...system.views[i] })\n    }\n\n    return {\n      bootstrap,\n      system,\n      heads\n    }\n  }\n\n  interrupt (reason) {\n    assert(this._applying !== null, 'Interrupt is only allowed in apply')\n    this._interrupting = true\n    if (reason) this.interrupted = reason\n    throw INTERRUPT\n  }\n\n  async flush () {\n    if (this.opened === false) await this.ready()\n    await this._advancing\n  }\n\n  getSystemKey () {\n    const core = this.system.core.getBackingCore()\n    return core ? core.key : null\n  }\n\n  recouple () {\n    if (this._coupler) this._coupler.destroy()\n    const core = this.system.core.getBackingCore()\n    this._coupler = new CoreCoupler(core.session, this._wakeupPeerBound)\n  }\n\n  _updateBootstrapWriters () {\n    const writers = this.linearizer.getBootstrapWriters()\n\n    // first clear all, but without applying it for churn reasons\n    for (const writer of this._bootstrapWriters) writer.isBootstrap = false\n\n    // all passed are bootstraps\n    for (const writer of writers) writer.setBootstrap(true)\n\n    // reset activity on old ones, all should be in sync now\n    for (const writer of this._bootstrapWriters) {\n      if (writer.isBootstrap === false) writer.setBootstrap(false)\n    }\n\n    this._bootstrapWriters = writers\n    this._bootstrapWritersChanged = false\n  }\n\n  async _openPreBump () {\n    this._presystem = this._openPreSystem()\n\n    try {\n      await this._presystem\n      await this._viewStore.flush()\n    } catch (err) {\n      safetyCatch(err)\n      if (err.code === 'ELOCKED') throw err\n      await this.local.setUserData('autobase/last-error', b4a.from(err.stack + ''))\n      await this.local.setUserData('autobase/boot', null)\n      this.store.close().catch(safetyCatch)\n      throw err\n    }\n\n    // see if we can load from indexer checkpoint\n    await this.system.ready()\n\n    if (this._initialSystem) {\n      await this._initialSystem.close()\n      this._initialSystem = null\n      this._initialViews = null\n    }\n\n    // check if this is a v0 base\n    const record = await this.local.getUserData('autobase/system')\n    if (record !== null && (await this.local.getUserData('autobase/reindexed')) === null) {\n      this.reindexing = true\n      this.emit('reindexing')\n      this._onreindexing(record).catch(safetyCatch)\n    }\n\n    // load previous digest if available\n    if (this.localWriter && !this.system.bootstrapping) {\n      await this._restoreLocalState()\n    }\n\n    this.recouple()\n\n    if (this.fastForwardTo !== null) {\n      const { key, timeout } = this.fastForwardTo\n      this.fastForwardTo = null // will get reset once ready\n      this.initialFastForward(key, timeout || DEFAULT_FF_TIMEOUT * 2)\n    }\n\n    if (this.localWriter && this._ackInterval) this._startAckTimer()\n  }\n\n  async _onreindexing (record) {\n    const { key, length } = messages.Checkout.decode({ buffer: record, start: 0, end: record.byteLength })\n    const encryptionKey = this._viewStore.getBlockKey(this._viewStore.getSystemCore().name)\n    const core = this.store.get({ key, encryptionKey, isBlockKey: true }).batch({ checkout: length, session: false })\n\n    const base = this\n    const system = new SystemView(core, {\n      checkout: length\n    })\n\n    await system.ready()\n\n    const indexerCores = []\n    for (const { key } of system.indexers) {\n      const core = this.store.get({ key, compat: false, valueEncoding: messages.OplogMessage, encryptionKey: this.encryptionKey })\n      indexerCores.push(core)\n    }\n\n    await system.close()\n\n    for (const core of indexerCores) tail(core).catch(safetyCatch)\n\n    async function onsyskey (key) {\n      for (const core of indexerCores) await core.close()\n      if (key === null || !base.reindexing || base._isFastForwarding()) return\n      base.initialFastForward(key, DEFAULT_FF_TIMEOUT * 2)\n    }\n\n    async function tail (core) {\n      await core.ready()\n\n      while (base.reindexing && !base._isFastForwarding()) {\n        const seq = core.length - 1\n        const blk = seq >= 0 ? await core.get(seq) : null\n        if (blk && blk.version >= 1) {\n          const sysKey = await getSystemKey(core, seq, blk)\n          if (sysKey) return onsyskey(sysKey)\n        }\n\n        await core.get(core.length) // force get next blk\n      }\n\n      return onsyskey(null)\n    }\n\n    async function getSystemKey (core, seq, blk) {\n      if (!blk.digest) return null\n      if (blk.digest.key) return blk.digest.key\n      const p = await core.get(seq - blk.digest.pointer)\n      return p.digest && p.digest.key\n    }\n  }\n\n  async _restoreLocalState () {\n    const version = await this.localWriter.getVersion()\n    if (version > this.maxSupportedVersion) {\n      this.store.close().catch(safetyCatch)\n      throw new Error('Autobase version cannot be downgraded')\n    }\n\n    await this._updateDigest()\n  }\n\n  async _open () {\n    this._prebump = this._openPreBump()\n    await this._prebump\n\n    await this._catchup(this._initialHeads)\n\n    await this._wakeup.ready()\n\n    this.system.requestWakeup()\n\n    // queue a full bump that handles wakeup etc (not legal to wait for that here)\n    this._queueBump()\n    this._advanced = this._advancing\n\n    if (this.reindexing) this._setReindexed()\n\n    this.queueFastForward()\n    this._updateBootstrapWriters()\n  }\n\n  async _catchup (nodes) {\n    if (!nodes.length) return\n\n    const visited = new Set()\n    const writers = new Map()\n\n    while (nodes.length) {\n      const { key, length } = nodes.pop()\n\n      const hex = b4a.toString(key, 'hex')\n      const ref = hex + ':' + length\n\n      if (visited.has(ref)) continue\n      visited.add(ref)\n\n      let w = writers.get(hex)\n      if (!w) {\n        const writer = await this._getWriterByKey(key, -1, 0, true, false, null)\n\n        w = { writer, end: writer.length }\n\n        writers.set(hex, w)\n      }\n\n      if (w.writer.length >= length) continue\n\n      if (length > w.end) w.end = length\n\n      // we should have all nodes locally\n      const block = await w.writer.core.get(length - 1, { wait: false })\n\n      assert(block !== null, 'Catchup failed: local block not available')\n\n      for (const dep of block.node.heads) {\n        nodes.push(dep)\n      }\n    }\n\n    while (writers.size) {\n      for (const [hex, info] of writers) {\n        const { writer, end } = info\n\n        if (writer === null || writer.length === end) {\n          writers.delete(hex)\n          continue\n        }\n\n        if (writer.available <= writer.length) {\n          // force in case they are not indexed yet\n          await writer.update(true)\n        }\n\n        const node = writer.advance()\n        if (!node) continue\n\n        this.linearizer.addHead(node)\n      }\n    }\n\n    await this._drain() // runs for one tick\n  }\n\n  _reindexersIdle () {\n    for (const idx of this.linearizer.indexers) {\n      if (idx.core.length !== idx.length) return false\n    }\n    return !this.localWriter || this.localWriter.core.length === this.localWriter.length\n  }\n\n  async _setReindexed () {\n    try {\n      while (true) {\n        await this._bump()\n\n        let p = this.progress()\n        if (p.processed === p.total && !(this.linearizer.indexers.length === 1 && this.linearizer.indexers[0].core.length === 0)) break\n\n        await this._waiting.wait(2000)\n        await this._advancing\n\n        p = this.progress()\n        if (p.processed === p.total) break\n\n        if (this._reindexersIdle()) break\n      }\n      if (this._interrupting) return\n      await this.local.setUserData('autobase/reindexed', b4a.from([0]))\n      this.reindexing = false\n      this.emit('reindexed')\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _close () {\n    this._interrupting = true\n    await Promise.resolve() // defer one tick\n\n    if (this._coupler) this._coupler.destroy()\n    this._coupler = null\n    this._waiting.notify(null)\n\n    const closing = this._advancing.catch(safetyCatch)\n\n    if (this._ackTimer) {\n      this._ackTimer.stop()\n      await this._ackTimer.flush()\n    }\n\n    await this._wakeup.close()\n\n    if (this._hasClose) await this._handlers.close(this.view)\n    if (this._primaryBootstrap) await this._primaryBootstrap.close()\n    await this.activeWriters.clear()\n    await this.corePool.clear()\n    await this.store.close()\n    await closing\n  }\n\n  _onError (err) {\n    if (this.closing) return\n\n    if (err === INTERRUPT) {\n      this.emit('interrupt', this.interrupted)\n      return\n    }\n\n    this.close().catch(safetyCatch)\n\n    // if no one is listening we should crash! we cannot rely on the EE here\n    // as this is wrapped in a promise so instead of nextTick throw it\n    if (ReadyResource.listenerCount(this, 'error') === 0) {\n      crashSoon(err)\n      return\n    }\n\n    this.emit('error', err)\n  }\n\n  async _closeWriter (w, now) {\n    this.activeWriters.delete(w)\n    if (!now) this.corePool.linger(w.core)\n    await w.close()\n  }\n\n  async _gcWriters () {\n    // just return early, why not\n    if (this._checkWriters.length === 0) return\n\n    while (this._checkWriters.length > 0) {\n      const w = this._checkWriters.pop()\n\n      if (!w.flushed()) continue\n\n      const unqueued = this._wakeup.unqueue(w.core.key, w.core.length)\n      this._coupler.remove(w.core)\n\n      if (!unqueued || w.isActiveIndexer) continue\n      if (this.localWriter === w) continue\n\n      await this._closeWriter(w, false)\n    }\n\n    await this._wakeup.flush()\n  }\n\n  _startAckTimer () {\n    if (this._ackTimer) return\n    this._ackTimer = new Timer(this._backgroundAck.bind(this), this._ackInterval)\n    this._bumpAckTimer()\n  }\n\n  _bumpAckTimer () {\n    if (!this._ackTimer) return\n    this._ackTimer.bump()\n  }\n\n  async _waitForIdle () {\n    let p = this.progress()\n    while (!this.closing && this.reindexing) {\n      if (p.processed === p.total && !(this.linearizer.indexers.length === 1 && this.linearizer.indexers[0].core.length === 0)) break\n      await this._waiting.wait(2000)\n      await this._advancing\n      const next = this.progress()\n      if (next.processed === p.processed && next.total === p.total) break\n      p = next\n    }\n\n    if (this.localWriter) {\n      await this.localWriter.ready()\n      while (!this.closing && this.localWriter.core.length > this.localWriter.length) {\n        await this.localWriter.waitForSynced()\n        await this._bump() // make sure its all flushed...\n      }\n    }\n  }\n\n  async update () {\n    if (this.opened === false) await this.ready()\n\n    try {\n      await this._bump()\n      if (this._acking) await this._bump() // if acking just rebump incase it was triggered from above...\n      await this._waitForIdle()\n    } catch (err) {\n      if (this._interrupting) return\n      throw err\n    }\n  }\n\n  // runs in bg, not allowed to throw\n  // TODO: refactor so this only moves the writer affected to a updated set\n  async _onremotewriterchange () {\n    this._bumpAckTimer()\n\n    try {\n      await this._bump()\n    } catch (err) {\n      if (!this._interrupting) throw err\n    }\n  }\n\n  _onwakeup () {\n    this._needsWakeup = true\n    this._queueBump()\n  }\n\n  _isPending () {\n    for (const key of this.system.pendingIndexers) {\n      if (b4a.equals(key, this.local.key)) return true\n    }\n    return false\n  }\n\n  _isFastForwarding () {\n    if (this.fastForwardTo !== null) return true\n    return this.fastForwardEnabled && this.fastForwarding > 0\n  }\n\n  _backgroundAck () {\n    return this.ack(true)\n  }\n\n  async ack (bg = false) {\n    if (this.localWriter === null) return\n\n    const isPendingIndexer = this._isPending()\n\n    // if no one is waiting for our index manifest, wait for FF before pushing an ack\n    if (!isPendingIndexer && this._isFastForwarding()) return\n\n    const isIndexer = this.localWriter.isActiveIndexer || isPendingIndexer\n\n    if (!isIndexer || this._acking || this._interrupting) return\n\n    this._acking = true\n\n    try {\n      await this._bump()\n    } catch (err) {\n      if (!this._interrupting) throw err\n    }\n\n    // avoid lumping acks together due to the bump wait here\n    if (this._ackTimer && bg) await this._ackTimer.asapStandalone()\n    if (this._interrupting) return\n\n    const unflushed = this._hasPendingCheckpoint || this.hasUnflushedIndexers()\n    if (!this._interrupting && (isPendingIndexer || this.linearizer.shouldAck(this.localWriter, unflushed))) {\n      try {\n        if (this.localWriter) await this.append(null)\n      } catch (err) {\n        if (!this._interrupting) throw err\n      }\n\n      if (!this._interrupting) {\n        this._updateAckThreshold()\n        this._bumpAckTimer()\n      }\n    }\n\n    this._acking = false\n  }\n\n  async append (value) {\n    if (!this.opened) await this.ready()\n    if (this._interrupting) throw new Error('Autobase is closing')\n\n    // if a reset is scheduled await those\n    while (this._queueViewReset && !this._interrupting) await this._bump()\n\n    // we wanna allow acks so interdexers can flush\n    if (this.localWriter === null || (this.localWriter.isRemoved && value !== null)) {\n      throw new Error('Not writable')\n    }\n\n    if (this._appending === null) this._appending = []\n\n    if (Array.isArray(value)) {\n      for (const v of value) this._append(v)\n    } else {\n      this._append(value)\n    }\n\n    // await in case append is in current tick\n    if (this._advancing) await this._advancing\n\n    // only bump if there are unflushed nodes\n    if (this._appending !== null) return this._bump()\n  }\n\n  _append (value) {\n    // if prev value is an ack that hasnt been flushed, skip it\n    if (this._appending.length > 0) {\n      if (value === null) return\n      if (this._appending[this._appending.length - 1] === null) {\n        this._appending.pop()\n      }\n    }\n    this._appending.push(value)\n  }\n\n  async checkpoint () {\n    await this.ready()\n    const all = []\n\n    for (const w of this.activeWriters) {\n      all.push(w.getCheckpoint())\n    }\n\n    const checkpoints = await Promise.all(all)\n    let best = null\n\n    for (const c of checkpoints) {\n      if (!c) continue\n      if (best === null || c.length > best.length) best = c\n    }\n\n    return best\n  }\n\n  static getLocalCore (store, handlers, encryptionKey) {\n    const opts = { ...handlers, compat: false, active: false, exclusive: true, valueEncoding: messages.OplogMessage, encryptionKey }\n    return opts.keyPair ? store.get(opts) : store.get({ ...opts, name: 'local' })\n  }\n\n  static async getUserData (core) {\n    const view = await core.getUserData('autobase/view')\n\n    return {\n      referrer: await core.getUserData('referrer'),\n      view: (!view || view[0] !== 0) ? null : c.decode(messages.ViewRecord, view)\n    }\n  }\n\n  static async isAutobase (core, opts = {}) {\n    const block = await core.get(0, opts)\n    if (!block) throw new Error('Core is empty.')\n    if (!b4a.isBuffer(block)) return isAutobaseMessage(block)\n\n    try {\n      const m = c.decode(messages.OplogMessage, block)\n      return isAutobaseMessage(m)\n    } catch {\n      return false\n    }\n  }\n\n  // no guarantees where the user data is stored, just that its associated with the base\n  async setUserData (key, val) {\n    await this._presystem\n    const core = this._primaryBootstrap === null ? this.local : this._primaryBootstrap\n\n    await core.setUserData(key, val)\n  }\n\n  async getUserData (key) {\n    await this._presystem\n    const core = this._primaryBootstrap === null ? this.local : this._primaryBootstrap\n\n    return await core.getUserData(key)\n  }\n\n  getNamespace (key, core) {\n    const w = this.activeWriters.get(key)\n    if (!w) return null\n\n    const namespace = w.deriveNamespace(core.name)\n    const publicKey = w.core.manifest.signers[0].publicKey\n\n    return {\n      namespace,\n      publicKey\n    }\n  }\n\n  // no guarantees about writer.isActiveIndexer property here\n  async _getWriterByKey (key, len, seen, allowGC, isAdded, system) {\n    assert(this._draining === true || (this.opening && !this.opened))\n\n    const release = await this._lock()\n\n    if (this._interrupting) {\n      release()\n      throw new Error('Autobase is closing')\n    }\n\n    try {\n      let w = this.activeWriters.get(key)\n      if (w !== null) {\n        if (isAdded && w.core.writable && this.localWriter === null) this._setLocalWriter(w)\n        if (w.isRemoved && isAdded) w.isRemoved = false\n        w.seen(seen)\n        return w\n      }\n\n      const sys = system || this.system\n      const writerInfo = await sys.get(key)\n\n      if (len === -1) {\n        if (!allowGC && writerInfo === null) return null\n        len = writerInfo === null ? 0 : writerInfo.length\n      }\n\n      const isActive = writerInfo !== null && (isAdded || !writerInfo.isRemoved)\n\n      // assumes that seen is passed 0 everywhere except in writer._ensureNodeDependencies\n      const isRemoved = seen === 0\n        ? writerInfo !== null && (!isAdded && writerInfo.isRemoved)\n        : !isActive // a writer might have referenced a removed writer\n\n      w = this._makeWriter(key, len, isActive, isRemoved)\n      if (!w) return null\n\n      w.seen(seen)\n      await w.ready()\n\n      if (allowGC && w.flushed()) {\n        this._wakeup.unqueue(key, len)\n        if (w !== this.localWriter) {\n          this.corePool.linger(w.core)\n          await w.close()\n          return w\n        }\n      }\n\n      this.activeWriters.add(w)\n      this._checkWriters.push(w)\n\n      // will only add non-indexer writers\n      if (this._coupler) this._coupler.add(w.core)\n\n      assert(w.opened)\n      assert(!w.closed)\n\n      this._resumeWriter(w)\n      return w\n    } finally {\n      release()\n    }\n  }\n\n  _updateAll () {\n    const p = []\n    for (const w of this.activeWriters) p.push(w.update(false).catch(this._warn))\n    return Promise.all(p)\n  }\n\n  _makeWriterCore (key) {\n    const pooled = this.corePool.get(key)\n    if (pooled) {\n      pooled.valueEncoding = messages.OplogMessage\n      return pooled\n    }\n\n    const local = b4a.equals(key, this.local.key)\n\n    const core = local\n      ? this.local.session({ valueEncoding: messages.OplogMessage, encryptionKey: this.encryptionKey, active: false })\n      : this.store.get({ key, compat: false, writable: false, valueEncoding: messages.OplogMessage, encryptionKey: this.encryptionKey, active: false })\n\n    return core\n  }\n\n  _makeWriter (key, length, isActive, isRemoved) {\n    const core = this._makeWriterCore(key)\n    const w = new Writer(this, core, length, isRemoved)\n\n    if (core.writable) {\n      if (isActive) this._setLocalWriter(w) // only set active writer\n      return w\n    }\n\n    core.on('append', this._onremotewriterchangeBound)\n    core.on('download', this._onremotewriterchangeBound)\n    core.on('manifest', this._onremotewriterchangeBound)\n\n    return w\n  }\n\n  _updateLinearizer (indexers, heads) {\n    // only current active indexers are reset to true below\n    const wasActiveIndexer = this._isActiveIndexer()\n\n    for (const w of this.activeWriters) w.isActiveIndexer = false\n    for (const writer of indexers) writer.isActiveIndexer = true\n\n    if (this._isActiveIndexer() && !wasActiveIndexer) {\n      this._setLocalIndexer()\n    } else if (!this._isActiveIndexer() && wasActiveIndexer) {\n      this._unsetLocalIndexer()\n      this._clearLocalIndexer()\n    }\n\n    this.linearizer = new Linearizer(indexers, { heads, writers: this.activeWriters })\n    this._addCheckpoints = !!(this.localWriter && (this.localWriter.isActiveIndexer || this._isPending()))\n    this._updateAckThreshold()\n  }\n\n  _resumeWriter (w) {\n    if (!this._isFastForwarding()) w.resume()\n  }\n\n  async _loadLocalWriter (sys) {\n    if (this.localWriter !== null) return\n    await this._getWriterByKey(this.local.key, -1, 0, false, false, sys)\n    this._tryLoadingLocal = false\n  }\n\n  async _bootstrapLinearizer () {\n    const bootstrap = this._makeWriter(this.bootstrap, 0, true, false)\n\n    this.activeWriters.add(bootstrap)\n    this._checkWriters.push(bootstrap)\n    bootstrap.inflateBackground()\n    await bootstrap.ready()\n    this._resumeWriter(bootstrap)\n\n    this._updateLinearizer([bootstrap], [])\n  }\n\n  async _makeLinearizer (sys) {\n    this._tryLoadingLocal = true\n\n    if (sys === null) {\n      return this._bootstrapLinearizer()\n    }\n\n    if (this.opened || await sys.hasLocal(this.local.key)) {\n      await this._loadLocalWriter(sys)\n    }\n\n    const indexers = []\n\n    for (const head of sys.indexers) {\n      const writer = await this._getWriterByKey(head.key, head.length, 0, false, false, sys)\n      writer.inflateBackground()\n      indexers.push(writer)\n    }\n\n    if (!this._isActiveIndexer()) {\n      for (const key of sys.pendingIndexers) {\n        if (b4a.equals(key, this.local.key)) {\n          this._setLocalIndexer()\n          break\n        }\n      }\n    }\n\n    this._updateLinearizer(indexers, sys.heads)\n\n    for (const { key, length } of sys.heads) {\n      await this._getWriterByKey(key, length, 0, false, false, sys)\n    }\n  }\n\n  async _refreshSystemState () {\n    if (!(await this.system.update())) return\n\n    for (const w of this.activeWriters) {\n      const data = await this.system.get(w.core.key)\n      w.isRemoved = data ? data.isRemoved : false\n    }\n  }\n\n  async _reindex () {\n    if (this._updates.length) {\n      this._undoAll()\n      await this._refreshSystemState()\n    }\n\n    const sameIndexers = this.system.sameIndexers(this.linearizer.indexers)\n\n    await this._makeLinearizer(this.system)\n    if (!sameIndexers) await this._viewStore.migrate()\n\n    this.version = this.system.version\n\n    this.queueFastForward()\n\n    for (const w of this.activeWriters) {\n      const value = await this.system.get(w.core.key)\n      const length = value ? value.length : 0\n      w.reset(length)\n      this._resumeWriter(w)\n    }\n  }\n\n  _onUpgrade (version) {\n    if (version > this.maxSupportedVersion) throw new Error('Autobase upgrade required')\n  }\n\n  _setLocalWriter (w) {\n    this.localWriter = w\n    if (this._ackInterval) this._startAckTimer()\n  }\n\n  _unsetLocalWriter () {\n    if (!this.localWriter) return\n\n    this._closeWriter(this.localWriter, true)\n    if (this.localWriter.isActiveIndexer) this._clearLocalIndexer()\n\n    this.localWriter = null\n  }\n\n  _setLocalIndexer () {\n    assert(this.localWriter !== null)\n    if (this.isIndexer) return\n\n    this.isIndexer = true\n    this._addCheckpoints = true // unset once indexer is cleared\n    this.emit('is-indexer')\n  }\n\n  _unsetLocalIndexer () {\n    assert(this.localWriter !== null)\n    if (!this.isIndexer) return\n\n    this.isIndexer = false\n    this.emit('is-non-indexer')\n  }\n\n  _clearLocalIndexer () {\n    assert(this.localWriter !== null)\n\n    this.localWriter.isActiveIndexer = false\n\n    if (this._ackTimer) this._ackTimer.stop()\n    this._ackTimer = null\n    this._addCheckpoints = false\n  }\n\n  _addLocalHeads () {\n    if (!this.localWriter.idle()) return null\n\n    const nodes = new Array(this._appending.length)\n    for (let i = 0; i < this._appending.length; i++) {\n      const heads = this.linearizer.getHeads()\n      const deps = new Set(this.linearizer.heads)\n      const batch = this._appending.length - i\n      const value = this._appending[i]\n\n      const node = this.localWriter.append(value, heads, batch, deps, this.maxSupportedVersion)\n\n      this.linearizer.addHead(node)\n      nodes[i] = node\n    }\n\n    this._appending = null\n\n    return nodes\n  }\n\n  async _addRemoteHeads () {\n    let added = 0\n\n    while (added < REMOTE_ADD_BATCH) {\n      await this._updateAll()\n\n      let advanced = 0\n\n      for (const w of this.activeWriters) {\n        let node = w.advance()\n        if (node === null) continue\n\n        advanced += node.batch\n\n        while (true) {\n          this.linearizer.addHead(node)\n          if (node.batch === 1) break\n          node = w.advance()\n        }\n      }\n\n      if (advanced === 0) break\n      added += advanced\n    }\n\n    return added\n  }\n\n  async _advanceBootRecord (length) {\n    if (length) { // TODO: remove when we are 100% we never hit the return in this if\n      const { views } = await this.system.getIndexedInfo(length)\n      for (const { key, length } of views) {\n        const view = this._viewStore.getByKey(key)\n        if (!view || (view.core.flushedLength < length)) {\n          // TODO: this fires in some FF scenarios cause the core above is another core, should be fine\n          return\n        }\n      }\n    }\n\n    this._systemPointer = length\n\n    const views = this._viewStore.indexedViewsByName()\n\n    await this._setBootRecord(this.system.core.key, length, this.system.heads, views)\n  }\n\n  async _updateBootRecordHeads (heads) {\n    if (this._systemPointer === 0) return // first tick\n\n    const views = this._viewStore.indexedViewsByName()\n\n    await this._setBootRecord(this.system.core.key, this._systemPointer, heads, views)\n  }\n\n  async _setBootRecord (key, length, heads, views) {\n    const pointer = c.encode(messages.BootRecord, {\n      indexed: { key, length },\n      heads,\n      views\n    })\n\n    await this.local.setUserData('autobase/boot', pointer)\n  }\n\n  async _drain () {\n    const writable = this.writable\n\n    while (!this._interrupting && !this.paused) {\n      if (this.opened && this.fastForwardTo !== null) {\n        await this._applyFastForward()\n        this.system.requestWakeup()\n      }\n\n      if (this.localWriter === null && this._tryLoadingLocal === true) {\n        // in case we cleared system blocks we need to defer loading of the local writer\n        await this._loadLocalWriter(this.system)\n      }\n\n      const remoteAdded = this.opened ? await this._addRemoteHeads() : null\n      const localNodes = this.opened && this._appending !== null ? this._addLocalHeads() : null\n\n      if (this._maybeStaticFastForward === true && this.fastForwardEnabled === true) await this._checkStaticFastForward()\n      if (this._interrupting) return\n\n      if (remoteAdded > 0 || localNodes !== null) {\n        this.updating = true\n      }\n\n      const u = this.linearizer.update()\n      const changed = u ? await this._applyUpdate(u) : null\n      const indexed = !!this._updatingCores\n\n      if (this._interrupting) return\n\n      if (this.localWriter !== null && localNodes !== null) {\n        await this._flushLocal(localNodes)\n      }\n\n      if (this.opened) await this._updateBootRecordHeads(this.system.heads)\n\n      if (this._interrupting) return\n\n      const flushed = (await this._flushIndexes()) ? this.system.core.getBackingCore().flushedLength : this._systemPointer\n      if (this.updating || flushed > this._systemPointer) await this._advanceBootRecord(flushed)\n\n      if (indexed) await this.onindex(this)\n\n      if (this._interrupting) return\n\n      // force reset state in worst case\n      if (this._queueViewReset && this._appending === null) {\n        this._queueViewReset = false\n        const sysCore = this.system.core.getBackingCore()\n        await this._forceResetViews(sysCore.indexedLength)\n        continue\n      }\n\n      if (!changed) {\n        if (this._checkWriters.length > 0) {\n          await this._gcWriters()\n          if (!this.opened) break // at most one tick preready\n          continue // rerun the update loop as a writer might have been added\n        }\n        if (remoteAdded >= REMOTE_ADD_BATCH) continue\n        break\n      }\n\n      await this._gcWriters()\n      await this._reindex()\n    }\n\n    // emit state changes post drain\n    if (writable !== this.writable) this.emit(writable ? 'unwritable' : 'writable')\n  }\n\n  progress () {\n    let processed = 0\n    let total = 0\n\n    for (const w of this.activeWriters) {\n      processed += w.length\n      total += w.core.length\n    }\n\n    return {\n      processed,\n      total\n    }\n  }\n\n  async _getLocallyStoredHeads () {\n    const buffer = await this.local.getUserData('autobase/boot')\n    if (!buffer) return []\n    return c.decode(messages.BootRecord, buffer).heads\n  }\n\n  _wakeupPeer (peer) {\n    this.system.sendWakeup(peer.remotePublicKey)\n  }\n\n  async _wakeupWriter (key) {\n    this._ensureWakeup(await this._getWriterByKey(key, -1, 0, true, false, null))\n  }\n\n  // ensure wakeup on an existing writer (the writer calls this in addition to above)\n  _ensureWakeup (w) {\n    if (w === null || w.isBootstrap === true) return\n    w.setBootstrap(true) // even if turn false at end of drain, hypercore makes them linger a bit so no churn\n    this._bootstrapWriters.push(w)\n    this._bootstrapWritersChanged = true\n  }\n\n  async _drainWakeup () { // TODO: parallel load the writers here later\n    if (this._needsWakeup === true) {\n      this._needsWakeup = false\n\n      for (const { key } of this._wakeup) {\n        await this._wakeupWriter(key)\n      }\n\n      if (this._needsWakeupHeads === true) {\n        this._needsWakeupHeads = false\n\n        for (const { key } of await this._getLocallyStoredHeads()) {\n          await this._wakeupWriter(key)\n        }\n      }\n    }\n\n    for (const [hex, length] of this._wakeupHints) {\n      const key = b4a.from(hex, 'hex')\n      if (length !== -1) {\n        const info = await this.system.get(key)\n        if (info && length < info.length) continue // stale hint\n      }\n\n      await this._wakeupWriter(key)\n    }\n\n    this._wakeupHints.clear()\n  }\n\n  pause () {\n    this.paused = true\n  }\n\n  resume () {\n    this.paused = false\n    this._queueBump()\n  }\n\n  async _advance () {\n    if (this.opened === false) await this.ready()\n    if (this.paused) return\n\n    try {\n      this._draining = true\n      // note: this might block due to network i/o\n      if (this._needsWakeup === true || this._wakeupHints.size > 0) await this._drainWakeup()\n      await this._drain()\n      this._draining = false\n    } catch (err) {\n      this._onError(err)\n      return\n    }\n\n    if (!this._interrupting && this.localWriter && this._ackIsNeeded()) {\n      if (this._ackTimer) this._ackTimer.asap()\n      else this.ack()\n    }\n\n    // keep bootstraps in sync with linearizer\n    if (this.updating === true || this._bootstrapWritersChanged === true) {\n      this._updateBootstrapWriters()\n    }\n\n    if (this.updating === true) {\n      this.updating = false\n      this.emit('update')\n      this._waiting.notify(null)\n    }\n\n    if (!this.closing) await this._gcWriters()\n  }\n\n  _ackIsNeeded () {\n    if (!this._addCheckpoints) return false // ack has no impact\n\n    // flush any pending indexers\n    if (this.system.pendingIndexers.length > 0) {\n      for (const key of this.system.pendingIndexers) {\n        if (b4a.equals(key, this.local.key) && !b4a.equals(key, this.bootstrap)) {\n          return true\n        }\n      }\n    }\n\n    // flush any pending migrates\n    for (const view of this._viewStore.opened.values()) {\n      if (view.queued === -1) continue\n\n      const checkpoint = view.signer.bestCheckpoint(this.localWriter)\n      const length = checkpoint ? checkpoint.length : 0\n\n      if (length < view.queued && length < view.indexedLength) {\n        this._hasPendingCheckpoint = true\n        return true\n      }\n    }\n\n    // flush if threshold is reached and we are not already acking\n    if (this._ackTickThreshold && !this._acking && this._ackTick >= this._ackTickThreshold) {\n      if (this._ackTimer) { // the bool in this case is implicitly an \"asap\" signal\n        for (const w of this.linearizer.indexers) {\n          if (w.core.length > w.length) return false // wait for the normal ack cycle in this case\n        }\n\n        return this.linearizer.shouldAck(this.localWriter, this.hasUnflushedIndexers())\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  async forceResetViews () {\n    if (!this.opened) await this.ready()\n\n    this._queueViewReset = true\n    this._queueBump()\n    this._advanced = this._advancing\n    await this._advanced\n  }\n\n  async _forceResetViews (length) {\n    const info = await this.system.getIndexedInfo(length)\n\n    this._undoAll()\n    this._systemPointer = length\n\n    const pointer = await this.local.getUserData('autobase/boot')\n    const { views } = c.decode(messages.BootRecord, pointer)\n\n    await this._setBootRecord(this.system.core.key, length, info.heads, views)\n\n    for (const { key, length } of info.views) {\n      const core = this._viewStore.getByKey(key)\n      await core.reset(length)\n    }\n\n    await this._closeAllActiveWriters(false)\n\n    await this._refreshSystemState()\n    await this._makeLinearizer(this.system)\n  }\n\n  doneFastForwarding () {\n    if (--this.fastForwarding === 0 && !this._isFastForwarding()) {\n      for (const w of this.activeWriters) w.resume()\n    }\n  }\n\n  async _checkStaticFastForward () {\n    let tally = null\n\n    for (let i = 0; i < this.linearizer.indexers.length; i++) {\n      const w = this.linearizer.indexers[i]\n      if (w.system !== null && !b4a.equals(w.system, this.system.core.key)) {\n        if (tally === null) tally = new Map()\n        const hex = b4a.toString(w.system, 'hex')\n        tally.set(hex, (tally.get(hex) || 0) + 1)\n      }\n    }\n\n    if (tally === null) {\n      this._maybeStaticFastForward = false\n      return\n    }\n\n    const maj = (this.linearizer.indexers.length >> 1) + 1\n\n    let candidate = null\n    for (const [hex, vote] of tally) {\n      if (vote < maj) continue\n      candidate = b4a.from(hex, 'hex')\n      break\n    }\n\n    if (candidate && !this._isFastForwarding()) {\n      await this.initialFastForward(candidate, DEFAULT_FF_TIMEOUT * 2)\n    }\n  }\n\n  async initialFastForward (key, timeout) {\n    this.fastForwarding++\n\n    const encryptionKey = this._viewStore.getBlockKey(this._viewStore.getSystemCore().name)\n\n    const core = this.store.get({ key, encryptionKey, isBlockKey: true })\n    await core.ready()\n\n    // get length from network\n    const length = await new Promise((resolve, reject) => {\n      if (core.length) return resolve(core.length)\n\n      const timer = setTimeout(() => {\n        core.off('append', resolveLength)\n        resolve(0)\n      }, timeout)\n\n      core.once('append', resolveLength)\n\n      function resolveLength () {\n        clearTimeout(timer)\n        resolve(core.length)\n      }\n    })\n\n    if (!length || length < this.system.core.indexedLength) {\n      await core.close()\n      this.doneFastForwarding()\n      this.queueFastForward()\n      return\n    }\n\n    const target = await this._preFastForward(core, length, timeout)\n    await core.close()\n\n    // initial fast-forward failed\n    if (target === null) {\n      this.doneFastForwarding()\n      return\n    }\n\n    this.fastForwardTo = target\n    this.doneFastForwarding()\n\n    this._bumpAckTimer()\n    this._queueBump()\n  }\n\n  async queueFastForward () {\n    // if already FFing, let the finish. TODO: auto kill the attempt after a while and move to latest?\n    if (!this.fastForwardEnabled || this.fastForwarding > 0) return\n\n    const core = this.system.core.getBackingCore()\n\n    if (core.session.length <= core.length + FF_THRESHOLD) return\n    if (this.fastForwardTo !== null && core.session.length <= this.fastForwardTo.length + FF_THRESHOLD) return\n    if (!core.session.length) return\n\n    this.fastForwarding++\n    const target = await this._preFastForward(core.session, core.session.length, DEFAULT_FF_TIMEOUT)\n\n    // fast-forward failed\n    if (target === null) {\n      this.doneFastForwarding()\n      return\n    }\n\n    // if it migrated underneath us, ignore for now\n    if (core !== this.system.core.getBackingCore()) {\n      this.doneFastForwarding()\n      return\n    }\n\n    this.fastForwardTo = target\n    this.doneFastForwarding()\n\n    this._bumpAckTimer()\n    this._queueBump()\n  }\n\n  // NOTE: runs in parallel with everything, can never fail\n  async _preFastForward (core, length, timeout) {\n    if (length === 0) return null\n\n    const info = {\n      key: core.key,\n      length,\n      localLength: 0\n    }\n\n    // pause writers\n    for (const w of this.activeWriters) w.pause()\n\n    try {\n      // sys runs open with wait false, so get head block first for low complexity\n      if (!(await core.has(length - 1))) {\n        await core.get(length - 1, { timeout })\n      }\n\n      const system = new SystemView(core.session(), {\n        checkout: length,\n        maxCacheSize: this.maxCacheSize\n      })\n\n      await system.ready()\n\n      if (system.version > this.maxSupportedVersion) {\n        const upgrade = {\n          version: system.version,\n          length\n        }\n\n        this.emit('upgrade-available', upgrade)\n        return null\n      }\n\n      const systemShouldMigrate = b4a.equals(core.key, this.system.core.key) &&\n        !system.sameIndexers(this.linearizer.indexers)\n\n      const localLookup = this.localWriter ? system.get(this.local.key, { timeout }) : null\n      if (localLookup) localLookup.catch(noop)\n\n      const indexers = []\n      const pendingViews = []\n\n      for (const { key, length } of system.indexers) {\n        if (length === 0) continue\n        const core = this.store.get(key)\n        await core.ready()\n        indexers.push({ key, core, length })\n      }\n\n      // handle rest of views\n      for (const v of system.views) {\n        const core = this.store.get(v.key)\n\n        // same as below, we technically just need to check that we have the hash, not the block\n        if (v.length === 0 || await core.has(v.length - 1)) {\n          await core.close()\n        } else {\n          pendingViews.push({ core, length: v.length })\n        }\n      }\n\n      const promises = []\n\n      for (const { key, core, length } of indexers) {\n        if (core.length === 0 && length > 0) promises.push(core.get(length - 1, { timeout }))\n        promises.push(system.get(key))\n      }\n\n      for (const { core, length } of pendingViews) {\n        // we could just get the hash here, but likely user wants the block so yolo\n        promises.push(core.get(length - 1, { timeout }))\n      }\n\n      await Promise.all(promises)\n\n      if (localLookup) {\n        const value = await localLookup\n        if (value) info.localLength = value.isRemoved ? -1 : value.length\n      }\n\n      const closing = []\n\n      // handle system migration\n      if (systemShouldMigrate) {\n        const hash = system.core.core.tree.hash()\n        const name = this.system.core._source.name\n        const prologue = { hash, length }\n\n        info.key = this.deriveKey(name, indexers, prologue)\n\n        const core = this.store.get(info.key)\n        await core.get(length - 1, { timeout })\n\n        closing.push(core.close())\n      }\n\n      for (const { core } of pendingViews) {\n        closing.push(core.close())\n      }\n\n      closing.push(system.close())\n\n      await Promise.allSettled(closing)\n    } catch (err) {\n      safetyCatch(err)\n      return null\n    }\n\n    return info\n  }\n\n  _clearFastForward (queue) {\n    if (this.fastForwarding === 0) {\n      for (const w of this.activeWriters) w.resume()\n    }\n    this.fastForwardTo = null\n    if (queue) this.queueFastForward() // queue in case we lost an ff while applying this one\n  }\n\n  async _applyFastForward () {\n    // remember these in case another fast forward gets queued\n    const { key, length, localLength } = this.fastForwardTo\n\n    const migrated = !b4a.equals(key, this.system.core.key)\n\n    const name = this._viewStore.getSystemCore().name\n    const encryptionKey = this._viewStore.getBlockKey(name)\n\n    const core = this.store.get({ key, encryptionKey, isBlockKey: true })\n    await core.ready()\n\n    const from = this.system.core.getBackingCore().length\n\n    // just extra sanity check that we are not going back in time, nor that we cleared the storage needed for ff\n    if (from >= length || core.length < length) {\n      this._clearFastForward(true)\n      return\n    }\n\n    const system = new SystemView(core, {\n      checkout: length,\n      maxCacheSize: this.maxCacheSize\n    })\n\n    await system.ready()\n\n    const opened = []\n    const indexers = [] // only used in migrate branch\n    const prologues = [] // only used in migrate branch\n\n    // preload async state\n    if (migrated) {\n      for (const { key } of system.indexers) {\n        const core = this.store.get(key)\n        await core.ready()\n        indexers.push({ core })\n        await core.close()\n      }\n\n      for (const { key } of system.views) {\n        const core = this.store.get(key)\n        await core.ready()\n        prologues.push(core.manifest.prologue)\n        await core.close()\n      }\n    }\n\n    const views = new Map()\n\n    const sysView = this.system.core._source\n    const sysInfo = { key, length, systemIndex: -1 }\n\n    views.set(sysView, sysInfo)\n\n    for (let i = 0; i < system.views.length; i++) {\n      const v = system.views[i]\n\n      // TODO: check behaviour if new view keys (+ double FF)\n      let view = this._viewStore.getByKey(v.key)\n\n      // search for corresponding view\n      if (!view) {\n        for (view of this._viewStore.opened.values()) {\n          const key = this.deriveKey(view.name, indexers, prologues[i])\n          if (b4a.equals(key, v.key)) break\n          view = null\n        }\n      }\n\n      if (!view) {\n        await closeAll(opened)\n        this._clearFastForward(false) // something wrong somewhere, likely a bug, just safety\n        return\n      }\n\n      const core = this.store.get(v.key)\n      await core.ready()\n\n      opened.push(core)\n\n      if (core.length < v.length) { // sanity check in case there was a migration etc\n        await closeAll(opened)\n        this._clearFastForward(true)\n        return\n      }\n\n      views.set(view, { key: v.key, length: v.length, systemIndex: i })\n    }\n\n    await system.close()\n    await this._closeAllActiveWriters(false)\n\n    this._undoAll()\n\n    for (const view of this._viewStore.opened.values()) {\n      const info = views.get(view)\n      if (info) await view.catchup(info)\n      else if (migrated) await view.migrateTo(indexers, 0)\n    }\n\n    await this._refreshSystemState()\n\n    if (this.localWriter) {\n      if (localLength < 0) this._unsetLocalWriter()\n      else this.localWriter.reset(localLength)\n    }\n\n    await this._makeLinearizer(this.system)\n    await this._advanceBootRecord(length)\n\n    // manually set the digest\n    if (migrated) {\n      this._setDigest(key)\n      this.recouple()\n    }\n\n    if (b4a.equals(this.fastForwardTo.key, key) && this.fastForwardTo.length === length) {\n      this._clearFastForward(false)\n    }\n\n    this.updating = true\n    this.emit('fast-forward', length, from)\n\n    // requeue in case we can do another jump!\n    this.queueFastForward()\n\n    await closeAll(opened)\n  }\n\n  async _closeAllActiveWriters (keepPool) {\n    for (const w of this.activeWriters) {\n      if (this.localWriter === w) continue\n      await this._closeWriter(w, true)\n    }\n    if (keepPool) await this.corePool.clear()\n  }\n\n  async _flushIndexes () {\n    let complete = true\n    this._updatingCores = false\n\n    for (const core of this._viewStore.opened.values()) {\n      if (!await core.flush()) complete = false\n    }\n\n    // updates emitted sync\n    for (const core of this._viewStore.opened.values()) {\n      if (core.indexing === 0) continue\n      const indexing = core.indexing\n      core.indexing = 0\n      core._onindex(indexing)\n    }\n\n    return complete\n  }\n\n  // triggered from linearized core\n  _onviewappend (core, blocks) {\n    assert(this._applying !== null, 'Append is only allowed in apply')\n\n    if (core.appending === 0) {\n      this._applying.views.push({ core, appending: 0 })\n    }\n\n    core.appending += blocks\n  }\n\n  // triggered from apply\n  async addWriter (key, { indexer = true, isIndexer = indexer } = {}) { // just compat for old version\n    assert(this._applying !== null, 'System changes are only allowed in apply')\n    await this.system.add(key, { isIndexer })\n\n    const writer = (await this._getWriterByKey(key, -1, 0, false, true, null)) || this._makeWriter(key, 0, true, false)\n    await writer.ready()\n\n    if (!this.activeWriters.has(key)) {\n      this.activeWriters.add(writer)\n      this._checkWriters.push(writer)\n      this._resumeWriter(writer)\n    }\n\n    // If we are getting added as indexer, already start adding checkpoints while we get confirmed...\n    if (writer === this.localWriter) {\n      if (isIndexer) this._setLocalIndexer()\n      else this._unsetLocalIndexer() // unset if demoted\n    }\n\n    // fetch any nodes needed for dependents\n    this._queueBump()\n  }\n\n  removeable (key) {\n    if (this.system.indexers.length !== 1) return true\n    return !b4a.equals(this.system.indexers[0].key, key)\n  }\n\n  // triggered from apply\n  async removeWriter (key) { // just compat for old version\n    assert(this._applying !== null, 'System changes are only allowed in apply')\n\n    if (!this.removeable(key)) {\n      throw new Error('Not allowed to remove the last indexer')\n    }\n\n    await this.system.remove(key)\n\n    if (b4a.equals(key, this.local.key)) {\n      if (this.isIndexer) this._unsetLocalIndexer()\n    }\n\n    const w = this.activeWriters.get(key)\n    if (w) w.isRemoved = true\n\n    this._queueBump()\n  }\n\n  _undoAll () {\n    let count = 0\n    for (const u of this._updates) {\n      count += u.batch\n    }\n    return this._undo(count)\n  }\n\n  _undo (popped) {\n    const truncating = []\n\n    while (popped > 0) {\n      const u = this._updates.pop()\n\n      popped -= u.batch\n\n      for (const { core, appending } of u.views) {\n        if (core.truncating === 0) truncating.push(core)\n        core.truncating += appending\n      }\n    }\n\n    for (const core of truncating) {\n      const truncating = core.truncating\n      core.truncating = 0\n      core._onundo(truncating)\n    }\n  }\n\n  async _getManifest (indexer, len) {\n    for (const w of this.linearizer.indexers) {\n      const d = await w.getDigest(len)\n      if (!d) continue\n      if (d.indexers.length > indexer) return d.indexers[indexer]\n    }\n\n    return null\n  }\n\n  _bootstrap () {\n    return this.system.add(this.bootstrap, { isIndexer: true, isPending: false })\n  }\n\n  _updateAckThreshold () {\n    if (this._ackThreshold === 0) return\n    if (this._ackTimer) this._ackTimer.bau()\n    this._ackTickThreshold = random2over1(this.linearizer.indexers.length * this._ackThreshold)\n  }\n\n  _resetAckTick () {\n    this._ackTick = 0\n    if (this._ackTimer) this._ackTimer.bau()\n  }\n\n  async _applyUpdate (u) {\n    assert(await this._viewStore.flush(), 'Views failed to open')\n\n    if (u.undo) this._undo(u.undo)\n\n    // if anything was indexed reset the ticks\n    if (u.indexed.length) this._resetAckTick()\n\n    // make sure the latest changes is reflected on the system...\n    await this._refreshSystemState()\n\n    // todo: refresh the active writer set in case any were removed\n\n    let batch = 0\n    let applyBatch = []\n    let versionUpgrade = false\n\n    let j = 0\n\n    let i = 0\n    while (i < Math.min(u.indexed.length, u.shared)) {\n      const node = u.indexed[i++]\n\n      if (node.batch > 1) continue\n      this._shiftWriter(node.writer)\n\n      const update = this._updates[j++]\n\n      // autobase version was bumped\n      let upgraded = false\n      if (update.version > this.version) {\n        this._onUpgrade(update.version) // throws if not supported\n        upgraded = true\n      }\n\n      if (!update.indexers && !upgraded) continue\n\n      this._queueIndexFlush(i)\n\n      // we have to set the digest here so it is\n      // flushed to local appends in same iteration\n      await this._updateDigest()\n\n      return true\n    }\n\n    for (i = u.shared; i < u.length; i++) {\n      if (this.fastForwardTo !== null && this.fastForwardTo.length > this.system.core.length && b4a.equals(this.fastForwardTo.key, this.system.core.key)) {\n        return false\n      }\n\n      const indexed = i < u.indexed.length\n      const node = indexed ? u.indexed[i] : u.tip[i - u.indexed.length]\n\n      if (node.version > this.system.version) versionUpgrade = true\n\n      if (node.writer === this.localWriter) {\n        this._resetAckTick()\n      } else if (!indexed) {\n        this._ackTick++\n      }\n\n      batch++\n\n      this.system.addHead(node)\n\n      if (node.value !== null && !node.writer.isRemoved) {\n        applyBatch.push({\n          indexed,\n          from: node.writer.core,\n          length: node.length,\n          value: node.value,\n          heads: node.actualHeads\n        })\n      }\n\n      if (node.batch > 1) continue\n\n      if (versionUpgrade) {\n        const version = await this._checkVersion()\n        this.system.version = version === -1 ? node.version : version\n      }\n\n      const update = {\n        batch,\n        indexers: false,\n        views: [],\n        version: this.system.version\n      }\n\n      this._updates.push(update)\n      this._applying = update\n\n      if (this.system.bootstrapping) await this._bootstrap()\n\n      if (applyBatch.length && this._hasApply === true) {\n        await this._handlers.apply(applyBatch, this.view, this)\n      }\n\n      update.indexers = !!this.system.indexerUpdate\n\n      await this.system.flush(await this._getViewInfo(update.indexers))\n\n      this._applying = null\n\n      batch = 0\n      applyBatch = []\n\n      for (let k = 0; k < update.views.length; k++) {\n        const u = update.views[k]\n        u.appending = u.core.appending\n        u.core.appending = 0\n      }\n\n      if (!indexed) continue\n\n      this._shiftWriter(node.writer)\n\n      // autobase version was bumped\n      let upgraded = false\n      if (update.version > this.version) {\n        this._onUpgrade(update.version) // throws if not supported\n        upgraded = true\n      }\n\n      if (!update.indexers && !upgraded) continue\n\n      // indexer set has updated\n      this._queueIndexFlush(i + 1)\n      await this._updateDigest() // see above\n\n      return true\n    }\n\n    if (u.indexed.length) {\n      this._queueIndexFlush(u.indexed.length)\n      await this._updateDigest() // see above\n    }\n\n    return false\n  }\n\n  async _getViewInfo (indexerUpdate) {\n    const indexers = []\n\n    for (const { key, length } of this.system.indexers) {\n      const indexer = await this._getWriterByKey(key, length, 0, false, false, null)\n      indexers.push(indexer)\n    }\n\n    // construct view keys to be passed to system\n    const views = []\n    for (const view of this._viewStore.opened.values()) {\n      if (!view.length || view._isSystem()) continue // system is omitted\n\n      const length = view.systemIndex !== -1\n        ? this.system.views[view.systemIndex].length\n        : 0\n\n      // TODO: the first part of this condition could be make clearer with a !this._isBootstrapping() condition instead\n      const key = (indexers.length > 1 || this.linearizer.indexers.length > indexers.length) && indexerUpdate\n        ? await view.deriveKey(indexers, length + view.appending)\n        : view.systemIndex === -1\n          ? view.key\n          : null\n\n      views.push({ view, key })\n    }\n\n    return views\n  }\n\n  async _checkVersion () {\n    if (!this.system.indexers.length) return -1\n\n    const maj = (this.system.indexers.length >> 1) + 1\n\n    const fetch = []\n\n    let localUnflushed = false\n    for (const { key, length } of this.system.indexers) {\n      const w = await this._getWriterByKey(key, length, 0, false, false, null)\n\n      if (length > w.core.length) localUnflushed = true // local writer has nodes in mem\n      else fetch.push(w.core.get(length - 1))\n    }\n\n    const heads = await Promise.all(fetch)\n\n    const tally = new Map()\n    const versions = []\n\n    // count ourself\n    if (localUnflushed) {\n      const local = { version: this.maxSupportedVersion, n: 1 }\n      versions.push(local)\n      tally.set(this.maxSupportedVersion, local)\n    }\n\n    for (const { maxSupportedVersion: version } of heads) {\n      let v = tally.get(version)\n\n      if (!v) {\n        v = { version, n: 0 }\n\n        tally.set(version, v)\n        versions.push(v)\n      }\n\n      if (++v.n >= maj) return version\n    }\n\n    let count = 0\n    for (const { version, n } of versions.sort(descendingVersion)) {\n      if ((count += n) >= maj) return version\n    }\n\n    assert(false, 'Failed to determine version')\n  }\n\n  _shiftWriter (w) {\n    w.shift()\n    if (w.flushed()) this._checkWriters.push(w)\n  }\n\n  _queueIndexFlush (indexed) {\n    assert(this._updatingCores === false, 'Updated cores not flushed')\n    this._updatingCores = true\n\n    while (indexed > 0) {\n      const u = this._updates.shift()\n\n      indexed -= u.batch\n\n      for (const { core, appending } of u.views) {\n        core.indexing += appending\n      }\n    }\n  }\n\n  deriveKey (name, indexers, prologue) {\n    return this._viewStore.deriveKey(name, indexers, prologue)\n  }\n\n  async _updateDigest () {\n    if (!this._addCheckpoints) return\n\n    if (this._localDigest === null) {\n      this._localDigest = await this.localWriter.getDigest()\n\n      // no previous digest available\n      if (this._localDigest === null) {\n        this._setDigest(this.system.core.key)\n      }\n\n      return\n    }\n\n    // we predict what the system key will be after flushing\n    const pending = this.system.core._source.pendingIndexedLength\n    const info = await this.system.getIndexedInfo(pending)\n\n    let same = info.indexers.length === this.linearizer.indexers.length\n    if (same) {\n      for (let i = 0; i < info.indexers.length; i++) {\n        if (!b4a.equals(info.indexers[i].key, this.linearizer.indexers[i].core.key)) {\n          same = false\n          break\n        }\n      }\n    }\n\n    let key = this.system.core.key\n\n    if (!same) {\n      const p = []\n      for (const { key } of info.indexers) {\n        p.push(await this._getWriterByKey(key, -1, 0, false, false, null))\n      }\n\n      const indexers = await p\n      const sys = this._viewStore.getSystemCore()\n      key = await sys.deriveKey(indexers, pending)\n    }\n\n    if (this._localDigest.key && b4a.equals(key, this._localDigest.key)) return\n\n    this._setDigest(key)\n  }\n\n  _setDigest (key) {\n    if (this._localDigest === null) this._localDigest = {}\n    this._localDigest.key = key\n    this._localDigest.pointer = 0\n  }\n\n  _generateDigest () {\n    return {\n      pointer: this._localDigest.pointer,\n      key: this._localDigest.key\n    }\n  }\n\n  async _generateCheckpoint (cores) {\n    if (!this._addCheckpoints) return null\n\n    if (this._firstCheckpoint) {\n      this._firstCheckpoint = false\n      // TODO: unsafe, use an array instead for views as the order is important\n      return generateCheckpoint(this._viewStore.opened.values())\n    }\n\n    return generateCheckpoint(cores)\n  }\n\n  async _flushLocal (localNodes) {\n    if (!this._localDigest) await this._updateDigest()\n\n    const cores = this._addCheckpoints ? this._viewStore.getIndexedCores() : []\n    const blocks = new Array(localNodes.length)\n\n    for (let i = 0; i < blocks.length; i++) {\n      const { value, heads, batch } = localNodes[i]\n\n      blocks[i] = {\n        version: 1,\n        maxSupportedVersion: this.maxSupportedVersion,\n        checkpoint: this._addCheckpoints ? await generateCheckpoint(cores) : null,\n        digest: this._addCheckpoints ? this._generateDigest() : null,\n        node: {\n          heads,\n          batch,\n          value: value === null ? null : c.encode(this.valueEncoding, value)\n        },\n        trace: []\n      }\n\n      if (this._addCheckpoints) this._localDigest.pointer++\n    }\n\n    await this.local.append(blocks)\n\n    if (this._addCheckpoints) {\n      const { checkpoint } = blocks[blocks.length - 1]\n      this.localWriter._addCheckpoints(checkpoint)\n      this._hasPendingCheckpoint = false\n    }\n  }\n}\n\nfunction generateCheckpoint (cores) {\n  const checkpoint = []\n\n  for (const core of cores) {\n    checkpoint.push(core.checkpoint())\n    core.checkpointer++\n  }\n\n  return Promise.all(checkpoint)\n}\n\nfunction toKey (k) {\n  return b4a.isBuffer(k) ? k : hypercoreId.decode(k)\n}\n\nfunction isAutobaseMessage (msg) {\n  return msg.checkpoint ? msg.checkpoint.length > 0 : msg.checkpoint === null\n}\n\nfunction compareNodes (a, b) {\n  return b4a.compare(a.key, b.key)\n}\n\nfunction descendingVersion (a, b) {\n  return b.version - a.version\n}\n\nfunction random2over1 (n) {\n  return Math.floor(n + Math.random() * n)\n}\n\nfunction noop () {}\n\nfunction crashSoon (err) {\n  queueMicrotask(() => { throw err })\n  throw err\n}\n\nfunction isObject (obj) {\n  return typeof obj === 'object' && obj !== null\n}\n\nfunction emitWarning (err) {\n  safetyCatch(err)\n  this.emit('warning', err)\n}\n\nasync function closeAll (list) {\n  for (const core of list) await core.close()\n}\nconst b4a = require('b4a')\n\nmodule.exports = class ActiveWriters {\n  constructor () {\n    this.map = new Map()\n  }\n\n  get size () {\n    return this.map.size\n  }\n\n  [Symbol.iterator] () {\n    return this.map.values()\n  }\n\n  get (key) {\n    return this.map.get(b4a.toString(key, 'hex')) || null\n  }\n\n  has (key) {\n    return this.get(key) !== null\n  }\n\n  add (writer) {\n    this.map.set(b4a.toString(writer.core.key, 'hex'), writer)\n  }\n\n  delete (writer) {\n    this.map.delete(b4a.toString(writer.core.key, 'hex'))\n  }\n\n  clear () {\n    const p = []\n    for (const w of this.map.values()) p.push(w.close())\n    this.map.clear()\n\n    return Promise.all(p)\n  }\n}\nconst BufferMap = require('tiny-buffer-map')\n\n// This is basically just a Map atm, but leaving it as an abstraction for now\n// in case we wanna optimize it for our exact usecase\n\nmodule.exports = class Clock {\n  constructor () {\n    this.seen = new BufferMap()\n  }\n\n  get size () {\n    return this.seen.size\n  }\n\n  has (key) {\n    return this.seen.has(key)\n  }\n\n  includes (key, length) {\n    return this.seen.has(key) && this.seen.get(key) >= length\n  }\n\n  get (key) {\n    return this.seen.get(key) || 0\n  }\n\n  set (key, len) {\n    this.seen.set(key, len)\n    return len\n  }\n\n  add (clock) {\n    for (const [key, l] of clock) {\n      if (this.get(key) < l) this.set(key, l)\n    }\n  }\n\n  [Symbol.iterator] () {\n    return this.seen[Symbol.iterator]()\n  }\n}\nconst BufferMap = require('tiny-buffer-map')\n\nconst Clock = require('./clock')\n\nconst UNSEEN = 0\nconst NEWER = 1\nconst ACKED = 2\n\n// Consensus machine for Autobase. Sort DAG nodes using\n// vector clocks to determine a globally consistent view\n\nmodule.exports = class Consensus {\n  constructor (indexers) {\n    this.merges = new Set()\n    this.majority = (indexers.length >>> 1) + 1\n    this.indexers = indexers\n    this.removed = new Clock()\n    this.updated = false\n\n    this.writers = new BufferMap()\n    for (const idx of this.indexers) {\n      this.writers.set(idx.core.key, idx)\n    }\n  }\n\n  addHead (node) {\n    if (!node.writer.isActiveIndexer) return\n    if (this._isMerge(node)) this.merges.add(node)\n    this.updated = true\n    return node\n  }\n\n  /* Indexer Only DAG methods */\n\n  _tails (node, tails) {\n    const tailSet = new Set()\n    for (const t of tails) {\n      if (node.clock.includes(t.writer.core.key, t.length)) tailSet.add(t)\n    }\n\n    return tailSet\n  }\n\n  _tailsAndMerges (node, tails) {\n    const all = this._tails(node, tails)\n    for (const m of this.merges) {\n      if (m !== node && node.clock.includes(m.writer.core.key, m.length)) {\n        all.add(m)\n      }\n    }\n    return all\n  }\n\n  _isMerge (node) {\n    if (!node.writer.isActiveIndexer) return false\n\n    const deps = []\n\n    for (const idx of this.indexers) {\n      let seq = node.clock.get(idx.core.key) - 1\n\n      if (idx === node.writer) seq--\n\n      const head = idx.get(seq)\n      if (!head || this.removed.includes(head.writer.core.key, head.length)) continue\n\n      let isDep = true\n      for (let i = 0; i < deps.length; i++) {\n        const d = deps[i]\n        if (d === head) continue\n\n        if (d.clock.includes(head.writer.core.key, head.length)) {\n          isDep = false\n          break\n        }\n\n        if (head.clock.includes(d.writer.core.key, d.length)) {\n          const popped = deps.pop()\n          if (d === popped) continue\n          deps[i--] = popped\n        }\n      }\n\n      if (isDep) deps.push(head)\n    }\n\n    return deps.length > 1\n  }\n\n  _indexerTails () {\n    const tails = new Set()\n    for (const idx of this.indexers) {\n      const length = this.removed.has(idx.core.key) ? this.removed.get(idx.core.key) : idx.indexed\n\n      const head = idx.get(length)\n      if (!head || this.removed.includes(head.writer.core.key, head.length)) continue\n\n      let isTail = true\n      for (const t of tails) {\n        if (head.clock.includes(t.writer.core.key, t.length)) {\n          isTail = false\n          break\n        }\n\n        if (t.clock.includes(head.writer.core.key, head.length)) {\n          tails.delete(t)\n        }\n      }\n\n      if (isTail) tails.add(head)\n    }\n\n    return tails\n  }\n\n  // parent is newer if for any node in parent's view,\n  // either node can see object or object can see node\n  _strictlyNewer (object, parent) {\n    for (const [key, latest] of parent.clock) {\n      const oldest = this.removed.get(key)\n      if (latest <= oldest) continue // check quickly if we removed it\n\n      // get the NEXT mode from the writer from the objects pov, adjust if its removed\n      let length = object.clock.get(key)\n      if (length <= oldest) length = oldest\n\n      // sanity check, likely not needed as someone has checked this before, but whatevs, free\n      if (latest < length) return false\n\n      // if the same, they both seen it, continue\n      if (latest === length) continue\n\n      const writer = this.writers.get(key)\n\n      // might not be in the removed set but the writer can tell us if it was indexed...\n      const next = writer && writer.get(length >= writer.indexed ? length : writer.indexed)\n\n      // no next, its been indexed, both seen it\n      if (!next) continue\n\n      // if the NEXT node has seen the object its fine - newer\n      if (next.clock.includes(object.writer.core.key, object.length)) continue\n\n      // otherwise the parent must also NOT has seen the next node\n      if (!parent.clock.includes(next.writer.core.key, next.length)) continue\n\n      return false\n    }\n\n    return parent.clock.get(object.writer.core.key) >= object.length\n  }\n\n  _acks (target) {\n    const acks = target.writer.isActiveIndexer ? [target] : [] // TODO: can be cached on the target node in future (ie if we add one we dont have to check it again)\n\n    for (const idx of this.indexers) {\n      if (idx === target.writer) continue\n\n      let next = target.clock.get(idx.core.key)\n      if (next < idx.nodes.offset) next = idx.nodes.offset\n\n      const nextIndexNode = idx.get(next >= idx.indexed ? next : idx.indexed)\n\n      // no node - no ack\n      if (!nextIndexNode) continue\n\n      // if the next index node does not see the target, no ack\n      if (!nextIndexNode.clock.includes(target.writer.core.key, target.length)) continue\n\n      // if the next index node is not strictly newer, skip to avoid ambig...\n      if (!this._strictlyNewer(target, nextIndexNode)) continue\n\n      acks.push(nextIndexNode)\n    }\n\n    return acks\n  }\n\n  acksFromNode (target, view) {\n    const acks = new Set()\n\n    if (!view || !view.clock.includes(target.writer.core.key, target.length)) return acks\n\n    acks.add(view.writer)\n\n    for (const idx of this.indexers) {\n      if (idx === view.writer) continue\n\n      const length = view.clock.get(idx.core.key)\n      if (!length) continue\n\n      if (target.clock.includes(idx.core.key, length)) continue\n\n      const head = idx.get(length - 1)\n      if (!head) continue\n\n      if (head.clock.includes(target.writer.core.key, target.length)) {\n        acks.add(idx)\n      }\n    }\n\n    return acks\n  }\n\n  _ackedAt (acks, parent) {\n    let seen = 0\n    let missing = acks.length\n\n    for (const node of acks) {\n      missing--\n\n      if (!parent.clock.includes(node.writer.core.key, node.length)) {\n        if (seen + missing < this.majority) return false\n        continue\n      }\n\n      if (++seen >= this.majority) return true\n    }\n\n    return false\n  }\n\n  confirms (indexer, target, acks, length) {\n    if (!length || this.removed.get(indexer.core.key) >= length) return UNSEEN\n    // def feels like there is a smarter way of doing this part\n    // ie we just wanna find a node from the indexer that is strictly newer than target\n    // and seens a maj of the acks - thats it\n\n    let jump = true\n    let newer = true\n\n    for (let i = length - 1; i >= 0; i--) {\n      const head = indexer.get(i)\n      if (head === null) return UNSEEN\n\n      let seen = 0\n\n      for (const node of acks) {\n        // if (node.writer === indexer) continue\n        if (!head.clock.includes(node.writer.core.key, node.length)) continue\n        if (++seen >= this.majority) break\n      }\n\n      if (!newer && seen < this.majority) {\n        break\n      }\n\n      if (!this._strictlyNewer(target, head)) {\n        // all strictly newer nodes are clustered together so bisect until we find the cluster\n        if (jump) {\n          jump = false\n\n          let t = length - 1\n          let b = 0\n\n          while (t > b) {\n            const mid = (t + b) >>> 1\n            const node = indexer.get(mid)\n\n            if (node === null || !node.clock.includes(target.writer.core.key, target.length) || this._strictlyNewer(target, node)) {\n              b = mid + 1\n            } else {\n              t = mid - 1\n            }\n          }\n\n          // + 2 in case we are off by one and the i--. its fine, just an optimisation\n          if (b + 1 < i) i = b + 2\n        }\n\n        newer = false\n        continue\n      } else if (seen < this.majority) {\n        return NEWER\n      }\n\n      return ACKED\n    }\n\n    return UNSEEN\n  }\n\n  _isConfirmed (target, parent = null) {\n    const acks = this._acks(target)\n    const confs = new Set()\n\n    if (acks.length < this.majority) return false\n    let allNewer = true\n\n    for (const indexer of this.indexers) {\n      const length = parent\n        ? (parent.writer === indexer) ? parent.length - 1 : parent.clock.get(indexer.core.key)\n        : indexer.length\n\n      const result = this.confirms(indexer, target, acks, length)\n\n      if (result === ACKED) {\n        confs.add(indexer)\n        if (confs.size >= this.majority) {\n          return true\n        }\n      }\n\n      if (result === UNSEEN) allNewer = false\n    }\n\n    if (parent) return this._isConfirmableAt(target, parent, acks, confs)\n\n    return allNewer\n  }\n\n  _isConfirmableAt (target, parent, acks, confs) {\n    if (!this._ackedAt(acks, parent)) return false\n\n    let potential = confs.size\n\n    for (const indexer of this.indexers) {\n      if (confs.has(indexer)) continue\n\n      const length = parent.clock.get(indexer.core.key)\n      const isSeen = target.clock.includes(indexer.core.key, length)\n\n      // if the target has seen the latest node, it can freely be used to confirm the target later\n      // otherwise, check if a newer node is strictly newer...\n      if (!isSeen) {\n        const head = indexer.get(length - 1)\n\n        // the next indexer head HAS to be strictly newer - meaning the current one has to be also.\n        if (head && !this.removed.includes(head.writer.core.key, head.length) && !this._strictlyNewer(target, head)) {\n          continue\n        }\n      }\n\n      if (++potential >= this.majority) return true\n    }\n\n    return false\n  }\n\n  // this can get called multiple times for same node\n  remove (node) {\n    this.merges.delete(node)\n    this.removed.set(node.writer.core.key, node.length)\n    return node\n  }\n\n  shift () {\n    if (!this.updated) return []\n\n    const tails = this._indexerTails()\n\n    for (const tail of tails) {\n      if (this._isConfirmed(tail)) {\n        return [this.remove(tail)]\n      }\n    }\n\n    for (const merge of this.merges) {\n      if (this._isConfirmed(merge)) {\n        return this._yieldNext(merge, tails)\n      }\n    }\n\n    this.updated = false\n    return []\n  }\n\n  // yields next indexer node\n  _yieldNext (node, tails) {\n    // only stop when we find a tail\n    while (!tails.has(node)) {\n      let next = null\n\n      // for merges check if one fork is confirmed\n      for (const t of this._tailsAndMerges(node, tails)) {\n        if (this._isConfirmed(t, node)) {\n          next = t\n          break\n        }\n      }\n\n      if (next) {\n        node = next\n        continue\n      }\n\n      // otherwise yield all tails\n      const tailSet = []\n      for (const t of this._tails(node, tails)) {\n        tailSet.push(this.remove(t))\n      }\n\n      return tailSet\n    }\n\n    return [this.remove(node)]\n  }\n\n  shouldAck (writer) {\n    for (const t of this._indexerTails()) {\n      if (t.writer === writer) continue\n      if (this._shouldAckNode(t, writer)) return true\n    }\n\n    return false\n  }\n\n  _shouldAckNode (target, writer) {\n    const head = writer.head()\n    const next = target.clock.get(writer.core.key)\n    const nextIndexNode = writer.get(next >= writer.indexed ? next : writer.indexed)\n\n    // if we have no next node and we didn't write target then ack\n    if (!nextIndexNode && writer !== target.writer) return true\n\n    // shortcuts if we have next node\n    if (nextIndexNode) {\n      // if the next node does not see the target, should ack\n      if (!nextIndexNode.clock.includes(target.writer.core.key, target.length)) {\n        return !head.clock.includes(target.writer.core.key, target.length)\n      }\n\n      // if the next node is not strictly newer, no point acking\n      if (!this._strictlyNewer(target, nextIndexNode)) return false\n    }\n\n    // now check if we can double confirm\n    const acks = this._acks(target)\n\n    // need enough to double confirm\n    if (acks.length >= this.majority) {\n      return this.confirms(writer, target, acks, writer.length) === UNSEEN\n    }\n\n    return false\n  }\n}\nconst b4a = require('b4a')\nconst safetyCatch = require('safety-catch')\n\n// TODO: should really be expressable with a corestore\n\nconst LINGER_TIME = 30_000\n\nmodule.exports = class CorePool {\n  constructor () {\n    this.pool = new Map()\n  }\n\n  linger (core) {\n    const hex = b4a.toString(core.key, 'hex')\n    if (this.pool.has(hex)) return\n\n    const session = core.session()\n\n    const wrap = {\n      session,\n      timeout: setTimeout(ontimeout, LINGER_TIME, this, session)\n    }\n\n    this.pool.set(hex, wrap)\n  }\n\n  get (key) {\n    const hex = b4a.toString(key, 'hex')\n    const wrap = this.pool.get(hex)\n    if (!wrap) return null\n\n    this.pool.delete(hex)\n    clearTimeout(wrap.timeout)\n    return wrap.session\n  }\n\n  clear () {\n    const closing = []\n    for (const { session, timeout } of this.pool.values()) {\n      clearTimeout(timeout)\n      closing.push(session.close())\n    }\n    this.pool.clear()\n    return Promise.all(closing)\n  }\n}\n\nfunction ontimeout (pool, core) {\n  const hex = b4a.toString(core.key, 'hex')\n  core.close().catch(safetyCatch)\n  pool.pool.delete(hex)\n}\nconst { EventEmitter } = require('events')\nconst ReadyResource = require('ready-resource')\nconst safetyCatch = require('safety-catch')\nconst c = require('compact-encoding')\nconst assert = require('nanoassert')\nconst b4a = require('b4a')\nconst WakeupExtension = require('./extension')\nconst Signer = require('./signer')\nconst { ViewRecord } = require('./messages')\n\nconst {\n  SESSION_CLOSED,\n  REQUEST_CANCELLED,\n  BLOCK_NOT_AVAILABLE\n} = require('hypercore/errors')\n\nconst BULK_SHIFT = 32\n\nclass Snapshot {\n  constructor (source, update) {\n    this.index = source._pendingSnapshots.push(this) - 1\n    this.fork = 0\n    this.length = 0\n    this.byteLength = 0\n    this.tipLength = 0\n    this.tip = null\n    this.source = source\n    if (update) this.update()\n  }\n\n  clone () {\n    const snap = new Snapshot(this.source, false)\n    snap.fork = this.fork\n    snap.length = this.length\n    snap.byteLength = this.byteLength\n\n    // detached clones should be detached\n    if (this.index === -1) {\n      snap.detach(this.tip, this.tipLength)\n    }\n\n    return snap\n  }\n\n  getIndexedLength () {\n    const sharedLength = this.length - this.tipLength\n    return Math.min(this.source.indexedLength, sharedLength)\n  }\n\n  getSignedLength () {\n    const sharedLength = this.length - this.tipLength\n    return Math.min(this.source.core.indexedLength, sharedLength)\n  }\n\n  getIndexedByteLength () {\n    const sharedByteLength = this.tipLength === 0\n      ? this.byteLength\n      : this.tip[0].byteOffset\n\n    return Math.min(this.source.indexedByteLength, sharedByteLength)\n  }\n\n  update () {\n    if (this.index === -1) { // reattach\n      this.index = this.source._pendingSnapshots.push(this) - 1\n      this.tip = null\n      this.tipLength = 0\n    }\n    this.fork = this.source.fork\n    this.length = this.source.length\n    this.byteLength = this.source.byteLength\n  }\n\n  clear () {\n    if (this.index !== -1) this.detach(null, 0)\n    this.source = null\n  }\n\n  detach (tip, length) {\n    this.tip = tip\n    this.tipLength = length\n    if (this.index === -1) return\n    const top = this.source._pendingSnapshots.pop()\n    if (top !== this) this.source._pendingSnapshots[top.index = this.index] = top\n    this.index = -1\n  }\n}\n\nclass AutocoreSession extends EventEmitter {\n  constructor (source, snapshot, indexed, valueEncoding) {\n    super()\n\n    this.isAutobase = true\n\n    this.closing = false\n    this.closed = source.closed\n    this.opened = false\n\n    this.indexed = !snapshot && indexed === true\n\n    this.writable = true // TODO: make this configurable\n\n    this.activeRequests = []\n    this.valueEncoding = valueEncoding || null\n    this.globalCache = source.base.globalCache\n\n    this._source = source\n    this._index = source.sessions.push(this) - 1\n    this._snapshot = snapshot\n\n    this.ready().catch(safetyCatch)\n  }\n\n  get base () {\n    return this._source.base\n  }\n\n  get id () {\n    return this._source.id\n  }\n\n  get key () {\n    return this._source.key\n  }\n\n  get snapshotted () {\n    return this._snapshot !== null\n  }\n\n  get discoveryKey () {\n    return this._source.discoveryKey\n  }\n\n  get fork () {\n    return this._snapshot === null ? this._source.fork : this._snapshot.fork\n  }\n\n  get byteLength () {\n    return this._snapshot === null ? this.indexed ? this.indexedByteLength : this._source.byteLength : this._snapshot.byteLength\n  }\n\n  get length () {\n    return this._snapshot === null ? this.indexed ? this.indexedLength : this._source.length : this._snapshot.length\n  }\n\n  get indexedByteLength () {\n    return this._snapshot === null ? this._source.indexedByteLength : this._snapshot.getIndexedByteLength()\n  }\n\n  get indexedLength () {\n    return this._snapshot === null ? this._source.indexedLength : this._snapshot.getIndexedLength()\n  }\n\n  get signedLength () {\n    return this._snapshot === null ? this._source.core.indexedLength : this._snapshot.getSignedLength()\n  }\n\n  get manifest () {\n    return this._source.core ? this._source.core.manifest : null\n  }\n\n  getBackingCore () {\n    return this._source.core ? this._source.core : null\n  }\n\n  async ready () {\n    if (this.opened) return\n    await this._source.ready()\n    if (this.opened) return\n    this.opened = true\n    this.emit('ready')\n  }\n\n  async getUserData (name) {\n    if (this.opened === false) await this.ready()\n    if (this.closing === true) throw SESSION_CLOSED()\n\n    return await this._source.getUserData(name)\n  }\n\n  async setUserData (name, value, opts) {\n    if (this.opened === false) await this.ready()\n    if (this.closing === true) throw SESSION_CLOSED()\n\n    return await this._source.setUserData(name, value, opts)\n  }\n\n  snapshot ({ valueEncoding = this.valueEncoding } = {}) {\n    if (this.closing === true) throw SESSION_CLOSED()\n\n    return this._snapshot === null\n      ? this._source.createSnapshot(valueEncoding)\n      : this._source._createSession(this._snapshot.clone(), valueEncoding)\n  }\n\n  session ({ valueEncoding = this.valueEncoding, snapshot = this._snapshot !== false, indexed = this.indexed } = {}) {\n    if (this.closing === true) throw SESSION_CLOSED()\n\n    return snapshot\n      ? this.snapshot({ valueEncoding })\n      : this._source.createSession(valueEncoding, indexed)\n  }\n\n  async update (opts) {\n    if (this.opened === false) await this.ready()\n    if (this.closing === true) throw SESSION_CLOSED()\n\n    if (opts && opts.wait) {\n      await this._source.update(opts)\n      if (this.closing === true) throw SESSION_CLOSED()\n    }\n\n    if (this._snapshot !== null) this._snapshot.update()\n    return true\n  }\n\n  async seek (byteOffset, opts) {\n    if (this.opened === false) await this.ready()\n    if (this.closing === true) throw SESSION_CLOSED()\n\n    if (byteOffset < this.indexedByteLength) {\n      return this._source.seek(byteOffset, { activeRequests: this.activeRequests, ...opts })\n    }\n\n    const nodes = this._getNodes()\n    const offset = nodes === this._source.nodes ? this._source._shifted : 0\n\n    let start = offset\n    let end = nodes === this._source.nodes ? nodes.length : this._snapshot.tipLength\n\n    while (end - start > 1) {\n      const mid = (start + end) >>> 1\n\n      if (nodes[mid].byteOffset <= byteOffset) start = mid\n      else end = mid\n    }\n\n    if (start >= end) return null\n\n    const node = nodes[start]\n    if (node.byteOffset + node.block.byteLength <= byteOffset) return null\n\n    return [start - offset + this.indexedLength, byteOffset - node.byteOffset]\n  }\n\n  async get (index, opts) {\n    if (this.opened === false) await this.ready()\n    if (this.closing === true) throw SESSION_CLOSED()\n\n    const onwait = autocoreOnWait.bind(this, opts && opts.onwait)\n\n    opts = { activeRequests: this.activeRequests, valueEncoding: this.valueEncoding, ...opts, onwait }\n\n    // check if we indexed this already\n    if (index < this.indexedLength) {\n      return this._source.get(index, opts)\n    }\n\n    // TODO: this should wait for the block to arrive if not a snap, per hypercore semantics...\n    if (index >= this.length) {\n      throw BLOCK_NOT_AVAILABLE()\n    }\n\n    const nodes = this._getNodes()\n\n    if (nodes === this._source.nodes) {\n      index -= this.indexedLength\n      index += this._source._shifted\n    } else {\n      // nodes might have been indexed since we copied in the nodes, so calculate the indexedLength at that time\n      index -= this._snapshot.length\n      index += this._snapshot.tipLength\n    }\n\n    const blk = index >= 0 && index < nodes.length ? nodes[index].block : null\n    const enc = (opts.valueEncoding && c.from(opts.valueEncoding)) || this.valueEncoding\n\n    return enc ? c.decode(enc, blk) : blk\n  }\n\n  async truncate (newLength) {\n    if (this.opened === false) await this.ready()\n\n    throw new Error('Truncating an Autobased index explicitly is not currently supported')\n  }\n\n  async append (block) {\n    if (this.opened === false) await this.ready()\n    if (this.closing === true) throw SESSION_CLOSED()\n\n    const blocks = Array.isArray(block) ? block : [block]\n    const buffers = new Array(blocks.length)\n\n    for (let i = 0; i < blocks.length; i++) {\n      const blk = blocks[i]\n\n      if (b4a.isBuffer(blk)) buffers[i] = blk\n      else if (this.valueEncoding) buffers[i] = c.encode(this.valueEncoding, blk)\n      else buffers[i] = b4a.from(blk)\n    }\n\n    return this._source._append(buffers)\n  }\n\n  async close () {\n    this.closing = true\n    if (this.opened === false) await this.ready()\n\n    if (this.closed) return\n    this.closed = true\n\n    if (this._snapshot !== null) this._snapshot.clear()\n\n    const top = this._source.sessions.pop()\n    if (top !== this) this._source.sessions[top._index = this._index] = top\n\n    const core = this.getBackingCore().session\n    if (core.replicator) core.replicator.clearRequests(this.activeRequests)\n\n    this.emit('close', false)\n  }\n\n  _getNodes () {\n    return (this._snapshot === null || this._snapshot.tip === null) ? this._source.nodes : this._snapshot.tip\n  }\n}\n\nmodule.exports = class Autocore extends ReadyResource {\n  constructor (base, core, name, opts = {}) {\n    super()\n\n    // set in _open\n    this.indexedLength = 0\n    this.indexedByteLength = 0\n    this.length = 0\n    this.byteLength = 0\n\n    this.fork = 0\n\n    this.base = base\n    this.name = name\n    this.originalCore = core\n    this.core = null\n    this.wakeupExtension = null\n    this.migrated = null\n\n    this.opts = opts\n\n    // managed by base\n    this.appending = 0\n    this.truncating = 0\n    this.indexing = 0\n\n    // managed by system\n    this.systemIndex = -1\n    this.checkpointer = 0\n\n    this.sessions = []\n    this.nodes = []\n\n    this.signer = new Signer(base, this)\n\n    this._shifted = 0\n    this._pendingSnapshots = []\n    this._lastCheckpoint = null\n\n    this._queueFastForward = this.base.queueFastForward.bind(this.base)\n\n    this.ready().catch(safetyCatch)\n  }\n\n  _isSystem () {\n    return this.base.system.core._source === this\n  }\n\n  get id () {\n    return this.originalCore.id\n  }\n\n  get key () {\n    return this.originalCore.key\n  }\n\n  get discoveryKey () {\n    return this.originalCore.discoveryKey\n  }\n\n  get latestKey () {\n    return this.base._viewStore.deriveKey(this.name) || this.key\n  }\n\n  get pendingIndexedLength () {\n    return this.indexedLength + this.indexing\n  }\n\n  _registerSystemCore () {\n    this._registerWakeupExtension()\n    this._registerFastForwardListener()\n  }\n\n  _registerWakeupExtension () {\n    if (this.wakeupExtension && this.wakeupExtension.core === this.originalCore) return // no need to reset\n    this.wakeupExtension = new WakeupExtension(this.base, this.originalCore)\n  }\n\n  _registerFastForwardListener () {\n    this.originalCore.removeListener('append', this._queueFastForward)\n    this.originalCore.on('append', this._queueFastForward)\n  }\n\n  async _ensureCore (key, length) {\n    let swap = null\n\n    if (!b4a.equals(this.originalCore.key, key)) {\n      const encryptionKey = this.base._viewStore.getBlockKey(this.name)\n      swap = this.base.store.get({ key, encryptionKey, isBlockKey: true, cache: !!this.originalCore.cache })\n      await swap.ready()\n    }\n\n    const prevOriginalCore = this.originalCore\n    this.originalCore = swap || this.originalCore\n\n    // set handlers if we replaced core\n    if (this._isSystem()) this._registerSystemCore()\n\n    const core = this.originalCore.batch({ autoClose: false, session: true, checkout: length })\n    await core.ready()\n\n    // reset state\n    if (this.core) await this._updateBatch(core)\n    else this.core = core\n\n    if (swap) await prevOriginalCore.close()\n\n    await this._ensureUserData(this.core, false)\n  }\n\n  async reset (length) {\n    let core = this.originalCore.batch({ clear: true, autoClose: false, session: true })\n    await core.ready()\n    if (core.length > length) {\n      await core.close()\n      core = this.originalCore.batch({ checkout: length, autoClose: false, session: true })\n      await core.ready()\n    }\n\n    await this._updateBatch(core)\n  }\n\n  async _updateBatch (core) {\n    const prevCore = this.core\n    const length = this.length\n\n    // detach all snaps\n    for (let i = this._pendingSnapshots.length - 1; i >= 0; i--) {\n      const snap = this._pendingSnapshots[i]\n      const end = snap.length - this.indexedLength - this._shifted\n      snap.detach(this.nodes, end)\n    }\n\n    this.core = core\n    this.nodes = []\n    this._shifted = 0\n\n    this.indexing = 0\n    this.appending = 0\n    this.truncating = 0\n\n    this._updateCoreState()\n\n    if (this.length > length) this._emitAppend()\n\n    await prevCore.close()\n  }\n\n  _updateCoreState () {\n    this.length = this.core.length\n    this.byteLength = this.core.byteLength\n    this.indexedLength = this.core.length\n    this.indexedByteLength = this.core.byteLength\n  }\n\n  async _open () {\n    await Promise.resolve() // wait a tick so this doesn't run sync in the constructor...\n    await this.base._presystem\n\n    await this.originalCore.ready()\n\n    if (this.base.encryptionKey && !this.originalCore.encryption) {\n      await this.originalCore.setEncryptionKey(this.base._viewStore.getBlockKey(this.name), { isBlockKey: true })\n    }\n\n    const sys = this.base.system.opened ? this.base.system : this.base._initialSystem\n\n    if (sys) {\n      await sys.ready()\n\n      for (let i = 0; i < this.base._initialViews.length; i++) {\n        const { name, key, length } = this.base._initialViews[i]\n        if (name !== this.name) continue\n\n        this.systemIndex = i - 1\n        await this._ensureCore(key, length)\n        break\n      }\n    }\n\n    // register handlers if needed\n    if (this._isSystem()) this._registerSystemCore()\n\n    if (!this.core) {\n      this.core = this.originalCore.batch({ autoClose: false, session: true, checkout: 0 })\n      await this.core.ready()\n    }\n\n    await this._ensureUserData(this.originalCore, false)\n\n    this._updateCoreState()\n\n    for (const snap of this._pendingSnapshots) snap.update()\n\n    if (this.signer !== null) this.signer.open()\n  }\n\n  _close () {\n    return this.core.close()\n  }\n\n  async _ensureUserData (core, force) {\n    await core.setUserData('referrer', this.base.key)\n\n    const buf = await core.getUserData('autobase/view')\n    const record = (buf !== null && buf[0] === 0) ? c.decode(ViewRecord, buf) : { name: null, migrated: null, audits: 1 }\n\n    if (record.audits === 0) {\n      // old core, audit it real quick\n      const corrections = await core.core.audit()\n      if (corrections.blocks || corrections.tree) debugWarn('view', core.id, 'auto corrected itself', corrections)\n    }\n\n    const prev = (!force && record.name) ? record : null\n    if (prev && !this.migrated) this.migrated = prev.migrated\n\n    await core.setUserData('autobase/view', c.encode(ViewRecord, { name: this.name, migrated: prev ? prev.migrated : this.migrated, audits: 1 }))\n  }\n\n  createSession (valueEncoding, indexed) {\n    return this._createSession(null, valueEncoding, indexed)\n  }\n\n  createSnapshot (valueEncoding) {\n    return this._createSession(new Snapshot(this, this.opened), valueEncoding)\n  }\n\n  _createSession (snapshot, valueEncoding, indexed) {\n    return new AutocoreSession(this, snapshot, indexed, valueEncoding ? c.from(valueEncoding) : null)\n  }\n\n  async seek (bytes, opts) {\n    const core = this.core\n\n    while (true) {\n      try {\n        return await core.seek(bytes, opts)\n      } catch (err) {\n        if (err.code === 'REQUEST_CANCELLED' || this.base.closing || core === this.core) throw err\n        // retry\n      }\n    }\n  }\n\n  async get (index, opts) {\n    const core = this.core\n\n    while (true) {\n      try {\n        return await core.get(index, opts)\n      } catch (err) {\n        if (err.code === 'REQUEST_CANCELLED' || this.base.closing || core === this.core) throw err\n        // retry\n      }\n    }\n  }\n\n  async setUserData (name, val, opts) {\n    const core = this.core\n\n    while (true) {\n      try {\n        return await core.setUserData(name, val, opts)\n      } catch (err) {\n        if (this.base.closing || core === this.core) throw err\n        // retry\n      }\n    }\n  }\n\n  async getUserData (name) {\n    const core = this.core\n\n    while (true) {\n      try {\n        return await core.getUserData(name)\n      } catch (err) {\n        if (this.base.closing || core === this.core) throw err\n        // retry\n      }\n    }\n  }\n\n  truncate (newLength) {\n    this._truncateAndDetach(newLength)\n    this.fork++\n\n    for (const session of this.sessions) {\n      if (session.snapshotted === false) session.emit('truncate', newLength, this.fork)\n    }\n  }\n\n  async checkpoint () {\n    return {\n      checkpointer: this.indexing === 0 ? this.checkpointer : 0,\n      checkpoint: (this.checkpointer && this.indexing === 0) ? null : await this._checkpoint()\n    }\n  }\n\n  async _checkpoint () {\n    if (!this._lastCheckpoint || this._lastCheckpoint.length < this.pendingIndexedLength) {\n      await this._updateCheckpoint()\n    }\n\n    return this._lastCheckpoint\n  }\n\n  async _updateCheckpoint (migrated) {\n    const blocks = this.indexBatch(0, this.indexing)\n    const batch = await this.core.restoreBatch(this.pendingIndexedLength, { blocks, clone: false })\n\n    const signable = batch.signable(this.core.key)\n    const signature = this.base.local.core.crypto.sign(signable, this.base.local.keyPair.secretKey)\n\n    // todo: signer should sign\n    this._lastCheckpoint = {\n      signature,\n      length: batch.length\n    }\n  }\n\n  update (opts) {\n    if (this._isSystem()) return\n    return this.base.update(opts)\n  }\n\n  indexBatch (start, end) {\n    if (start >= end) return []\n    const blocks = new Array(end - start)\n    for (let i = 0; i < blocks.length; i++) {\n      blocks[i] = this.nodes[this._shifted + start + i].block\n    }\n    return blocks\n  }\n\n  // called by autobase\n  _onindex (added) {\n    const head = this.nodes[this._shifted + added - 1]\n\n    this.indexedLength += added\n    this.indexedByteLength = head.byteOffset + head.block.byteLength\n\n    this._shifted += added\n    if (this._shifted >= BULK_SHIFT || this._shifted === this.nodes.length) this._gc()\n\n    this.checkpointer = 0\n\n    this._emitIndexedAppend()\n  }\n\n  // called by autobase\n  _onundo (removed) {\n    if (!removed) return\n    const newLength = this.length - removed\n    this.truncate(newLength)\n  }\n\n  _append (batch) {\n    for (let i = 0; i < batch.length; i++) {\n      const block = batch[i]\n      this.nodes.push({ byteOffset: this.byteLength, block })\n      this.byteLength += block.byteLength\n    }\n\n    this.length += batch.length\n    this.base._onviewappend(this, batch.length)\n    this._emitAppend()\n  }\n\n  _emitAppend () {\n    for (const session of this.sessions) {\n      if (session.snapshotted === false && session.indexed === false) session.emit('append')\n    }\n  }\n\n  _emitIndexedAppend () {\n    for (const session of this.sessions) {\n      if (session.indexed) session.emit('append')\n    }\n  }\n\n  isBootstrapped () {\n    return !!(this.core && this.core.manifest && this.core.manifest.signers.length > 0)\n  }\n\n  async bootstrap () {\n    if (this.isBootstrapped()) return true\n\n    if (this.base.linearizer.indexers.length === 0) return false\n\n    const [bootstrap] = this.base.linearizer.indexers\n    if (!bootstrap.core.manifest) return false\n\n    await this.migrateTo([bootstrap], 0)\n\n    this.base.queueFastForward()\n    return true\n  }\n\n  _shouldFlush () {\n    if (this.indexing > 0) return true\n    if (this.core.session.opened && this.core.indexedLength === this.core.length) return false\n    return true\n  }\n\n  async flush () {\n    if (!this.core.opened) await this.core.ready()\n\n    if (!this.isBootstrapped() && !(await this.bootstrap())) {\n      return false\n    }\n\n    if (!this._shouldFlush()) return true\n\n    if (this.indexing) {\n      const batch = this.indexBatch(0, this.indexing)\n      await this.core.append(batch)\n    }\n\n    return this._flush()\n  }\n\n  async _flush () {\n    let flushed = this.core.flushedLength === this.core.length\n\n    const maxLength = this.core.length\n    if (maxLength === 0) return flushed\n\n    const maxFlushedLength = Math.min(maxLength, this.core.length)\n\n    if (maxFlushedLength > this.core.indexedLength && this.core.flushedLength < this.core.length) {\n      flushed = false\n    }\n\n    const indexers = this.base._viewStore._indexers\n    const signableLength = await this.signer.getSignableLength(indexers)\n\n    // current core can only flush up to first pending migrate\n    const maxSignedlength = Math.min(maxLength, signableLength)\n\n    if (maxSignedlength > this.core.indexedLength) {\n      const signature = await this.signer.sign(indexers, maxSignedlength)\n      if (!(await this.core.flush({ length: maxSignedlength, signature }))) return false\n      flushed = true\n    }\n\n    return flushed\n  }\n\n  async getPrologue (length) {\n    if (!length) return null\n\n    const blocks = this.indexBatch(0, length - this.indexedLength)\n    const batch = await this.core.restoreBatch(length, { blocks, clone: false })\n\n    return { hash: batch.hash(), length }\n  }\n\n  async deriveKey (indexers, length) {\n    const prologue = await this.getPrologue(length)\n    return this.base.deriveKey(this.name, indexers, prologue)\n  }\n\n  async migrateTo (indexers, length) {\n    if (!this.opened) await this.ready()\n\n    const core = await this.base._viewStore.getCore(this, indexers, length, this.opts)\n    await core.ready()\n\n    // clone state from previous core\n    const batch = await this._migrateCurrentCore(core, length, indexers)\n\n    const old = this.core\n    const oldOriginal = this.originalCore\n\n    this.originalCore = core\n    this.core = batch\n\n    await old.close()\n    await oldOriginal.close()\n\n    if (this._isSystem()) this._registerSystemCore()\n\n    for (const session of this.sessions) {\n      if (!session.snapshotted) session.emit('migrate')\n    }\n  }\n\n  async _migrateCurrentCore (next, length, indexers) {\n    if (length > 0) {\n      const sourceLength = this.core.indexedLength\n\n      // copy state over\n      const additional = []\n      for (let i = sourceLength; i < length; i++) {\n        additional.push(await this.core.get(i, { raw: true }))\n      }\n\n      if (this.core.session.core !== next.core) {\n        await next.core.copyPrologue(this.core.session.core, { additional })\n      }\n    }\n\n    // force update as we might have copied to old migrated pointer userdata\n    this.migrated = this.core.key\n    await this._ensureUserData(next, true)\n\n    // todo: should core always be flushed to length?\n    const batch = next.batch({ autoClose: false, session: true, checkout: length })\n    await batch.ready()\n\n    // handle remaining state\n    if (batch.length < this.core.length) {\n      const blocks = []\n      while (batch.length + blocks.length < this.core.length) {\n        blocks.push(await this.core.get(batch.length + blocks.length))\n      }\n      await batch.append(blocks)\n    }\n\n    return batch\n  }\n\n  async catchup ({ key, length, systemIndex }) {\n    if (!this.opened) await this.ready()\n    await this._ensureCore(key, length)\n    if (systemIndex !== -1) this.systemIndex = systemIndex\n  }\n\n  _gc () {\n    if (this._shifted === 0) return\n    this.nodes = this.nodes.slice(this._shifted)\n    this._shifted = 0\n  }\n\n  _truncateAndDetach (sharedLength) {\n    assert(this.indexedLength <= sharedLength && sharedLength <= this.length, 'Invalid truncation')\n\n    // if same len, nothing to do...\n    if (sharedLength === this.length) return\n    if (sharedLength === 0) this.base._viewStore._unindex(this)\n\n    let maxSnap = 0\n    for (const snap of this._pendingSnapshots) {\n      if (snap.length > sharedLength && maxSnap < snap.length) {\n        maxSnap = snap.length\n      }\n    }\n\n    if (maxSnap <= sharedLength) {\n      while (this.length > sharedLength) {\n        const { block } = this.nodes.pop()\n        this.length--\n        this.byteLength -= block.byteLength\n      }\n      return\n    }\n\n    this._gc()\n\n    for (let i = this._pendingSnapshots.length - 1; i >= 0; i--) {\n      const snap = this._pendingSnapshots[i]\n      const end = snap.length - this.indexedLength - this._shifted\n      if (snap.length > sharedLength) snap.detach(this.nodes, end)\n    }\n\n    const firstRemovedIndex = sharedLength - this.indexedLength\n    const firstRemoved = this.nodes[firstRemovedIndex]\n\n    this.nodes = this.nodes.slice(0, firstRemovedIndex)\n    this.length = sharedLength\n    this.byteLength = firstRemoved.byteOffset\n  }\n}\n\nfunction debugWarn (...msg) { // calls to this are ONLY allowed for soft assertions\n  console.log('[autobase]', ...msg)\n}\n\nfunction autocoreOnWait (fn, index, core) {\n  if (this.closing) throw REQUEST_CANCELLED()\n  if (fn) return fn(index, this)\n}\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst { Wakeup } = require('./messages')\n\nconst VERSION = 1\n\nmodule.exports = class WakeupExtension {\n  constructor (base, core, passive) {\n    this.base = base\n    this.core = core\n\n    this.extension = this.core.registerExtension('autobase', {\n      onmessage: this._onmessage.bind(this)\n    })\n\n    const req = c.encode(Wakeup, { type: 0 })\n\n    this.core.on('peer-add', (peer) => {\n      this.extension.send(req, peer)\n    })\n\n    if (!passive) {\n      for (const peer of this.core.peers) {\n        this.extension.send(req, peer)\n      }\n    }\n  }\n\n  sendWakeup (key, target) {\n    const m = this._encodeWakeup(VERSION)\n    if (!m) return\n\n    for (const peer of this.core.peers) {\n      if (b4a.equals(peer.remotePublicKey, key)) {\n        this.extension.send(m, peer)\n        break\n      }\n    }\n  }\n\n  requestWakeup () {\n    this.extension.broadcast(c.encode(Wakeup, { type: 0 }))\n  }\n\n  broadcastWakeup () {\n    const m = this._encodeWakeup(VERSION)\n    if (m) this.extension.broadcast(m)\n  }\n\n  _encodeWakeup (version) {\n    const writers = []\n\n    for (const w of this.base.activeWriters) {\n      if (w.isActiveIndexer || w.flushed()) continue\n      writers.push({ key: w.core.key, length: w.length })\n    }\n\n    if (!writers.length) return null\n\n    return c.encode(Wakeup, { version, type: 1, writers })\n  }\n\n  _onmessage (buf, from) {\n    if (!buf) return\n\n    let value = null\n    try {\n      value = c.decode(Wakeup, buf)\n    } catch {\n      return\n    }\n\n    if (value.type === 0) {\n      const m = this._encodeWakeup(value.version)\n      if (m) this.extension.send(m, from)\n      return\n    }\n\n    this.base.hintWakeup(value.writers)\n  }\n}\nconst b4a = require('b4a')\nconst assert = require('nanoassert')\n\nconst Clock = require('./clock')\nconst Consensus = require('./consensus')\nconst Topolist = require('./topolist')\n\nclass Node {\n  constructor (writer, length, value, heads, batch, dependencies, version) {\n    this.writer = writer\n    this.length = length\n    this.value = value\n    this.heads = heads\n    this.actualHeads = heads.slice(0) // TODO: we should remove this and just not mutate heads...\n\n    this.dependents = new Set()\n    this.dependencies = dependencies\n\n    this.version = version\n\n    this.batch = batch\n\n    this.clock = new Clock()\n\n    this.yielded = false\n    this.yielding = false\n  }\n\n  clear () {\n    this.clock = null\n    this.dependencies = null\n    this.dependents = null\n    return this\n  }\n\n  reset () {\n    this.yielded = false\n    this.yielding = false\n    for (const dep of this.dependents) dep.dependencies.add(this)\n    this.dependents.clear()\n  }\n\n  active () {\n    for (const dep of this.dependencies) {\n      if (dep.yielded) {\n        this.dependencies.delete(dep) // nodes might be yielded during buffering\n      } else {\n        dep.dependents.add(this)\n        this.clock.add(dep.clock)\n      }\n    }\n\n    if (this.writer.isActiveIndexer) this.clock.set(this.writer.core.key, this.length)\n  }\n\n  tieBreak (node) {\n    return tieBreak(this, node)\n  }\n\n  hasDependency (dep) {\n    for (const h of this.actualHeads) {\n      if (sameNode(h, dep)) return true\n    }\n    return false\n  }\n\n  get ref () {\n    return this.writer.core.key.toString('hex').slice(0, 2) + ':' + this.length\n  }\n}\n\nmodule.exports = class Linearizer {\n  constructor (indexers, { heads = [], writers = new Map() } = {}) {\n    this.heads = new Set()\n    this.tails = new Set()\n    this.tip = new Topolist()\n    this.size = 0 // useful for debugging\n    this.updated = false\n    this.indexersUpdated = false\n    this.writers = writers\n\n    this.consensus = new Consensus(indexers)\n    this._initialHeads = heads.slice(0)\n    this._strictlyAdded = null\n\n    for (const { key, length } of heads) {\n      this.consensus.removed.set(key, length)\n    }\n  }\n\n  get indexers () {\n    return this.consensus.indexers\n  }\n\n  static createNode (writer, length, value, heads, batch, dependencies, version) {\n    return new Node(writer, length, value, heads, batch, dependencies, version)\n  }\n\n  // returns the global links of the dag, use this to link against the current state of the dag\n  // TODO: rename to heads() and move the sets to _ props\n  getHeads () {\n    const heads = this._initialHeads.slice(0)\n    for (const node of this.heads) heads.push({ key: node.writer.core.key, length: node.length })\n    return heads\n  }\n\n  // TODO: might contain dups atm, nbd for how we use it, returns an array of writers you can \"pull\"\n  // to get the full dag view at any time\n  getBootstrapWriters () {\n    const writers = []\n\n    for (const head of this.heads) writers.push(head.writer)\n    for (let i = 0; i < this.consensus.indexers.length; i++) writers.push(this.consensus.indexers[i])\n\n    return writers\n  }\n\n  addHead (node) {\n    node.active()\n\n    // 99.99% of the time _initialHeads is empty...\n    if (this._initialHeads.length > 0) this._updateInitialHeads(node)\n\n    if (!node.dependencies.size) {\n      this.tails.add(node)\n    }\n\n    for (const head of this.heads) {\n      if (node.hasDependency(head)) {\n        this.heads.delete(head)\n      }\n    }\n\n    this.tip.add(node)\n    if (node.writer.isActiveIndexer) this.consensus.addHead(node)\n\n    this.size++\n    this.heads.add(node)\n\n    this.updated = true\n\n    return node\n  }\n\n  update () {\n    if (!this.updated) return null\n    this.updated = false\n\n    // get the indexed nodes\n    const indexed = []\n    while (true) {\n      const nodes = this.consensus.shift()\n      if (!nodes.length) break\n\n      this._yield(nodes, indexed)\n    }\n\n    return this.tip.flush(indexed)\n  }\n\n  _updateInitialHeads (node) {\n    for (const head of node.actualHeads) {\n      for (let i = 0; i < this._initialHeads.length; i++) {\n        const { key, length } = this._initialHeads[i]\n        if (length !== head.length || !b4a.equals(key, head.key)) continue\n        this._initialHeads.splice(i--, 1)\n      }\n    }\n  }\n\n  /* Ack methods */\n\n  shouldAck (writer, pending = false) {\n    if (!writer || !writer.isActiveIndexer) return false\n\n    // all indexers have to flushed to the dag before we ack as a quick \"debounce\"\n    for (const w of this.indexers) {\n      if (w.length !== w.available) return false\n    }\n\n    let isHead = false\n\n    // if ANY head is not an indexer ack\n    for (const head of this.heads) {\n      if (!head.writer.isActiveIndexer) return true\n      if (head.writer === writer) isHead = true\n    }\n\n    if (this.heads.size === 1 && isHead) {\n      return false // never self-ack!\n    }\n\n    const visited = new Set()\n\n    // check if there is non-null value\n    let valueCheck = false\n\n    for (const tail of this.tails) {\n      if (pending || this._nonNull(tail, visited)) {\n        valueCheck = true\n        break\n      }\n    }\n\n    if (!valueCheck) return false\n\n    if (this.consensus.shouldAck(writer)) return true\n\n    return this._shouldAckHeads(writer, pending)\n  }\n\n  // check if there is any value above this node\n  _nonNull (target, visited) {\n    const stack = [target]\n\n    while (stack.length) {\n      const node = stack.pop()\n\n      if (visited.has(node)) continue\n      if (node.value !== null) return true\n\n      visited.add(node)\n\n      for (const dep of node.dependents) {\n        stack.push(dep)\n      }\n    }\n\n    return false\n  }\n\n  // ack if any head is closer to confirming a value\n  _shouldAckHeads (writer, pending) {\n    const prev = writer.head()\n\n    for (const head of this.heads) {\n      // only check other writers heads\n      if (head.writer === writer) continue\n\n      const stack = [head]\n      const visited = new Set()\n\n      while (stack.length) {\n        const node = stack.pop()\n\n        if (visited.has(node)) continue\n        visited.add(node)\n\n        if (pending || node.value !== null) {\n          const acks = this.consensus.acksFromNode(node, head)\n          const prevAcks = this.consensus.acksFromNode(node, prev)\n\n          // head sees more acks\n          if (acks.size > prevAcks.size) return true\n\n          for (const idx of acks) {\n            // head sees acks that writer does not\n            if (!prevAcks.has(idx)) return true\n          }\n\n          // both seen, no point going any further down\n          if (prevAcks.size && acks.size) continue\n        }\n\n        stack.push(...node.dependencies)\n      }\n    }\n\n    return false\n  }\n\n  /* Full DAG methods */\n\n  _yield (nodes, indexed = []) {\n    const offset = indexed.length\n    const tails = []\n\n    // determine which nodes are yielded\n    while (nodes.length) {\n      const node = nodes.pop()\n\n      if (node.yielding) continue\n      node.yielding = true\n\n      if (!node.dependencies.size) tails.push(node)\n\n      nodes.push(...node.dependencies)\n    }\n\n    while (tails.length) {\n      let tail = tails.pop()\n\n      for (tail of this._removeBatch(tail)) {\n        Topolist.add(tail, indexed, offset)\n      }\n\n      for (const dep of tail.dependents) {\n        if (!dep.dependencies.size && dep.yielding) tails.push(dep)\n      }\n    }\n\n    return indexed\n  }\n\n  _isTail (node) {\n    // a tail has no unyielded dependencies\n    for (const dep of node.dependencies) {\n      if (!dep.yielded) return false\n    }\n\n    return true\n  }\n\n  _removeNode (node) {\n    this.tails.delete(node)\n    this.heads.delete(node)\n    this.consensus.remove(node)\n\n    // update the tailset\n    for (const d of node.dependents) {\n      d.dependencies.delete(node)\n      if (this._isTail(d)) this.tails.add(d)\n    }\n\n    node.yielded = true\n    this.size--\n\n    if (this.heads.size === 0) {\n      // in case of a single writer the dag might drain immediately...\n      this._initialHeads.push({ key: node.writer.core.key, length: node.length })\n    }\n\n    return node\n  }\n\n  _removeBatch (node) {\n    const batch = [this._removeNode(node)]\n\n    while (node.batch !== 1) { // its a batch!\n      if (node.dependents.size === 0) { // bad batch node, auto correct\n        const next = node.writer.get(node.length)\n        if (next && next.batch === node.batch - 1) node.dependents.add(next)\n      }\n\n      assert(node.dependents.size === 1, 'Batch is linked partially, which is not allowed')\n\n      node = getFirst(node.dependents)\n      batch.push(this._removeNode(node))\n    }\n\n    return batch\n  }\n}\n\nfunction tieBreak (a, b) {\n  return Topolist.compare(a, b) < 0 // lowest key wis\n}\n\nfunction getFirst (set) {\n  return set[Symbol.iterator]().next().value\n}\n\nfunction sameNode (a, b) {\n  return b4a.equals(a.key, b.writer.core.key) && a.length === b.length\n}\nconst c = require('compact-encoding')\nconst assert = require('nanoassert')\n\nconst Checkout = {\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.key)\n    c.uint.preencode(state, m.length)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.key)\n    c.uint.encode(state, m.length)\n  },\n  decode (state) {\n    return {\n      key: c.fixed32.decode(state),\n      length: c.uint.decode(state)\n    }\n  }\n}\n\nconst Clock = c.array(Checkout)\n\nconst IndexCheckpoint = {\n  preencode (state, m) {\n    c.fixed64.preencode(state, m.signature)\n    c.uint.preencode(state, m.length)\n  },\n  encode (state, m) {\n    c.fixed64.encode(state, m.signature)\n    c.uint.encode(state, m.length)\n  },\n  decode (state) {\n    return {\n      signature: c.fixed64.decode(state),\n      length: c.uint.decode(state)\n    }\n  }\n}\n\nconst KeyV0 = {\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.key)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.key)\n  },\n  decode (state) {\n    return {\n      key: c.fixed32.decode(state),\n      length: -1\n    }\n  }\n}\n\nconst KeysV0 = c.array(KeyV0)\n\nconst WakeupV0 = {\n  preencode (state, m) {\n    c.uint.preencode(state, 0) // version\n    c.uint.preencode(state, m.type)\n\n    if (m.type === 1) {\n      KeysV0.preencode(state, m.writers)\n    }\n  },\n  encode (state, m) {\n    c.uint.encode(state, 0) // version\n    c.uint.encode(state, m.type)\n\n    if (m.type === 1) {\n      KeysV0.encode(state, m.writers)\n    }\n  },\n  decode (state) {\n    const v = c.uint.decode(state)\n    if (v !== 0) throw new Error('Unsupported version: ' + v)\n\n    const type = c.uint.decode(state)\n    const m = { version: 0, type, writers: null }\n\n    if (m.type === 1) {\n      m.writers = KeysV0.decode(state)\n    }\n\n    return m\n  }\n}\n\nconst Wakeup = {\n  preencode (state, m) {\n    if (m.version === 0) return WakeupV0.preencode(state, m)\n\n    c.uint.preencode(state, 1) // version\n    c.uint.preencode(state, m.type)\n\n    if (m.type === 1) {\n      Clock.preencode(state, m.writers)\n    }\n  },\n  encode (state, m) {\n    if (m.version === 0) return WakeupV0.encode(state, m)\n\n    c.uint.encode(state, 1) // version\n    c.uint.encode(state, m.type)\n\n    if (m.type === 1) {\n      Clock.encode(state, m.writers)\n    }\n  },\n  decode (state) {\n    const start = state.start\n    const v = c.uint.decode(state)\n\n    if (v > 1) throw new Error('Unsupported version: ' + v)\n\n    if (v === 0) {\n      state.start = start\n      return WakeupV0.decode(state)\n    }\n\n    const type = c.uint.decode(state)\n    const m = { version: 1, type, writers: null }\n\n    if (m.type === 1) {\n      m.writers = Clock.decode(state)\n    }\n\n    return m\n  }\n}\n\nconst Views = c.array(c.string)\n\nconst BootRecord = {\n  preencode (state, m) {\n    c.uint.preencode(state, 0) // version\n    Checkout.preencode(state, m.indexed)\n    Clock.preencode(state, m.heads)\n    Views.preencode(state, m.views)\n  },\n  encode (state, m) {\n    c.uint.encode(state, 0) // version\n    Checkout.encode(state, m.indexed)\n    Clock.encode(state, m.heads)\n    Views.encode(state, m.views)\n  },\n  decode (state) {\n    const v = c.uint.decode(state)\n    assert(v === 0, 'Unsupported version: ' + v)\n\n    return {\n      indexed: Checkout.decode(state),\n      heads: Clock.decode(state),\n      views: Views.decode(state)\n    }\n  }\n}\n\nconst ViewRecord = {\n  preencode (state, m) {\n    c.uint.preencode(state, 0) // version\n    c.string.preencode(state, m.name)\n    c.uint.preencode(state, (m.migrated ? 1 : 0) | (m.audits ? 2 : 0))\n    if (m.migrated) c.fixed32.preencode(state, m.migrated)\n    if (m.audits) c.uint.preencode(state, m.audits)\n  },\n  encode (state, m) {\n    c.uint.encode(state, 0) // version\n    c.string.encode(state, m.name)\n    c.uint.encode(state, (m.migrated ? 1 : 0) | (m.audits ? 2 : 0))\n    if (m.migrated) c.fixed32.encode(state, m.migrated)\n    if (m.audits) c.uint.encode(state, m.audits)\n  },\n  decode (state) {\n    const v = c.uint.decode(state)\n    assert(v === 0, 'Unsupported version: ' + v)\n\n    const name = c.string.decode(state)\n    const flags = c.uint.decode(state)\n    const migrated = (flags & 1) ? c.fixed32.decode(state) : null\n    const audits = (flags & 2) ? c.uint.decode(state) : 0\n\n    return {\n      name,\n      migrated,\n      audits\n    }\n  }\n}\n\nconst Checkpoint = c.array({\n  preencode (state, idx) {\n    c.uint.preencode(state, idx.checkpointer)\n    if (idx.checkpoint !== null) IndexCheckpoint.preencode(state, idx.checkpoint)\n  },\n  encode (state, idx) {\n    c.uint.encode(state, idx.checkpointer)\n    if (idx.checkpoint !== null) IndexCheckpoint.encode(state, idx.checkpoint)\n  },\n  decode (state) {\n    const checkpointer = c.uint.decode(state)\n    const checkpoint = checkpointer ? null : IndexCheckpoint.decode(state)\n\n    return {\n      checkpointer,\n      checkpoint\n    }\n  }\n})\n\nconst Indexer = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.signature)\n    c.fixed32.preencode(state, m.namespace)\n    c.fixed32.preencode(state, m.publicKey)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.signature)\n    c.fixed32.encode(state, m.namespace)\n    c.fixed32.encode(state, m.publicKey)\n  },\n  decode (state) {\n    return {\n      signature: c.uint.decode(state),\n      namespace: c.fixed32.decode(state),\n      publicKey: c.fixed32.decode(state)\n    }\n  }\n}\n\nconst Indexers = c.array(Indexer)\n\nconst DigestV0 = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.pointer)\n    if (m.pointer === 0) {\n      Indexers.preencode(state, m.indexers)\n    }\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.pointer)\n    if (m.pointer === 0) {\n      Indexers.encode(state, m.indexers)\n    }\n  },\n  decode (state) {\n    const pointer = c.uint.decode(state)\n    return {\n      pointer,\n      indexers: pointer === 0 ? Indexers.decode(state) : null\n    }\n  }\n}\n\nconst Digest = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.pointer)\n    if (m.pointer === 0) {\n      c.fixed32.preencode(state, m.key)\n    }\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.pointer)\n    if (m.pointer === 0) {\n      c.fixed32.encode(state, m.key)\n    }\n  },\n  decode (state) {\n    const pointer = c.uint.decode(state)\n    return {\n      pointer,\n      key: pointer === 0 ? c.fixed32.decode(state) : null\n    }\n  }\n}\n\nconst Node = {\n  preencode (state, m) {\n    Clock.preencode(state, m.heads)\n    c.uint.preencode(state, m.batch)\n    c.buffer.preencode(state, m.value)\n  },\n  encode (state, m) {\n    Clock.encode(state, m.heads)\n    c.uint.encode(state, m.batch)\n    c.buffer.encode(state, m.value)\n  },\n  decode (state, m) {\n    return {\n      heads: Clock.decode(state),\n      batch: c.uint.decode(state),\n      value: c.buffer.decode(state)\n    }\n  }\n}\n\nconst Additional = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.pointer)\n    if (m.pointer === 0) {\n      AdditionalData.preencode(state, m.data)\n    }\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.pointer)\n    if (m.pointer === 0) {\n      AdditionalData.encode(state, m.data)\n    }\n  },\n  decode (state) {\n    const pointer = c.uint.decode(state)\n    return {\n      pointer,\n      data: pointer === 0 ? AdditionalData.decode(state) : null\n    }\n  }\n}\n\nconst AdditionalData = {\n  preencode (state, m) {\n    c.uint.preencode(state, 0)\n  },\n  encode (state, m) {\n    c.uint.encode(state, 0) // empty for now, for the future\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      encryptionId: flags & 1 ? c.fixed32.decode(state) : null, // to help validate the encryption key used\n      abi: flags & 2 ? c.uint.decode(state) : 0\n    }\n  }\n}\n\nconst OplogMessage = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.version)\n    c.uint.preencode(state, m.maxSupportedVersion)\n\n    const isCheckpointer = m.digest !== null && m.checkpoint !== null\n\n    let flags = 0\n    if (isCheckpointer) flags |= 1\n\n    c.uint.preencode(state, flags)\n\n    if (isCheckpointer) {\n      Checkpoint.preencode(state, m.checkpoint)\n      Digest.preencode(state, m.digest)\n    }\n\n    Node.preencode(state, m.node)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.version)\n    c.uint.encode(state, m.maxSupportedVersion)\n\n    const isCheckpointer = m.digest !== null && m.checkpoint !== null\n\n    let flags = 0\n    if (isCheckpointer) flags |= 1\n\n    c.uint.encode(state, flags)\n\n    if (isCheckpointer) {\n      Checkpoint.encode(state, m.checkpoint)\n      Digest.encode(state, m.digest)\n    }\n\n    Node.encode(state, m.node)\n  },\n  decode (state) {\n    const version = c.uint.decode(state)\n\n    if (version === 0) {\n      const m = OplogMessageV0.decode(state)\n\n      return {\n        version,\n        maxSupportedVersion: m.maxSupportedVersion,\n        digest: null,\n        checkpoint: m.checkpoint,\n        node: m.node\n      }\n    }\n\n    const maxSupportedVersion = c.uint.decode(state)\n\n    const flags = c.uint.decode(state)\n\n    const isCheckpointer = (flags & 1) !== 0\n\n    const checkpoint = isCheckpointer ? Checkpoint.decode(state) : null\n    const digest = isCheckpointer ? Digest.decode(state) : null\n\n    const node = Node.decode(state)\n\n    return {\n      version,\n      maxSupportedVersion,\n      digest,\n      checkpoint,\n      node\n    }\n  }\n}\n\nconst OplogMessageV0 = {\n  preencode (state, m) {\n    const isCheckpointer = m.digest !== null && m.checkpoint !== null\n    c.uint.preencode(state, isCheckpointer ? 1 : 0)\n\n    if (isCheckpointer) {\n      DigestV0.preencode(state, m.digest)\n      Checkpoint.preencode(state, m.checkpoint)\n    }\n\n    Node.preencode(state, m.node)\n\n    Additional.preencode(state, m.additional) // at the btm so it can be edited\n    c.uint.preencode(state, m.maxSupportedVersion)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.version)\n\n    const isCheckpointer = m.digest !== null && m.checkpoint !== null\n    c.uint.encode(state, isCheckpointer ? 1 : 0)\n\n    if (isCheckpointer) {\n      DigestV0.encode(state, m.digest)\n      Checkpoint.encode(state, m.checkpoint)\n    }\n\n    Node.encode(state, m.node)\n\n    Additional.encode(state, m.additional)\n    c.uint.encode(state, m.maxSupportedVersion)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n\n    const isCheckpointer = (flags & 1) !== 0\n\n    const digest = isCheckpointer ? DigestV0.decode(state) : null\n    const checkpoint = isCheckpointer ? Checkpoint.decode(state) : null\n    const node = Node.decode(state)\n    const additional = Additional.decode(state)\n    const maxSupportedVersion = state.start < state.end ? c.uint.decode(state) : 0\n\n    return {\n      version: 0,\n      digest,\n      checkpoint,\n      node,\n      additional,\n      maxSupportedVersion\n    }\n  }\n}\n\nconst PendingIndexers = c.array(c.fixed32)\n\nconst Info = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.version)\n    c.uint.preencode(state, m.members)\n    PendingIndexers.preencode(state, m.pendingIndexers)\n    Clock.preencode(state, m.indexers)\n    Clock.preencode(state, m.heads)\n    Clock.preencode(state, m.views)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.version)\n    c.uint.encode(state, m.members)\n    PendingIndexers.encode(state, m.pendingIndexers)\n    Clock.encode(state, m.indexers)\n    Clock.encode(state, m.heads)\n    Clock.encode(state, m.views)\n  },\n  decode (state) {\n    return {\n      version: c.uint.decode(state),\n      members: c.uint.decode(state),\n      pendingIndexers: PendingIndexers.decode(state),\n      indexers: Clock.decode(state),\n      heads: Clock.decode(state),\n      views: Clock.decode(state)\n    }\n  }\n}\n\nconst Member = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.uint.preencode(state, m.length)\n  },\n  encode (state, m) {\n    c.uint.encode(state, (m.isIndexer ? 1 : 0) | (m.isRemoved ? 2 : 0))\n    c.uint.encode(state, m.length)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      isIndexer: (flags & 1) !== 0,\n      isRemoved: (flags & 2) !== 0,\n      length: c.uint.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  Wakeup,\n  Clock,\n  Checkout,\n  BootRecord,\n  ViewRecord,\n  OplogMessage,\n  Checkpoint,\n  Info,\n  Member\n}\nconst DEFAULT_SIZE = 32\n\nmodule.exports = class NodeBuffer {\n  constructor (offset, hwm) {\n    this.hwm = hwm || DEFAULT_SIZE\n    this.defaultHwm = this.hwm\n    this.mask = this.hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.buffer = new Array(this.hwm)\n    this.offset = offset || 0\n    this.length = this.offset\n  }\n\n  get size () {\n    return this.length - this.offset\n  }\n\n  isEmpty () {\n    return this.length === this.offset\n  }\n\n  isFull () {\n    return this.size === this.buffer.length\n  }\n\n  grow () {\n    this.hwm <<= 1\n\n    const size = this.size\n    const buffer = new Array(this.hwm)\n    const mask = this.hwm - 1\n\n    for (let i = 0; i < size; i++) {\n      buffer[i] = this.buffer[(this.btm + i) & this.mask]\n    }\n\n    this.mask = mask\n    this.top = size\n    this.btm = 0\n    this.buffer = buffer\n  }\n\n  push (data) {\n    if (this.isFull()) this.grow()\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return this.length++\n  }\n\n  shift () {\n    if (this.isEmpty()) return null\n\n    const last = this.buffer[this.btm]\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    this.offset++\n\n    // reset on empty\n    if (this.isEmpty() && this.hwm !== this.defaultHwm) {\n      this.buffer = new Array(this.defaultHwm)\n      this.hwm = this.buffer.length\n      this.mask = this.hwm - 1\n      this.top = this.btm = 0\n    }\n\n    return last\n  }\n\n  get (seq) {\n    if (seq < this.offset || seq >= this.length) return null\n    return this.buffer[(this.btm + (seq - this.offset)) & this.mask]\n  }\n}\nconst b4a = require('b4a')\nconst { partialSignature } = require('hypercore/lib/multisig.js')\n\nmodule.exports = class Signer {\n  constructor (base, core) {\n    this.base = base\n    this.core = core\n\n    this.opened = false\n    this.checkpoints = new Map()\n\n    this.open()\n  }\n\n  async sign (indexers, length) {\n    const signatures = await this.getSignatures(indexers, length)\n    const tree = this.core.core.createTreeBatch()\n    const p = await Promise.all(signatures.map(s => partialSignature(tree, s.signer, length, s.length, s.signature)))\n    return this.core.core.session.core.verifier.assemble(p)\n  }\n\n  async _verify (length, signature, key) {\n    if (!this.core.core || length > this.core.core.length) return false\n    if (length < this.core.core.indexedLength) return true\n    const batch = await this.core.core.restoreBatch(length)\n    const { publicKey } = this.base.getNamespace(key, this.core)\n    return batch.tree.crypto.verify(batch.signable(this.core.key), signature, publicKey)\n  }\n\n  open () {\n    if (this.opened) return true\n    if (!this.core.pendingIndexedLength) return false\n\n    for (const idx of this.base.linearizer.indexers) {\n      for (const checkpoint of idx.flushCheckpoints(this.core.systemIndex)) {\n        this.addCheckpoint(idx.core.key, checkpoint)\n      }\n    }\n\n    this.opened = true\n    return true\n  }\n\n  addCheckpoint (key, checkpoint) {\n    const hex = b4a.toString(key, 'hex')\n\n    let checkpoints = this.checkpoints.get(hex)\n    if (!checkpoints) {\n      checkpoints = []\n      this.checkpoints.set(hex, checkpoints)\n    }\n\n    if (checkpoints.length > 0 && checkpoint.length <= checkpoints[checkpoints.length - 1].length) return\n\n    checkpoints.push(checkpoint)\n  }\n\n  bestCheckpoint (idx, gc = false) {\n    const hex = b4a.toString(idx.core.key, 'hex')\n\n    const checkpoints = this.checkpoints.get(hex)\n    if (!checkpoints) return null\n\n    const i = findBestCheckpoint(checkpoints, this.core.pendingIndexedLength)\n    if (i === -1) return null\n\n    const checkpoint = checkpoints[i]\n\n    if (gc) {\n      this.checkpoints.set(hex, checkpoints.slice(i))\n    }\n\n    return checkpoint\n  }\n\n  async getSignableLength (indexers) {\n    if (!this.open()) return 0\n\n    const signed = []\n    const thres = (indexers.length >> 1) + 1\n\n    for (const idx of indexers) {\n      const checkpoint = this.bestCheckpoint(idx)\n      if (!checkpoint) continue\n\n      // signature is invalid\n      if (!(await this._verify(checkpoint.length, checkpoint.signature, idx.core.key))) {\n        continue\n      }\n\n      signed.push(checkpoint.length)\n    }\n\n    return signed.length < thres ? 0 : signed.sort(descendingOrder)[thres - 1]\n  }\n\n  async getSignatures (indexers, length) {\n    const signatures = []\n    const thres = (indexers.length >> 1) + 1\n\n    for (let signer = 0; signer < indexers.length; signer++) {\n      const idx = indexers[signer]\n      const checkpoint = this.bestCheckpoint(idx, true)\n      if (!checkpoint) continue\n\n      // signature is invalid\n      if (!(await this._verify(checkpoint.length, checkpoint.signature, idx.core.key))) {\n        continue\n      }\n\n      const signature = {\n        signature: checkpoint.signature,\n        length: checkpoint.length,\n        signer\n      }\n\n      if (checkpoint.length === length) {\n        if (signatures.length >= thres) signatures.pop()\n        signatures.push(signature)\n      } else if (checkpoint.length > length && checkpoint.length <= this.core.core.length) {\n        signatures.push(signature)\n      }\n\n      if (signatures.length >= thres) return signatures\n    }\n\n    return null\n  }\n}\n\nfunction findBestCheckpoint (checkpoints, len) {\n  if (!checkpoints.length || checkpoints[0].length > len) return -1\n\n  let btm = 0\n  let top = checkpoints.length\n\n  while (true) {\n    const mid = (btm + top) >> 1\n\n    const c = checkpoints[mid]\n    if (c.length === len) return mid\n\n    if (c.length > len) top = mid\n    else btm = mid + 1\n\n    if (btm === top) {\n      return c.length < len ? mid : mid - 1\n    }\n  }\n}\n\nfunction descendingOrder (a, b) {\n  return a > b ? -1 : a < b ? 1 : 0\n}\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\nconst Hypercore = require('hypercore')\nconst crypto = require('hypercore-crypto')\n\nconst Autocore = require('./core')\n\nconst MANIFEST_VERSION = 1\nconst INDEX_VERSION = 1\n\nconst EMPTY = b4a.alloc(0)\n\nconst [NS_SIGNER_NAMESPACE, NS_VIEW_BLOCK_KEY] = crypto.namespace('autobase', 2)\n\nmodule.exports = class AutoStore {\n  constructor (base) {\n    this.base = base\n    this.opened = new Map()\n    this.coresByKey = new Map()\n    this.coresByIndex = new Map()\n    this.waiting = []\n  }\n\n  async ready () {\n    await this.base._presystem\n  }\n\n  get _indexers () {\n    return this.base.linearizer && indexersWithManifest(this.base.linearizer.indexers.slice(0))\n  }\n\n  async migrate () {\n    const sys = this.getSystemCore()\n    const { indexers, views } = await this.base.system.getIndexedInfo()\n    const nextIndexers = await this.getWriters(indexers)\n\n    for (const ac of this.opened.values()) {\n      const view = views[ac.systemIndex]\n      const length = view ? view.length : ac._isSystem() ? sys.indexedLength : 0\n      await ac.migrateTo(nextIndexers, length)\n    }\n\n    this.base.recouple()\n  }\n\n  get (opts, moreOpts) {\n    if (typeof opts === 'string') opts = { name: opts }\n    if (moreOpts) opts = { ...opts, ...moreOpts, compat: false }\n\n    const name = opts.name\n    const valueEncoding = opts.valueEncoding || null\n\n    const core = this._indexers\n      ? this.base.store.get(this._corePreload(this._indexers, name, null, opts.cache))\n      : this.base.store.get({\n        preload: async () => {\n          await Promise.resolve()\n          if (!this.base.opening) throw new Error('Autobase failed to open')\n\n          await this.ready()\n          return this._corePreload(this._indexers, name, null, opts.cache)\n        }\n      })\n\n    const ac = new Autocore(this.base, core, name, opts)\n\n    this.opened.set(name, ac)\n\n    this.waiting.push(ac)\n\n    return ac.createSession(valueEncoding)\n  }\n\n  _corePreload (indexers, name, prologue, cache) {\n    return {\n      manifest: this._createManifest(indexers, name, prologue),\n      cache,\n      exclusive: true,\n      compat: false,\n      encryptionKey: this.getBlockKey(name),\n      isBlockKey: true\n    }\n  }\n\n  close () {\n    const closing = []\n    for (const core of this.opened.values()) {\n      closing.push(core.close())\n    }\n\n    return Promise.all(closing)\n  }\n\n  static getBlockKey (bootstrap, encryptionKey, name) {\n    return getBlockKey(bootstrap, encryptionKey, name)\n  }\n\n  getBlockKey (name) {\n    return getBlockKey(this.base.bootstrap, this.base.encryptionKey, name)\n  }\n\n  getSystemCore () {\n    return this.base.system.core._source\n  }\n\n  async getWriters (keys) {\n    // todo: should initial system entry have bootstrap as indexer?\n    if (!keys.length) return this.base.linearizer.indexers.slice(0)\n\n    return Promise.all(keys.map(({ key }) => this.base._getWriterByKey(key, -1, 0, false, false, null)))\n  }\n\n  async getCore (ac, indexers, length, opts = {}) {\n    const prologue = await ac.getPrologue(length)\n    return this.base.store.get(this._corePreload(indexers, ac.name, prologue, opts.cache))\n  }\n\n  getIndexedCores () {\n    const cores = [this.getSystemCore()]\n\n    for (let i = 0; i < this.base.system.views.length; i++) {\n      const core = this.getByIndex(i)\n      if (!core || !core.pendingIndexedLength) break\n      cores.push(core)\n    }\n\n    return cores\n  }\n\n  indexedViewsByName () {\n    const views = []\n\n    for (let i = 0; i < this.base.system.views.length; i++) {\n      const core = this.getByIndex(i)\n      if (!core || !core.pendingIndexedLength) break\n      views.push(core.name)\n    }\n\n    return views\n  }\n\n  async flush () {\n    while (this.waiting.length) {\n      const core = this.waiting.pop()\n      await core.ready()\n    }\n\n    for (const view of this.opened.values()) {\n      if (!view.isBootstrapped() && !(await view.bootstrap())) return false\n    }\n\n    return true\n  }\n\n  // called by autocore on truncate\n  _unindex (ac) {\n    this.coresByIndex.delete(ac.systemIndex)\n    ac.systemIndex = -1\n  }\n\n  deriveNamespace (name, entropy) {\n    const encryptionId = crypto.hash(this.base.encryptionKey || EMPTY)\n    const version = c.encode(c.uint, INDEX_VERSION)\n    const bootstrap = this.base.bootstrap\n\n    return crypto.hash([\n      NS_SIGNER_NAMESPACE,\n      version,\n      bootstrap,\n      encryptionId,\n      entropy,\n      b4a.from(name)\n    ])\n  }\n\n  getByKey (key, indexers = this.base.linearizer.indexers) {\n    const hex = b4a.toString(key, 'hex')\n    if (this.coresByKey.has(hex)) return this.coresByKey.get(hex)\n\n    for (const core of this.opened.values()) {\n      if (b4a.equals(key, core.key)) {\n        this.coresByKey.set(hex, core)\n        return core\n      }\n    }\n\n    return null\n  }\n\n  getByIndex (index) {\n    if (this.coresByIndex.has(index)) return this.coresByIndex.get(index)\n\n    for (const core of this.opened.values()) {\n      if (core.systemIndex !== index) continue\n      this.coresByIndex.set(index, core)\n      return core\n    }\n\n    return null\n  }\n\n  deriveKey (name, indexers = this.base.linearizer.indexers, prologue = null) {\n    const pl = prologue && prologue.length ? prologue : null\n    const manifest = this._createManifest(indexers, name, pl)\n    return manifest && Hypercore.key(manifest)\n  }\n\n  _deriveStaticHash (name) {\n    // key doesnt matter...\n    return crypto.hash([this.base.bootstrap, b4a.from(name)])\n  }\n\n  _createManifest (indexers, name, prologue) {\n    if (!indexers.length && !(prologue && prologue.length > 0)) {\n      prologue = {\n        hash: this._deriveStaticHash(name),\n        length: 0\n      }\n    }\n\n    for (const idx of indexers) {\n      if (!idx.core.manifest) return null\n    }\n\n    const signers = indexers.map(idx => ({\n      namespace: this.deriveNamespace(name, idx.core.manifest.signers[0].namespace),\n      signature: 'ed25519',\n      publicKey: idx.core.manifest.signers[0].publicKey\n    }))\n\n    return {\n      version: MANIFEST_VERSION,\n      hash: 'blake2b',\n      prologue,\n      allowPatch: true,\n      quorum: Math.min(signers.length, (signers.length >> 1) + 1),\n      signers\n    }\n  }\n}\n\nfunction getBlockKey (bootstrap, encryptionKey, name) {\n  return encryptionKey && crypto.hash([NS_VIEW_BLOCK_KEY, bootstrap, encryptionKey, b4a.from(name)])\n}\n\nfunction indexersWithManifest (indexers) {\n  if (indexers.length === 1 && !indexers[0].core.manifest) return []\n  return indexers\n}\nconst Hyperbee = require('hyperbee')\nconst SubEncoder = require('sub-encoder')\nconst ReadyResource = require('ready-resource')\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\n\nconst { Info, Member } = require('./messages')\n\nconst subs = new SubEncoder()\n\nconst DIGEST = subs.sub(b4a.from([0]))\nconst MEMBERS = subs.sub(b4a.from([1]))\n\nmodule.exports = class SystemView extends ReadyResource {\n  constructor (core, { checkout = 0 } = {}) {\n    super()\n\n    this.core = core\n\n    // sessions is a workaround for batches not having sessions atm...\n    this.db = new Hyperbee(core, { keyEncoding: 'binary', extension: false, checkout, sessions: typeof core.session === 'function' })\n\n    this.version = -1 // set version in apply\n    this.members = 0\n    this.pendingIndexers = []\n    this.indexers = []\n    this.heads = []\n    this.views = []\n\n    this.indexerUpdate = false\n\n    this._fork = 0\n    this._length = 0\n    this._indexerMap = new Map()\n    this._clockUpdates = new Map()\n    this._batch = null\n  }\n\n  static async getIndexedInfo (core, length) {\n    const sys = new this(core.session())\n\n    try {\n      return await sys.getIndexedInfo(length)\n    } finally {\n      await sys.close()\n    }\n  }\n\n  get bootstrapping () {\n    return this.members === 0\n  }\n\n  sendWakeup (remotePublicKey) {\n    if (this.core._source.wakeupExtension) {\n      this.core._source.wakeupExtension.sendWakeup(remotePublicKey)\n    }\n  }\n\n  requestWakeup () {\n    if (this.core._source.wakeupExtension) {\n      this.core._source.wakeupExtension.requestWakeup()\n    }\n  }\n\n  broadcastWakeup () {\n    if (this.core._source.wakeupExtension) {\n      this.core._source.wakeupExtension.broadcastWakeup()\n    }\n  }\n\n  async checkout (length) {\n    const checkout = new SystemView(this.core.session(), {\n      checkout: length\n    })\n\n    await checkout.ready()\n\n    return checkout\n  }\n\n  async _open () {\n    // this should NEVER fail, if so we have a bug elsewhere (should always be consistent)\n    const info = await this.db.get('info', { valueEncoding: Info, keyEncoding: DIGEST, update: false, wait: false })\n    await this._reset(info)\n  }\n\n  async _close () {\n    await this.db.close()\n  }\n\n  async getIndexedInfo (length = this.core.indexedLength) {\n    if (this.opened === false) await this.ready()\n\n    if (length === this.core.length) {\n      return { version: this.version, members: this.members, pendingIndexers: this.pendingIndexers, indexers: this.indexers, heads: this.heads, views: this.views }\n    }\n\n    const node = length === 0 ? null : await this.db.getBySeq(length - 1)\n    if (node === null) return { version: 0, members: 0, pendingIndexers: [], indexers: [], heads: [], views: [] }\n\n    return c.decode(Info, node.value)\n  }\n\n  sameIndexers (indexers) {\n    if (this.indexers.length !== indexers.length) return false\n\n    for (let i = 0; i < this.indexers.length; i++) {\n      if (!b4a.equals(this.indexers[i].key, indexers[i].core.key)) return false\n    }\n\n    return true\n  }\n\n  async update () {\n    if (this.opened === false) await this.ready()\n    if (this._fork === this.core.fork && this._length === this.core.length) return false\n\n    await this._reset(await this.db.get('info', { valueEncoding: Info, keyEncoding: DIGEST }))\n    return true\n  }\n\n  async _reset (info) {\n    this.version = info === null ? -1 : info.value.version\n    this.members = info === null ? 0 : info.value.members\n    this.pendingIndexers = info === null ? [] : info.value.pendingIndexers\n    this.indexers = info === null ? [] : info.value.indexers\n    this.heads = info === null ? [] : info.value.heads\n    this.views = info === null ? [] : info.value.views\n\n    this.indexerUpdate = false\n    this._indexerMap.clear()\n    this._clockUpdates.clear()\n    this._length = this.core.length\n    this._fork = this.core.fork\n\n    for (const idx of this.indexers) {\n      this._indexerMap.set(b4a.toString(idx.key, 'hex'), idx)\n    }\n\n    if (this._batch) await this._batch.close()\n    this._batch = this.db.batch({ update: false })\n  }\n\n  _updateView (length, core, systemIndex, key) {\n    if (systemIndex > -1 && systemIndex < this.views.length) {\n      const v = this.views[systemIndex]\n      if (v) {\n        v.length = length\n        if (key) v.key = key\n        return systemIndex\n      }\n    }\n\n    // store indexer count so we can derive the key on restart\n    this.views.push({\n      length,\n      key\n    })\n\n    return this.views.length - 1\n  }\n\n  async flush (views) {\n    for (const [hex, length] of this._clockUpdates) {\n      const isIndexer = this._indexerMap.get(hex) !== undefined\n      const key = b4a.from(hex, 'hex')\n\n      const info = await this._batch.get(key, { valueEncoding: Member, keyEncoding: MEMBERS })\n      const value = { isIndexer, isRemoved: info.value.isRemoved, length }\n\n      await this._batch.put(key, value, { valueEncoding: Member, keyEncoding: MEMBERS })\n    }\n\n    this._clockUpdates.clear()\n\n    for (const { view, key } of views) {\n      view.systemIndex = this._updateView(\n        view.length,\n        view,\n        view.systemIndex,\n        key\n      )\n    }\n\n    const info = {\n      version: this.version,\n      members: this.members,\n      pendingIndexers: this.pendingIndexers,\n      indexers: this.indexers,\n      heads: this.heads,\n      views: this.views\n    }\n\n    await this._batch.put('info', info, { valueEncoding: Info, keyEncoding: DIGEST })\n    await this._batch.flush()\n\n    this._length = this.core.length // should be ok\n    this._batch = this.db.batch({ update: false })\n\n    if (this.indexerUpdate) this.indexerUpdate = false\n  }\n\n  addHead (node) {\n    const h = { key: node.writer.core.key, length: node.length }\n\n    for (let i = 0; i < this.heads.length; i++) {\n      const head = this.heads[i]\n\n      if (!hasDependency(node, head)) {\n        if (!b4a.equals(node.writer.core.key, head.key)) continue\n\n        // todo: remove in next major because bug was fixed here:\n        // https://github.com/holepunchto/autobase-next/pull/237\n\n        // filter out any bad heads introduced by a bug to\n        // prevent inconsistencies being written to the oplog\n        if (head.length > h.length) return false\n      }\n\n      const popped = this.heads.pop()\n      if (popped !== head) this.heads[i--] = popped\n    }\n\n    this.heads.push(h)\n\n    const hex = b4a.toString(h.key, 'hex')\n\n    this._clockUpdates.set(hex, h.length)\n\n    if (this.pendingIndexers.length > 0) {\n      for (let i = 0; i < this.pendingIndexers.length; i++) {\n        if (!b4a.equals(this.pendingIndexers[i], h.key)) continue\n        this._updateIndexer(h.key, h.length, true, i)\n        return true\n      }\n    }\n\n    const idx = this._indexerMap.get(hex)\n    if (idx !== undefined) {\n      idx.length = h.length\n    }\n\n    return false\n  }\n\n  _updateIndexer (key, length, isIndexer, i) {\n    const hex = b4a.toString(key, 'hex')\n\n    if (!isIndexer) {\n      const existing = this._indexerMap.get(hex)\n      if (existing) {\n        this.indexerUpdate = true\n        this.indexers.splice(this.indexers.indexOf(existing), 1)\n        this._indexerMap.delete(hex)\n      }\n      return\n    }\n\n    for (; i < this.pendingIndexers.length; i++) {\n      if (b4a.equals(this.pendingIndexers[i], key)) break\n    }\n\n    if (length === 0) {\n      if (i >= this.pendingIndexers.length) this.pendingIndexers.push(key)\n      return\n    }\n\n    if (i < this.pendingIndexers.length) {\n      const top = this.pendingIndexers.pop()\n      if (i < this.pendingIndexers.length) this.pendingIndexers[i] = top\n    }\n\n    const idx = this._indexerMap.get(hex)\n\n    if (idx === undefined) {\n      const newIdx = { key, length }\n      this._indexerMap.set(hex, newIdx)\n      this.indexers.push(newIdx)\n\n      // bootstrap is \"silently\" added so that initial views have no prologue\n      if (!this.bootstrapping) this.indexerUpdate = true\n    } else {\n      idx.length = length\n    }\n  }\n\n  _seenLength (key) {\n    return this._clockUpdates.get(b4a.toString(key, 'hex')) || 0\n  }\n\n  async add (key, { isIndexer = false, length = this._seenLength(key) } = {}) {\n    let wasTracked = false\n    let wasIndexer = false\n\n    if (length === 0) { // a bit hacky atm due to cas limitations...\n      const node = await this._batch.get(key, { valueEncoding: Member, keyEncoding: MEMBERS })\n      if (node) length = node.value.length\n    }\n\n    await this._batch.put(key, {\n      isIndexer,\n      isRemoved: false,\n      length\n    }, {\n      valueEncoding: Member,\n      keyEncoding: MEMBERS,\n      cas (older, newer) {\n        if (older === null) return true\n\n        const o = older.value\n        const n = newer.value\n\n        if (!o.isRemoved) wasTracked = true\n        if (o.isIndexer) wasIndexer = true\n\n        if (length === 0 && o.length) length = o.length\n\n        return o.isRemoved !== n.isRemoved || o.isIndexer !== n.isIndexer || o.length !== n.length\n      }\n    })\n\n    if (!wasTracked) this.members++\n\n    if (wasIndexer || isIndexer) this._updateIndexer(key, length, isIndexer, 0)\n  }\n\n  async remove (key) {\n    let isIndexer = false\n\n    for (const idx of this.indexers) {\n      isIndexer = b4a.equals(idx.key, key)\n      if (isIndexer) break\n    }\n\n    if (isIndexer) this._updateIndexer(key, null, false, 0)\n\n    let wasTracked = false\n\n    const node = await this._batch.get(key, { valueEncoding: Member, keyEncoding: MEMBERS })\n    const length = node ? node.value.length : 0\n\n    await this._batch.put(key, {\n      isIndexer: false,\n      isRemoved: true,\n      length\n    }, {\n      valueEncoding: Member,\n      keyEncoding: MEMBERS,\n      cas (older, newer) {\n        if (older === null) return true\n\n        wasTracked = !!older.value.isRemoved\n        return !wasTracked\n      }\n    })\n\n    if (!wasTracked) this.members--\n\n    return isIndexer\n  }\n\n  async has (key, opts) {\n    // could be optimised...\n    return await this.get(key, opts) !== null\n  }\n\n  async get (key, opts = {}) {\n    const node = await this._batch.get(key, { valueEncoding: Member, keyEncoding: MEMBERS })\n    if (node === null) return null\n    return (opts.onlyActive !== false || !node.value.isRemoved) ? node.value : null\n  }\n\n  async hasLocal (key) {\n    try {\n      const node = await this.db.get(key, { valueEncoding: Member, keyEncoding: MEMBERS, update: false, wait: false })\n      return node !== null\n    } catch {\n      return false\n    }\n  }\n\n  async getLocalLength (key) {\n    try {\n      const node = await this.db.get(key, { valueEncoding: Member, keyEncoding: MEMBERS, update: false, wait: false })\n      return node === null ? 0 : node.value.length\n    } catch {\n      return 0\n    }\n  }\n\n  list () {\n    return this._batch.createReadStream({\n      valueEncoding: Member,\n      keyEncoding: MEMBERS\n    })\n  }\n\n  async isIndexed (key, length) {\n    const co = this.db.checkout(this.core.indexedLength)\n    try {\n      const node = await co.get(key, { valueEncoding: Member, keyEncoding: MEMBERS })\n      return node !== null && node.value.length >= length\n    } finally {\n      await co.close()\n    }\n  }\n}\n\nfunction hasDependency (node, dep) {\n  for (const h of node.actualHeads) {\n    if (sameNode(h, dep)) return true\n  }\n  return false\n}\n\nfunction sameNode (a, b) {\n  return b4a.equals(a.key, b.key) && a.length === b.length\n}\nconst safetyCatch = require('safety-catch')\n\nconst MAX_WAIT = 2 * 60 * 1000\nconst DEFAULT_INTERVAL = 10 * 1000\n\nmodule.exports = class Timer {\n  constructor (handler, interval, opts = {}) {\n    this.handler = handler || noop\n    this.interval = interval || DEFAULT_INTERVAL\n    this.limit = opts.limit || MAX_WAIT\n\n    this._executing = null\n\n    this._limit = random2over1(this.limit)\n    this._timer = null\n    this._resolve = null\n    this._start = 0\n    this._stopped = false\n    this._asap = false\n    this._standalone = new Set()\n\n    this._unref = opts.unref !== false\n    this._timerCallback = this._executeBackground.bind(this)\n  }\n\n  _executeBackground () {\n    this._executing = this._execute()\n    this._executing.catch(safetyCatch) // make sure it doesnt crash in the bg\n  }\n\n  async _execute () {\n    this._asap = false\n    await this.handler()\n    this._start = 0\n    this._executing = null\n    this.bump()\n  }\n\n  bump () {\n    if (this._stopped || this._executing || this._asap) return\n\n    if (!this._start) this._start = Date.now()\n    else if (Date.now() - this._start > this._limit) return\n\n    const interval = random2over1(this.interval)\n\n    clearTimeout(this._timer)\n    this._timer = setTimeout(this._timerCallback, interval)\n    if (this._unref && this._timer.unref) this._timer.unref()\n  }\n\n  async trigger () {\n    if (this._stopped) return\n    if (this._executing) await this._executing\n    if (this._stopped) return\n\n    clearTimeout(this._timer)\n    this._timer = null\n\n    this._executeBackground()\n    await this._executing\n  }\n\n  async flush () {\n    if (this._executing) await this._executing\n  }\n\n  // business-as-usual\n  bau () {\n    if (!this._asap) return\n    this._asap = false\n    this.bump()\n  }\n\n  asap () {\n    if (this._asap) return\n    this._asap = true\n\n    const interval = Math.floor(Math.random() * this.interval / 3)\n    clearTimeout(this._timer)\n    this._timer = setTimeout(this._timerCallback, interval)\n    if (this._unref && this._timer.unref) this._timer.unref()\n  }\n\n  stop () {\n    if (this._timer) clearTimeout(this._timer)\n    this._timer = null\n    this._start = 0\n    this._asap = false\n    this._stopped = true\n\n    for (const { timer, resolve } of this._standalone) {\n      clearTimeout(timer)\n      resolve()\n    }\n\n    this._standalone.clear()\n  }\n\n  asapStandalone () {\n    const interval = Math.floor(Math.random() * this.interval / 3)\n    return new Promise((resolve) => {\n      const ref = { timer: null, resolve }\n      ref.timer = setTimeout(resolveStandalone, interval, ref, this._standalone)\n      if (ref.timer.unref) ref.timer.unref()\n      this._standalone.add(ref)\n    })\n  }\n\n  unref () {\n    if (this._timer && this._timer.unref) this._timer.unref()\n  }\n}\n\nfunction resolveStandalone (ref, set) {\n  set.delete(ref)\n  ref.resolve()\n}\n\n// random value x between n <= x < 2n\nfunction random2over1 (n) {\n  return Math.floor(n + Math.random() * n)\n}\n\nfunction noop () {}\nconst b4a = require('b4a')\nconst assert = require('nanoassert')\n\nmodule.exports = class TopoList {\n  constructor () {\n    this.tip = []\n    this.undo = 0\n    this.shared = 0\n  }\n\n  static compare (a, b) {\n    return cmp(a, b)\n  }\n\n  static add (node, indexed, offset) {\n    addSorted(node, indexed, offset)\n  }\n\n  mark () {\n    this.shared = this.tip.length\n    this.undo = 0\n  }\n\n  // todo: bump to new api that just tracks undo\n  flush (indexed = []) {\n    if (indexed.length) this._applyIndexed(indexed)\n\n    const u = {\n      shared: this.shared,\n      undo: this.undo,\n      length: indexed.length + this.tip.length,\n      indexed,\n      tip: this.tip\n    }\n\n    this.mark()\n\n    return u\n  }\n\n  print () {\n    return this.tip.map(n => n.writer.core.key.toString() + n.length)\n  }\n\n  _applyIndexed (nodes) {\n    assert(nodes.length <= this.tip.length, 'Indexed batch cannot exceed tip')\n\n    let shared = 0\n\n    for (; shared < nodes.length; shared++) {\n      if (this.tip[shared] !== nodes[shared]) break\n    }\n\n    // reordering\n    if (shared < nodes.length) this._track(shared)\n\n    let j = 0\n    for (let i = shared; i < this.tip.length; i++) {\n      const node = this.tip[i]\n      if (node.yielded) continue\n\n      this.tip[j++] = node\n    }\n\n    this.tip.splice(j, this.tip.length - j)\n  }\n\n  add (node) {\n    const shared = addSorted(node, this.tip, 0)\n    this._track(shared)\n  }\n\n  _track (shared) {\n    if (shared < this.shared) {\n      this.undo += this.shared - shared\n      this.shared = shared\n    }\n  }\n}\n\nfunction addSorted (node, list, offset = 0) {\n  list.push(node)\n\n  let i = list.length - 1\n\n  while (i >= offset + 1) {\n    const prev = list[i - 1]\n    if (links(node, prev)) break\n    list[i] = prev\n    list[--i] = node\n  }\n\n  while (i < list.length - 1) {\n    const next = list[i + 1]\n    const c = cmp(node, next)\n    if (c <= 0) break\n    list[i] = next\n    list[++i] = node\n  }\n\n  return i\n}\n\nfunction links (a, b) {\n  if (b.dependents.has(a)) return true\n  return a.length > 0 && b.length === a.length - 1 && a.writer === b.writer\n}\n\nfunction cmp (a, b) {\n  const c = b4a.compare(a.writer.core.key, b.writer.core.key)\n  if (c !== 0 && a.version !== b.version) return b.version - a.version\n  return c === 0 ? a.length < b.length ? -1 : 1 : c\n}\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\nconst ReadyResource = require('ready-resource')\n\nconst WakeupEntry = {\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.key)\n    c.uint.preencode(state, m.length)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.key)\n    c.uint.encode(state, m.length)\n  },\n  decode (state) {\n    return {\n      key: c.fixed32.decode(state),\n      length: c.uint.decode(state)\n    }\n  }\n}\n\nmodule.exports = class AutoWakeup extends ReadyResource {\n  constructor (base) {\n    super()\n\n    this.base = base\n    this.flushing = null\n\n    this._rootStore = getRootCorestore(this.base.store)\n    this._addBound = this.add.bind(this)\n    this._preupdateBound = this._preupdate.bind(this)\n    this._needsFlush = false\n    this._map = new Map()\n  }\n\n  [Symbol.iterator] () {\n    return this._map.values()\n  }\n\n  async _preupdate (batch, key) {\n    this.queue(key, batch.length)\n    await this.flush()\n    this.base._onwakeup()\n  }\n\n  async _save () {\n    const slab = b4a.allocUnsafe(8 + this._map.size * 40) // 32 + 8\n    const state = { start: 0, end: 0, buffer: slab }\n\n    c.uint.encode(state, this._map.size)\n    for (const m of this._map.values()) WakeupEntry.encode(state, m)\n\n    await this.base.local.setUserData('autobase/wakeup', slab.subarray(0, state.start))\n  }\n\n  async _load () {\n    const buffer = await this.base.local.getUserData('autobase/wakeup')\n    if (!buffer) return\n\n    const state = { start: 0, end: buffer.byteLength, buffer }\n\n    let len = c.uint.decode(state)\n    while (len-- > 0) {\n      const m = WakeupEntry.decode(state)\n      this._map.set(b4a.toString(m.key, 'hex'), m)\n    }\n  }\n\n  async _open () {\n    await this._load()\n\n    this._rootStore.setMaxListeners(0)\n    this._rootStore.on('core-open', this._addBound)\n\n    for (const core of this._rootStore.cores.values()) {\n      if (core.opened === false) await core.ready().catch(noop)\n      if (!core.closing) this.add(core)\n    }\n  }\n\n  async _close () {\n    this._rootStore.removeListener('core-open', this._addBound)\n\n    for (const core of this._rootStore.cores.values()) {\n      if (core.opened && !core.closing) this.remove(core)\n    }\n\n    this._map.clear()\n\n    while (this.flushing) {\n      try {\n        await this.flushing\n      } catch {}\n    }\n  }\n\n  queue (key, length) {\n    const hex = b4a.toString(key, 'hex')\n    const m = this._map.get(hex)\n\n    if (m && m.length > length) {\n      return false\n    }\n\n    this._needsFlush = true\n    this._map.set(hex, { key, length })\n\n    return true\n  }\n\n  unqueue (key, length) {\n    const hex = b4a.toString(key, 'hex')\n    const m = this._map.get(hex)\n\n    if (!m) return true\n    if (m.length > length) return false\n\n    this._needsFlush = true\n    this._map.delete(hex)\n\n    return true\n  }\n\n  async flush () {\n    if (this.closing) throw new Error('Closing')\n\n    // wait for someone\n    if (this.flushing) await this.flushing\n\n    // if another still active they flushed us\n    if (this.flushing) return this.flushing\n\n    if (this._needsFlush === false) return\n    this._needsFlush = false\n\n    try {\n      this.flushing = this._save()\n      return await this.flushing\n    } finally {\n      this.flushing = null\n    }\n  }\n\n  add (core) {\n    if (core.writable || !core.opened) return // no need to track local cores...\n    return this._add(core.core)\n  }\n\n  remove (core) {\n    return this._remove(core.core)\n  }\n\n  _add (core) {\n    const userData = core.header.userData // unsafe but sync so much less race-condition-ey\n    let referrer = null\n\n    for (const { key, value } of userData) {\n      if (key === 'referrer') referrer = value\n      else if (key === 'autobase/view') return false\n    }\n\n    if (referrer === null || !b4a.equals(referrer, this.base.key)) return false\n\n    core.preupdate = this._preupdateBound\n\n    return true\n  }\n\n  _remove (core) {\n    if (core.preupdate !== this._preupdateBound) return false\n    core.preupdate = null\n    return true\n  }\n}\n\nfunction getRootCorestore (store) {\n  return store._root // TODO: make public\n}\n\nfunction noop () {}\nconst Linearizer = require('./linearizer')\nconst NodeBuffer = require('./node-buffer')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst ReadyResource = require('ready-resource')\nconst safetyCatch = require('safety-catch')\nconst assert = require('nanoassert')\nconst SignalPromise = require('signal-promise')\n\nconst MAX_PRELOAD = 4\n\nmodule.exports = class Writer extends ReadyResource {\n  constructor (base, core, length, isRemoved) {\n    super()\n\n    this.base = base\n    this.core = core\n    this.isRemoved = isRemoved\n    this.updated = false\n    this.range = null\n    this.nodes = new NodeBuffer(length)\n    this.node = null\n    this.isBootstrap = false // maintained by updateBootstrapWriters\n    this.isActiveIndexer = false\n    this.available = length\n    this.length = length\n    this.seenLength = 0\n    this.recover = false\n\n    this.system = null\n    this.digestIndex = 0\n    this.digestLength = 0\n\n    this.pendingCheckpoints = []\n    this.syncSignal = null\n  }\n\n  pause () {\n    if (this.range) this.range.destroy()\n    this.range = null\n  }\n\n  setBootstrap (bool) {\n    this.isBootstrap = bool\n    this.core.setActive(bool)\n  }\n\n  async isInSystem () {\n    const bootstrapping = this.base.system.core.length === 0 && b4a.equals(this.core.key, this.base.key)\n\n    if (!bootstrapping) {\n      const record = await this.base.system.get(this.core.key, { onlyActive: true })\n      if (record === null) return false\n    }\n\n    return true\n  }\n\n  resume () {\n    if (this.range) return\n    this.range = this.core.download({ start: this.nodes.length, end: -1, linear: true })\n  }\n\n  seen (length) {\n    if (length > this.seenLength) this.seenLength = length\n  }\n\n  waitForSynced () {\n    if (this.core.length === this.length) return Promise.resolve()\n    if (this.syncSignal === null) this.syncSignal = new SignalPromise()\n    return this.syncSignal.wait()\n  }\n\n  async _open () {\n    await this.core.ready()\n    await this.core.setUserData('referrer', this.base.key)\n\n    // remove later\n    this.recover = autoRecover(this.core)\n\n    // add it again incase it wasn't readied before, only needed if this is the first time we set the referrer...\n    this.base._wakeup.add(this.core)\n  }\n\n  // in case we are in the middle of a migration we might need to old sigs to reach threshold on the new cores\n  inflateBackground () {\n    this.inflateExistingCheckpoints().catch(safetyCatch)\n  }\n\n  async inflateExistingCheckpoints () {\n    await this.ready()\n\n    if (this.core.length === 0 || !this.isActiveIndexer || this.nodes.length === 0) {\n      return\n    }\n\n    const seq = this.nodes.length - 1\n    const { checkpoint } = await this.core.get(seq)\n    if (!checkpoint) return\n\n    for (let i = 0; i < checkpoint.length; i++) {\n      const c = checkpoint[i]\n      if (c.checkpointer === 0) {\n        this._addCheckpoint(i, c.checkpoint)\n        continue\n      }\n      const prev = await this.core.get(seq - c.checkpointer)\n      this._addCheckpoint(i, prev.checkpoint[i].checkpoint)\n    }\n  }\n\n  _close () {\n    if (this.syncSignal !== null) this.syncSignal.notify()\n    return this.core.close()\n  }\n\n  reset (length) {\n    assert(length <= this.core.length || length <= this.length)\n\n    this.pause()\n\n    this.updated = false\n    this.node = null\n    this.nodes = new NodeBuffer(length)\n\n    this.length = length\n    this.available = length\n    this.seenLength = length\n  }\n\n  get indexed () {\n    return this.nodes.offset\n  }\n\n  idle () {\n    return this.length === this.available && this.length === this.core.length && this.core.opened\n  }\n\n  flushed () { // TODO: prop a cleaner way to express this...\n    return this.seenLength <= this.length && this.length === this.available && this.length === this.core.length &&\n        this.shiftable() === false && !this.core.core.upgrading && this.core.opened\n  }\n\n  compare (writer) {\n    return b4a.compare(this.core.key, writer.core.key)\n  }\n\n  head () {\n    return this.nodes.get(this.length - 1)\n  }\n\n  advance () {\n    if (this.syncSignal !== null && this.length + 1 === this.core.length) this.syncSignal.notify()\n    return this.length < this.available ? this.nodes.get(this.length++) : null\n  }\n\n  shiftable () {\n    return this.length > this.nodes.offset\n  }\n\n  shift () {\n    if (this.shiftable() === false) return false\n\n    let node = this._shiftAndClear()\n    while (node.batch > 1) node = this._shiftAndClear()\n\n    return true\n  }\n\n  deriveNamespace (name) {\n    const { namespace } = this.core.manifest.signers[0]\n    return this.base._viewStore.deriveNamespace(name, namespace)\n  }\n\n  get (seq) {\n    return seq < this.length ? this.nodes.get(seq) : null\n  }\n\n  append (value, heads, batch, dependencies, version) {\n    const node = Linearizer.createNode(this, this.nodes.length + 1, value, heads, batch, dependencies, version)\n\n    node.actualHeads = node.heads.slice(0)\n\n    this.nodes.push(node)\n    this.available++\n    this.length++\n\n    return node\n  }\n\n  async update (force) {\n    if (this.opened === false) await this.ready()\n\n    while (this.available - this.length < MAX_PRELOAD) {\n      // quick sanity check\n      if (this.nodes.length === this.core.length || this.core.length === 0) break\n\n      // load next node\n      if (this.node === null && !(await this._loadNextNode())) break\n      if (!(await this._ensureNodeDependencies())) break\n\n      // TODO: need a proper solution for knowing if we should load node\n      if (!force && this.length === 0 && !(await this.isInSystem()) && !this.recover) break\n      if (this.recover) this.node.value = null\n\n      this.nodes.push(this.node)\n      if (this.node.batch === 1) this.available = this.nodes.length\n      this.node = null\n    }\n\n    if (this.digestLength < this.core.length && this.isActiveIndexer) await this._checkDigest()\n\n    return this.length < this.available\n  }\n\n  async _checkDigest () {\n    const index = this.core.length - 1\n    const node = await this.core.get(index, { wait: false })\n\n    if (!node) {\n      this.core.get(index).catch(safetyCatch)\n      return\n    }\n\n    if (!node.digest) {\n      this.digestLength = index + 1\n      return\n    }\n\n    const seq = index - node.digest.pointer\n    if (seq < 0 || seq === this.digestIndex) {\n      this.digestLength = index + 1\n      return\n    }\n\n    const digestNode = seq === index ? node : await this.core.get(seq, { wait: false })\n\n    if (!digestNode) {\n      this.core.get(seq).catch(safetyCatch)\n      return\n    }\n\n    this.digestLength = index + 1\n    this.digestIndex = seq\n    this.system = digestNode.digest.key\n\n    // signal that things have changed\n    this.base._maybeStaticFastForward = true\n  }\n\n  async getVersion (length = this.core.length) {\n    if (this.opened === false) await this.ready()\n\n    if (length === 0) return -1\n\n    const node = await this.core.get(length - 1)\n\n    return node.maxSupportedVersion\n  }\n\n  async getDigest (length = this.core.length) {\n    if (this.opened === false) await this.ready()\n\n    if (length === 0) return null\n\n    let node = await this.core.get(length - 1)\n\n    if (node.digest === null) return null\n\n    if (node.digest.pointer) {\n      length -= node.digest.pointer\n      node = await this.core.get(length - 1)\n    }\n\n    node.digest.pointer = this.core.length - (length - 1)\n\n    return node.digest\n  }\n\n  async getCheckpoint (index, length = this.core.length) {\n    if (this.opened === false) await this.ready()\n\n    if (length === 0) return null\n\n    let node = await this.core.get(length - 1)\n\n    let target = node.checkpoint[index]\n    if (!target) return null\n\n    if (!target.checkpoint) {\n      length -= target.checkpointer\n      node = await this.core.get(length - 1)\n      target = node.checkpoint[index]\n    }\n\n    return target.checkpoint\n  }\n\n  _shiftAndClear () {\n    const node = this.nodes.shift()\n    node.clear()\n    return node\n  }\n\n  flushCheckpoints (systemIndex) {\n    const index = systemIndex + 1 // view index is offset by 1\n    if (index >= this.pendingCheckpoints.length) return []\n\n    const pending = this.pendingCheckpoints[index]\n    this.pendingCheckpoints[index] = null\n\n    while (this.pendingCheckpoints.length > 0 && this.pendingCheckpoints[this.pendingCheckpoints.length - 1] === null) {\n      this.pendingCheckpoints.pop()\n    }\n\n    return pending !== null ? pending : []\n  }\n\n  _addCheckpoints (checkpoints) {\n    for (let i = 0; i < checkpoints.length; i++) {\n      const { checkpoint, checkpointer } = checkpoints[i]\n      if (checkpointer === 0) this._addCheckpoint(i, checkpoint)\n    }\n  }\n\n  _upsertPendingCheckpoints (index) {\n    while (index >= this.pendingCheckpoints.length) this.pendingCheckpoints.push(null)\n    if (this.pendingCheckpoints[index]) return this.pendingCheckpoints[index]\n    const p = this.pendingCheckpoints[index] = []\n    return p\n  }\n\n  _addCheckpoint (index, checkpoint) {\n    const core = this.base._viewStore.getByIndex(index - 1) // view index is offset by 1\n\n    if (core) {\n      core.signer.addCheckpoint(this.core.key, checkpoint)\n      return\n    }\n\n    const p = this._upsertPendingCheckpoints(index)\n    if (p.length > 0 && p[p.length - 1].length >= checkpoint.length) return\n    p.push(checkpoint)\n  }\n\n  async _loadNextNode () {\n    const seq = this.nodes.length\n    if (!(await this.core.has(seq))) return false\n    const { node, checkpoint, maxSupportedVersion } = await this.core.get(seq, { wait: false })\n\n    if (this.isActiveIndexer && checkpoint) {\n      this._addCheckpoints(checkpoint)\n    }\n\n    const value = node.value == null ? null : c.decode(this.base.valueEncoding, node.value)\n    this.node = Linearizer.createNode(this, seq + 1, value, node.heads, node.batch, new Set(), maxSupportedVersion)\n    return true\n  }\n\n  async _ensureNodeDependencies () {\n    while (this.node.dependencies.size < this.node.heads.length) {\n      const rawHead = this.node.heads[this.node.dependencies.size]\n\n      const headWriter = await this.base._getWriterByKey(rawHead.key, -1, rawHead.length, true, false, null)\n\n      if (headWriter !== this && (headWriter === null || headWriter.length < rawHead.length)) {\n        this.base._ensureWakeup(headWriter)\n        return false\n      }\n\n      let headNode = headWriter.nodes.get(rawHead.length - 1)\n\n      // could be a stub node\n      if (!headNode) {\n        for (const node of this.base.linearizer.heads) {\n          if (!compareHead(node, rawHead)) continue\n          headNode = node\n          break\n        }\n      }\n\n      // TODO: generalise DAG validation and freeze the writer\n      assert(!this.node.dependencies.has(headNode), 'Corrupted DAG')\n\n      // TODO: better way to solve the stub check is to never mutate heads below\n      if (headNode === null) { // already yielded\n        popAndSwap(this.node.heads, this.node.dependencies.size)\n        continue\n      }\n\n      this.node.dependencies.add(headNode)\n    }\n\n    // always link previous node if it's not indexed\n    const offset = this.node.length - 1\n    if (offset > this.indexed) {\n      this.node.dependencies.add(this.nodes.get(offset - 1))\n    }\n\n    return true\n  }\n}\n\nfunction popAndSwap (list, i) {\n  const pop = list.pop()\n  if (i >= list.length) return false\n  list[i] = pop\n  return true\n}\n\nfunction compareHead (node, head) {\n  if (node.length !== head.length) return false\n  return b4a.equals(node.writer.core.key, head.key)\n}\n\n// this is a list of peers we bugged in the btc and planb room.\n// adding them here so migration can run, can be removed in a month or so from time of commit\n// note, no security implications of this, we just null them out.\n\nfunction autoRecover (core) {\n  assert(core.opened)\n\n  switch (core.id) {\n    case 'ghrpexaboutdm46ombqho7mroxknassnntrxx3cubfux4qi6w6hy':\n    case 'qoaanao71s4he1rcd197d336qepykk4467geo1uq8cwnzmpb786o':\n    case 'fomhdxgn4j4tzjqy6y7iskhffimzokt7kraddyd8orcht3r8q61o':\n    case 'd8f5taxxrit51apftoi38e5b86hb98cgfd7dfp3uo1uoh95qt49o':\n    case 'objyf75uggsqpjcut69xdgj46ks8r71jjrq7oxdfsz95sstchkno':\n      return true\n  }\n\n  return false\n}\n{\n  \"name\": \"autobase\",\n  \"version\": \"6.5.13\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\",\n    \"test:encrypted\": \"standard && brittle test/*.js --encrypt-all\",\n    \"fuzz:generated\": \"brittle test/reference/fuzz/generated/*.js\",\n    \"fuzz:main\": \"node test/fuzz/index.js\",\n    \"fuzz\": \"node test/reference/fuzz/fuzz.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"lib/**\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/autobase.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/autobase/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/autobase#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.1\",\n    \"bare-events\": \"^2.2.0\",\n    \"core-coupler\": \"^1.0.0\",\n    \"debounceify\": \"^1.0.0\",\n    \"hyperbee\": \"^2.15.0\",\n    \"hypercore\": \"^10.37.10\",\n    \"hypercore-crypto\": \"^3.4.0\",\n    \"hypercore-id-encoding\": \"^1.2.0\",\n    \"mutexify\": \"^1.4.0\",\n    \"nanoassert\": \"^2.0.0\",\n    \"ready-resource\": \"^1.0.0\",\n    \"safety-catch\": \"^1.0.2\",\n    \"signal-promise\": \"^1.0.3\",\n    \"sub-encoder\": \"^2.1.1\",\n    \"tiny-buffer-map\": \"^1.1.1\"\n  },\n  \"devDependencies\": {\n    \"autobase-test-helpers\": \"^2.0.1\",\n    \"brittle\": \"^3.1.1\",\n    \"corestore\": \"^6.18.3\",\n    \"rache\": \"^1.0.0\",\n    \"random-access-memory\": \"^6.2.0\",\n    \"same-data\": \"^1.0.0\",\n    \"standard\": \"^17.0.0\",\n    \"test-tmp\": \"^1.2.0\"\n  },\n  \"standard\": {\n    \"ignore\": [\n      \"**/test/fuzz/generated/**\",\n      \"**/test/reference/**\",\n      \"example.mjs\"\n    ]\n  }\n}\nfunction isBuffer (value) {\n  return Buffer.isBuffer(value) || value instanceof Uint8Array\n}\n\nfunction isEncoding (encoding) {\n  return Buffer.isEncoding(encoding)\n}\n\nfunction alloc (size, fill, encoding) {\n  return Buffer.alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  return Buffer.allocUnsafe(size)\n}\n\nfunction allocUnsafeSlow (size) {\n  return Buffer.allocUnsafeSlow(size)\n}\n\nfunction byteLength (string, encoding) {\n  return Buffer.byteLength(string, encoding)\n}\n\nfunction compare (a, b) {\n  return Buffer.compare(a, b)\n}\n\nfunction concat (buffers, totalLength) {\n  return Buffer.concat(buffers, totalLength)\n}\n\nfunction copy (source, target, targetStart, start, end) {\n  return toBuffer(source).copy(target, targetStart, start, end)\n}\n\nfunction equals (a, b) {\n  return toBuffer(a).equals(b)\n}\n\nfunction fill (buffer, value, offset, end, encoding) {\n  return toBuffer(buffer).fill(value, offset, end, encoding)\n}\n\nfunction from (value, encodingOrOffset, length) {\n  return Buffer.from(value, encodingOrOffset, length)\n}\n\nfunction includes (buffer, value, byteOffset, encoding) {\n  return toBuffer(buffer).includes(value, byteOffset, encoding)\n}\n\nfunction indexOf (buffer, value, byfeOffset, encoding) {\n  return toBuffer(buffer).indexOf(value, byfeOffset, encoding)\n}\n\nfunction lastIndexOf (buffer, value, byteOffset, encoding) {\n  return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding)\n}\n\nfunction swap16 (buffer) {\n  return toBuffer(buffer).swap16()\n}\n\nfunction swap32 (buffer) {\n  return toBuffer(buffer).swap32()\n}\n\nfunction swap64 (buffer) {\n  return toBuffer(buffer).swap64()\n}\n\nfunction toBuffer (buffer) {\n  if (Buffer.isBuffer(buffer)) return buffer\n  return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n}\n\nfunction toString (buffer, encoding, start, end) {\n  return toBuffer(buffer).toString(encoding, start, end)\n}\n\nfunction write (buffer, string, offset, length, encoding) {\n  return toBuffer(buffer).write(string, offset, length, encoding)\n}\n\nfunction writeDoubleLE (buffer, value, offset) {\n  return toBuffer(buffer).writeDoubleLE(value, offset)\n}\n\nfunction writeFloatLE (buffer, value, offset) {\n  return toBuffer(buffer).writeFloatLE(value, offset)\n}\n\nfunction writeUInt32LE (buffer, value, offset) {\n  return toBuffer(buffer).writeUInt32LE(value, offset)\n}\n\nfunction writeInt32LE (buffer, value, offset) {\n  return toBuffer(buffer).writeInt32LE(value, offset)\n}\n\nfunction readDoubleLE (buffer, offset) {\n  return toBuffer(buffer).readDoubleLE(offset)\n}\n\nfunction readFloatLE (buffer, offset) {\n  return toBuffer(buffer).readFloatLE(offset)\n}\n\nfunction readUInt32LE (buffer, offset) {\n  return toBuffer(buffer).readUInt32LE(offset)\n}\n\nfunction readInt32LE (buffer, offset) {\n  return toBuffer(buffer).readInt32LE(offset)\n}\n\nfunction writeDoubleBE (buffer, value, offset) {\n  return toBuffer(buffer).writeDoubleBE(value, offset)\n}\n\nfunction writeFloatBE (buffer, value, offset) {\n  return toBuffer(buffer).writeFloatBE(value, offset)\n}\n\nfunction writeUInt32BE (buffer, value, offset) {\n  return toBuffer(buffer).writeUInt32BE(value, offset)\n}\n\nfunction writeInt32BE (buffer, value, offset) {\n  return toBuffer(buffer).writeInt32BE(value, offset)\n}\n\nfunction readDoubleBE (buffer, offset) {\n  return toBuffer(buffer).readDoubleBE(offset)\n}\n\nfunction readFloatBE (buffer, offset) {\n  return toBuffer(buffer).readFloatBE(offset)\n}\n\nfunction readUInt32BE (buffer, offset) {\n  return toBuffer(buffer).readUInt32BE(offset)\n}\n\nfunction readInt32BE (buffer, offset) {\n  return toBuffer(buffer).readInt32BE(offset)\n}\n\nmodule.exports = {\n  isBuffer,\n  isEncoding,\n  alloc,\n  allocUnsafe,\n  allocUnsafeSlow,\n  byteLength,\n  compare,\n  concat,\n  copy,\n  equals,\n  fill,\n  from,\n  includes,\n  indexOf,\n  lastIndexOf,\n  swap16,\n  swap32,\n  swap64,\n  toBuffer,\n  toString,\n  write,\n  writeDoubleLE,\n  writeFloatLE,\n  writeUInt32LE,\n  writeInt32LE,\n  readDoubleLE,\n  readFloatLE,\n  readUInt32LE,\n  readInt32LE,\n  writeDoubleBE,\n  writeFloatBE,\n  writeUInt32BE,\n  writeInt32BE,\n  readDoubleBE,\n  readFloatBE,\n  readUInt32BE,\n  readInt32BE\n\n}\n{\n  \"name\": \"b4a\",\n  \"version\": \"1.6.7\",\n  \"description\": \"Bridging the gap between buffers and typed arrays\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"browser.js\",\n    \"index.js\",\n    \"lib\"\n  ],\n  \"browser\": {\n    \"./index.js\": \"./browser.js\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/b4a.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/b4a/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/b4a#readme\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.2\",\n    \"nanobench\": \"^3.0.0\",\n    \"standard\": \"^17.1.0\"\n  }\n}\nmodule.exports = require.addon()\nconst { Transform } = require('bare-stream')\nconst binding = require('./binding')\nconst constants = (exports.constants = require('./lib/constants'))\nconst errors = (exports.errors = require('./lib/errors'))\n\nexports.Hash = class CryptoHash extends Transform {\n  constructor(algorithm, opts = {}) {\n    super(opts)\n\n    if (typeof algorithm === 'string') {\n      if (algorithm in constants.hash) algorithm = constants.hash[algorithm]\n      else {\n        algorithm = algorithm.toUpperCase()\n\n        if (algorithm in constants.hash) algorithm = constants.hash[algorithm]\n        else {\n          throw errors.UNSUPPORTED_DIGEST_METHOD(\n            `Unsupported digest method '${algorithm}'`\n          )\n        }\n      }\n    }\n\n    this._handle = binding.hashInit(algorithm)\n  }\n\n  update(data, encoding = 'utf8') {\n    if (typeof data === 'string') data = Buffer.from(data, encoding)\n\n    binding.hashUpdate(this._handle, data)\n\n    return this\n  }\n\n  digest(encoding) {\n    const digest = Buffer.from(binding.hashFinal(this._handle))\n\n    return encoding ? digest.toString(encoding) : digest\n  }\n\n  _transform(data, encoding, cb) {\n    this.update(data)\n\n    cb(null)\n  }\n\n  _flush(cb) {\n    this.push(this.digest())\n\n    cb(null)\n  }\n}\n\nexports.createHash = function createHash(algorithm, opts) {\n  return new exports.Hash(algorithm, opts)\n}\n\nexports.randomBytes = function randomBytes(size, cb) {\n  const buffer = Buffer.allocUnsafe(size)\n  exports.randomFill(buffer)\n  if (cb) queueMicrotask(() => cb(null, buffer))\n  else return buffer\n}\n\nexports.randomFill = function randomFill(buffer, offset, size, cb) {\n  if (typeof offset === 'function') {\n    cb = offset\n    offset = undefined\n  } else if (typeof size === 'function') {\n    cb = size\n    size = undefined\n  }\n\n  const elementSize = buffer.BYTES_PER_ELEMENT || 1\n\n  if (offset === undefined) offset = 0\n  else offset *= elementSize\n\n  if (size === undefined) size = buffer.byteLength - offset\n  else size *= elementSize\n\n  if (offset < 0 || offset > buffer.byteLength) {\n    throw new RangeError('offset is out of range')\n  }\n\n  if (size < 0 || size > buffer.byteLength) {\n    throw new RangeError('size is out of range')\n  }\n\n  if (offset + size > buffer.byteLength) {\n    throw new RangeError('offset + size is out of range')\n  }\n\n  let arraybuffer\n\n  if (ArrayBuffer.isView(buffer)) {\n    offset += buffer.byteOffset\n    arraybuffer = buffer.buffer\n  } else {\n    arraybuffer = buffer\n  }\n\n  binding.randomFill(arraybuffer, offset, size)\n\n  if (cb) queueMicrotask(() => cb(null, buffer))\n  else return buffer\n}\n\n// For Node.js compatibility\nexports.randomFillSync = function randomFillSync(buffer, offset, size) {\n  return exports.randomFill(buffer, offset, size)\n}\n\n// For Node.js compatibility\nexports.webcrypto = require('./web')\nconst binding = require('../binding')\n\nmodule.exports = {\n  hash: {\n    MD5: binding.MD5,\n    SHA1: binding.SHA1,\n    SHA256: binding.SHA256,\n    SHA512: binding.SHA512,\n    BLAKE2B256: binding.BLAKE2B256\n  }\n}\nmodule.exports = class CryptoError extends Error {\n  constructor(msg, code, fn = CryptoError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'CryptoError'\n  }\n\n  static UNSUPPORTED_DIGEST_METHOD(msg) {\n    return new CryptoError(\n      msg,\n      'UNSUPPORTED_DIGEST_METHOD',\n      CryptoError.UNSUPPORTED_DIGEST_METHOD\n    )\n  }\n}\n{\n  \"name\": \"bare-crypto\",\n  \"version\": \"1.4.0\",\n  \"description\": \"Cryptographic primitives for JavaScript\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./package\": \"./package.json\",\n    \"./web\": {\n      \"types\": \"./web.d.ts\",\n      \"default\": \"./web.js\"\n    },\n    \"./constants\": \"./lib/constants.js\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"web.js\",\n    \"web.d.ts\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-crypto.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-crypto/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-crypto#readme\",\n  \"dependencies\": {\n    \"bare-stream\": \"^2.6.3\"\n  },\n  \"devDependencies\": {\n    \"bare-buffer\": \"^3.0.1\",\n    \"brittle\": \"^3.5.0\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"cmake-fetch\": \"^1.0.0\",\n    \"prettier\": \"^3.4.2\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  },\n  \"peerDependencies\": {\n    \"bare-buffer\": \"*\"\n  },\n  \"peerDependenciesMeta\": {\n    \"bare-buffer\": {\n      \"optional\": true\n    }\n  }\n}\nconst crypto = require('.')\n\n// https://w3c.github.io/webcrypto/#Crypto-method-getRandomValues\nexports.getRandomValues = function getRandomValues(array) {\n  return crypto.randomFillSync(array)\n}\nmodule.exports = require.addon()\nconst binding = require('./binding')\n\nfunction onlookup (err, addresses) {\n  const req = this\n\n  if (err) return req.cb(err, null, 0)\n\n  const { address, family } = addresses[0]\n\n  return req.cb(null, address, family)\n}\n\nfunction onlookupall (err, addresses) {\n  const req = this\n\n  if (err) return req.cb(err, null)\n\n  return req.cb(null, addresses)\n}\n\nexports.lookup = function lookup (hostname, opts = {}, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  let {\n    family = 0,\n    all = false\n  } = opts\n\n  if (typeof family === 'string') {\n    switch (family) {\n      case 'IPv4': family = 4\n        break\n      case 'IPv6': family = 6\n        break\n      default: family = 0\n    }\n  }\n\n  const req = {\n    cb,\n    handle: null\n  }\n\n  req.handle = binding.lookup(hostname, family || 0, all, req, all ? onlookupall : onlookup)\n}\n{\n  \"name\": \"bare-dns\",\n  \"version\": \"1.0.5\",\n  \"description\": \"Domain name resolution for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"standard && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-dns.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-dns/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-dns\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"standard\": \"^17.1.0\"\n  }\n}\nconst errors = require('./lib/errors')\n\nclass EventListener {\n  constructor() {\n    this.list = []\n    this.count = 0\n  }\n\n  append(ctx, name, fn, once) {\n    this.count++\n    ctx.emit('newListener', name, fn) // Emit BEFORE adding\n    this.list.push([fn, once])\n  }\n\n  prepend(ctx, name, fn, once) {\n    this.count++\n    ctx.emit('newListener', name, fn) // Emit BEFORE adding\n    this.list.unshift([fn, once])\n  }\n\n  remove(ctx, name, fn) {\n    for (let i = 0, n = this.list.length; i < n; i++) {\n      const l = this.list[i]\n\n      if (l[0] === fn) {\n        this.list.splice(i, 1)\n\n        if (this.count === 1) delete ctx._events[name]\n\n        ctx.emit('removeListener', name, fn) // Emit AFTER removing\n\n        this.count--\n        return\n      }\n    }\n  }\n\n  removeAll(ctx, name) {\n    const list = [...this.list]\n    this.list = []\n\n    if (this.count === list.length) delete ctx._events[name]\n\n    for (let i = list.length - 1; i >= 0; i--) {\n      ctx.emit('removeListener', name, list[i][0]) // Emit AFTER removing\n    }\n\n    this.count -= list.length\n  }\n\n  emit(ctx, name, ...args) {\n    const list = [...this.list]\n\n    for (let i = 0, n = list.length; i < n; i++) {\n      const l = list[i]\n\n      if (l[1] === true) this.remove(ctx, name, l[0])\n\n      l[0].call(ctx, ...args)\n    }\n\n    return list.length > 0\n  }\n}\n\nfunction appendListener(ctx, name, fn, once) {\n  const e = ctx._events[name] || (ctx._events[name] = new EventListener())\n  e.append(ctx, name, fn, once)\n  return ctx\n}\n\nfunction prependListener(ctx, name, fn, once) {\n  const e = ctx._events[name] || (ctx._events[name] = new EventListener())\n  e.prepend(ctx, name, fn, once)\n  return ctx\n}\n\nfunction removeListener(ctx, name, fn) {\n  const e = ctx._events[name]\n  if (e !== undefined) e.remove(ctx, name, fn)\n  return ctx\n}\n\nfunction throwUnhandledError(...args) {\n  let err\n\n  if (args.length > 0) err = args[0]\n\n  if (err instanceof Error === false) err = errors.UNHANDLED_ERROR(err)\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(err, exports.prototype.emit)\n  }\n\n  queueMicrotask(() => {\n    throw err\n  })\n}\n\nmodule.exports = exports = class EventEmitter {\n  constructor() {\n    this._events = Object.create(null)\n  }\n\n  addListener(name, fn) {\n    return appendListener(this, name, fn, false)\n  }\n\n  addOnceListener(name, fn) {\n    return appendListener(this, name, fn, true)\n  }\n\n  prependListener(name, fn) {\n    return prependListener(this, name, fn, false)\n  }\n\n  prependOnceListener(name, fn) {\n    return prependListener(this, name, fn, true)\n  }\n\n  removeListener(name, fn) {\n    return removeListener(this, name, fn)\n  }\n\n  on(name, fn) {\n    return appendListener(this, name, fn, false)\n  }\n\n  once(name, fn) {\n    return appendListener(this, name, fn, true)\n  }\n\n  off(name, fn) {\n    return removeListener(this, name, fn)\n  }\n\n  emit(name, ...args) {\n    if (name === 'error' && this._events.error === undefined) {\n      throwUnhandledError(...args)\n    }\n\n    const e = this._events[name]\n    return e === undefined ? false : e.emit(this, name, ...args)\n  }\n\n  listeners(name) {\n    const e = this._events[name]\n    return e === undefined ? [] : [...e.list]\n  }\n\n  listenerCount(name) {\n    const e = this._events[name]\n    return e === undefined ? 0 : e.list.length\n  }\n\n  getMaxListeners() {\n    return EventEmitter.defaultMaxListeners\n  }\n\n  setMaxListeners(n) {}\n\n  removeAllListeners(name) {\n    if (arguments.length === 0) {\n      for (const key of Reflect.ownKeys(this._events)) {\n        if (key === 'removeListener') continue\n        this.removeAllListeners(key)\n      }\n      this.removeAllListeners('removeListener')\n    } else {\n      const e = this._events[name]\n      if (e !== undefined) e.removeAll(this, name)\n    }\n    return this\n  }\n}\n\nexports.EventEmitter = exports\n\nexports.errors = errors\n\nexports.defaultMaxListeners = 10\n\nexports.on = function on(emitter, name, opts = {}) {\n  const { signal } = opts\n\n  if (signal && signal.aborted) {\n    throw errors.OPERATION_ABORTED(signal.reason)\n  }\n\n  let error = null\n  let done = false\n\n  const events = []\n  const promises = []\n\n  emitter.on(name, onevent)\n\n  if (name !== 'error') emitter.on('error', onerror)\n\n  if (signal) signal.addEventListener('abort', onabort)\n\n  return {\n    next() {\n      if (events.length) {\n        return Promise.resolve({ value: events.shift(), done: false })\n      }\n\n      if (error) {\n        const err = error\n\n        error = null\n\n        return Promise.reject(err)\n      }\n\n      if (done) return onclose()\n\n      return new Promise((resolve, reject) =>\n        promises.push({ resolve, reject })\n      )\n    },\n\n    return() {\n      return onclose()\n    },\n\n    throw(err) {\n      return onerror(err)\n    },\n\n    [Symbol.asyncIterator]() {\n      return this\n    }\n  }\n\n  function onevent(...args) {\n    if (promises.length) {\n      promises.shift().resolve({ value: args, done: false })\n    } else {\n      events.push(args)\n    }\n  }\n\n  function onerror(err) {\n    if (promises.length) {\n      promises.shift().reject(err)\n    } else {\n      error = err\n    }\n\n    return Promise.resolve({ done: true })\n  }\n\n  function onabort() {\n    onerror(errors.OPERATION_ABORTED(signal.reason))\n  }\n\n  function onclose() {\n    emitter.off(name, onevent)\n\n    if (name !== 'error') emitter.off('error', onerror)\n\n    if (signal) signal.removeEventListener('abort', onabort)\n\n    done = true\n\n    if (promises.length) promises.shift().resolve({ done: true })\n\n    return Promise.resolve({ done: true })\n  }\n}\n\nexports.once = function once(emitter, name, opts = {}) {\n  const { signal } = opts\n\n  if (signal && signal.aborted) {\n    throw errors.OPERATION_ABORTED(signal.reason)\n  }\n\n  return new Promise((resolve, reject) => {\n    if (name !== 'error') emitter.on('error', onerror)\n\n    if (signal) signal.addEventListener('abort', onabort)\n\n    emitter.once(name, (...args) => {\n      if (name !== 'error') emitter.off('error', onerror)\n\n      if (signal) signal.removeEventListener('abort', onabort)\n\n      resolve(args)\n    })\n\n    function onerror(err) {\n      emitter.off('error', onerror)\n\n      reject(err)\n    }\n\n    function onabort() {\n      signal.removeEventListener('abort', onabort)\n\n      onerror(errors.OPERATION_ABORTED(signal.reason))\n    }\n  })\n}\n\nexports.forward = function forward(from, to, names, opts = {}) {\n  if (typeof names === 'string') names = [names]\n\n  const { emit = to.emit.bind(to) } = opts\n\n  const listeners = names.map(\n    (name) =>\n      function onevent(...args) {\n        emit(name, ...args)\n      }\n  )\n\n  to.on('newListener', (name) => {\n    const i = names.indexOf(name)\n\n    if (i !== -1 && to.listenerCount(name) === 0) {\n      from.on(name, listeners[i])\n    }\n  }).on('removeListener', (name) => {\n    const i = names.indexOf(name)\n\n    if (i !== -1 && to.listenerCount(name) === 0) {\n      from.off(name, listeners[i])\n    }\n  })\n}\n\nexports.listenerCount = function listenerCount(emitter, name) {\n  return emitter.listenerCount(name)\n}\nmodule.exports = class EventEmitterError extends Error {\n  constructor(msg, code, fn = EventEmitterError, opts) {\n    super(`${code}: ${msg}`, opts)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'EventEmitterError'\n  }\n\n  static OPERATION_ABORTED(cause, msg = 'Operation aborted') {\n    return new EventEmitterError(\n      msg,\n      'OPERATION_ABORTED',\n      EventEmitterError.OPERATION_ABORTED,\n      { cause }\n    )\n  }\n\n  static UNHANDLED_ERROR(cause, msg = 'Unhandled error') {\n    return new EventEmitterError(\n      msg,\n      'UNHANDLED_ERROR',\n      EventEmitterError.UNHANDLED_ERROR,\n      { cause }\n    )\n  }\n}\n{\n  \"name\": \"bare-events\",\n  \"version\": \"2.5.4\",\n  \"description\": \"Event emitters for JavaScript\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./package\": \"./package.json\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"npm run lint && npm run test:bare && npm run test:node\",\n    \"test:bare\": \"bare test.js\",\n    \"test:node\": \"node test.js\",\n    \"lint\": \"prettier . --check\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-events.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-events/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-events#readme\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"prettier\": \"^3.4.2\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nmodule.exports = require.addon()\n/* global Bare */\nconst EventEmitter = require('bare-events')\nconst path = require('bare-path')\nconst { Readable, Writable } = require('bare-stream')\nconst binding = require('./binding')\n\nconst isWindows = Bare.platform === 'win32'\n\nconst constants = (exports.constants = {\n  O_RDWR: binding.O_RDWR,\n  O_RDONLY: binding.O_RDONLY,\n  O_WRONLY: binding.O_WRONLY,\n  O_CREAT: binding.O_CREAT,\n  O_TRUNC: binding.O_TRUNC,\n  O_APPEND: binding.O_APPEND,\n\n  F_OK: binding.F_OK || 0,\n  R_OK: binding.R_OK || 0,\n  W_OK: binding.W_OK || 0,\n  X_OK: binding.X_OK || 0,\n\n  S_IFMT: binding.S_IFMT,\n  S_IFREG: binding.S_IFREG,\n  S_IFDIR: binding.S_IFDIR,\n  S_IFCHR: binding.S_IFCHR,\n  S_IFLNK: binding.S_IFLNK,\n  S_IFBLK: binding.S_IFBLK || 0,\n  S_IFIFO: binding.S_IFIFO || 0,\n  S_IFSOCK: binding.S_IFSOCK || 0,\n\n  S_IRUSR: binding.S_IRUSR || 0,\n  S_IWUSR: binding.S_IWUSR || 0,\n  S_IXUSR: binding.S_IXUSR || 0,\n  S_IRGRP: binding.S_IRGRP || 0,\n  S_IWGRP: binding.S_IWGRP || 0,\n  S_IXGRP: binding.S_IXGRP || 0,\n  S_IROTH: binding.S_IROTH || 0,\n  S_IWOTH: binding.S_IWOTH || 0,\n  S_IXOTH: binding.S_IXOTH || 0,\n\n  UV_DIRENT_UNKNOWN: binding.UV_DIRENT_UNKNOWN,\n  UV_DIRENT_FILE: binding.UV_DIRENT_FILE,\n  UV_DIRENT_DIR: binding.UV_DIRENT_DIR,\n  UV_DIRENT_LINK: binding.UV_DIRENT_LINK,\n  UV_DIRENT_FIFO: binding.UV_DIRENT_FIFO,\n  UV_DIRENT_SOCKET: binding.UV_DIRENT_SOCKET,\n  UV_DIRENT_CHAR: binding.UV_DIRENT_CHAR,\n  UV_DIRENT_BLOCK: binding.UV_DIRENT_BLOCK,\n\n  COPYFILE_EXCL: binding.UV_FS_COPYFILE_EXCL,\n  COPYFILE_FICLONE: binding.UV_FS_COPYFILE_FICLONE,\n  COPYFILE_FICLONE_FORCE: binding.UV_FS_COPYFILE_FICLONE_FORCE,\n  UV_FS_SYMLINK_DIR: binding.UV_FS_SYMLINK_DIR,\n  UV_FS_SYMLINK_JUNCTION: binding.UV_FS_SYMLINK_JUNCTION\n})\n\n// Lightly-modified from the Node FS internal utils.\nfunction flagsToNumber(flags) {\n  switch (flags) {\n    case 'r':\n      return constants.O_RDONLY\n    case 'rs': // Fall through.\n    case 'sr':\n      return constants.O_RDONLY | constants.O_SYNC\n    case 'r+':\n      return constants.O_RDWR\n    case 'rs+': // Fall through.\n    case 'sr+':\n      return constants.O_RDWR | constants.O_SYNC\n\n    case 'w':\n      return constants.O_TRUNC | constants.O_CREAT | constants.O_WRONLY\n    case 'wx': // Fall through.\n    case 'xw':\n      return (\n        constants.O_TRUNC |\n        constants.O_CREAT |\n        constants.O_WRONLY |\n        constants.O_EXCL\n      )\n\n    case 'w+':\n      return constants.O_TRUNC | constants.O_CREAT | constants.O_RDWR\n    case 'wx+': // Fall through.\n    case 'xw+':\n      return (\n        constants.O_TRUNC |\n        constants.O_CREAT |\n        constants.O_RDWR |\n        constants.O_EXCL\n      )\n\n    case 'a':\n      return constants.O_APPEND | constants.O_CREAT | constants.O_WRONLY\n    case 'ax': // Fall through.\n    case 'xa':\n      return (\n        constants.O_APPEND |\n        constants.O_CREAT |\n        constants.O_WRONLY |\n        constants.O_EXCL\n      )\n    case 'as': // Fall through.\n    case 'sa':\n      return (\n        constants.O_APPEND |\n        constants.O_CREAT |\n        constants.O_WRONLY |\n        constants.O_SYNC\n      )\n\n    case 'a+':\n      return constants.O_APPEND | constants.O_CREAT | constants.O_RDWR\n    case 'ax+': // Fall through.\n    case 'xa+':\n      return (\n        constants.O_APPEND |\n        constants.O_CREAT |\n        constants.O_RDWR |\n        constants.O_EXCL\n      )\n    case 'as+': // Fall through.\n    case 'sa+':\n      return (\n        constants.O_APPEND |\n        constants.O_CREAT |\n        constants.O_RDWR |\n        constants.O_SYNC\n      )\n  }\n\n  throw typeError('ERR_INVALID_ARG_VALUE', `Invalid value in flags: ${flags}`)\n}\n\nfunction modeToNumber(mode) {\n  mode = parseInt(mode, 8)\n  if (isNaN(mode))\n    throw typeError(\n      'ERR_INVALID_ARG_VALUE',\n      'Mode must be a number or octal string'\n    )\n  return mode\n}\n\nconst free = []\n\nfunction alloc() {\n  const req = { handle: null, callback: null }\n  req.handle = binding.init(req, onresponse)\n  return req\n}\n\nfunction getReq() {\n  return free.length ? free.pop() : alloc()\n}\n\nfunction onresponse(err, result) {\n  const req = this\n  const cb = req.callback\n  req.callback = null\n  free.push(req)\n  cb(err, result)\n}\n\nfunction open(filepath, flags, mode, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof cb !== 'function') {\n    if (typeof flags === 'function') {\n      cb = flags\n      flags = 'r'\n      mode = 0o666\n    } else if (typeof mode === 'function') {\n      cb = mode\n      mode = 0o666\n    } else {\n      throw typeError(\n        'ERR_INVALID_ARG_TYPE',\n        'Callback must be a function. Received type ' +\n          typeof cb +\n          ' (' +\n          cb +\n          ')'\n      )\n    }\n  }\n\n  if (typeof flags === 'string') flags = flagsToNumber(flags)\n  if (typeof mode === 'string') mode = modeToNumber(mode)\n\n  const req = getReq()\n  req.callback = cb\n  binding.open(req.handle, filepath, flags, mode)\n}\n\nfunction openSync(filepath, flags = 'r', mode = 0o666) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof flags === 'string') flags = flagsToNumber(flags)\n  if (typeof mode === 'string') mode = modeToNumber(mode)\n\n  return binding.openSync(filepath, flags, mode)\n}\n\nfunction close(fd, cb = noop) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  const req = getReq()\n  req.callback = cb\n  binding.close(req.handle, fd)\n}\n\nfunction closeSync(fd) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  return binding.closeSync(fd)\n}\n\nfunction access(filepath, mode, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof cb !== 'function') {\n    if (typeof mode === 'function') {\n      cb = mode\n      mode = constants.F_OK\n    } else {\n      throw typeError(\n        'ERR_INVALID_ARG_TYPE',\n        'Callback must be a function. Received type ' +\n          typeof cb +\n          ' (' +\n          cb +\n          ')'\n      )\n    }\n  }\n\n  const req = getReq()\n  req.callback = cb\n  binding.access(req.handle, filepath, mode)\n}\n\nfunction accessSync(filepath, mode = constants.F_OK) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  binding.accessSync(filepath, mode)\n}\n\nfunction exists(filepath, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  return access(filepath, (err) => cb(!!err))\n}\n\nfunction existsSync(filepath) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  try {\n    accessSync(filepath)\n    return true\n  } catch {\n    return false\n  }\n}\n\nfunction read(fd, buffer, offset, len, pos, cb) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  if (!Buffer.isBuffer(buffer) && !ArrayBuffer.isView(buffer)) {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Buffer must be a buffer. Received type ' +\n        typeof buffer +\n        ' (' +\n        buffer +\n        ')'\n    )\n  }\n\n  if (typeof cb !== 'function') {\n    if (typeof offset === 'function') {\n      cb = offset\n      offset = 0\n      len = buffer.byteLength\n      pos = -1\n    } else if (typeof len === 'function') {\n      cb = len\n      len = buffer.byteLength - offset\n      pos = -1\n    } else if (typeof pos === 'function') {\n      cb = pos\n      pos = -1\n    } else {\n      throw typeError(\n        'ERR_INVALID_ARG_TYPE',\n        'Callback must be a function. Received type ' +\n          typeof cb +\n          ' (' +\n          cb +\n          ')'\n      )\n    }\n  }\n\n  if (typeof pos !== 'number') pos = -1\n\n  const req = getReq()\n  req.callback = cb\n  binding.read(req.handle, fd, buffer, offset, len, pos)\n}\n\nfunction readSync(\n  fd,\n  buffer,\n  offset = 0,\n  len = buffer.byteLength - offset,\n  pos = -1\n) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  if (!Buffer.isBuffer(buffer) && !ArrayBuffer.isView(buffer)) {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Buffer must be a buffer. Received type ' +\n        typeof buffer +\n        ' (' +\n        buffer +\n        ')'\n    )\n  }\n\n  return binding.readSync(fd, buffer, offset, len, pos)\n}\n\nfunction readv(fd, buffers, pos, cb) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  if (typeof pos === 'function') {\n    cb = pos\n    pos = -1\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  if (typeof pos !== 'number') pos = -1\n\n  const req = getReq()\n  req.callback = cb\n  binding.readv(req.handle, fd, buffers, pos)\n}\n\nfunction write(fd, data, offset, len, pos, cb) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  if (\n    typeof data !== 'string' &&\n    !Buffer.isBuffer(data) &&\n    !ArrayBuffer.isView(data)\n  ) {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Data must be a string or buffer. Received type ' + typeof data\n    )\n  }\n\n  if (typeof data === 'string') {\n    let encoding = len\n    cb = pos\n    pos = offset\n\n    if (typeof cb !== 'function') {\n      if (typeof pos === 'function') {\n        cb = pos\n        pos = -1\n        encoding = 'utf8'\n      } else if (typeof encoding === 'function') {\n        cb = encoding\n        encoding = 'utf8'\n      } else {\n        throw typeError(\n          'ERR_INVALID_ARG_TYPE',\n          'Callback must be a function. Received type ' +\n            typeof cb +\n            ' (' +\n            cb +\n            ')'\n        )\n      }\n    }\n\n    if (typeof pos === 'string') {\n      encoding = pos\n      pos = -1\n    }\n\n    data = Buffer.from(data, encoding)\n    offset = 0\n    len = data.byteLength\n  } else if (typeof cb !== 'function') {\n    if (typeof offset === 'function') {\n      cb = offset\n      offset = 0\n      len = data.byteLength\n      pos = -1\n    } else if (typeof len === 'function') {\n      cb = len\n      len = data.byteLength - offset\n      pos = -1\n    } else if (typeof pos === 'function') {\n      cb = pos\n      pos = -1\n    } else {\n      throw typeError(\n        'ERR_INVALID_ARG_TYPE',\n        'Callback must be a function. Received type ' +\n          typeof cb +\n          ' (' +\n          cb +\n          ')'\n      )\n    }\n  }\n\n  if (typeof pos !== 'number') pos = -1\n\n  const req = getReq()\n  req.callback = cb\n  binding.write(req.handle, fd, data, offset, len, pos)\n}\n\nfunction writeSync(fd, data, offset = 0, len, pos) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  if (\n    typeof data !== 'string' &&\n    !Buffer.isBuffer(data) &&\n    !ArrayBuffer.isView(data)\n  ) {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Data must be a string or buffer. Received type ' + typeof data\n    )\n  }\n\n  if (typeof data === 'string') data = Buffer.from(data)\n\n  if (typeof len !== 'number') len = data.byteLength - offset\n\n  if (typeof pos !== 'number') pos = -1\n\n  return binding.writeSync(fd, data, offset, len, pos)\n}\n\nfunction writev(fd, buffers, pos, cb) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  if (typeof pos === 'function') {\n    cb = pos\n    pos = -1\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  if (typeof pos !== 'number') pos = -1\n\n  const req = getReq()\n  req.callback = cb\n  binding.writev(req.handle, fd, buffers, pos)\n}\n\nfunction stat(filepath, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  const data = new Array(Stats.length)\n\n  const req = getReq()\n\n  req.callback = function (err, _) {\n    if (err) cb(err, null)\n    else cb(null, new Stats(...data))\n  }\n\n  binding.stat(req.handle, filepath, data)\n}\n\nfunction statSync(filepath) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  return new Stats(...binding.statSync(filepath))\n}\n\nfunction lstat(filepath, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  const data = new Array(Stats.length)\n\n  const req = getReq()\n\n  req.callback = function (err, _) {\n    if (err) cb(err, null)\n    else cb(null, new Stats(...data))\n  }\n\n  binding.lstat(req.handle, filepath, data)\n}\n\nfunction lstatSync(filepath) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  return new Stats(...binding.lstatSync(filepath))\n}\n\nfunction fstat(fd, cb) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  const data = new Array(Stats.length)\n\n  const req = getReq()\n\n  req.callback = function (err, _) {\n    if (err) cb(err, null)\n    else cb(null, new Stats(...data))\n  }\n\n  binding.fstat(req.handle, fd, data)\n}\n\nfunction fstatSync(fd) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  return new Stats(...binding.fstatSync(fd))\n}\n\nfunction ftruncate(fd, len, cb) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  if (typeof len === 'function') {\n    cb = len\n    len = 0\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  const req = getReq()\n  req.callback = cb\n  binding.ftruncate(req.handle, fd, len)\n}\n\nfunction chmod(filepath, mode, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof mode === 'string') mode = modeToNumber(mode)\n\n  const req = getReq()\n  req.callback = cb\n  binding.chmod(req.handle, filepath, mode)\n}\n\nfunction chmodSync(filepath, mode) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof mode === 'string') mode = modeToNumber(mode)\n\n  binding.chmodSync(filepath, mode)\n}\n\nfunction fchmod(fd, mode, cb) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  if (typeof mode === 'string') mode = modeToNumber(mode)\n\n  const req = getReq()\n  req.callback = cb\n  binding.fchmod(req.handle, fd, mode)\n}\n\nfunction fchmodSync(fd, mode) {\n  if (typeof fd !== 'number') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'File descriptor must be a number. Received type ' +\n        typeof fd +\n        ' (' +\n        fd +\n        ')'\n    )\n  }\n\n  if (fd < 0 || fd > 0x7fffffff) {\n    throw typeError(\n      'ERR_OUT_OF_RANGE',\n      'File descriptor is out of range. It must be >= 0 && <= 2147483647. Received ' +\n        fd\n    )\n  }\n\n  if (typeof mode === 'string') mode = modeToNumber(mode)\n\n  binding.fchmodSync(fd, mode)\n}\n\nfunction mkdirRecursive(filepath, mode, cb) {\n  mkdir(filepath, { mode }, function (err) {\n    if (err === null) return cb(null, 0, null)\n\n    if (err.code !== 'ENOENT') {\n      stat(filepath, function (e, st) {\n        if (e) return cb(e, e.errno, null)\n        if (st.isDirectory()) return cb(null, 0, null)\n        cb(err, err.errno, null)\n      })\n      return\n    }\n\n    while (filepath.endsWith(path.sep)) filepath = filepath.slice(0, -1)\n    const i = filepath.lastIndexOf(path.sep)\n    if (i <= 0) return cb(err, err.errno, null)\n\n    mkdirRecursive(filepath.slice(0, i), mode, function (err) {\n      if (err) return cb(err, err.errno, null)\n\n      mkdir(filepath, { mode }, function (err) {\n        if (err === null) return cb(null, 0, null)\n\n        stat(filepath, function (e, st) {\n          if (e) return cb(e, e.errno, null)\n          if (st.isDirectory()) return cb(null, 0, null)\n          cb(err, err.errno, null)\n        })\n      })\n    })\n  })\n}\n\nfunction mkdir(filepath, opts, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = { mode: 0o777 }\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'number') opts = { mode: opts }\n  else if (!opts) opts = {}\n\n  const mode = typeof opts.mode === 'number' ? opts.mode : 0o777\n\n  if (opts.recursive)\n    return mkdirRecursive(filepath.replace(/\\//g, path.sep), mode, cb)\n\n  const req = getReq()\n  req.callback = cb\n  binding.mkdir(req.handle, filepath, mode)\n}\n\nfunction mkdirRecursiveSync(filepath, mode) {\n  try {\n    mkdirSync(filepath, { mode })\n  } catch (err) {\n    if (err.code !== 'ENOENT' && statSync(filepath).isDirectory()) {\n      return\n    }\n\n    while (filepath.endsWith(path.sep)) filepath = filepath.slice(0, -1)\n    const i = filepath.lastIndexOf(path.sep)\n    if (i <= 0) throw err\n\n    mkdirRecursiveSync(filepath.slice(0, i), { mode })\n\n    try {\n      mkdirSync(filepath, { mode })\n    } catch (err) {\n      if (statSync(filepath).isDirectory()) {\n        return\n      }\n\n      throw err\n    }\n  }\n}\n\nfunction mkdirSync(filepath, opts) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'number') opts = { mode: opts }\n  else if (!opts) opts = {}\n\n  const mode = typeof opts.mode === 'number' ? opts.mode : 0o777\n\n  if (opts.recursive)\n    return mkdirRecursiveSync(filepath.replace(/\\//g, path.sep), mode)\n\n  binding.mkdirSync(filepath, mode)\n}\n\nfunction rmdir(filepath, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  const req = getReq()\n  req.callback = cb\n  binding.rmdir(req.handle, filepath)\n}\n\nfunction rmdirSync(filepath) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  binding.rmdirSync(filepath)\n}\n\nfunction rmRecursive(filepath, opts, cb) {\n  rmdir(filepath, function (err) {\n    if (err === null) return cb(null)\n\n    if (err.code !== 'ENOTEMPTY') return cb(err)\n\n    readdir(filepath, function (err, files) {\n      if (err) return cb(err)\n\n      if (files.length === 0) return rmdir(filepath, cb)\n\n      let missing = files.length\n      let done = false\n\n      for (const file of files) {\n        rm(filepath + path.sep + file, opts, function (err) {\n          if (done) return\n\n          if (err) {\n            done = true\n            return cb(err)\n          }\n\n          if (--missing === 0) rmdir(filepath, cb)\n        })\n      }\n    })\n  })\n}\n\nfunction rm(filepath, opts, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  if (!opts) opts = {}\n\n  lstat(filepath, function (err, st) {\n    if (err) {\n      return cb(err.code === 'ENOENT' && opts.force ? null : err)\n    }\n\n    if (st.isDirectory()) {\n      if (opts.recursive) return rmRecursive(filepath, opts, cb)\n\n      const err = new Error('is a directory')\n      err.code = 'EISDIR'\n      return cb(err)\n    }\n\n    unlink(filepath, cb)\n  })\n}\n\nfunction rmRecursiveSync(filepath, opts) {\n  try {\n    rmdirSync(filepath)\n  } catch (err) {\n    if (err.code !== 'ENOTEMPTY') throw err\n\n    const files = readdirSync(filepath)\n\n    for (const file of files) {\n      rmSync(filepath + path.sep + file, opts)\n    }\n\n    rmdirSync(filepath)\n  }\n}\n\nfunction rmSync(filepath, opts) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (!opts) opts = {}\n\n  try {\n    const st = lstatSync(filepath)\n\n    if (st.isDirectory()) {\n      if (opts.recursive) return rmRecursiveSync(filepath, opts)\n\n      const err = new Error('is a directory')\n      err.code = 'EISDIR'\n      throw err\n    }\n\n    unlinkSync(filepath)\n  } catch (err) {\n    if (err.code !== 'ENOENT' || !opts.force) throw err\n  }\n}\n\nfunction unlink(filepath, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  const req = getReq()\n  req.callback = cb\n  binding.unlink(req.handle, filepath)\n}\n\nfunction unlinkSync(filepath) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  binding.unlinkSync(filepath)\n}\n\nfunction rename(src, dst, cb) {\n  if (typeof src !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' + typeof src + ' (' + src + ')'\n    )\n  }\n\n  if (typeof dst !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' + typeof dst + ' (' + dst + ')'\n    )\n  }\n\n  if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  const req = getReq()\n  req.callback = cb\n  binding.rename(req.handle, src, dst)\n}\n\nfunction renameSync(src, dst) {\n  if (typeof src !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' + typeof src + ' (' + src + ')'\n    )\n  }\n\n  if (typeof dst !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' + typeof dst + ' (' + dst + ')'\n    )\n  }\n\n  binding.renameSync(src, dst)\n}\n\nfunction copyFile(src, dst, mode, cb) {\n  if (typeof mode === 'function') {\n    cb = mode\n    mode = 0\n  }\n\n  if (typeof src !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' + typeof src + ' (' + src + ')'\n    )\n  }\n\n  if (typeof dst !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' + typeof dst + ' (' + dst + ')'\n    )\n  }\n\n  const req = getReq()\n  req.callback = cb\n  binding.copyfile(req.handle, src, dst, mode)\n}\n\nfunction copyFileSync(src, dst, mode = 0) {\n  if (typeof src !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' + typeof src + ' (' + src + ')'\n    )\n  }\n\n  if (typeof dst !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' + typeof dst + ' (' + dst + ')'\n    )\n  }\n\n  binding.copyfileSync(src, dst, mode)\n}\n\nfunction realpath(filepath, opts, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  const { encoding = 'utf8' } = opts\n\n  const data = Buffer.allocUnsafe(binding.sizeofFSPath)\n\n  const req = getReq()\n\n  req.callback = function (err, _) {\n    if (err) return cb(err, null)\n    let path = data.subarray(0, data.indexOf(0))\n    if (encoding !== 'buffer') path = path.toString(encoding)\n    cb(null, path)\n  }\n\n  binding.realpath(req.handle, filepath, data)\n}\n\nfunction realpathSync(filepath, opts) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  const { encoding = 'utf8' } = opts\n\n  const data = Buffer.allocUnsafe(binding.sizeofFSPath)\n\n  binding.realpathSync(filepath, data)\n\n  filepath = data.subarray(0, data.indexOf(0))\n  if (encoding !== 'buffer') filepath = filepath.toString(encoding)\n  return filepath\n}\n\nfunction readlink(filepath, opts, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  const { encoding = 'utf8' } = opts\n\n  const data = Buffer.allocUnsafe(binding.sizeofFSPath)\n\n  const req = getReq()\n\n  req.callback = function (err, _) {\n    if (err) return cb(err, null)\n    let path = data.subarray(0, data.indexOf(0))\n    if (encoding !== 'buffer') path = path.toString(encoding)\n    cb(null, path)\n  }\n\n  binding.readlink(req.handle, filepath, data)\n}\n\nfunction readlinkSync(filepath, opts) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  const { encoding = 'utf8' } = opts\n\n  const data = Buffer.allocUnsafe(binding.sizeofFSPath)\n\n  binding.readlinkSync(filepath, data)\n\n  filepath = data.subarray(0, data.indexOf(0))\n  if (encoding !== 'buffer') filepath = filepath.toString(encoding)\n  return filepath\n}\n\nfunction normalizeSymlinkTarget(target, type, filepath) {\n  if (isWindows) {\n    if (type === 'junction') target = path.resolve(filepath, '..', target)\n\n    if (path.isAbsolute(target)) return path.toNamespacedPath(target)\n\n    return target.replace(/\\//g, path.sep)\n  }\n\n  return target\n}\n\nfunction symlink(target, filepath, type, cb) {\n  if (typeof target !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Target must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof type === 'function') {\n    cb = type\n    type = null\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  if (typeof type === 'string') {\n    switch (type) {\n      case 'file':\n        type = 0\n        break\n      case 'dir':\n        type = constants.UV_FS_SYMLINK_DIR\n        break\n      case 'junction':\n        type = constants.UV_FS_SYMLINK_JUNCTION\n        break\n      default:\n        throw typeError(\n          'ERR_FS_INVALID_SYMLINK_TYPE',\n          'Symlink type must be one of \"dir\", \"file\", or \"junction\". Received \"' +\n            type +\n            '\"'\n        )\n    }\n  } else if (typeof type !== 'number') {\n    if (isWindows) {\n      target = path.resolve(filepath, '..', target)\n\n      stat(target, (err, st) => {\n        type =\n          err === null && st.isDirectory()\n            ? constants.UV_FS_SYMLINK_DIR\n            : constants.UV_FS_SYMLINK_JUNCTION\n\n        symlink(target, filepath, type, cb)\n      })\n\n      return\n    }\n\n    type = 0\n  }\n\n  const req = getReq()\n  req.callback = cb\n  binding.symlink(\n    req.handle,\n    normalizeSymlinkTarget(target),\n    path.toNamespacedPath(filepath),\n    type\n  )\n}\n\nfunction symlinkSync(target, filepath, type) {\n  if (typeof target !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Target must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof type === 'string') {\n    switch (type) {\n      case 'file':\n        type = 0\n        break\n      case 'dir':\n        type = constants.UV_FS_SYMLINK_DIR\n        break\n      case 'junction':\n        type = constants.UV_FS_SYMLINK_JUNCTION\n        break\n      default:\n        throw typeError(\n          'ERR_FS_INVALID_SYMLINK_TYPE',\n          'Symlink type must be one of \"dir\", \"file\", or \"junction\". Received \"' +\n            type +\n            '\"'\n        )\n    }\n  } else if (typeof type !== 'number') {\n    if (isWindows) {\n      target = path.resolve(filepath, '..', target)\n\n      type = statSync(target).isDirectory()\n        ? constants.UV_FS_SYMLINK_DIR\n        : constants.UV_FS_SYMLINK_JUNCTION\n    } else {\n      type = 0\n    }\n  }\n\n  binding.symlinkSync(\n    normalizeSymlinkTarget(target),\n    path.toNamespacedPath(filepath),\n    type\n  )\n}\n\nfunction opendir(filepath, opts, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  const data = Buffer.allocUnsafe(binding.sizeofFSDir)\n\n  const req = getReq()\n\n  req.callback = function (err, _) {\n    if (err) return cb(err, null)\n    cb(null, new Dir(filepath, data, opts))\n  }\n\n  binding.opendir(req.handle, filepath, data)\n}\n\nfunction opendirSync(filepath, opts) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  const data = Buffer.allocUnsafe(binding.sizeofFSDir)\n  binding.opendirSync(filepath, data)\n  return new Dir(filepath, data, opts)\n}\n\nfunction readdir(filepath, opts, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  const { withFileTypes = false } = opts\n\n  opendir(filepath, opts, async (err, dir) => {\n    if (err) return cb(err, null)\n    const result = []\n    for await (const entry of dir) {\n      result.push(withFileTypes ? entry : entry.name)\n    }\n    cb(null, result)\n  })\n}\n\nfunction readdirSync(filepath, opts) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  const { withFileTypes = false } = opts\n\n  const dir = opendirSync(filepath, opts)\n  const result = []\n\n  while (true) {\n    const entry = dir.readSync()\n    if (entry === null) break\n    result.push(withFileTypes ? entry : entry.name)\n  }\n\n  return result\n}\n\nfunction readFile(filepath, opts, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  const { encoding = 'buffer' } = opts\n\n  open(filepath, opts.flag || 'r', function (err, fd) {\n    if (err) return cb(err)\n\n    fstat(fd, function (err, st) {\n      if (err) return closeAndError(err)\n\n      let buffer = Buffer.allocUnsafe(st.size)\n      let len = 0\n\n      read(fd, buffer, loop)\n\n      function loop(err, r) {\n        if (err) return closeAndError(err)\n        len += r\n        if (r === 0 || len === buffer.byteLength) return done()\n        read(fd, buffer.subarray(len), loop)\n      }\n\n      function done() {\n        if (len !== buffer.byteLength) buffer = buffer.subarray(0, len)\n        close(fd, function (err) {\n          if (err) return cb(err)\n          if (encoding !== 'buffer') buffer = buffer.toString(encoding)\n          cb(null, buffer)\n        })\n      }\n    })\n\n    function closeAndError(err) {\n      close(fd, function () {\n        cb(err)\n      })\n    }\n  })\n}\n\nfunction readFileSync(filepath, opts) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  const { encoding = 'buffer' } = opts\n\n  const fd = openSync(filepath, opts.flag || 'r')\n\n  try {\n    const st = fstatSync(fd)\n\n    let buffer = Buffer.allocUnsafe(st.size)\n    let len = 0\n\n    while (true) {\n      const r = readSync(fd, len ? buffer.subarray(len) : buffer)\n      len += r\n      if (r === 0 || len === buffer.byteLength) break\n    }\n\n    if (len !== buffer.byteLength) buffer = buffer.subarray(0, len)\n    if (encoding !== 'buffer') buffer = buffer.toString(encoding)\n    return buffer\n  } finally {\n    try {\n      closeSync(fd)\n    } catch {}\n  }\n}\n\nfunction writeFile(filepath, data, opts, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (\n    typeof data !== 'string' &&\n    !Buffer.isBuffer(data) &&\n    !ArrayBuffer.isView(data)\n  ) {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Data must be a string or buffer. Received type ' + typeof data\n    )\n  }\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  if (typeof data === 'string') data = Buffer.from(data, opts.encoding)\n\n  open(filepath, opts.flag || 'w', opts.mode || 0o666, function (err, fd) {\n    if (err) return cb(err)\n\n    write(fd, data, loop)\n\n    function loop(err, w) {\n      if (err) return closeAndError(err)\n      if (w === data.byteLength) return done()\n      write(fd, data.subarray(w), loop)\n    }\n\n    function done() {\n      close(fd, function (err) {\n        if (err) return cb(err)\n        return cb(null)\n      })\n    }\n\n    function closeAndError(err) {\n      close(fd, function () {\n        cb(err)\n      })\n    }\n  })\n}\n\nfunction writeFileSync(filepath, data, opts) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (\n    typeof data !== 'string' &&\n    !Buffer.isBuffer(data) &&\n    !ArrayBuffer.isView(data)\n  ) {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Data must be a string or buffer. Received type ' + typeof data\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  if (typeof data === 'string') data = Buffer.from(data, opts.encoding)\n\n  const fd = openSync(filepath, opts.flag || 'w', opts.mode)\n\n  try {\n    let len = 0\n\n    while (true) {\n      len += writeSync(fd, len ? data.subarray(len) : data)\n      if (len === data.byteLength) break\n    }\n  } finally {\n    try {\n      closeSync(fd)\n    } catch {}\n  }\n}\n\nfunction appendFile(filepath, data, opts, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (\n    typeof data !== 'string' &&\n    !Buffer.isBuffer(data) &&\n    !ArrayBuffer.isView(data)\n  ) {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Data must be a string or buffer. Received type ' + typeof data\n    )\n  }\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  } else if (typeof cb !== 'function') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Callback must be a function. Received type ' +\n        typeof cb +\n        ' (' +\n        cb +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  opts = { ...opts }\n\n  if (!opts.flags) opts.flag = 'a'\n\n  return writeFile(filepath, data, opts, cb)\n}\n\nfunction appendFileSync(filepath, data, opts) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (\n    typeof data !== 'string' &&\n    !Buffer.isBuffer(data) &&\n    !ArrayBuffer.isView(data)\n  ) {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Data must be a string or buffer. Received type ' + typeof data\n    )\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  opts = { ...opts }\n\n  if (!opts.flags) opts.flag = 'a'\n\n  return writeFileSync(filepath, data, opts)\n}\n\nfunction watch(filepath, opts, cb) {\n  if (typeof filepath !== 'string') {\n    throw typeError(\n      'ERR_INVALID_ARG_TYPE',\n      'Path must be a string. Received type ' +\n        typeof filepath +\n        ' (' +\n        filepath +\n        ')'\n    )\n  }\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  if (typeof opts === 'string') opts = { encoding: opts }\n  else if (!opts) opts = {}\n\n  const watcher = new Watcher(filepath, opts)\n  if (cb) watcher.on('change', cb)\n  return watcher\n}\n\nclass Stats {\n  constructor(\n    dev,\n    mode,\n    nlink,\n    uid,\n    gid,\n    rdev,\n    blksize,\n    ino,\n    size,\n    blocks,\n    atimeMs,\n    mtimeMs,\n    ctimeMs,\n    birthtimeMs\n  ) {\n    this.dev = dev\n    this.mode = mode\n    this.nlink = nlink\n    this.uid = uid\n    this.gid = gid\n    this.rdev = rdev\n    this.blksize = blksize\n    this.ino = ino\n    this.size = size\n    this.blocks = blocks\n    this.atimeMs = atimeMs\n    this.mtimeMs = mtimeMs\n    this.ctimeMs = ctimeMs\n    this.birthtimeMs = birthtimeMs\n    this.atime = new Date(atimeMs)\n    this.mtime = new Date(mtimeMs)\n    this.ctime = new Date(ctimeMs)\n    this.birthtime = new Date(birthtimeMs)\n  }\n\n  isDirectory() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFDIR\n  }\n\n  isFile() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFREG\n  }\n\n  isBlockDevice() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFBLK\n  }\n\n  isCharacterDevice() {\n    return (this.mode & constants.S_IFCHR) === constants.S_IFCHR\n  }\n\n  isFIFO() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFIFO\n  }\n\n  isSymbolicLink() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFLNK\n  }\n\n  isSocket() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFSOCK\n  }\n}\n\nclass Dir {\n  constructor(path, handle, opts = {}) {\n    const { encoding = 'utf8', bufferSize = 32 } = opts\n\n    this._handle = handle\n    this._dirents = Buffer.allocUnsafe(binding.sizeofFSDirent * bufferSize)\n    this._encoding = encoding\n    this._buffer = []\n    this._ended = false\n\n    this.path = path\n  }\n\n  read(cb) {\n    if (!cb) return promisify(this.read.bind(this))\n\n    if (this._buffer.length)\n      return queueMicrotask(() => cb(null, this._buffer.shift()))\n    if (this._ended) return queueMicrotask(() => cb(null, null))\n\n    const data = []\n    const req = getReq()\n\n    req.callback = (err, _) => {\n      if (err) return cb(err, null)\n      if (data.length === 0) this._ended = true\n      else {\n        for (const entry of data) {\n          let name = Buffer.from(entry.name)\n          if (this._encoding !== 'buffer') name = name.toString(this._encoding)\n          this._buffer.push(new Dirent(this.path, name, entry.type))\n        }\n      }\n\n      if (this._ended) return cb(null, null)\n      cb(null, this._buffer.shift())\n    }\n\n    binding.readdir(req.handle, this._handle, this._dirents, data)\n  }\n\n  readSync() {\n    if (this._buffer.length) return this._buffer.shift()\n    if (this._ended) return null\n\n    const data = []\n\n    binding.readdirSync(this._handle, this._dirents, data)\n\n    if (data.length === 0) this._ended = true\n    else {\n      for (const entry of data) {\n        let name = Buffer.from(entry.name)\n        if (this._encoding !== 'buffer') name = name.toString(this._encoding)\n        this._buffer.push(new Dirent(this.path, name, entry.type))\n      }\n    }\n\n    if (this._ended) return null\n    return this._buffer.shift()\n  }\n\n  close(cb) {\n    if (!cb) return promisify(this.close.bind(this))\n\n    const req = getReq()\n\n    req.callback = (err, _) => {\n      this._handle = null\n      cb(err)\n    }\n\n    binding.closedir(req.handle, this._handle)\n  }\n\n  closeSync() {\n    binding.closedirSync(this._handle)\n    this._handle = null\n  }\n\n  [Symbol.iterator]() {\n    return {\n      next: () => {\n        if (this._buffer.length) {\n          return { done: false, value: this._buffer.shift() }\n        }\n\n        if (this._ended) {\n          return { done: true }\n        }\n\n        const entry = this.readSync()\n\n        if (entry) {\n          return { done: false, value: entry }\n        }\n\n        this.closeSync()\n\n        return { done: true }\n      }\n    }\n  }\n\n  [Symbol.asyncIterator]() {\n    return {\n      next: () =>\n        new Promise((resolve, reject) => {\n          if (this._buffer.length) {\n            return resolve({ done: false, value: this._buffer.shift() })\n          }\n\n          if (this._ended) {\n            return resolve({ done: true })\n          }\n\n          this.read((err, entry) => {\n            if (err) return reject(err)\n\n            if (entry) {\n              return resolve({ done: false, value: entry })\n            }\n\n            this.close((err) => (err ? reject(err) : resolve({ done: true })))\n          })\n        })\n    }\n  }\n}\n\nclass Dirent {\n  constructor(path, name, type) {\n    this.type = type\n    this.path = path\n    this.name = name\n  }\n\n  isFile() {\n    return this.type === constants.UV_DIRENT_FILE\n  }\n\n  isDirectory() {\n    return this.type === constants.UV_DIRENT_DIR\n  }\n\n  isSymbolicLink() {\n    return this.type === constants.UV_DIRENT_LINK\n  }\n\n  isFIFO() {\n    return this.type === constants.UV_DIRENT_FIFO\n  }\n\n  isSocket() {\n    return this.type === constants.UV_DIRENT_SOCKET\n  }\n\n  isCharacterDevice() {\n    return this.type === constants.UV_DIRENT_CHAR\n  }\n\n  isBlockDevice() {\n    return this.type === constants.UV_DIRENT_BLOCK\n  }\n}\n\nclass FileWriteStream extends Writable {\n  constructor(path, opts = {}) {\n    super({ map })\n\n    this.path = path\n    this.fd = 0\n    this.flags = opts.flags || 'w'\n    this.mode = opts.mode || 0o666\n  }\n\n  _open(cb) {\n    open(this.path, this.flags, this.mode, (err, fd) => {\n      if (err) return cb(err)\n      this.fd = fd\n      cb(null)\n    })\n  }\n\n  _writev(batch, cb) {\n    writev(\n      this.fd,\n      batch.map(({ chunk }) => chunk),\n      cb\n    )\n  }\n\n  _destroy(err, cb) {\n    if (!this.fd) return cb(err)\n    close(this.fd, () => cb(err))\n  }\n}\n\nclass FileReadStream extends Readable {\n  constructor(path, opts = {}) {\n    super()\n\n    this.path = path\n    this.fd = 0\n\n    this._offset = opts.start || 0\n    this._missing = 0\n\n    if (opts.length) {\n      this._missing = opts.length\n    } else if (typeof opts.end === 'number') {\n      this._missing = opts.end - this._offset + 1\n    } else {\n      this._missing = -1\n    }\n  }\n\n  _open(cb) {\n    open(this.path, constants.O_RDONLY, (err, fd) => {\n      if (err) return cb(err)\n\n      const onerror = (err) => close(fd, () => cb(err))\n\n      fstat(fd, (err, st) => {\n        if (err) return onerror(err)\n        if (!st.isFile())\n          return onerror(new Error(this.path + ' is not a file'))\n\n        this.fd = fd\n        if (this._missing === -1) this._missing = st.size\n\n        if (st.size < this._offset) {\n          this._offset = st.size\n          this._missing = 0\n          return cb(null)\n        }\n        if (st.size < this._offset + this._missing) {\n          this._missing = st.size - this._offset\n          return cb(null)\n        }\n\n        cb(null)\n      })\n    })\n  }\n\n  _read(size) {\n    if (!this._missing) {\n      this.push(null)\n      return\n    }\n\n    const data = Buffer.allocUnsafe(Math.min(this._missing, size))\n\n    read(this.fd, data, 0, data.byteLength, this._offset, (err, read) => {\n      if (err) return this.destroy(err)\n\n      if (!read) {\n        this.push(null)\n        return\n      }\n\n      if (this._missing < read) read = this._missing\n      this.push(data.subarray(0, read))\n      this._missing -= read\n      this._offset += read\n      if (!this._missing) this.push(null)\n    })\n  }\n\n  _destroy(err, cb) {\n    if (!this.fd) return cb(err)\n    close(this.fd, () => cb(err))\n  }\n}\n\nclass Watcher extends EventEmitter {\n  constructor(path, opts) {\n    const { persistent = true, recursive = false, encoding = 'utf8' } = opts\n\n    super()\n\n    this._closed = false\n    this._encoding = encoding\n    this._handle = binding.watcherInit(\n      path,\n      recursive,\n      this,\n      this._onevent,\n      this._onclose\n    )\n\n    if (!persistent) this.unref()\n  }\n\n  _onevent(err, events, filename) {\n    if (err) {\n      this.close()\n      this.emit('error', err)\n    } else {\n      const path =\n        this._encoding === 'buffer'\n          ? Buffer.from(filename)\n          : Buffer.from(filename).toString(this._encoding)\n\n      if (events & binding.UV_RENAME) {\n        this.emit('change', 'rename', path)\n      }\n\n      if (events & binding.UV_CHANGE) {\n        this.emit('change', 'change', path)\n      }\n    }\n  }\n\n  _onclose() {\n    this._handle = null\n\n    this.emit('close')\n  }\n\n  close() {\n    if (this._closed) return\n    this._closed = true\n\n    binding.watcherClose(this._handle)\n  }\n\n  ref() {\n    if (this._handle) binding.watcherRef(this._handle)\n    return this\n  }\n\n  unref() {\n    if (this._handle) binding.watcherUnref(this._handle)\n    return this\n  }\n\n  [Symbol.asyncIterator]() {\n    const buffer = []\n    let done = false\n    let error = null\n    let next = null\n\n    this.on('change', (eventType, filename) => {\n      if (next) {\n        next.resolve({ done: false, value: { eventType, filename } })\n        next = null\n      } else {\n        buffer.push({ eventType, filename })\n      }\n    })\n      .on('error', (err) => {\n        done = true\n        error = err\n\n        if (next) {\n          next.reject(error)\n          next = null\n        }\n      })\n      .on('close', () => {\n        done = true\n\n        if (next) {\n          next.resolve({ done })\n          next = null\n        }\n      })\n\n    return {\n      next: () =>\n        new Promise((resolve, reject) => {\n          if (error) return reject(error)\n\n          if (buffer.length)\n            return resolve({ done: false, value: buffer.shift() })\n\n          if (done) return resolve({ done })\n\n          next = { resolve, reject }\n        })\n    }\n  }\n}\n\nexports.promises = {}\n\nfunction typeError(code, message) {\n  const error = new TypeError(message)\n  error.code = code\n  return error\n}\n\nfunction noop() {}\n\nexports.access = access\nexports.appendFile = appendFile\nexports.chmod = chmod\nexports.close = close\nexports.copyFile = copyFile\nexports.exists = exists\nexports.fchmod = fchmod\nexports.fstat = fstat\nexports.ftruncate = ftruncate\nexports.lstat = lstat\nexports.mkdir = mkdir\nexports.open = open\nexports.opendir = opendir\nexports.read = read\nexports.readFile = readFile\nexports.readdir = readdir\nexports.readlink = readlink\nexports.readv = readv\nexports.realpath = realpath\nexports.rename = rename\nexports.rm = rm\nexports.rmdir = rmdir\nexports.stat = stat\nexports.symlink = symlink\nexports.unlink = unlink\nexports.watch = watch\nexports.write = write\nexports.writeFile = writeFile\nexports.writev = writev\n\nexports.accessSync = accessSync\nexports.appendFileSync = appendFileSync\nexports.chmodSync = chmodSync\nexports.closeSync = closeSync\nexports.copyFileSync = copyFileSync\nexports.existsSync = existsSync\nexports.fchmodSync = fchmodSync\nexports.fstatSync = fstatSync\nexports.lstatSync = lstatSync\nexports.mkdirSync = mkdirSync\nexports.openSync = openSync\nexports.opendirSync = opendirSync\nexports.readFileSync = readFileSync\nexports.readSync = readSync\nexports.readdirSync = readdirSync\nexports.readlinkSync = readlinkSync\nexports.realpathSync = realpathSync\nexports.renameSync = renameSync\nexports.rmSync = rmSync\nexports.rmdirSync = rmdirSync\nexports.statSync = statSync\nexports.symlinkSync = symlinkSync\nexports.unlinkSync = unlinkSync\nexports.writeFileSync = writeFileSync\nexports.writeSync = writeSync\n\nexports.promises.access = promisify(access)\nexports.promises.appendFile = promisify(appendFile)\nexports.promises.chmod = promisify(chmod)\nexports.promises.copyFile = promisify(copyFile)\nexports.promises.lstat = promisify(lstat)\nexports.promises.mkdir = promisify(mkdir)\nexports.promises.opendir = promisify(opendir)\nexports.promises.readFile = promisify(readFile)\nexports.promises.readdir = promisify(readdir)\nexports.promises.readlink = promisify(readlink)\nexports.promises.realpath = promisify(realpath)\nexports.promises.rename = promisify(rename)\nexports.promises.rm = promisify(rm)\nexports.promises.rmdir = promisify(rmdir)\nexports.promises.stat = promisify(stat)\nexports.promises.symlink = promisify(symlink)\nexports.promises.unlink = promisify(unlink)\nexports.promises.writeFile = promisify(writeFile)\n\nexports.promises.watch = watch // Already async iterable\n\nexports.Stats = Stats\nexports.Dir = Dir\nexports.Dirent = Dirent\nexports.Watcher = Watcher\n\nexports.ReadStream = FileReadStream\nexports.createReadStream = function createReadStream(path, opts) {\n  return new FileReadStream(path, opts)\n}\n\nexports.WriteStream = FileWriteStream\nexports.createWriteStream = function createWriteStream(path, opts) {\n  return new FileWriteStream(path, opts)\n}\n\nfunction promisify(fn) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      fn(...args, function (err, res) {\n        if (err) return reject(err)\n        resolve(res)\n      })\n    })\n  }\n}\n\nfunction map(data) {\n  return typeof data === 'string' ? Buffer.from(data) : data\n}\n{\n  \"name\": \"bare-fs\",\n  \"version\": \"4.0.1\",\n  \"description\": \"Native file system for Javascript\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"promises.js\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-fs.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-fs/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-fs#readme\",\n  \"engines\": {\n    \"bare\": \">=1.7.0\"\n  },\n  \"dependencies\": {\n    \"bare-events\": \"^2.0.0\",\n    \"bare-path\": \"^3.0.0\",\n    \"bare-stream\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.1\",\n    \"cmake-bare\": \"^1.1.7\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nexports.IncomingMessage = require('./lib/incoming-message')\nexports.OutgoingMessage = require('./lib/outgoing-message')\n\nconst Agent = exports.Agent = require('./lib/agent')\nexports.globalAgent = Agent.global\n\nconst Server = exports.Server = require('./lib/server')\nexports.ServerResponse = require('./lib/server-response')\nexports.ServerConnection = require('./lib/server-connection')\n\nconst Request = exports.ClientRequest = require('./lib/client-request')\nexports.ClientConnection = require('./lib/client-connection')\n\nexports.constants = require('./lib/constants')\n\nexports.STATUS_CODES = exports.constants.status // For Node.js compatibility\n\nexports.createServer = function createServer (opts, onrequest) {\n  return new Server(opts, onrequest)\n}\n\nexports.request = function request (url, opts, onresponse) {\n  if (typeof opts === 'function') {\n    onresponse = opts\n    opts = {}\n  }\n\n  if (typeof url === 'string') url = new URL(url)\n\n  if (isURL(url)) {\n    opts = opts ? { ...opts } : {}\n\n    opts.host = url.hostname\n    opts.path = url.pathname + url.search\n    opts.port = url.port ? parseInt(url.port, 10) : defaultPort(url)\n  } else {\n    opts = url ? { ...url } : {}\n\n    // For Node.js compatibility\n    opts.host = opts.hostname || opts.host\n    opts.port = typeof opts.port === 'string' ? parseInt(opts.port, 10) : opts.port\n  }\n\n  return new Request(opts, onresponse)\n}\n\n// https://url.spec.whatwg.org/#default-port\nfunction defaultPort (url) {\n  switch (url.protocol) {\n    case 'ftp:': return 21\n    case 'http:':\n    case 'ws:': return 80\n    case 'https:':\n    case 'wss:': return 443\n  }\n\n  return null\n}\n\n// https://url.spec.whatwg.org/#api\nfunction isURL (url) {\n  return (\n    url !== null &&\n    typeof url === 'object' &&\n    typeof url.protocol === 'string' &&\n    typeof url.hostname === 'string' &&\n    typeof url.pathname === 'string' &&\n    typeof url.search === 'string'\n  )\n}\nconst tcp = require('bare-tcp')\nconst HTTPClientConnection = require('./client-connection')\n\nmodule.exports = class HTTPAgent {\n  constructor (opts = {}) {\n    const {\n      keepAlive = false,\n      keepAliveMsecs = 1000\n    } = opts\n\n    this._sockets = new Map()\n    this._freeSockets = new Map()\n\n    this._keepAlive = typeof keepAlive === 'number' ? keepAlive : keepAlive ? keepAliveMsecs : -1\n\n    this._opts = { ...opts }\n  }\n\n  createConnection (opts) {\n    return tcp.createConnection(opts)\n  }\n\n  reuseSocket (socket, req) {\n    socket.ref()\n  }\n\n  keepSocketAlive (socket) {\n    if (this._keepAlive === -1) return false\n\n    socket.setKeepAlive(true, this._keepAlive)\n    socket.unref()\n\n    return true\n  }\n\n  getName (opts) {\n    return `${opts.host}:${opts.port}`\n  }\n\n  addRequest (req, opts) {\n    opts = { ...opts, ...this._opts }\n\n    const name = this.getName(opts)\n\n    let socket\n\n    if (this._freeSockets.has(name)) {\n      const sockets = this._freeSockets.get(name)\n      socket = sockets.values().next().value\n      sockets.delete(socket)\n      if (sockets.size === 0) this._freeSockets.delete(name)\n\n      this.reuseSocket(socket, req)\n    } else {\n      socket = this.createConnection(opts)\n\n      socket\n        .on('free', () => this._onfree(socket, name))\n        .on('close', () => this._onremove(socket, name))\n        .on('timeout', () => this._ontimeout(socket, name))\n    }\n\n    let sockets = this._sockets.get(name)\n    if (sockets === undefined) {\n      sockets = new Set()\n      this._sockets.set(name, sockets)\n    }\n\n    sockets.add(socket)\n\n    req.socket = socket\n\n    const connection = HTTPClientConnection.from(socket, opts)\n\n    connection.req = req\n  }\n\n  destroy () {\n    for (const set of [this._sockets, this._freeSockets]) {\n      for (const [, sockets] of set) {\n        for (const socket of sockets) socket.destroy()\n      }\n    }\n  }\n\n  _onfree (socket, name) {\n    if (this.keepSocketAlive(socket)) {\n      this._onremove(socket, name, false)\n\n      let sockets = this._freeSockets.get(name)\n      if (sockets === undefined) {\n        sockets = new Set()\n        this._freeSockets.set(name, sockets)\n      }\n\n      sockets.add(socket)\n    } else {\n      socket.end()\n    }\n  }\n\n  _onremove (socket, name, all = true) {\n    for (const set of all ? [this._sockets, this._freeSockets] : [this._sockets]) {\n      const sockets = set.get(name)\n      if (sockets === undefined) continue\n\n      sockets.delete(socket)\n      if (sockets.size === 0) set.delete(name)\n    }\n  }\n\n  _ontimeout (socket, name) {\n    const sockets = this._freeSockets.get(name)\n    if (!sockets) return\n\n    if (sockets.delete(socket)) socket.destroy()\n    if (sockets.size === 0) this._freeSockets.delete(name)\n  }\n\n  static global = new this({ keepAlive: 1000, timeout: 5000 })\n}\nconst HTTPIncomingMessage = require('./incoming-message')\nconst constants = require('./constants')\nconst errors = require('./errors')\n\nconst empty = Buffer.alloc(0)\n\nmodule.exports = class HTTPClientConnection {\n  static _connections = new WeakMap()\n\n  static for (socket) {\n    return this._connections.get(socket) || null\n  }\n\n  static from (socket, opts) {\n    return this.for(socket) || new this(socket, opts)\n  }\n\n  constructor (socket, opts = {}) {\n    const {\n      IncomingMessage = HTTPIncomingMessage\n    } = opts\n\n    this.socket = socket\n\n    this.req = null\n    this.res = null\n\n    this._IncomingMessage = IncomingMessage\n\n    this._state = constants.state.BEFORE_HEAD\n    this._length = -1\n    this._read = 0\n    this._buffer = null\n    this._idle = true\n\n    this._onerror = this._onerror.bind(this)\n    this._onclose = this._onclose.bind(this)\n    this._onend = this._onend.bind(this)\n    this._ondata = this._ondata.bind(this)\n    this._ondrain = this._ondrain.bind(this)\n    this._ontimeout = this._ontimeout.bind(this)\n\n    socket\n      .on('error', this._onerror)\n      .on('close', this._onclose)\n      .on('end', this._onend)\n      .on('data', this._ondata)\n      .on('drain', this._ondrain)\n      .on('timeout', this._ontimeout)\n\n    HTTPClientConnection._connections.set(socket, this)\n  }\n\n  get idle () {\n    return this._idle\n  }\n\n  _onerror (err) {\n    if (this.req) this.req.destroy(err)\n  }\n\n  _onclose () {\n    if (this.req) this.req._continueFinal()\n  }\n\n  _onend () {\n    if (this.req) this.req.destroy(errors.CONNECTION_LOST())\n  }\n\n  _ondata (data) {\n    this._idle = false\n\n    if (this._state === constants.state.IN_BODY) return this._onbody(data)\n\n    if (this._buffer !== null) {\n      this._buffer = Buffer.concat([this._buffer, data])\n    } else {\n      this._buffer = data\n    }\n\n    let hits = 0\n\n    for (let i = 0; i < this._buffer.byteLength; i++) {\n      const b = this._buffer[i]\n\n      if (hits === 0 && b === 13) {\n        hits++\n      } else if (hits === 1 && b === 10) {\n        hits++\n\n        if (this._state === constants.state.BEFORE_CHUNK) {\n          const head = this._buffer.subarray(0, i - 1)\n          this._buffer = i + 1 === this._buffer.byteLength ? null : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onchunklength(head)\n\n          if (this._buffer === null) break\n        } else if (this._state === constants.state.IN_CHUNK) {\n          const chunk = this._buffer.subarray(0, i - 1)\n\n          if (chunk.byteLength !== this._length) {\n            hits = 0\n            continue\n          }\n\n          this._buffer = i + 1 === this._buffer.byteLength ? null : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onchunk(chunk)\n\n          if (this._buffer === null) break\n        }\n      } else if (hits === 2 && b === 13) {\n        hits++\n      } else if (hits === 3 && b === 10) {\n        if (this._state === constants.state.BEFORE_HEAD) {\n          const head = this._buffer.subarray(0, i - 3)\n          this._buffer = i + 1 === this._buffer.byteLength ? null : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onhead(head)\n\n          if (this._buffer === null) break\n        }\n      } else {\n        hits = 0\n      }\n    }\n  }\n\n  _onhead (data) {\n    this._state = constants.state.IN_HEAD\n\n    const r = data.toString().split('\\r\\n')\n    if (r.length === 0) return this.socket.destroy()\n\n    const [, statusCode, ...statusMessage] = r[0].split(' ')\n    if (!statusCode || !statusMessage) return this.socket.destroy()\n\n    const headers = {}\n\n    for (let i = 1; i < r.length; i++) {\n      const [name, value] = r[i].split(': ')\n      headers[name.toLowerCase()] = value\n    }\n\n    this.req.on('close', () => { this.req = null })\n\n    this.res = new this._IncomingMessage(this.socket, headers, { statusCode: parseInt(statusCode, 10), statusMessage: statusMessage.join(' ') })\n\n    this.res.on('close', () => { this.res = null; this._onreset() })\n\n    if (headers.connection && headers.connection.toLowerCase() === 'upgrade') {\n      const head = this._buffer\n      this._buffer = null\n      return this._onupgrade(head)\n    }\n\n    this.req.emit('response', this.res)\n\n    if (headers['transfer-encoding'] === 'chunked') {\n      this._state = constants.state.BEFORE_CHUNK\n    } else {\n      this._length = parseInt(headers['content-length'], 10) || 0\n\n      if (this._length === 0) return this._onfinished()\n\n      this._state = constants.state.IN_BODY\n\n      if (this._buffer) {\n        const body = this._buffer\n        this._buffer = null\n        this._onbody(body)\n      }\n    }\n  }\n\n  _onchunklength (data) {\n    this._length = parseInt(data.toString(), 16)\n\n    if (this._length === 0) this._onfinished()\n    else this._state = constants.state.IN_CHUNK\n  }\n\n  _onchunk (data) {\n    this._read += data.byteLength\n\n    this.res.push(data)\n\n    this._state = constants.state.BEFORE_CHUNK\n  }\n\n  _onbody (data) {\n    this._read += data.byteLength\n\n    this.res.push(data)\n\n    if (this._read === this._length) this._onfinished()\n  }\n\n  _onupgrade (head) {\n    this._ondetach()\n\n    const req = this.req\n\n    req.upgrade = true\n    req.destroy()\n\n    if (req.emit('upgrade', this.res, this.socket, head || empty)) return\n\n    this.socket.destroy()\n  }\n\n  _ontimeout () {\n    if (this.req) this.req.emit('timeout')\n  }\n\n  _onfinished () {\n    if (this.res) this.res.push(null)\n    if (this.req) this.req._continueFinal()\n  }\n\n  _onreset () {\n    this._state = constants.state.BEFORE_HEAD\n    this._length = -1\n    this._read = 0\n    this._buffer = null\n    this._idle = true\n\n    this.socket.emit('free')\n  }\n\n  _ondrain () {\n    if (this.req) this.req._continueWrite()\n  }\n\n  _ondetach () {\n    this.socket\n      .off('error', this._onerror)\n      .off('close', this._onclose)\n      .off('end', this._onend)\n      .off('data', this._ondata)\n      .off('drain', this._ondrain)\n      .off('timeout', this._ontimeout)\n\n    HTTPClientConnection._connections.delete(this.socket)\n  }\n}\nconst HTTPAgent = require('./agent')\nconst HTTPOutgoingMessage = require('./outgoing-message')\n\nmodule.exports = class HTTPClientRequest extends HTTPOutgoingMessage {\n  constructor (opts = {}, onresponse = null) {\n    if (typeof opts === 'function') {\n      onresponse = opts\n      opts = {}\n    }\n\n    opts = opts ? { ...opts } : {}\n\n    const agent = opts.agent === false ? new HTTPAgent() : opts.agent || HTTPAgent.global\n    const method = opts.method || 'GET'\n    const path = opts.path || '/'\n    const host = opts.host = opts.host || 'localhost'\n    const port = opts.port = opts.port || 80\n\n    super()\n\n    agent.addRequest(this, opts)\n\n    this.method = method\n    this.path = path\n    this.headers = { host: host + ':' + port, ...opts.headers }\n\n    this._chunked = method !== 'GET' && method !== 'HEAD'\n\n    this._pendingFinal = null\n\n    if (onresponse) this.once('response', onresponse)\n  }\n\n  _header () {\n    let h = `${this.method} ${this.path} HTTP/1.1\\r\\n`\n\n    let upgrade = false\n\n    for (const name of Object.keys(this.headers)) {\n      const n = name.toLowerCase()\n      const v = this.headers[name]\n\n      if (n === 'content-length') this._chunked = false\n      if (n === 'connection' && v && v.toLowerCase() === 'upgrade') upgrade = true\n\n      h += `${httpCase(n)}: ${v}\\r\\n`\n    }\n\n    if (upgrade) this._chunked = false\n\n    if (this._chunked) h += 'Transfer-Encoding: chunked\\r\\n'\n\n    h += '\\r\\n'\n\n    return h\n  }\n\n  _write (data, encoding, cb) {\n    if (this.headersSent === false) this.flushHeaders()\n\n    if (this._chunked) {\n      data = Buffer.concat([\n        Buffer.from('' + data.byteLength.toString(16) + '\\r\\n'),\n        data,\n        Buffer.from('\\r\\n')\n      ])\n    }\n\n    if (this.socket.write(data)) cb(null)\n    else this._pendingWrite = cb\n  }\n\n  _final (cb) {\n    if (this.headersSent === false) this.flushHeaders()\n\n    if (this._chunked) this.socket.write(Buffer.from('0\\r\\n\\r\\n'))\n\n    this._pendingFinal = cb\n  }\n\n  _predestroy () {\n    if (this.upgrade) return this._continueFinal()\n\n    this.socket.destroy()\n  }\n\n  _continueWrite () {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite\n    this._pendingWrite = null\n    cb(null)\n  }\n\n  _continueFinal () {\n    if (this._pendingFinal === null) return\n    const cb = this._pendingFinal\n    this._pendingFinal = null\n    cb(null)\n  }\n}\n\nfunction httpCase (n) {\n  let s = ''\n  for (const part of n.split('-')) {\n    s += (s ? '-' : '') + part.slice(0, 1).toUpperCase() + part.slice(1)\n  }\n  return s\n}\nmodule.exports = {\n  state: {\n    BEFORE_HEAD: 1,\n    IN_HEAD: 2,\n    IN_BODY: 3,\n    BEFORE_CHUNK: 4,\n    IN_CHUNK: 5\n  },\n  method: {\n    GET: 'GET',\n    HEAD: 'HEAD',\n    POST: 'POST',\n    PUT: 'PUT',\n    DELETE: 'DELETE',\n    CONNECT: 'CONNECT',\n    OPTIONS: 'OPTIONS',\n    TRACE: 'TRACE',\n    PATCH: 'PATCH'\n  },\n  status: {\n    100: 'Continue',\n    101: 'Switching Protocols',\n    102: 'Processing',\n    103: 'Early Hints',\n    200: 'OK',\n    201: 'Created',\n    202: 'Accepted',\n    203: 'Non-Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    207: 'Multi-Status',\n    208: 'Already Reported',\n    226: 'IM Used',\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    307: 'Temporary Redirect',\n    308: 'Permanent Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Payload Too Large',\n    414: 'URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Range Not Satisfiable',\n    417: 'Expectation Failed',\n    418: \"I'm a Teapot\",\n    421: 'Misdirected Request',\n    422: 'Unprocessable Entity',\n    423: 'Locked',\n    424: 'Failed Dependency',\n    425: 'Too Early',\n    426: 'Upgrade Required',\n    428: 'Precondition Required',\n    429: 'Too Many Requests',\n    431: 'Request Header Fields Too Large',\n    451: 'Unavailable For Legal Reasons',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'HTTP Version Not Supported',\n    506: 'Variant Also Negotiates',\n    507: 'Insufficient Storage',\n    508: 'Loop Detected',\n    509: 'Bandwidth Limit Exceeded',\n    510: 'Not Extended',\n    511: 'Network Authentication Required'\n  }\n}\nmodule.exports = class HTTPError extends Error {\n  constructor (msg, code, fn = HTTPError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name () {\n    return 'HTTPError'\n  }\n\n  static NOT_IMPLEMENTED (msg = 'Method not implemented') {\n    return new HTTPError(msg, 'NOT_IMPLEMENTED', HTTPError.NOT_IMPLEMENTED)\n  }\n\n  static CONNECTION_LOST (msg = 'Socket hung up') {\n    return new HTTPError(msg, 'CONNECTION_LOST', HTTPError.CONNECTION_LOST)\n  }\n}\nconst { Readable } = require('bare-stream')\n\nmodule.exports = class HTTPIncomingMessage extends Readable {\n  constructor (socket = null, headers = {}, opts = {}) {\n    super()\n\n    this.socket = socket\n    this.headers = headers\n    this.upgrade = false\n\n    // Server options\n    this.method = opts.method || ''\n    this.url = opts.url || ''\n\n    // Client options\n    this.statusCode = opts.statusCode || 0\n    this.statusMessage = opts.statusMessage || ''\n  }\n\n  get httpVersion () {\n    return '1.1'\n  }\n\n  getHeader (name) {\n    return this.headers[name.toLowerCase()]\n  }\n\n  getHeaders () {\n    return { ...this.headers }\n  }\n\n  hasHeader (name) {\n    return name.toLowerCase() in this.headers\n  }\n\n  setTimeout (ms, ontimeout) {\n    if (ontimeout) this.once('timeout', ontimeout)\n\n    this.socket.setTimeout(ms)\n\n    return this\n  }\n\n  _predestroy () {\n    if (this.upgrade === false && this.socket !== null) this.socket.destroy()\n  }\n}\nconst { Writable } = require('bare-stream')\nconst errors = require('./errors')\n\nmodule.exports = class HTTPOutgoingMessage extends Writable {\n  constructor (socket = null) {\n    super()\n\n    this.socket = socket\n    this.headers = {}\n    this.headersSent = false\n    this.upgrade = false\n  }\n\n  getHeader (name) {\n    return this.headers[name.toLowerCase()]\n  }\n\n  getHeaders () {\n    return { ...this.headers }\n  }\n\n  hasHeader (name) {\n    return name.toLowerCase() in this.headers\n  }\n\n  setHeader (name, value) {\n    this.headers[name.toLowerCase()] = value\n  }\n\n  flushHeaders () {\n    if (this.headersSent === true || this.socket === null) return\n\n    this.socket.write(Buffer.from(this._header()))\n    this.headersSent = true\n  }\n\n  setTimeout (ms, ontimeout) {\n    if (ontimeout) this.once('timeout', ontimeout)\n\n    this.socket.setTimeout(ms)\n\n    return this\n  }\n\n  _header () {\n    throw errors.NOT_IMPLEMENTED()\n  }\n\n  _predestroy () {\n    if (this.upgrade === false && this.socket !== null) this.socket.destroy()\n  }\n}\nconst tcp = require('bare-tcp')\nconst { isEnded, isFinished, getStreamError } = require('bare-stream')\nconst HTTPIncomingMessage = require('./incoming-message')\nconst HTTPServerResponse = require('./server-response')\nconst constants = require('./constants')\n\nconst empty = Buffer.alloc(0)\n\nmodule.exports = class HTTPServerConnection {\n  static _connections = new WeakMap()\n\n  static for (socket) {\n    return this._connections.get(socket) || null\n  }\n\n  constructor (server, socket, opts = {}) {\n    const {\n      IncomingMessage = HTTPIncomingMessage,\n      ServerResponse = HTTPServerResponse\n    } = opts\n\n    this.server = server\n    this.socket = socket\n\n    this.req = null\n    this.res = null\n\n    this._IncomingMessage = IncomingMessage\n    this._ServerResponse = ServerResponse\n\n    this._state = constants.state.BEFORE_HEAD\n    this._length = -1\n    this._read = 0\n    this._buffer = null\n    this._idle = true\n\n    this._onclose = this._onclose.bind(this)\n    this._ondata = this._ondata.bind(this)\n    this._ondrain = this._ondrain.bind(this)\n    this._ontimeout = this._ontimeout.bind(this)\n\n    socket\n      .on('error', noop)\n      .on('close', this._onclose)\n      .on('data', this._ondata)\n      .on('drain', this._ondrain)\n      .on('timeout', this._ontimeout)\n\n    HTTPServerConnection._connections.set(socket, this)\n\n    if (this.server.timeout) socket.setTimeout(this.server.timeout)\n  }\n\n  get idle () {\n    return this._idle\n  }\n\n  _onclose () {\n    if (this.req && !isEnded(this.req)) this.req.destroy()\n    if (this.res && !isFinished(this.res)) this.res.destroy()\n    const err = getStreamError(this.socket)\n    if (err) this.socket.destroy(err)\n  }\n\n  _ondata (data) {\n    this._idle = false\n\n    if (this._state === constants.state.IN_BODY) return this._onbody(data)\n\n    if (this._buffer !== null) {\n      this._buffer = Buffer.concat([this._buffer, data])\n    } else {\n      this._buffer = data\n    }\n\n    let hits = 0\n\n    for (let i = 0; i < this._buffer.byteLength; i++) {\n      const b = this._buffer[i]\n\n      if (hits === 0 && b === 13) {\n        hits++\n      } else if (hits === 1 && b === 10) {\n        hits++\n\n        if (this._state === constants.state.BEFORE_CHUNK) {\n          const head = this._buffer.subarray(0, i - 1)\n          this._buffer = i + 1 === this._buffer.byteLength ? null : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onchunklength(head)\n\n          if (this._buffer === null) break\n        } else if (this._state === constants.state.IN_CHUNK) {\n          const chunk = this._buffer.subarray(0, i - 1)\n\n          if (chunk.byteLength !== this._length) {\n            hits = 0\n            continue\n          }\n\n          this._buffer = i + 1 === this._buffer.byteLength ? null : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onchunk(chunk)\n\n          if (this._buffer === null) break\n        }\n      } else if (hits === 2 && b === 13) {\n        hits++\n      } else if (hits === 3 && b === 10) {\n        if (this._state === constants.state.BEFORE_HEAD) {\n          const head = this._buffer.subarray(0, i - 3)\n          this._buffer = i + 1 === this._buffer.byteLength ? null : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onhead(head)\n\n          if (this._buffer === null) break\n        }\n      } else {\n        hits = 0\n      }\n    }\n  }\n\n  _onhead (data) {\n    this._state = constants.state.IN_HEAD\n\n    const r = data.toString().split('\\r\\n')\n    if (r.length === 0) return this.socket.destroy()\n\n    const [method, url] = r[0].split(' ')\n    if (!method || !url) return this.socket.destroy()\n\n    const headers = {}\n\n    for (let i = 1; i < r.length; i++) {\n      const [name, value] = r[i].split(': ')\n      headers[name.toLowerCase()] = value\n    }\n\n    this.req = new this._IncomingMessage(this.socket, headers, { method, url })\n\n    this.req.on('close', () => { this.req = null; this._onreset() })\n\n    if (headers.connection && headers.connection.toLowerCase() === 'upgrade') {\n      const head = this._buffer\n      this._buffer = null\n      return this._onupgrade(head)\n    }\n\n    this.res = new this._ServerResponse(this.socket, this.req, headers.connection === 'close')\n\n    this.res.on('close', () => { this.res = null })\n\n    this.server.emit('request', this.req, this.res)\n\n    if (headers['transfer-encoding'] === 'chunked') {\n      this._state = constants.state.BEFORE_CHUNK\n    } else {\n      this._length = parseInt(headers['content-length'], 10) || 0\n\n      if (this._length === 0) return this._onfinished()\n\n      this._state = constants.state.IN_BODY\n\n      if (this._buffer) {\n        const body = this._buffer\n        this._buffer = null\n        this._onbody(body)\n      }\n    }\n  }\n\n  _onchunklength (data) {\n    this._length = parseInt(data.toString(), 16)\n\n    if (this._length === 0) this._onfinished()\n    else this._state = constants.state.IN_CHUNK\n  }\n\n  _onchunk (data) {\n    this._read += data.byteLength\n\n    this.req.push(data)\n\n    this._state = constants.state.BEFORE_CHUNK\n  }\n\n  _onbody (data) {\n    this._read += data.byteLength\n\n    this.req.push(data)\n\n    if (this._read === this._length) this._onfinished()\n  }\n\n  _onupgrade (head) {\n    this._ondetach()\n\n    const req = this.req\n\n    req.upgrade = true\n    req.destroy()\n\n    this.server.emit('upgrade', req, this.socket, head || empty)\n  }\n\n  _ontimeout () {\n    const reqTimeout = this.req && this.req.emit('timeout')\n    const resTimeout = this.res && this.res.emit('timeout')\n    const serverTimeout = this.server.emit('timeout', this.socket)\n\n    if (!reqTimeout && !resTimeout && !serverTimeout) this.socket.destroy()\n  }\n\n  _onfinished () {\n    if (this.req) this.req.push(null)\n  }\n\n  _onreset () {\n    this._state = constants.state.BEFORE_HEAD\n    this._length = -1\n    this._read = 0\n    this._buffer = null\n    this._idle = true\n\n    if (this.server._state & tcp.constants.state.CLOSING) {\n      this.socket.destroy()\n    }\n  }\n\n  _ondrain () {\n    if (this.res) this.res._continueWrite()\n  }\n\n  _ondetach () {\n    this.socket\n      .off('error', noop)\n      .off('close', this._onclose)\n      .off('data', this._ondata)\n      .off('drain', this._ondrain)\n      .off('timeout', this._ontimeout)\n\n    HTTPServerConnection._connections.delete(this.socket)\n  }\n}\n\nfunction noop () {}\nconst HTTPOutgoingMessage = require('./outgoing-message')\nconst constants = require('./constants')\n\nmodule.exports = class HTTPServerResponse extends HTTPOutgoingMessage {\n  constructor (socket, req, close) {\n    super(socket)\n\n    this.req = req\n\n    this.statusCode = 200\n    this.statusMessage = null\n\n    this._chunked = true\n    this._close = close\n    this._finishing = false\n    this._onlyHeaders = req.method === 'HEAD'\n\n    this._pendingWrite = null\n  }\n\n  end (data) {\n    this._finishing = true\n    return super.end(data)\n  }\n\n  writeHead (statusCode, statusMessage = null, headers = {}) {\n    if (typeof statusMessage === 'object' && statusMessage !== null) {\n      headers = statusMessage\n      statusMessage = null\n    }\n\n    this.statusCode = statusCode\n    this.statusMessage = statusMessage || null\n    this.headers = headers || {}\n  }\n\n  _header () {\n    let h = 'HTTP/1.1 ' + this.statusCode + ' ' + (this.statusMessage === null ? constants.status[this.statusCode] : this.statusMessage) + '\\r\\n'\n\n    for (const name of Object.keys(this.headers)) {\n      const n = name.toLowerCase()\n      const v = this.headers[name]\n\n      if (n === 'content-length') this._chunked = false\n      if (n === 'connection' && v && v.toLowerCase() === 'close') this._close = true\n\n      h += httpCase(n) + ': ' + v + '\\r\\n'\n    }\n\n    if (this._chunked) h += 'Transfer-Encoding: chunked\\r\\n'\n\n    h += '\\r\\n'\n\n    return h\n  }\n\n  _write (data, encoding, cb) {\n    if (this.headersSent === false) {\n      if (this._finishing) {\n        this.setHeader('Content-Length', (data.byteLength + this._writableState.buffered).toString())\n      }\n\n      this.flushHeaders()\n    }\n\n    if (this._onlyHeaders === true) return cb(null)\n\n    if (this._chunked) {\n      data = Buffer.concat([\n        Buffer.from('' + data.byteLength.toString(16) + '\\r\\n'),\n        data,\n        Buffer.from('\\r\\n')\n      ])\n    }\n\n    if (this.socket.write(data)) cb(null)\n    else this._pendingWrite = cb\n  }\n\n  _final (cb) {\n    if (this.headersSent === false) {\n      this.setHeader('Content-Length', '0')\n      this.flushHeaders()\n    }\n\n    if (this._chunked && this._onlyHeaders === false) this.socket.write(Buffer.from('0\\r\\n\\r\\n'))\n    if (this._close) this.socket.end()\n\n    cb(null)\n  }\n\n  _predestroy () {\n    super._predestroy()\n    this.req.destroy()\n    this._continueWrite()\n  }\n\n  _continueWrite () {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite\n    this._pendingWrite = null\n    cb(null)\n  }\n}\n\nfunction httpCase (n) {\n  let s = ''\n  for (const part of n.split('-')) {\n    s += (s ? '-' : '') + part.slice(0, 1).toUpperCase() + part.slice(1)\n  }\n  return s\n}\nconst TCPServer = require('bare-tcp').Server\nconst HTTPServerConnection = require('./server-connection')\n\nmodule.exports = class HTTPServer extends TCPServer {\n  constructor (opts = {}, onrequest) {\n    if (typeof opts === 'function') {\n      onrequest = opts\n      opts = {}\n    }\n\n    super({ allowHalfOpen: false })\n\n    this._timeout = 0\n\n    this.on('connection', (socket) => new HTTPServerConnection(this, socket, opts))\n\n    if (onrequest) this.on('request', onrequest)\n  }\n\n  get timeout () {\n    return this._timeout || undefined // For Node.js compatibility\n  }\n\n  setTimeout (ms = 0, ontimeout) {\n    if (ontimeout) this.on('timeout', ontimeout)\n\n    this._timeout = ms\n\n    return this\n  }\n\n  close (onclose) {\n    super.close(onclose)\n\n    for (const socket of this._connections) {\n      const connection = HTTPServerConnection.for(socket)\n\n      if (connection && connection.idle) {\n        socket.destroy()\n      }\n    }\n  }\n}\n{\n  \"name\": \"bare-http1\",\n  \"version\": \"3.8.2\",\n  \"description\": \"Native HTTP/1 library for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\",\n    \"./constants\": \"./lib/constants.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-http1.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-http1/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-http1#readme\",\n  \"dependencies\": {\n    \"bare-events\": \"^2.0.0\",\n    \"bare-stream\": \"^2.3.0\",\n    \"bare-tcp\": \"^1.8.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.0\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst tcp = require('bare-tcp')\nconst tls = require('bare-tls')\nconst http = require('bare-http1')\n\nconst Agent = exports.Agent = class HTTPSAgent extends http.Agent {\n  createConnection (opts) {\n    return new tls.Socket(super.createConnection(opts), opts)\n  }\n\n  static global = new this({ keepAlive: 1000, timeout: 5000 })\n}\n\nexports.globalAgent = Agent.global\n\nconst Server = exports.Server = class HTTPSServer extends tcp.Server {\n  constructor (opts = {}, onrequest) {\n    if (typeof opts === 'function') {\n      onrequest = opts\n      opts = {}\n    }\n\n    super({ allowHalfOpen: false })\n\n    this._timeout = 0\n\n    this.on('connection', (socket) => new http.ServerConnection(this, new tls.Socket(socket, { ...opts, isServer: true }), opts))\n\n    if (onrequest) this.on('request', onrequest)\n  }\n\n  get timeout () {\n    return this._timeout || undefined // For Node.js compatibility\n  }\n\n  setTimeout (ms = 0, ontimeout) {\n    if (ontimeout) this.on('timeout', ontimeout)\n\n    this._timeout = ms\n\n    return this\n  }\n\n  close (onclose) {\n    super.close(onclose)\n\n    for (const socket of this._connections) {\n      const connection = http.ServerConnection.for(socket)\n\n      if (connection && connection.idle) {\n        socket.destroy()\n      }\n    }\n  }\n}\n\nexports.createServer = function createServer (opts, onrequest) {\n  return new Server(opts, onrequest)\n}\n\nexports.request = function request (url, opts, onresponse) {\n  if (typeof opts === 'function') {\n    onresponse = opts\n    opts = {}\n  }\n\n  if (typeof url === 'string') url = new URL(url)\n\n  if (isURL(url)) {\n    opts = opts ? { ...opts } : {}\n\n    opts.host = url.hostname\n    opts.path = url.pathname + url.search\n    opts.port = url.port ? parseInt(url.port, 10) : defaultPort(url)\n  } else {\n    opts = url ? { ...url } : {}\n\n    // For Node.js compatibility\n    opts.host = opts.hostname || opts.host\n    opts.port = typeof opts.port === 'string' ? parseInt(opts.port, 10) : opts.port\n  }\n\n  // TODO: Renable the default global agent when tests have been sorted\n  // opts.agent = opts.agent === false ? new Agent() : opts.agent || Agent.global\n\n  opts.agent = opts.agent || new Agent()\n\n  return new http.ClientRequest(opts, onresponse)\n}\n\n// https://url.spec.whatwg.org/#default-port\nfunction defaultPort (url) {\n  switch (url.protocol) {\n    case 'ftp:': return 21\n    case 'http:':\n    case 'ws:': return 80\n    case 'https:':\n    case 'wss:': return 443\n  }\n\n  return null\n}\n\n// https://url.spec.whatwg.org/#api\nfunction isURL (url) {\n  return (\n    url !== null &&\n    typeof url === 'object' &&\n    typeof url.protocol === 'string' &&\n    typeof url.hostname === 'string' &&\n    typeof url.pathname === 'string' &&\n    typeof url.search === 'string'\n  )\n}\n{\n  \"name\": \"bare-https\",\n  \"version\": \"1.3.0\",\n  \"description\": \"HTTPS library for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-https.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-https/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-https#readme\",\n  \"dependencies\": {\n    \"bare-http1\": \"^3.8.0\",\n    \"bare-tcp\": \"^1.1.2\",\n    \"bare-tls\": \"^1.0.2\"\n  },\n  \"devDependencies\": {\n    \"bare-fs\": \"^2.2.3\",\n    \"brittle\": \"^3.3.0\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nmodule.exports = require.addon()\nexports.Console = require('./lib/console')\nexports.Session = require('./lib/session')\nexports.Server = require('./lib/server')\nexports.HeapSnapshot = require('./lib/heap-snapshot')\nconst binding = require('../binding')\n\nmodule.exports = class InspectorConsole {\n  constructor () {\n    for (const method of Object.keys(binding.console)) {\n      this[method] = binding.console[method]\n    }\n  }\n}\nmodule.exports = {\n  state: {\n    CONNECTED: 0x1,\n    DESTROYED: 0x2\n  }\n}\nconst { Readable } = require('bare-stream')\n\nmodule.exports = class InspectorHeapSnapshot extends Readable {\n  constructor (session) {\n    super()\n\n    this._session = session\n    this._request = null\n  }\n\n  _open (cb) {\n    const onchunk = ({ params }) => {\n      this.push(params.chunk)\n    }\n\n    const onclose = ({ error } = {}) => {\n      this._session.off('HeapProfiler.addHeapSnapshotChunk', onchunk)\n\n      if (error) this.destroy(error)\n      else this.push(null)\n    }\n\n    this._session.on('HeapProfiler.addHeapSnapshotChunk', onchunk)\n\n    this._request = this._session.post('HeapProfiler.takeHeapSnapshot')\n    this._request.then(onclose, onclose)\n\n    cb()\n  }\n}\n/* global Bare */\nconst EventEmitter = require('bare-events')\nconst url = require('bare-url')\nconst ws = require('bare-ws')\nconst http = require('bare-http1')\nconst Session = require('./session')\n\nmodule.exports = class InspectorServer extends EventEmitter {\n  constructor (port, host, opts = {}) {\n    if (typeof port === 'object' && port !== null) {\n      opts = port\n      port = 0\n      host = 'localhost'\n    } else if (typeof host === 'object' && host !== null) {\n      opts = host\n      host = 'localhost'\n    }\n\n    const {\n      path = require.main.path\n    } = opts\n\n    super()\n\n    this._path = typeof path === 'string' ? url.pathToFileURL(path) : path\n    this._sessions = new Map()\n\n    this._server = new ws.Server(\n      {\n        server: new http.Server(this._onrequest.bind(this))\n          .listen(\n            { port, host },\n            this._onlistening.bind(this)\n          )\n      },\n      this._onconnection.bind(this)\n    )\n  }\n\n  get listening () {\n    return this._server.listening\n  }\n\n  address () {\n    return this._server.address()\n  }\n\n  close (cb) {\n    for (const socket of this._sessions.keys()) socket.destroy()\n\n    return this._server.close(cb)\n  }\n\n  ref () {\n    this._server.ref()\n  }\n\n  unref () {\n    this._server.unref()\n  }\n\n  _onlistening () {\n    this.emit('listening')\n  }\n\n  _onrequest (req, res) {\n    if (req.url === '/json/list') return this._onlist(req, res)\n\n    res.writeHead(404)\n    res.end()\n  }\n\n  _onconnection (socket) {\n    const sessions = this._sessions\n\n    const session = new Session()\n\n    sessions.set(socket, session)\n\n    session\n      .on('inspectorNotification', onnotification)\n      .connect()\n\n    socket\n      .on('close', onclose)\n      .on('data', ondata)\n\n    function onnotification (message) {\n      socket.write(JSON.stringify(message))\n    }\n\n    function onclose () {\n      session.destroy()\n      sessions.delete(socket)\n    }\n\n    function ondata (data) {\n      const { id, method, params } = JSON.parse(data)\n\n      session.post(method, params, (err, result) => {\n        const response = err ? { id, error: err } : { id, result }\n\n        socket.write(JSON.stringify(response))\n      })\n    }\n  }\n\n  _onlist (req, res) {\n    res.writeHead(200, { 'Content-Type': 'application/json' })\n\n    const { address, port } = this.address()\n\n    res.end(JSON.stringify([\n      {\n        title: `bare[${Bare.pid}]`,\n        id: `${Bare.pid}`,\n        type: 'node',\n        url: this._path,\n        devtoolsFrontendUrl: `devtools://devtools/bundled/js_app.html?ws=${address}:${port}`,\n        webSocketDebuggerUrl: `ws://${address}:${port}`,\n        faviconUrl: 'https://holepunch.to/favicon.ico'\n      }\n    ]))\n  }\n}\nconst EventEmitter = require('bare-events')\nconst binding = require('../binding')\nconst constants = require('./constants')\n\nmodule.exports = class InspectorSession extends EventEmitter {\n  constructor (onpaused) {\n    super()\n\n    this._state = 0\n\n    this._nextId = 1\n    this._requests = new Map()\n\n    this._onpaused = onpaused || defaultPaused\n\n    this._handle = binding.create(this, this._onresponse, this._onpaused)\n  }\n\n  get connected () {\n    return (this._state & constants.state.CONNECTED) !== 0 && (this._state & constants.state.DESTROYED) === 0\n  }\n\n  get destroyed () {\n    return (this._state & constants.state.DESTROYED) !== 0\n  }\n\n  connect () {\n    if (this._state & (constants.state.CONNECTED | constants.state.DESTROYED)) return\n\n    this._state |= constants.state.CONNECTED\n\n    binding.connect(this._handle)\n  }\n\n  post (method, params, cb) {\n    if (typeof params === 'function') {\n      cb = params\n      params = null\n    }\n\n    let result\n\n    if (typeof cb !== 'function') {\n      result = new Promise((resolve, reject) => {\n        cb = (err, result) => {\n          if (err) reject(err)\n          else resolve(result)\n        }\n      })\n    }\n\n    const id = this._nextId++\n\n    const req = {\n      id,\n      callback: cb\n    }\n\n    this._requests.set(id, req)\n\n    binding.post(this._handle, JSON.stringify({\n      id,\n      method,\n      params\n    }))\n\n    return result\n  }\n\n  destroy () {\n    if (this._state & constants.state.DESTROYED) return\n\n    this._state |= constants.state.DESTROYED\n\n    binding.destroy(this._handle)\n  }\n\n  _onresponse (string) {\n    const message = JSON.parse(string)\n\n    if (message.method) {\n      this.emit(message.method, message)\n      this.emit('inspectorNotification', message)\n    } else {\n      const req = this._requests.get(message.id)\n\n      if (req) {\n        this._requests.delete(message.id)\n\n        let err = null\n\n        if (message.error) {\n          err = new Error(message.error.message)\n          err.code = message.error.code\n        }\n\n        req.callback(err, message.result)\n      }\n    }\n  }\n}\n\nfunction defaultPaused () {\n  return false\n}\n{\n  \"name\": \"bare-inspector\",\n  \"version\": \"3.0.2\",\n  \"description\": \"V8 inspector support for Bare\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\",\n    \"./console\": \"./lib/console.js\",\n    \"./session\": \"./lib/session.js\",\n    \"./server\": \"./lib/server.js\",\n    \"./heap-snapshot\": \"./lib/heap-snapshot.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"binding.c\",\n    \"binding.js\",\n    \"lib\",\n    \"CMakeLists.txt\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"standard && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-inspector.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-inspector/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-inspector#readme\",\n  \"engines\": {\n    \"bare\": \">=1.2.0\"\n  },\n  \"dependencies\": {\n    \"bare-events\": \"^2.1.0\",\n    \"bare-http1\": \"^3.5.2\",\n    \"bare-stream\": \"^2.0.0\",\n    \"bare-url\": \"^2.0.0\",\n    \"bare-ws\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nmodule.exports = require.addon()\nconst binding = require('./binding')\nconst errors = require('./lib/errors')\nconst constants = require('./lib/constants')\n\nexports.constants = constants\n\nexports.EOL = binding.platform === 'win32' ? '\\r\\n' : '\\n'\n\nexports.platform = function platform() {\n  return binding.platform\n}\n\nexports.arch = function arch() {\n  return binding.arch\n}\n\nexports.type = binding.type\nexports.version = binding.version\nexports.release = binding.release\nexports.machine = binding.machine\nexports.execPath = binding.execPath\nexports.pid = binding.pid\nexports.ppid = binding.ppid\nexports.cwd = binding.cwd\nexports.chdir = binding.chdir\nexports.tmpdir = binding.tmpdir\nexports.homedir = binding.homedir\nexports.hostname = binding.hostname\n\nexports.kill = function kill(pid, signal = constants.signals.SIGTERM) {\n  if (typeof signal === 'string') {\n    if (signal in constants.signals === false) {\n      throw errors.UNKNOWN_SIGNAL('Unknown signal: ' + signal)\n    }\n\n    signal = constants.signals[signal]\n  }\n\n  binding.kill(pid, signal)\n}\n\nexports.endianness = function endianness() {\n  return binding.isLittleEndian ? 'LE' : 'BE'\n}\n\nexports.availableParallelism = binding.availableParallelism\n\nexports.cpuUsage = function cpuUsage(previous) {\n  const current = binding.cpuUsage()\n\n  if (previous) {\n    return {\n      user: current.user - previous.user,\n      system: current.system - previous.system\n    }\n  }\n\n  return current\n}\n\nexports.resourceUsage = binding.resourceUsage\nexports.memoryUsage = binding.memoryUsage\nexports.freemem = binding.freemem\nexports.totalmem = binding.totalmem\nexports.uptime = binding.uptime\nexports.loadavg = binding.loadavg\nexports.cpus = binding.cpus\n\nexports.getProcessTitle = binding.getProcessTitle\n\nexports.setProcessTitle = function setProcessTitle(title) {\n  if (typeof title !== 'string') title = title.toString()\n\n  if (title.length >= 256) {\n    throw errors.TITLE_OVERFLOW('Process title is too long')\n  }\n\n  binding.setProcessTitle(title)\n}\n\nexports.getEnvKeys = binding.getEnvKeys\nexports.getEnv = binding.getEnv\nexports.hasEnv = binding.hasEnv\nexports.setEnv = binding.setEnv\nexports.unsetEnv = binding.unsetEnv\nconst binding = require('../binding')\n\nmodule.exports = {\n  signals: binding.signals,\n  errnos: binding.errnos\n}\nmodule.exports = class OSError extends Error {\n  constructor(msg, code, fn = OSError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'OSError'\n  }\n\n  static UNKNOWN_SIGNAL(msg) {\n    return new OSError(msg, 'UNKNOWN_SIGNAL', OSError.UNKNOWN_SIGNAL)\n  }\n\n  static TITLE_OVERFLOW(msg) {\n    return new OSError(msg, 'TITLE_OVERFLOW', OSError.TITLE_OVERFLOW)\n  }\n}\n{\n  \"name\": \"bare-os\",\n  \"version\": \"3.4.0\",\n  \"description\": \"Operating system utilities for Javascript\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./package\": \"./package.json\",\n    \"./constants\": \"./lib/constants.js\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-os.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-os/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-os#readme\",\n  \"engines\": {\n    \"bare\": \">=1.6.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.1\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"prettier\": \"^3.4.2\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\n/* global Bare */\n\n// This export SHOULD NOT be shortened in any way as having the full\n// `module.exports = require(...)` statement is crucial for synthesizing\n// ESM exports.\n\nif (Bare.platform === 'win32') {\n  module.exports = require('./lib/win32')\n} else {\n  module.exports = require('./lib/posix')\n}\nmodule.exports = {\n  CHAR_UPPERCASE_A: 0x41,\n  CHAR_LOWERCASE_A: 0x61,\n  CHAR_UPPERCASE_Z: 0x5a,\n  CHAR_LOWERCASE_Z: 0x7a,\n  CHAR_DOT: 0x2e,\n  CHAR_FORWARD_SLASH: 0x2f,\n  CHAR_BACKWARD_SLASH: 0x5c,\n  CHAR_COLON: 0x3a,\n  CHAR_QUESTION_MARK: 0x3f\n}\nconst os = require('bare-os')\n\nconst { normalizeString } = require('./shared')\nconst {\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH\n} = require('./constants')\n\nfunction isPosixPathSeparator (code) {\n  return code === CHAR_FORWARD_SLASH\n}\n\nexports.win32 = require('./win32')\nexports.posix = exports\n\nexports.sep = '/'\nexports.delimiter = ':'\n\nexports.resolve = function resolve (...args) {\n  let resolvedPath = ''\n  let resolvedAbsolute = false\n\n  for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    const path = i >= 0 ? args[i] : os.cwd()\n\n    if (path.length === 0) {\n      continue\n    }\n\n    resolvedPath = `${path}/${resolvedPath}`\n    resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH\n  }\n\n  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator)\n\n  if (resolvedAbsolute) {\n    return `/${resolvedPath}`\n  }\n\n  return resolvedPath.length > 0 ? resolvedPath : '.'\n}\n\nexports.normalize = function normalize (path) {\n  if (path.length === 0) return '.'\n\n  const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH\n  const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH\n\n  path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator)\n\n  if (path.length === 0) {\n    if (isAbsolute) return '/'\n    return trailingSeparator ? './' : '.'\n  }\n\n  if (trailingSeparator) path += '/'\n\n  return isAbsolute ? `/${path}` : path\n}\n\nexports.isAbsolute = function isAbsolute (path) {\n  return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH\n}\n\nexports.join = function join (...args) {\n  if (args.length === 0) return '.'\n  let joined\n  for (let i = 0; i < args.length; ++i) {\n    const arg = args[i]\n    if (arg.length > 0) {\n      if (joined === undefined) joined = arg\n      else joined += `/${arg}`\n    }\n  }\n  if (joined === undefined) return '.'\n  return exports.normalize(joined)\n}\n\nexports.relative = function relative (from, to) {\n  if (from === to) return ''\n\n  from = exports.resolve(from)\n  to = exports.resolve(to)\n\n  if (from === to) return ''\n\n  const fromStart = 1\n  const fromEnd = from.length\n  const fromLen = fromEnd - fromStart\n  const toStart = 1\n  const toLen = to.length - toStart\n\n  const length = (fromLen < toLen ? fromLen : toLen)\n  let lastCommonSep = -1\n  let i = 0\n  for (; i < length; i++) {\n    const fromCode = from.charCodeAt(fromStart + i)\n    if (fromCode !== to.charCodeAt(toStart + i)) {\n      break\n    } else if (fromCode === CHAR_FORWARD_SLASH) {\n      lastCommonSep = i\n    }\n  }\n  if (i === length) {\n    if (toLen > length) {\n      if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n        return to.substring(toStart + i + 1)\n      }\n      if (i === 0) {\n        return to.substring(toStart + i)\n      }\n    } else if (fromLen > length) {\n      if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i\n      } else if (i === 0) {\n        lastCommonSep = 0\n      }\n    }\n  }\n\n  let out = ''\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n      out += out.length === 0 ? '..' : '/..'\n    }\n  }\n\n  return `${out}${to.substring(toStart + lastCommonSep)}`\n}\n\nexports.toNamespacedPath = function toNamespacedPath (path) {\n  return path\n}\n\nexports.dirname = function dirname (path) {\n  if (path.length === 0) return '.'\n  const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH\n  let end = -1\n  let matchedSlash = true\n  for (let i = path.length - 1; i >= 1; --i) {\n    if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n      if (!matchedSlash) {\n        end = i\n        break\n      }\n    } else {\n      matchedSlash = false\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.'\n  if (hasRoot && end === 1) return '//'\n  return path.substring(0, end)\n}\n\nexports.basename = function basename (path, suffix) {\n  let start = 0\n  let end = -1\n  let matchedSlash = true\n\n  if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n    if (suffix === path) { return '' }\n    let extIdx = suffix.length - 1\n    let firstNonSlashEnd = -1\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i)\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          start = i + 1\n          break\n        }\n      } else {\n        if (firstNonSlashEnd === -1) {\n          matchedSlash = false\n          firstNonSlashEnd = i + 1\n        }\n        if (extIdx >= 0) {\n          if (code === suffix.charCodeAt(extIdx)) {\n            if (--extIdx === -1) {\n              end = i\n            }\n          } else {\n            extIdx = -1\n            end = firstNonSlashEnd\n          }\n        }\n      }\n    }\n\n    if (start === end) end = firstNonSlashEnd\n    else if (end === -1) end = path.length\n    return path.substring(start, end)\n  }\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n      if (!matchedSlash) {\n        start = i + 1\n        break\n      }\n    } else if (end === -1) {\n      matchedSlash = false\n      end = i + 1\n    }\n  }\n\n  if (end === -1) return ''\n  return path.substring(start, end)\n}\n\nexports.extname = function extname (path) {\n  let startDot = -1\n  let startPart = 0\n  let end = -1\n  let matchedSlash = true\n  let preDotState = 0\n  for (let i = path.length - 1; i >= 0; --i) {\n    const code = path.charCodeAt(i)\n    if (code === CHAR_FORWARD_SLASH) {\n      if (!matchedSlash) {\n        startPart = i + 1\n        break\n      }\n      continue\n    }\n    if (end === -1) {\n      matchedSlash = false\n      end = i + 1\n    }\n    if (code === CHAR_DOT) {\n      if (startDot === -1) startDot = i\n      else if (preDotState !== 1) preDotState = 1\n    } else if (startDot !== -1) {\n      preDotState = -1\n    }\n  }\n\n  if (startDot === -1 || end === -1 || preDotState === 0 || (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {\n    return ''\n  }\n  return path.substring(startDot, end)\n}\nconst {\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH\n} = require('./constants')\n\nexports.normalizeString = function normalizeString (path, allowAboveRoot, separator, isPathSeparator) {\n  let res = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let code = 0\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i)\n    } else if (isPathSeparator(code)) {\n      break\n    } else {\n      code = CHAR_FORWARD_SLASH\n    }\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) ;\n      else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator)\n            if (lastSlashIndex === -1) {\n              res = ''\n              lastSegmentLength = 0\n            } else {\n              res = res.substring(0, lastSlashIndex)\n              lastSegmentLength =\n                res.length - 1 - res.lastIndexOf(separator)\n            }\n            lastSlash = i\n            dots = 0\n            continue\n          } else if (res.length !== 0) {\n            res = ''\n            lastSegmentLength = 0\n            lastSlash = i\n            dots = 0\n            continue\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (res.length > 0) {\n          res += `${separator}${path.substring(lastSlash + 1, i)}`\n        } else {\n          res = path.substring(lastSlash + 1, i)\n        }\n        lastSegmentLength = i - lastSlash - 1\n      }\n      lastSlash = i\n      dots = 0\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots\n    } else {\n      dots = -1\n    }\n  }\n  return res\n}\nconst os = require('bare-os')\n\nconst { normalizeString } = require('./shared')\nconst {\n  CHAR_UPPERCASE_A,\n  CHAR_LOWERCASE_A,\n  CHAR_UPPERCASE_Z,\n  CHAR_LOWERCASE_Z,\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH,\n  CHAR_BACKWARD_SLASH,\n  CHAR_COLON,\n  CHAR_QUESTION_MARK\n} = require('./constants')\n\nfunction isWindowsPathSeparator (code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH\n}\n\nfunction isWindowsDeviceRoot (code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z)\n}\n\nexports.posix = require('./posix')\nexports.win32 = exports\n\nexports.sep = '\\\\'\nexports.delimiter = ';'\n\nexports.resolve = function resolve (...args) {\n  let resolvedDevice = ''\n  let resolvedTail = ''\n  let resolvedAbsolute = false\n\n  for (let i = args.length - 1; i >= -1; i--) {\n    let path\n    if (i >= 0) {\n      path = args[i]\n\n      if (path.length === 0) continue\n    } else if (resolvedDevice.length === 0) {\n      path = os.cwd()\n    } else {\n      path = os.getEnv(`=${resolvedDevice}`) || os.cwd()\n\n      if (path === undefined || (path.substring(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {\n        path = `${resolvedDevice}\\\\`\n      }\n    }\n\n    const len = path.length\n    let rootEnd = 0\n    let device = ''\n    let isAbsolute = false\n    const code = path.charCodeAt(0)\n\n    if (len === 1) {\n      if (isWindowsPathSeparator(code)) {\n        rootEnd = 1\n        isAbsolute = true\n      }\n    } else if (isWindowsPathSeparator(code)) {\n      isAbsolute = true\n\n      if (isWindowsPathSeparator(path.charCodeAt(1))) {\n        let j = 2\n        let last = j\n        while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {\n          j++\n        }\n        if (j < len && j !== last) {\n          const firstPart = path.substring(last, j)\n          last = j\n          while (j < len && isWindowsPathSeparator(path.charCodeAt(j))) {\n            j++\n          }\n          if (j < len && j !== last) {\n            last = j\n            while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {\n              j++\n            }\n            if (j === len || j !== last) {\n              device = `\\\\\\\\${firstPart}\\\\${path.substring(last, j)}`\n              rootEnd = j\n            }\n          }\n        }\n      } else {\n        rootEnd = 1\n      }\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      device = path.substring(0, 2)\n      rootEnd = 2\n      if (len > 2 && isWindowsPathSeparator(path.charCodeAt(2))) {\n        isAbsolute = true\n        rootEnd = 3\n      }\n    }\n\n    if (device.length > 0) {\n      if (resolvedDevice.length > 0) {\n        if (device.toLowerCase() !== resolvedDevice.toLowerCase()) { continue }\n      } else {\n        resolvedDevice = device\n      }\n    }\n\n    if (resolvedAbsolute) {\n      if (resolvedDevice.length > 0) { break }\n    } else {\n      resolvedTail = `${path.substring(rootEnd)}\\\\${resolvedTail}`\n      resolvedAbsolute = isAbsolute\n      if (isAbsolute && resolvedDevice.length > 0) {\n        break\n      }\n    }\n  }\n\n  resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isWindowsPathSeparator)\n\n  return resolvedAbsolute ? `${resolvedDevice}\\\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || '.'\n}\n\nexports.normalize = function normalize (path) {\n  const len = path.length\n  if (len === 0) return '.'\n  let rootEnd = 0\n  let device\n  let isAbsolute = false\n  const code = path.charCodeAt(0)\n\n  if (len === 1) {\n    return code === CHAR_FORWARD_SLASH ? '\\\\' : path\n  }\n\n  if (isWindowsPathSeparator(code)) {\n    isAbsolute = true\n\n    if (isWindowsPathSeparator(path.charCodeAt(1))) {\n      let j = 2\n      let last = j\n      while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {\n        j++\n      }\n      if (j < len && j !== last) {\n        const firstPart = path.substring(last, j)\n        last = j\n        while (j < len && isWindowsPathSeparator(path.charCodeAt(j))) {\n          j++\n        }\n        if (j < len && j !== last) {\n          last = j\n          while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {\n            j++\n          }\n          if (j === len) {\n            return `\\\\\\\\${firstPart}\\\\${path.substring(last)}\\\\`\n          }\n          if (j !== last) {\n            device = `\\\\\\\\${firstPart}\\\\${path.substring(last, j)}`\n            rootEnd = j\n          }\n        }\n      }\n    } else {\n      rootEnd = 1\n    }\n  } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n    device = path.substring(0, 2)\n    rootEnd = 2\n    if (len > 2 && isWindowsPathSeparator(path.charCodeAt(2))) {\n      isAbsolute = true\n      rootEnd = 3\n    }\n  }\n\n  let tail = rootEnd < len ? normalizeString(path.substring(rootEnd), !isAbsolute, '\\\\', isWindowsPathSeparator) : ''\n  if (tail.length === 0 && !isAbsolute) {\n    tail = '.'\n  }\n  if (tail.length > 0 && isWindowsPathSeparator(path.charCodeAt(len - 1))) {\n    tail += '\\\\'\n  }\n  if (device === undefined) {\n    return isAbsolute ? `\\\\${tail}` : tail\n  }\n  return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`\n}\n\nexports.isAbsolute = function isAbsolute (path) {\n  const len = path.length\n  if (len === 0) return false\n\n  const code = path.charCodeAt(0)\n\n  return isWindowsPathSeparator(code) || (len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isWindowsPathSeparator(path.charCodeAt(2)))\n}\n\nexports.join = function join (...args) {\n  if (args.length === 0) return '.'\n\n  let joined\n  let firstPart\n  for (let i = 0; i < args.length; ++i) {\n    const arg = args[i]\n    if (arg.length > 0) {\n      if (joined === undefined) joined = firstPart = arg\n      else joined += `\\\\${arg}`\n    }\n  }\n\n  if (joined === undefined) return '.'\n\n  let needsReplace = true\n  let slashCount = 0\n  if (isWindowsPathSeparator(firstPart.charCodeAt(0))) {\n    ++slashCount\n    const firstLen = firstPart.length\n    if (firstLen > 1 && isWindowsPathSeparator(firstPart.charCodeAt(1))) {\n      ++slashCount\n      if (firstLen > 2) {\n        if (isWindowsPathSeparator(firstPart.charCodeAt(2))) {\n          ++slashCount\n        } else {\n          needsReplace = false\n        }\n      }\n    }\n  }\n  if (needsReplace) {\n    while (slashCount < joined.length && isWindowsPathSeparator(joined.charCodeAt(slashCount))) {\n      slashCount++\n    }\n\n    if (slashCount >= 2) {\n      joined = `\\\\${joined.substring(slashCount)}`\n    }\n  }\n\n  return exports.normalize(joined)\n}\n\nexports.relative = function relative (from, to) {\n  if (from === to) return ''\n\n  const fromOrig = exports.resolve(from)\n  const toOrig = exports.resolve(to)\n\n  if (fromOrig === toOrig) return ''\n\n  from = fromOrig.toLowerCase()\n  to = toOrig.toLowerCase()\n\n  if (from === to) return ''\n\n  let fromStart = 0\n  while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n    fromStart++\n  }\n  let fromEnd = from.length\n  while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n    fromEnd--\n  }\n  const fromLen = fromEnd - fromStart\n\n  let toStart = 0\n  while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n    toStart++\n  }\n  let toEnd = to.length\n  while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n    toEnd--\n  }\n  const toLen = toEnd - toStart\n\n  const length = fromLen < toLen ? fromLen : toLen\n  let lastCommonSep = -1\n  let i = 0\n  for (; i < length; i++) {\n    const fromCode = from.charCodeAt(fromStart + i)\n    if (fromCode !== to.charCodeAt(toStart + i)) {\n      break\n    } else if (fromCode === CHAR_BACKWARD_SLASH) {\n      lastCommonSep = i\n    }\n  }\n\n  if (i !== length) {\n    if (lastCommonSep === -1) return toOrig\n  } else {\n    if (toLen > length) {\n      if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n        return toOrig.substring(toStart + i + 1)\n      }\n      if (i === 2) {\n        return toOrig.substring(toStart + i)\n      }\n    }\n    if (fromLen > length) {\n      if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n        lastCommonSep = i\n      } else if (i === 2) {\n        lastCommonSep = 3\n      }\n    }\n    if (lastCommonSep === -1) lastCommonSep = 0\n  }\n\n  let out = ''\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n      out += out.length === 0 ? '..' : '\\\\..'\n    }\n  }\n\n  toStart += lastCommonSep\n\n  if (out.length > 0) {\n    return `${out}${toOrig.substring(toStart, toEnd)}`\n  }\n  if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n    ++toStart\n  }\n  return toOrig.substring(toStart, toEnd)\n}\n\nexports.toNamespacedPath = function toNamespacedPath (path) {\n  if (path.length === 0) return path\n\n  const resolvedPath = exports.resolve(path)\n\n  if (resolvedPath.length <= 2) return path\n\n  if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n    if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n      const code = resolvedPath.charCodeAt(2)\n      if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n        return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.substring(2)}`\n      }\n    }\n  } else if (\n    isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n      resolvedPath.charCodeAt(1) === CHAR_COLON &&\n      resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH\n  ) {\n    return `\\\\\\\\?\\\\${resolvedPath}`\n  }\n\n  return path\n}\n\nexports.dirname = function dirname (path) {\n  const len = path.length\n  if (len === 0) return '.'\n  let rootEnd = -1\n  let offset = 0\n  const code = path.charCodeAt(0)\n\n  if (len === 1) {\n    return isWindowsPathSeparator(code) ? path : '.'\n  }\n\n  if (isWindowsPathSeparator(code)) {\n    rootEnd = offset = 1\n\n    if (isWindowsPathSeparator(path.charCodeAt(1))) {\n      let j = 2\n      let last = j\n      while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {\n        j++\n      }\n      if (j < len && j !== last) {\n        last = j\n        while (j < len && isWindowsPathSeparator(path.charCodeAt(j))) {\n          j++\n        }\n        if (j < len && j !== last) {\n          last = j\n          while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {\n            j++\n          }\n          if (j === len) {\n            return path\n          }\n          if (j !== last) {\n            rootEnd = offset = j + 1\n          }\n        }\n      }\n    }\n  } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n    rootEnd = len > 2 && isWindowsPathSeparator(path.charCodeAt(2)) ? 3 : 2\n    offset = rootEnd\n  }\n\n  let end = -1\n  let matchedSlash = true\n  for (let i = len - 1; i >= offset; --i) {\n    if (isWindowsPathSeparator(path.charCodeAt(i))) {\n      if (!matchedSlash) {\n        end = i\n        break\n      }\n    } else {\n      matchedSlash = false\n    }\n  }\n\n  if (end === -1) {\n    if (rootEnd === -1) return '.'\n\n    end = rootEnd\n  }\n  return path.substring(0, end)\n}\n\nexports.basename = function basename (path, suffix) {\n  let start = 0\n  let end = -1\n  let matchedSlash = true\n\n  if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {\n    start = 2\n  }\n\n  if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n    if (suffix === path) return ''\n    let extIdx = suffix.length - 1\n    let firstNonSlashEnd = -1\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = path.charCodeAt(i)\n      if (isWindowsPathSeparator(code)) {\n        if (!matchedSlash) {\n          start = i + 1\n          break\n        }\n      } else {\n        if (firstNonSlashEnd === -1) {\n          matchedSlash = false\n          firstNonSlashEnd = i + 1\n        }\n        if (extIdx >= 0) {\n          if (code === suffix.charCodeAt(extIdx)) {\n            if (--extIdx === -1) {\n              end = i\n            }\n          } else {\n            extIdx = -1\n            end = firstNonSlashEnd\n          }\n        }\n      }\n    }\n\n    if (start === end) end = firstNonSlashEnd\n    else if (end === -1) end = path.length\n    return path.substring(start, end)\n  }\n  for (let i = path.length - 1; i >= start; --i) {\n    if (isWindowsPathSeparator(path.charCodeAt(i))) {\n      if (!matchedSlash) {\n        start = i + 1\n        break\n      }\n    } else if (end === -1) {\n      matchedSlash = false\n      end = i + 1\n    }\n  }\n\n  if (end === -1) return ''\n  return path.substring(start, end)\n}\n\nexports.extname = function extname (path) {\n  let start = 0\n  let startDot = -1\n  let startPart = 0\n  let end = -1\n  let matchedSlash = true\n  let preDotState = 0\n\n  if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {\n    start = startPart = 2\n  }\n\n  for (let i = path.length - 1; i >= start; --i) {\n    const code = path.charCodeAt(i)\n    if (isWindowsPathSeparator(code)) {\n      if (!matchedSlash) {\n        startPart = i + 1\n        break\n      }\n      continue\n    }\n    if (end === -1) {\n      matchedSlash = false\n      end = i + 1\n    }\n    if (code === CHAR_DOT) {\n      if (startDot === -1) startDot = i\n      else if (preDotState !== 1) preDotState = 1\n    } else if (startDot !== -1) {\n      preDotState = -1\n    }\n  }\n\n  if (startDot === -1 || end === -1 || preDotState === 0 || (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {\n    return ''\n  }\n  return path.substring(startDot, end)\n}\n{\n  \"name\": \"bare-path\",\n  \"version\": \"3.0.0\",\n  \"description\": \"Path manipulation library for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\",\n    \"./posix\": \"./lib/posix.js\",\n    \"./win32\": \"./lib/win32.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"lib\",\n    \"NOTICE\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-path.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-path/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-path#readme\",\n  \"dependencies\": {\n    \"bare-os\": \"^3.0.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst stream = require('streamx')\n\nconst defaultEncoding = 'utf8'\n\nmodule.exports = exports = stream.Stream\n\nexports.pipeline = stream.pipeline\n\nexports.isStream = stream.isStream\nexports.isEnded = stream.isEnded\nexports.isFinished = stream.isFinished\nexports.isDisturbed = stream.isDisturbed\n\nexports.getStreamError = stream.getStreamError\n\nexports.Stream = exports\n\nexports.Readable = class Readable extends stream.Readable {\n  constructor(opts = {}) {\n    super({\n      ...opts,\n      byteLength: null,\n      byteLengthReadable: null,\n      map: null,\n      mapReadable: null\n    })\n\n    if (this._construct) this._open = this._construct\n\n    if (this._read !== stream.Readable.prototype._read) {\n      this._read = read.bind(this, this._read)\n    }\n\n    if (this._destroy !== stream.Stream.prototype._destroy) {\n      this._destroy = destroy.bind(this, this._destroy)\n    }\n  }\n\n  push(chunk, encoding) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    }\n\n    return super.push(chunk)\n  }\n\n  unshift(chunk, encoding) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    }\n\n    super.unshift(chunk)\n  }\n}\n\nexports.Writable = class Writable extends stream.Writable {\n  constructor(opts = {}) {\n    super({\n      ...opts,\n      byteLength: null,\n      byteLengthWritable,\n      map: null,\n      mapWritable: null\n    })\n\n    if (this._construct) this._open = this._construct\n\n    if (this._write !== stream.Writable.prototype._write) {\n      this._write = write.bind(this, this._write)\n    }\n\n    if (this._destroy !== stream.Stream.prototype._destroy) {\n      this._destroy = destroy.bind(this, this._destroy)\n    }\n  }\n\n  write(chunk, encoding, cb) {\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (typeof chunk === 'string') {\n      encoding = encoding || defaultEncoding\n      chunk = Buffer.from(chunk, encoding)\n    } else {\n      encoding = 'buffer'\n    }\n\n    const result = super.write({ chunk, encoding })\n\n    if (cb) stream.Writable.drained(this).then(() => cb(null), cb)\n\n    return result\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') {\n      cb = chunk\n      chunk = null\n    } else if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (typeof chunk === 'string') {\n      encoding = encoding || defaultEncoding\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    } else {\n      encoding = 'buffer'\n    }\n\n    const result =\n      chunk !== undefined && chunk !== null\n        ? super.end({ chunk, encoding })\n        : super.end()\n\n    if (cb) this.once('end', () => cb(null))\n\n    return result\n  }\n}\n\nexports.Duplex = class Duplex extends stream.Duplex {\n  constructor(opts = {}) {\n    super({\n      ...opts,\n      byteLength: null,\n      byteLengthReadable: null,\n      byteLengthWritable,\n      map: null,\n      mapReadable: null,\n      mapWritable: null\n    })\n\n    if (this._construct) this._open = this._construct\n\n    if (this._read !== stream.Readable.prototype._read) {\n      this._read = read.bind(this, this._read)\n    }\n\n    if (this._write !== stream.Duplex.prototype._write) {\n      this._write = write.bind(this, this._write)\n    }\n\n    if (this._destroy !== stream.Stream.prototype._destroy) {\n      this._destroy = destroy.bind(this, this._destroy)\n    }\n  }\n\n  push(chunk, encoding) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    }\n\n    return super.push(chunk)\n  }\n\n  unshift(chunk, encoding) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    }\n\n    super.unshift(chunk)\n  }\n\n  write(chunk, encoding, cb) {\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (typeof chunk === 'string') {\n      encoding = encoding || defaultEncoding\n      chunk = Buffer.from(chunk, encoding)\n    } else {\n      encoding = 'buffer'\n    }\n\n    const result = super.write({ chunk, encoding })\n\n    if (cb) stream.Writable.drained(this).then(() => cb(null), cb)\n\n    return result\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') {\n      cb = chunk\n      chunk = null\n    } else if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (typeof chunk === 'string') {\n      encoding = encoding || defaultEncoding\n      chunk = Buffer.from(chunk, encoding)\n    } else {\n      encoding = 'buffer'\n    }\n\n    const result =\n      chunk !== undefined && chunk !== null\n        ? super.end({ chunk, encoding })\n        : super.end()\n\n    if (cb) this.once('end', () => cb(null))\n\n    return result\n  }\n}\n\nexports.Transform = class Transform extends stream.Transform {\n  constructor(opts = {}) {\n    super({\n      ...opts,\n      byteLength: null,\n      byteLengthReadable: null,\n      byteLengthWritable,\n      map: null,\n      mapReadable: null,\n      mapWritable: null\n    })\n\n    if (this._transform !== stream.Transform.prototype._transform) {\n      this._transform = transform.bind(this, this._transform)\n    } else {\n      this._transform = passthrough\n    }\n  }\n\n  push(chunk, encoding) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    }\n\n    return super.push(chunk)\n  }\n\n  unshift(chunk, encoding) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    }\n\n    super.unshift(chunk)\n  }\n\n  write(chunk, encoding, cb) {\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (typeof chunk === 'string') {\n      encoding = encoding || defaultEncoding\n      chunk = Buffer.from(chunk, encoding)\n    } else {\n      encoding = 'buffer'\n    }\n\n    const result = super.write({ chunk, encoding })\n\n    if (cb) stream.Writable.drained(this).then(() => cb(null), cb)\n\n    return result\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') {\n      cb = chunk\n      chunk = null\n    } else if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (typeof chunk === 'string') {\n      encoding = encoding || defaultEncoding\n      chunk = Buffer.from(chunk, encoding)\n    } else {\n      encoding = 'buffer'\n    }\n\n    const result =\n      chunk !== undefined && chunk !== null\n        ? super.end({ chunk, encoding })\n        : super.end()\n\n    if (cb) this.once('end', () => cb(null))\n\n    return result\n  }\n}\n\nexports.PassThrough = class PassThrough extends exports.Transform {}\n\nexports.finished = function finished(stream, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  if (!opts) opts = {}\n\n  const { cleanup = false } = opts\n\n  const done = () => {\n    cb(exports.getStreamError(stream, { all: true }))\n\n    if (cleanup) detach()\n  }\n\n  const detach = () => {\n    stream.off('close', done)\n    stream.off('error', noop)\n  }\n\n  if (stream.destroyed) {\n    done()\n  } else {\n    stream.on('close', done)\n    stream.on('error', noop)\n  }\n\n  return detach\n}\n\nfunction read(read, cb) {\n  read.call(this, 65536)\n\n  cb(null)\n}\n\nfunction write(write, data, cb) {\n  write.call(this, data.chunk, data.encoding, cb)\n}\n\nfunction transform(transform, data, cb) {\n  transform.call(this, data.chunk, data.encoding, cb)\n}\n\nfunction destroy(destroy, cb) {\n  destroy.call(this, exports.getStreamError(this), cb)\n}\n\nfunction passthrough(data, cb) {\n  cb(null, data.chunk)\n}\n\nfunction byteLengthWritable(data) {\n  return data.chunk.byteLength\n}\n\nfunction noop() {}\n{\n  \"name\": \"bare-stream\",\n  \"version\": \"2.6.5\",\n  \"description\": \"Streaming data for JavaScript\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./package\": \"./package.json\",\n    \"./promises\": \"./promises.js\",\n    \"./web\": \"./web.js\",\n    \"./global\": \"./global.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"promises.js\",\n    \"web.js\",\n    \"global.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-stream.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-stream/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-stream#readme\",\n  \"dependencies\": {\n    \"streamx\": \"^2.21.0\"\n  },\n  \"devDependencies\": {\n    \"bare-buffer\": \"^3.0.0\",\n    \"bare-events\": \"^2.5.4\",\n    \"brittle\": \"^3.5.2\",\n    \"prettier\": \"^3.3.3\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  },\n  \"peerDependencies\": {\n    \"bare-buffer\": \"*\",\n    \"bare-events\": \"*\"\n  },\n  \"peerDependenciesMeta\": {\n    \"bare-buffer\": {\n      \"optional\": true\n    },\n    \"bare-events\": {\n      \"optional\": true\n    }\n  }\n}\nmodule.exports = require.addon()\n/* global Bare */\nconst EventEmitter = require('bare-events')\nconst { Duplex } = require('bare-stream')\nconst dns = require('bare-dns')\nconst binding = require('./binding')\nconst constants = require('./lib/constants')\nconst errors = require('./lib/errors')\nconst ip = require('./lib/ip')\n\nconst defaultReadBufferSize = 65536\n\nconst Socket = exports.Socket = class TCPSocket extends Duplex {\n  constructor (opts = {}) {\n    super({ eagerOpen: true })\n\n    const {\n      readBufferSize = defaultReadBufferSize,\n      allowHalfOpen = true\n    } = opts\n\n    this._state = 0\n\n    this._allowHalfOpen = allowHalfOpen\n\n    this._remotePort = -1\n    this._remoteHost = null\n    this._remoteFamily = 0\n\n    this._pendingOpen = null\n    this._pendingWrite = null\n    this._pendingFinal = null\n    this._pendingDestroy = null\n\n    this._timer = null\n    this._timeout = 0\n\n    this._buffer = Buffer.alloc(readBufferSize)\n\n    this._handle = binding.init(this._buffer, this,\n      noop,\n      this._onconnect,\n      this._onread,\n      this._onwrite,\n      this._onfinal,\n      this._onclose\n    )\n\n    TCPSocket._sockets.add(this)\n  }\n\n  get connecting () {\n    return (this._state & constants.state.CONNECTING) !== 0\n  }\n\n  get pending () {\n    return (this._state & constants.state.CONNECTED) === 0\n  }\n\n  get timeout () {\n    return this._timeout || undefined // For Node.js compatibility\n  }\n\n  connect (port, host = 'localhost', opts = {}, onconnect) {\n    if (this._state & constants.state.CONNECTING || this._state & constants.state.CONNECTED) {\n      throw errors.SOCKET_ALREADY_CONNECTED('Socket is already connected')\n    }\n\n    this._state |= constants.state.CONNECTING\n\n    if (typeof host === 'function') {\n      onconnect = host\n      host = 'localhost'\n    } else if (typeof opts === 'function') {\n      onconnect = opts\n      opts = {}\n    }\n\n    let family = 0\n\n    if (typeof port === 'object' && port !== null) {\n      opts = port || {}\n      port = opts.port || 0\n      host = opts.host || 'localhost'\n      family = opts.family || 0\n    }\n\n    if (!host) host = 'localhost'\n\n    const type = ip.isIP(host)\n\n    if (type === 0) {\n      const {\n        lookup = dns.lookup,\n        hints\n      } = opts\n\n      lookup(host, { family, hints }, (err, address, family) => {\n        this.emit('lookup', err, address, family, host)\n\n        this._state &= ~constants.state.CONNECTING\n\n        if (err) {\n          if (this._pendingOpen) this._continueOpen(err)\n          else this.destroy(err)\n          return\n        }\n\n        if (this._handle !== null) {\n          this.connect(port, address, { ...opts, family }, onconnect)\n        }\n      })\n\n      return this\n    }\n\n    family = type\n\n    try {\n      binding.connect(this._handle, port, host, family)\n\n      if (opts.keepAlive === true) this.setKeepAlive(opts.keepAlive, opts.keepAliveInitialDelay)\n      if (opts.noDelay === true) this.setNoDelay()\n      if (opts.timeout) this.setTimeout(opts.timeout)\n\n      this._remotePort = port\n      this._remoteHost = host\n      this._remoteFamily = family\n\n      if (onconnect) this.once('connect', onconnect)\n    } catch (err) {\n      queueMicrotask(() => {\n        if (this._pendingOpen) this._pendingOpen(err)\n        else this.destroy(err)\n      })\n    }\n\n    return this\n  }\n\n  setKeepAlive (enable = false, delay = 0) {\n    if (typeof enable === 'number') {\n      delay = enable\n      enable = false\n    }\n\n    delay = Math.floor(delay / 1000)\n\n    if (delay === 0) enable = false\n\n    binding.keepalive(this._handle, enable, delay)\n\n    return this\n  }\n\n  setNoDelay (enable = true) {\n    binding.nodelay(this._handle, enable)\n\n    return this\n  }\n\n  setTimeout (ms, ontimeout) {\n    if (ms === 0) {\n      clearTimeout(this._timer)\n      this._timer = null\n    } else {\n      if (ontimeout) this.once('timeout', ontimeout)\n\n      this._timer = setTimeout(() => this.emit('timeout'), ms)\n      this._timer.unref()\n    }\n\n    this._timeout = ms\n\n    return this\n  }\n\n  ref () {\n    binding.ref(this._handle)\n  }\n\n  unref () {\n    binding.unref(this._handle)\n  }\n\n  _open (cb) {\n    if (this._state & constants.state.CONNECTED) return cb(null)\n    this._pendingOpen = cb\n  }\n\n  _read () {\n    if ((this._state & constants.state.READING) === 0) {\n      this._state |= constants.state.READING\n      binding.resume(this._handle)\n    }\n  }\n\n  _writev (batch, cb) {\n    this._pendingWrite = [cb, batch]\n    binding.writev(this._handle, batch.map(({ chunk }) => chunk))\n  }\n\n  _final (cb) {\n    this._pendingFinal = cb\n    binding.end(this._handle)\n  }\n\n  _predestroy () {\n    if (this._state & constants.state.CLOSING) return\n    this._state |= constants.state.CLOSING\n    binding.close(this._handle)\n    TCPSocket._sockets.delete(this)\n  }\n\n  _destroy (err, cb) {\n    if (this._state & constants.state.CLOSING) return cb(err)\n    this._state |= constants.state.CLOSING\n    this._pendingDestroy = cb\n    binding.close(this._handle)\n    TCPSocket._sockets.delete(this)\n  }\n\n  _continueOpen (err) {\n    if (this._pendingOpen === null) return\n    const cb = this._pendingOpen\n    this._pendingOpen = null\n    cb(err)\n  }\n\n  _continueWrite (err) {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite[0]\n    this._pendingWrite = null\n    cb(err)\n  }\n\n  _continueFinal (err) {\n    if (this._pendingFinal === null) return\n    const cb = this._pendingFinal\n    this._pendingFinal = null\n    cb(err)\n  }\n\n  _continueDestroy () {\n    if (this._pendingDestroy === null) return\n    const cb = this._pendingDestroy\n    this._pendingDestroy = null\n    cb(null)\n  }\n\n  _onconnect (err) {\n    if (err) {\n      if (this._pendingOpen) this._continueOpen(err)\n      else this.destroy(err)\n      return\n    }\n\n    this._state |= constants.state.CONNECTED\n    this._state &= ~constants.state.CONNECTING\n    this._continueOpen()\n\n    this.emit('connect')\n  }\n\n  _onread (err, read) {\n    if (this._timer) this._timer.refresh()\n\n    if (err) {\n      this.destroy(err)\n      return\n    }\n\n    if (read === 0) {\n      this.push(null)\n      if (this._allowHalfOpen === false) this.end()\n      return\n    }\n\n    const copy = Buffer.allocUnsafe(read)\n    copy.set(this._buffer.subarray(0, read))\n\n    if (this.push(copy) === false && this.destroying === false) {\n      this._state &= ~constants.state.READING\n      binding.pause(this._handle)\n    }\n  }\n\n  _onwrite (err) {\n    if (this._timer) this._timer.refresh()\n\n    this._continueWrite(err)\n  }\n\n  _onfinal (err) {\n    this._continueFinal(err)\n  }\n\n  _onclose () {\n    clearTimeout(this._timer)\n\n    this._handle = null\n    this._continueDestroy()\n  }\n\n  static _sockets = new Set()\n}\n\nconst Server = exports.Server = class TCPServer extends EventEmitter {\n  constructor (opts = {}, onconnection) {\n    if (typeof opts === 'function') {\n      onconnection = opts\n      opts = {}\n    }\n\n    super()\n\n    const {\n      readBufferSize = defaultReadBufferSize,\n      allowHalfOpen = true\n    } = opts\n\n    this._state = 0\n\n    this._readBufferSize = readBufferSize\n    this._allowHalfOpen = allowHalfOpen\n\n    this._keepAlive = opts.keepAlive\n    this._keepAliveDelay = opts.keepAliveInitialDelay\n    this._noDelay = opts.noDelay\n\n    this._port = -1\n    this._host = null\n    this._family = 0\n    this._connections = new Set()\n\n    this._error = null\n    this._handle = null\n\n    if (onconnection) this.on('connection', onconnection)\n\n    TCPServer._servers.add(this)\n  }\n\n  get listening () {\n    return (this._state & constants.state.BOUND) !== 0\n  }\n\n  address () {\n    if ((this._state & constants.state.BOUND) === 0) {\n      return null\n    }\n\n    return {\n      address: this._host,\n      family: `IPv${this._family}`,\n      port: this._port\n    }\n  }\n\n  listen (port = 0, host = 'localhost', backlog = 511, opts = {}, onlistening) {\n    if (this._state & constants.state.BINDING || this._state & constants.state.BOUND) {\n      throw errors.SERVER_ALREADY_LISTENING('Server is already listening')\n    }\n\n    if (this._state & constants.state.CLOSING) {\n      throw errors.SERVER_IS_CLOSED('Server is closed')\n    }\n\n    this._state |= constants.state.BINDING\n\n    if (typeof port === 'function') {\n      onlistening = port\n      port = 0\n    } else if (typeof host === 'function') {\n      onlistening = host\n      host = 'localhost'\n    } else if (typeof backlog === 'function') {\n      onlistening = backlog\n      backlog = 511\n    } else if (typeof opts === 'function') {\n      onlistening = opts\n      opts = {}\n    }\n\n    let family = 0\n\n    if (typeof port === 'object' && port !== null) {\n      opts = port || {}\n      port = opts.port || 0\n      host = opts.host || 'localhost'\n      family = opts.family || 0\n      backlog = opts.backlog || 511\n    }\n\n    if (!host) host = 'localhost'\n    if (!backlog) backlog = 511\n\n    const type = ip.isIP(host)\n\n    if (type === 0) {\n      const {\n        lookup = dns.lookup,\n        hints\n      } = opts\n\n      lookup(host, { family, hints }, (err, address, family) => {\n        if (this._state & constants.state.CLOSING) return\n\n        this.emit('lookup', err, address, family, host)\n\n        this._state &= ~constants.state.BINDING\n\n        if (err) return this.emit('error', err)\n\n        this.listen(port, address, backlog, { ...opts, family }, onlistening)\n      })\n\n      return this\n    }\n\n    family = type\n\n    this._handle = binding.init(empty, this,\n      this._onconnection,\n      noop,\n      noop,\n      noop,\n      noop,\n      this._onclose\n    )\n\n    if (this._state & constants.state.UNREFED) binding.unref(this._handle)\n\n    try {\n      this._port = binding.bind(this._handle, port, host, backlog, family)\n      this._host = host\n      this._family = family\n      this._state |= constants.state.BOUND\n      this._state &= ~constants.state.BINDING\n\n      if (onlistening) this.once('listening', onlistening)\n\n      queueMicrotask(() => this.emit('listening'))\n    } catch (err) {\n      this._error = err\n\n      binding.close(this._handle)\n    }\n\n    return this\n  }\n\n  close (onclose) {\n    if (onclose) this.once('close', onclose)\n    if (this._state & constants.state.CLOSING) return\n    this._state |= constants.state.CLOSING\n    this._closeMaybe()\n  }\n\n  ref () {\n    this._state &= ~constants.state.UNREFED\n    if (this._handle !== null) binding.ref(this._handle)\n  }\n\n  unref () {\n    this._state |= constants.state.UNREFED\n    if (this._handle !== null) binding.unref(this._handle)\n  }\n\n  _closeMaybe () {\n    if ((this._state & constants.state.CLOSING) && this._connections.size === 0) {\n      if (this._handle !== null) binding.close(this._handle)\n      else queueMicrotask(() => this.emit('close'))\n      TCPServer._servers.delete(this)\n    }\n  }\n\n  _onconnection (err) {\n    if (err) {\n      this.emit('error', err)\n      return\n    }\n\n    if (this._state & constants.state.CLOSING) return\n\n    const socket = new Socket({\n      readBufferSize: this._readBufferSize,\n      allowHalfOpen: this._allowHalfOpen\n    })\n\n    try {\n      binding.accept(this._handle, socket._handle)\n\n      socket._state |= constants.state.CONNECTED\n\n      this._connections.add(socket)\n\n      if (this._keepAlive === true) socket.setKeepAlive(this._keepAlive, this._keepAliveDelay)\n      if (this._noDelay === true) socket.setNoDelay()\n\n      socket.on('close', () => {\n        this._connections.delete(socket)\n        this._closeMaybe()\n      })\n\n      this.emit('connection', socket)\n    } catch (err) {\n      socket.destroy()\n\n      throw err\n    }\n  }\n\n  _onclose () {\n    const err = this._error\n\n    this._state &= ~constants.state.BINDING\n    this._error = null\n    this._handle = null\n\n    if (err) this.emit('error', err)\n    else this.emit('close')\n  }\n\n  static _servers = new Set()\n}\n\nexports.constants = constants\nexports.errors = errors\n\nexports.isIP = ip.isIP\nexports.isIPv4 = ip.isIPv4\nexports.isIPv6 = ip.isIPv6\n\nexports.createConnection = function createConnection (port, host, opts, onconnect) {\n  if (typeof host === 'function') {\n    onconnect = host\n    host = 'localhost'\n  } else if (typeof opts === 'function') {\n    onconnect = opts\n    opts = {}\n  }\n\n  if (typeof port === 'object' && port !== null) {\n    opts = port || {}\n    port = opts.port || 0\n    host = opts.host || 'localhost'\n  }\n\n  return new Socket(opts).connect(port, host, opts, onconnect)\n}\n\n// For Node.js compatibility\nexports.connect = exports.createConnection\n\nexports.createServer = function createServer (opts, onconnection) {\n  return new Server(opts, onconnection)\n}\n\nBare\n  .on('exit', () => {\n    for (const socket of Socket._sockets) {\n      socket.destroy()\n    }\n\n    for (const server of Server._servers) {\n      server.close()\n    }\n  })\n\nconst empty = Buffer.alloc(0)\n\nfunction noop () {}\nmodule.exports = {\n  state: {\n    CONNECTING: 0x1,\n    CONNECTED: 0x2,\n    BINDING: 0x4,\n    BOUND: 0x8,\n    READING: 0x10,\n    CLOSING: 0x20,\n    UNREFED: 0x40\n  }\n}\nmodule.exports = class TCPError extends Error {\n  constructor (msg, code, fn = TCPError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name () {\n    return 'TCPError'\n  }\n\n  static SOCKET_ALREADY_CONNECTED (msg) {\n    return new TCPError(msg, 'SOCKET_ALREADY_CONNECTED', TCPError.SOCKET_ALREADY_CONNECTED)\n  }\n\n  static SERVER_ALREADY_LISTENING (msg) {\n    return new TCPError(msg, 'SERVER_ALREADY_LISTENING', TCPError.SERVER_ALREADY_LISTENING)\n  }\n\n  static SERVER_IS_CLOSED (msg) {\n    return new TCPError(msg, 'SERVER_IS_CLOSED', TCPError.SERVER_IS_CLOSED)\n  }\n\n  static INVALID_HOST (msg = 'Unrecognizable host format') {\n    return new TCPError(msg, 'INVALID_HOST', TCPError.INVALID_HOST)\n  }\n}\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`\nconst IPv4Pattern = new RegExp(`^${v4Str}$`)\n\nconst v6Seg = '(?:[0-9a-fA-F]{1,4})'\nconst IPv6Pattern = new RegExp('^(' +\n  `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` +\n  `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` +\n  `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` +\n  `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` +\n  `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` +\n  `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` +\n')(%[0-9a-zA-Z-.:]{1,})?$')\n\nconst isIPv4 = exports.isIPv4 = function isIPv4 (host) {\n  return IPv4Pattern.test(host)\n}\n\nconst isIPv6 = exports.isIPv6 = function isIPv6 (host) {\n  return IPv6Pattern.test(host)\n}\n\nexports.isIP = function isIP (host) {\n  if (isIPv4(host)) return 4\n  if (isIPv6(host)) return 6\n  return 0\n}\n{\n  \"name\": \"bare-tcp\",\n  \"version\": \"1.9.1\",\n  \"description\": \"Native TCP sockets for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\",\n    \"./constants\": \"./lib/constants.js\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"standard && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-tcp.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-tcp/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-tcp#readme\",\n  \"dependencies\": {\n    \"bare-dns\": \"^1.0.0\",\n    \"bare-events\": \"^2.2.2\",\n    \"bare-stream\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.0\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"standard\": \"^17.1.0\"\n  }\n}\nmodule.exports = require.addon()\n/* global Bare */\nconst { Duplex } = require('bare-stream')\nconst binding = require('./binding')\nconst constants = require('./lib/constants')\nconst errors = require('./lib/errors')\n\nconst readBufferSize = 65536\n\nconst context = binding.initContext()\n\nexports.Socket = class TLSSocket extends Duplex {\n  static _buffer = Buffer.alloc(readBufferSize)\n\n  constructor (socket, opts = {}) {\n    const {\n      isServer = false,\n      cert = null,\n      key = null,\n      host = null,\n      eagerOpen = true,\n      allowHalfOpen = true\n    } = opts\n\n    super({ eagerOpen })\n\n    this._state = 0\n\n    this._socket = socket\n    this._key = key\n    this._cert = cert\n    this._allowHalfOpen = allowHalfOpen\n\n    this._pendingOpen = null\n    this._pendingWrite = null\n\n    this._buffer = null\n\n    this._handle = binding.init(context, isServer, cert, key, host, this,\n      this._onread,\n      this._onwrite\n    )\n\n    TLSSocket._sockets.add(this)\n  }\n\n  get socket () {\n    return this._socket\n  }\n\n  get encrypted () {\n    return true\n  }\n\n  _onconnect () {\n    this._state |= constants.state.HANDSHAKE\n\n    this.emit('connect')\n\n    const cb = this._pendingOpen\n    this._pendingOpen = null\n    cb(null)\n  }\n\n  _ondata (data) {\n    if (this._buffer !== null) {\n      this._buffer = Buffer.concat([this._buffer, data])\n    } else {\n      this._buffer = data\n    }\n\n    while (this._buffer !== null) {\n      if (this._state & constants.state.HANDSHAKE) {\n        let read\n        try {\n          read = binding.read(this._handle, TLSSocket._buffer)\n        } catch (err) {\n          return this.destroy(errors.from(err))\n        }\n\n        if (read < 0) break\n\n        if (read === 0) {\n          this.push(null)\n          if (this._allowHalfOpen === false) this.end()\n          return\n        }\n\n        const copy = Buffer.allocUnsafe(read)\n        copy.set(TLSSocket._buffer.subarray(0, read))\n\n        this.push(copy)\n      } else {\n        try {\n          if (binding.handshake(this._handle)) this._onconnect()\n          else break\n        } catch (err) {\n          if (this._pendingOpen) this._pendingOpen(errors.from(err))\n          else this.destroy(errors.from(err))\n          return\n        }\n      }\n    }\n  }\n\n  _ondrain () {\n    const cb = this._pendingWrite\n    this._pendingWrite = null\n    if (cb) cb(null)\n  }\n\n  _onend () {\n    this.push(null)\n  }\n\n  _onclose () {\n    this.destroy()\n  }\n\n  _onread (data) {\n    let buffer = this._buffer\n    if (buffer === null) return 0\n\n    if (buffer.byteLength > data.byteLength) {\n      const rest = buffer.subarray(data.byteLength)\n      buffer = buffer.subarray(0, data.byteLength)\n      this._buffer = rest\n    } else {\n      this._buffer = null\n    }\n\n    data.set(buffer)\n\n    return buffer.byteLength\n  }\n\n  _onwrite (data) {\n    data = Buffer.from(data)\n\n    if (this._socket.write(data)) this._pendingWrite = null\n\n    return data.byteLength\n  }\n\n  _open (cb) {\n    this._pendingOpen = cb\n\n    this._socket\n      .on('data', this._ondata.bind(this))\n      .on('drain', this._ondrain.bind(this))\n      .on('end', this._onend.bind(this))\n      .on('close', this._onclose.bind(this))\n\n    try {\n      if (binding.handshake(this._handle)) this._onconnect()\n    } catch (err) {\n      this._pendingOpen = null\n\n      cb(errors.from(err))\n    }\n  }\n\n  _write (data, encoding, cb) {\n    this._pendingWrite = cb\n\n    try {\n      binding.write(this._handle, data)\n\n      if (this._pendingWrite !== null) return\n\n      cb(null)\n    } catch (err) {\n      this._pendingWrite = null\n\n      cb(errors.from(err))\n    }\n  }\n\n  _final (cb) {\n    try {\n      binding.shutdown(this._handle)\n\n      cb(null)\n    } catch (err) {\n      cb(err)\n    }\n\n    this._socket.end()\n  }\n\n  _predestroy () {\n    binding.destroy(this._handle)\n    this._handle = null\n    TLSSocket._sockets.delete(this)\n  }\n\n  _destroy (err, cb) {\n    if (this._handle) {\n      binding.destroy(this._handle)\n      this._handle = null\n      TLSSocket._sockets.delete(this)\n    }\n    cb(err)\n  }\n\n  static _sockets = new Set()\n}\n\nexports.TLSSocket = exports.Socket // For Node.js compatibility\n\nexports.constants = constants\nexports.errors = errors\n\nBare.on('exit', () => {\n  for (const socket of exports.Socket._sockets) {\n    socket.destroy()\n  }\n\n  binding.destroyContext(context)\n})\nmodule.exports = {\n  state: {\n    HANDSHAKE: 0x1\n  }\n}\nmodule.exports = class TLSError extends Error {\n  constructor (msg, code, fn = TLSError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name () {\n    return 'TLSError'\n  }\n\n  static from (err) {\n    return new TLSError(err.message, err.code, TLSError.from)\n  }\n}\n{\n  \"name\": \"bare-tls\",\n  \"version\": \"1.2.1\",\n  \"description\": \"Transport Layer Security (TLS) streams for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\",\n    \"./constants\": \"./lib/constants.js\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"standard && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-tls.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-tls/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-tls#readme\",\n  \"dependencies\": {\n    \"bare-stream\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"bare-fs\": \"^3.0.0\",\n    \"brittle\": \"^3.1.1\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"cmake-fetch\": \"^1.0.0\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nmodule.exports = require.addon()\nconst path = require('bare-path')\nconst binding = require('./binding')\nconst errors = require('./lib/errors')\n\nconst isWindows = Bare.platform === 'win32'\n\nmodule.exports = exports = class URL {\n  static {\n    binding.tag(this)\n  }\n\n  constructor(input, base, opts = {}) {\n    if (arguments.length === 0) throw errors.INVALID_URL()\n\n    input = `${input}`\n\n    if (base !== undefined) base = `${base}`\n\n    this._components = new Uint32Array(8)\n\n    this._parse(input, base, opts.throw !== false)\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-href\n\n  get href() {\n    return this._href\n  }\n\n  set href(value) {\n    this._update(value)\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-protocol\n\n  get protocol() {\n    return this._slice(0, this._components[0]) + ':'\n  }\n\n  set protocol(value) {\n    this._update(\n      this._replace(value.replace(/:+$/, ''), 0, this._components[0])\n    )\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-username\n\n  get username() {\n    return this._slice(this._components[0] + 3 /* :// */, this._components[1])\n  }\n\n  set username(value) {\n    if (cannotHaveCredentialsOrPort(this)) {\n      return\n    }\n\n    if (this.username === '') value += '@'\n\n    this._update(\n      this._replace(\n        value,\n        this._components[0] + 3 /* :// */,\n        this._components[1]\n      )\n    )\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-password\n\n  get password() {\n    return this._href.slice(\n      this._components[1] + 1 /* : */,\n      this._components[2] - 1 /* @ */\n    )\n  }\n\n  set password(value) {\n    if (cannotHaveCredentialsOrPort(this)) {\n      return\n    }\n\n    let start = this._components[1] + 1 /* : */\n    let end = this._components[2] - 1 /* @ */\n\n    if (this.password === '') {\n      value = ':' + value\n      start--\n    }\n\n    if (this.username === '') {\n      value += '@'\n      end++\n    }\n\n    this._update(this._replace(value, start, end))\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-host\n\n  get host() {\n    return this._slice(this._components[2], this._components[5])\n  }\n\n  set host(value) {\n    if (hasOpaquePath(this)) {\n      return\n    }\n\n    this._update(\n      this._replace(\n        value,\n        this._components[2],\n        this._components[value.includes(':') ? 5 : 3]\n      )\n    )\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-hostname\n\n  get hostname() {\n    return this._slice(this._components[2], this._components[3])\n  }\n\n  set hostname(value) {\n    if (hasOpaquePath(this)) {\n      return\n    }\n\n    this._update(this._replace(value, this._components[2], this._components[3]))\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-port\n\n  get port() {\n    return this._slice(this._components[3] + 1 /* : */, this._components[5])\n  }\n\n  set port(value) {\n    if (cannotHaveCredentialsOrPort(this)) {\n      return\n    }\n\n    let start = this._components[3] + 1 /* : */\n\n    if (this.port === '') {\n      value = ':' + value\n      start--\n    }\n\n    this._update(this._replace(value, start, this._components[5]))\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-pathname\n\n  get pathname() {\n    return this._slice(this._components[5], this._components[6] - 1 /* ? */)\n  }\n\n  set pathname(value) {\n    if (hasOpaquePath(this)) {\n      return\n    }\n\n    if (value[0] !== '/' && value[0] !== '\\\\') {\n      value = '/' + value\n    }\n\n    this._update(\n      this._replace(value, this._components[5], this._components[6] - 1 /* ? */)\n    )\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-search\n\n  get search() {\n    return this._slice(\n      this._components[6] - 1 /* ? */,\n      this._components[7] - 1 /* # */\n    )\n  }\n\n  set search(value) {\n    if (value && value[0] !== '?') value = '?' + value\n\n    this._update(\n      this._replace(\n        value,\n        this._components[6] - 1 /* ? */,\n        this._components[7] - 1 /* # */\n      )\n    )\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-hash\n\n  get hash() {\n    return this._slice(this._components[7] - 1 /* # */)\n  }\n\n  set hash(value) {\n    if (value && value[0] !== '#') value = '#' + value\n\n    this._update(this._replace(value, this._components[7] - 1 /* # */))\n  }\n\n  toString() {\n    return this._href\n  }\n\n  toJSON() {\n    return this._href\n  }\n\n  [Symbol.for('bare.inspect')]() {\n    return {\n      __proto__: { constructor: URL },\n\n      href: this.href,\n      protocol: this.protocol,\n      username: this.username,\n      password: this.password,\n      host: this.host,\n      hostname: this.hostname,\n      port: this.port,\n      pathname: this.pathname,\n      search: this.search,\n      hash: this.hash\n    }\n  }\n\n  _slice(start, end = this._href.length) {\n    return this._href.slice(start, end)\n  }\n\n  _replace(replacement, start, end = this._href.length) {\n    return this._slice(0, start) + replacement + this._slice(end)\n  }\n\n  _parse(href, base, shouldThrow) {\n    try {\n      this._href = binding.parse(\n        String(href),\n        base ? String(base) : null,\n        this._components,\n        shouldThrow\n      )\n    } catch (err) {\n      if (err instanceof TypeError) throw err\n\n      throw errors.INVALID_URL()\n    }\n  }\n\n  _update(href) {\n    try {\n      this._parse(href, null, true)\n    } catch (err) {\n      if (err instanceof TypeError) throw err\n    }\n  }\n}\n\n// https://url.spec.whatwg.org/#url-opaque-path\nfunction hasOpaquePath(url) {\n  return url.pathname[0] !== '/'\n}\n\n// https://url.spec.whatwg.org/#cannot-have-a-username-password-port\nfunction cannotHaveCredentialsOrPort(url) {\n  return url.hostname === '' || url.protocol === 'file:'\n}\n\nconst URL = exports\n\nexports.URL = URL // For Node.js compatibility\n\nexports.errors = errors\n\nexports.isURL = function isURL(value) {\n  if (typeof value !== 'object' || value === null) return false\n\n  let constructor = value.constructor\n\n  while (typeof constructor === 'function') {\n    if (binding.isTagged(constructor)) return true\n\n    constructor = Reflect.getPrototypeOf(constructor)\n  }\n\n  return false\n}\n\nexports.parse = function parse(input, base) {\n  const url = new URL(input, base, { throw: false })\n  return url.href ? url : null\n}\n\nexports.canParse = function canParse(input, base) {\n  return binding.canParse(String(input), base ? String(base) : null)\n}\n\nexports.fileURLToPath = function fileURLToPath(url) {\n  if (typeof url === 'string') {\n    url = new URL(url)\n  }\n\n  if (url.protocol !== 'file:') {\n    throw errors.INVALID_URL_SCHEME('The URL must use the file: protocol')\n  }\n\n  if (isWindows) {\n    if (/%2f|%5c/i.test(url.pathname)) {\n      throw errors.INVALID_FILE_URL_PATH(\n        'The file: URL path must not include encoded \\\\ or / characters'\n      )\n    }\n  } else {\n    if (url.hostname) {\n      throw errors.INVALID_FILE_URL_HOST(\n        \"The file: URL host must be 'localhost' or empty\"\n      )\n    }\n\n    if (/%2f/i.test(url.pathname)) {\n      throw errors.INVALID_FILE_URL_PATH(\n        'The file: URL path must not include encoded / characters'\n      )\n    }\n  }\n\n  const pathname = path.normalize(decodeURIComponent(url.pathname))\n\n  if (isWindows) {\n    if (url.hostname) return '\\\\\\\\' + url.hostname + pathname\n\n    const letter = pathname.charCodeAt(1) | 0x20\n\n    if (\n      letter < 0x61 /* a */ ||\n      letter > 0x7a /* z */ ||\n      pathname.charCodeAt(2) !== 0x3a /* : */\n    ) {\n      throw errors.INVALID_FILE_URL_PATH('The file: URL path must be absolute')\n    }\n\n    return pathname.slice(1)\n  }\n\n  return pathname\n}\n\nexports.pathToFileURL = function pathToFileURL(pathname) {\n  let resolved = path.resolve(pathname)\n\n  if (pathname[pathname.length - 1] === '/') {\n    resolved += '/'\n  } else if (isWindows && pathname[pathname.length - 1] === '\\\\') {\n    resolved += '\\\\'\n  }\n\n  resolved = resolved\n    .replaceAll('%', '%25') // Must be first\n    .replaceAll('#', '%23')\n    .replaceAll('?', '%3f')\n    .replaceAll('\\n', '%0a')\n    .replaceAll('\\r', '%0d')\n    .replaceAll('\\t', '%09')\n\n  if (!isWindows) {\n    resolved = resolved.replaceAll('\\\\', '%5c')\n  }\n\n  return new URL('file:' + resolved)\n}\nmodule.exports = class URLError extends Error {\n  constructor(msg, code, fn = URLError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'URLError'\n  }\n\n  static INVALID_URL(msg = 'Invalid URL') {\n    return new URLError(msg, 'INVALID_URL', URLError.INVALID_URL)\n  }\n\n  static INVALID_URL_SCHEME(msg = 'Invalid URL') {\n    return new URLError(msg, 'INVALID_URL_SCHEME', URLError.INVALID_URL_SCHEME)\n  }\n\n  static INVALID_FILE_URL_HOST(msg = 'Invalid file: URL host') {\n    return new URLError(\n      msg,\n      'INVALID_FILE_URL_HOST',\n      URLError.INVALID_FILE_URL_HOST\n    )\n  }\n\n  static INVALID_FILE_URL_PATH(msg = 'Invalid file: URL path') {\n    return new URLError(\n      msg,\n      'INVALID_FILE_URL_PATH',\n      URLError.INVALID_FILE_URL_PATH\n    )\n  }\n}\n{\n  \"name\": \"bare-url\",\n  \"version\": \"2.1.3\",\n  \"description\": \"WHATWG URL implementation for JavaScript\",\n  \"exports\": {\n    \"./package\": \"./package.json\",\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./global\": {\n      \"types\": \"./global.d.ts\",\n      \"default\": \"./global.js\"\n    }\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"global.js\",\n    \"global.d.ts\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-url.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-url/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-url\",\n  \"dependencies\": {\n    \"bare-path\": \"^3.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"cmake-fetch\": \"^1.0.0\",\n    \"prettier\": \"^3.3.3\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nexports.Server = require('./lib/server')\nexports.Socket = require('./lib/socket')\nconst EOL = exports.EOL = '\\r\\n'\n\nexports.EOF = EOL.repeat(2)\n\nexports.GUID = Buffer.from('258EAFA5-E914-47DA-95CA-C5AB0DC85B11')\n\n// https://datatracker.ietf.org/doc/html/rfc6455#section-11.8\nexports.opcode = {\n  CONTINUATION: 0x0,\n  TEXT: 0x1,\n  BINARY: 0x2,\n  CLOSE: 0x8,\n  PING: 0x9,\n  PONG: 0xa\n}\n\n// https://datatracker.ietf.org/doc/html/rfc6455#section-7.4.1\nexports.status = {\n  PROTOCOL_ERROR: 1002,\n  MESSAGE_TOO_LARGE: 1009\n}\nconst { status } = require('./constants')\n\nmodule.exports = class WebSocketError extends Error {\n  constructor (msg, code, status, fn = WebSocketError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n    this.status = status\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name () {\n    return 'WebSocketError'\n  }\n\n  static NOT_CONNECTED (msg = 'Socket is not connected') {\n    return new WebSocketError(msg, 'NOT_CONNECTED', 0, WebSocketError.NOT_CONNECTED)\n  }\n\n  static UNEXPECTED_RSV1 (msg = 'RSV1 must be unset') {\n    return new WebSocketError(msg, 'UNEXPECTED_RSV1', status.PROTOCOL_ERROR, WebSocketError.UNEXPECTED_RSV1)\n  }\n\n  static UNEXPECTED_RSV2 (msg = 'RSV2 must be unset') {\n    return new WebSocketError(msg, 'UNEXPECTED_RSV2', status.PROTOCOL_ERROR, WebSocketError.UNEXPECTED_RSV2)\n  }\n\n  static UNEXPECTED_RSV3 (msg = 'RSV3 must be unset') {\n    return new WebSocketError(msg, 'UNEXPECTED_RSV3', status.PROTOCOL_ERROR, WebSocketError.UNEXPECTED_RSV3)\n  }\n\n  static EXPECTED_MASK (msg = 'MASK must be set') {\n    return new WebSocketError(msg, 'EXPECTED_MASK', status.PROTOCOL_ERROR, WebSocketError.EXPECTED_MASK)\n  }\n\n  static UNEXPECTED_MASK (msg = 'MASK must be unset') {\n    return new WebSocketError(msg, 'UNEXPECTED_MASK', status.PROTOCOL_ERROR, WebSocketError.UNEXPECTED_MASK)\n  }\n\n  static EXPECTED_CONTINUATION (msg = 'Expected a continuation frame') {\n    return new WebSocketError(msg, 'EXPECTED_CONTINUATION', status.PROTOCOL_ERROR, WebSocketError.EXPECTED_CONTINUATION)\n  }\n\n  static UNEXPECTED_CONTINUATION (msg = 'Unexpected continuation frame') {\n    return new WebSocketError(msg, 'UNEXPECTED_CONTINUATION', status.PROTOCOL_ERROR, WebSocketError.UNEXPECTED_CONTINUATION)\n  }\n\n  static UNEXPECTED_CONTROL (msg = 'Unexpected control frame') {\n    return new WebSocketError(msg, 'UNEXPECTED_CONTROL', status.PROTOCOL_ERROR, WebSocketError.UNEXPECTED_CONTROL)\n  }\n\n  static INVALID_ENCODING (msg = 'Invalid encoding') {\n    return new WebSocketError(msg, 'INVALID_ENCODING', status.PROTOCOL_ERROR, WebSocketError.INVALID_ENCODING)\n  }\n\n  static INVALID_UPGRADE_HEADER (msg = 'Invalid Upgrade header') {\n    return new WebSocketError(msg, 'INVALID_UPGRADE_HEADER', status.PROTOCOL_ERROR, WebSocketError.INVALID_UPGRADE_HEADER)\n  }\n\n  static INVALID_VERSION_HEADER (msg = 'Invalid Sec-WebSocket-Version header') {\n    return new WebSocketError(msg, 'INVALID_VERSION_HEADER', status.PROTOCOL_ERROR, WebSocketError.INVALID_VERSION_HEADER)\n  }\n\n  static INVALID_KEY_HEADER (msg = 'Invalid Sec-WebSocket-Key header') {\n    return new WebSocketError(msg, 'INVALID_KEY_HEADER', status.PROTOCOL_ERROR, WebSocketError.INVALID_KEY_HEADER)\n  }\n\n  static INVALID_ACCEPT_HEADER (msg = 'Invalid Sec-WebSocket-Accept header') {\n    return new WebSocketError(msg, 'INVALID_ACCEPT_HEADER', status.PROTOCOL_ERROR, WebSocketError.INVALID_ACCEPT_HEADER)\n  }\n\n  static INVALID_OPCODE (msg = 'Invalid opcode') {\n    return new WebSocketError(msg, 'INVALID_OPCODE', status.PROTOCOL_ERROR, WebSocketError.INVALID_OPCODE)\n  }\n\n  static INVALID_PAYLOAD_LENGTH (msg = 'Invalid payload length') {\n    return new WebSocketError(msg, 'INVALID_PAYLOAD_LENGTH', status.MESSAGE_TOO_LARGE, WebSocketError.INVALID_PAYLOAD_LENGTH)\n  }\n}\nconst crypto = require('bare-crypto')\nconst errors = require('./errors')\n\nconst EMPTY = Buffer.alloc(0)\n\nconst FIN = 0b10000000\nconst RSV1 = 0b01000000\nconst RSV2 = 0b00100000\nconst RSV3 = 0b00010000\nconst OPCODE = 0b00001111\nconst MASK = 0b10000000\nconst LENGTH = 0b01111111\n\n// https://datatracker.ietf.org/doc/html/rfc6455#section-5\nconst Frame = module.exports = exports = class Frame {\n  constructor (opcode, payload = EMPTY, opts = {}) {\n    if (payload && !Buffer.isBuffer(payload)) {\n      opts = payload\n      payload = EMPTY\n    }\n\n    const {\n      fin = true,\n      rsv1 = false,\n      rsv2 = false,\n      rsv3 = false,\n      mask = null\n    } = opts\n\n    this.fin = fin\n    this.rsv1 = rsv1\n    this.rsv2 = rsv2\n    this.rsv3 = rsv3\n    this.opcode = opcode\n    this.mask = mask\n    this.payload = payload\n  }\n\n  toBuffer () {\n    const state = { start: 0, end: 0, buffer: null }\n\n    Frame.preencode(state, this)\n\n    state.buffer = Buffer.allocUnsafe(state.end)\n\n    Frame.encode(state, this)\n\n    return state.buffer\n  }\n}\n\nexports.preencode = function preencode (state, f) {\n  let i = state.end\n\n  i++\n\n  const length = f.payload.length\n\n  if (length <= 0x7d) i++\n  else {\n    if (length <= 0xffff) i += 3\n    else i += 9\n  }\n\n  if (f.mask) i += 4\n\n  i += length\n\n  state.end = i\n}\n\nexports.encode = function encode (state, f) {\n  const b = state.buffer\n\n  let i = state.start\n\n  const v = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  b[i] = f.opcode & OPCODE\n\n  if (f.fin) b[i] |= FIN\n  if (f.rsv1) b[i] |= RSV1\n  if (f.rsv1) b[i] |= RSV2\n  if (f.rsv1) b[i] |= RSV3\n\n  i++\n\n  b[i] = f.mask ? MASK : 0\n\n  const length = f.payload.length\n\n  if (length <= 0x7d) b[i++] |= length\n  else {\n    if (length <= 0xffff) {\n      b[i++] |= 0x7e\n\n      v.setUint16(i, length, false)\n\n      i += 2\n    } else {\n      b[i++] |= 0x7f\n\n      const high = Math.floor(length / 0x100000000)\n\n      v.setUint16(i, high, false)\n\n      i += 4\n\n      const low = length & 0xffffffff\n\n      v.setUint16(i, low, false)\n\n      i += 4\n    }\n  }\n\n  if (f.mask) {\n    crypto.randomFill(f.mask, 0, 4)\n\n    b.set(f.mask, i)\n\n    i += 4\n\n    for (let j = 0; j < length; j++) {\n      b[i + j] = f.payload[j] ^ f.mask[j & 3]\n    }\n  } else {\n    b.set(f.payload, i)\n  }\n\n  i += length\n\n  state.start = i\n}\n\nexports.decode = function decode (state) {\n  const b = state.buffer\n\n  let i = state.start\n  let n = b.length\n\n  if (n < 2) return null\n\n  const view = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  const fin = !!(b[i] & FIN)\n\n  const rsv1 = !!(b[i] & RSV1)\n  const rsv2 = !!(b[i] & RSV2)\n  const rsv3 = !!(b[i] & RSV3)\n\n  const opcode = b[i] & OPCODE\n\n  i++\n  n--\n\n  const masked = !!(b[i] & MASK)\n\n  let length = b[i] & LENGTH\n\n  i++\n  n--\n\n  if (length === 0x7e) {\n    if (n < 2) return null\n\n    length = view.getUint16(i, false)\n\n    i += 2\n    n -= 2\n  } else if (length === 0x7f) {\n    if (n < 8) return null\n\n    const high = view.getUint32(i, false)\n\n    if (high >= 0x200000) throw errors.INVALID_PAYLOAD_LENGTH()\n\n    i += 4\n    n -= 4\n\n    const low = view.getUint32(i, false)\n\n    i += 4\n    n -= 4\n\n    length = high * 0x100000000 + low\n  }\n\n  let mask = null\n\n  if (masked) {\n    if (n < 4) return null\n\n    mask = b.subarray(i, i + 4)\n\n    i += 4\n    n -= 4\n  }\n\n  if (n < length) return null\n\n  const payload = b.subarray(i, i + length)\n\n  i += length\n  n -= length\n\n  if (mask) {\n    for (let i = 0; i < length; i++) {\n      payload[i] ^= mask[i & 3]\n    }\n  }\n\n  state.start = i\n\n  return new Frame(opcode, payload, { fin, rsv1, rsv2, rsv3, mask })\n}\nconst EventEmitter = require('bare-events')\nconst http = require('bare-http1')\nconst https = require('bare-https')\nconst crypto = require('bare-crypto')\nconst { GUID, EOL, EOF } = require('./constants')\nconst errors = require('./errors')\nconst WebSocket = require('./socket')\n\nconst EMPTY = Buffer.alloc(0)\n\nconst KEY = /^[+/0-9A-Za-z]{22}==$/\n\nmodule.exports = exports = class WebSocketServer extends EventEmitter {\n  constructor (opts = {}, onconnection) {\n    if (typeof opts === 'function') {\n      onconnection = opts\n      opts = {}\n    }\n\n    super()\n\n    const createServer = opts.secure ? https.createServer : http.createServer\n\n    const {\n      server = createServer(opts, this._onrequest.bind(this)).listen(opts, this._onlistening.bind(this))\n    } = opts\n\n    this._server = server\n\n    this._server.on('upgrade', this._onupgrade.bind(this))\n\n    if (onconnection) this.on('connection', onconnection)\n  }\n\n  get listening () {\n    return this._server.listening\n  }\n\n  address () {\n    return this._server.address()\n  }\n\n  close (cb) {\n    return this._server.close(cb)\n  }\n\n  ref () {\n    this._server.ref()\n  }\n\n  unref () {\n    this._server.unref()\n  }\n\n  _onlistening () {\n    this.emit('listening')\n  }\n\n  _onrequest (req, res) {\n    const body = http.constants.status[426]\n\n    res.writeHead(426, {\n      'Content-Type': 'text/plain',\n      'Content-Length': body.length\n    })\n\n    res.end(body)\n  }\n\n  _onupgrade (req, socket, head) {\n    handshake(req, socket, head, (err) => {\n      if (err) return socket.destroy(err)\n\n      this.emit('connection', new WebSocket({ socket, isServer: true }), req)\n    })\n  }\n}\n\n// https://datatracker.ietf.org/doc/html/rfc6455#section-4.2\nconst handshake = exports.handshake = function handshake (req, socket = req.socket, head = EMPTY, cb) {\n  if (typeof socket === 'function') {\n    cb = socket\n    socket = req.socket\n    head = EMPTY\n  } else if (typeof head === 'function') {\n    cb = head\n    head = EMPTY\n  }\n\n  if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n    return cb(errors.INVALID_UPGRADE_HEADER())\n  }\n\n  const version = +req.headers['sec-websocket-version']\n\n  if (version !== 8 && version !== 13) {\n    return cb(errors.INVALID_VERSION_HEADER())\n  }\n\n  const key = req.headers['sec-websocket-key']\n\n  if (!key || !KEY.test(key)) {\n    return cb(errors.INVALID_KEY_HEADER())\n  }\n\n  const digest = crypto.createHash('sha1')\n    .update(key)\n    .update(GUID)\n    .digest('base64')\n\n  socket.write(\n    'HTTP/1.1 101 Web Socket Protocol Handshake' + EOL +\n    'Upgrade: WebSocket' + EOL +\n    'Connection: Upgrade' + EOL +\n    `Sec-WebSocket-Accept: ${digest}` + EOF\n  )\n\n  if (head.byteLength) socket.unshift(head)\n\n  cb(null)\n}\nconst { Duplex } = require('bare-stream')\nconst http = require('bare-http1')\nconst https = require('bare-https')\nconst crypto = require('bare-crypto')\nconst { GUID, opcode } = require('./constants')\nconst errors = require('./errors')\nconst Frame = require('./frame')\n\nconst CLOSE = new Frame(opcode.CLOSE).toBuffer()\n\nmodule.exports = exports = class WebSocket extends Duplex {\n  constructor (url, opts = {}) {\n    if (typeof url === 'string') url = new URL(url)\n\n    if (isURL(url)) {\n      opts = opts ? { ...opts } : {}\n\n      opts.host = url.hostname\n      opts.path = url.pathname + url.search\n      opts.port = url.port ? parseInt(url.port, 10) : defaultPort(url)\n      opts.secure = url.protocol === 'https:' || url.protocol === 'wss:'\n    } else {\n      opts = url ? { ...url } : {}\n\n      // For Node.js compatibility\n      opts.host = opts.hostname || opts.host\n      opts.port = typeof opts.port === 'string' ? parseInt(opts.port, 10) : opts.port\n    }\n\n    const {\n      isServer = false,\n      socket = null\n    } = opts\n\n    super({ eagerOpen: true })\n\n    this._socket = null\n    this._isServer = isServer\n    this._mask = isServer ? null : Buffer.allocUnsafe(4)\n    this._fragments = []\n\n    this._pendingOpen = null\n    this._pendingWrite = null\n\n    this._buffer = null\n\n    if (socket !== null) this._attach(socket)\n    else this._connect(opts)\n  }\n\n  ping (data) {\n    if (this._socket === null) throw errors.NOT_CONNECTED()\n\n    if (typeof data === 'string') data = Buffer.from(data)\n\n    this._socket.write(new Frame(opcode.PING, data, { mask: this._mask }).toBuffer())\n  }\n\n  pong (data) {\n    if (this._socket === null) throw errors.NOT_CONNECTED()\n\n    if (typeof data === 'string') data = Buffer.from(data)\n\n    this._socket.write(new Frame(opcode.PONG, data, { mask: this._mask }).toBuffer())\n  }\n\n  _attach (socket) {\n    this._socket = socket\n\n    this._socket\n      .on('error', this._onerror.bind(this))\n      .on('close', this._onclose.bind(this))\n      .on('data', this._ondata.bind(this))\n      .on('drain', this._ondrain.bind(this))\n  }\n\n  _connect (opts) {\n    const request = opts.secure ? https.request : http.request\n\n    const req = request(opts)\n\n    handshake(req, (err) => {\n      const cb = this._pendingOpen\n      this._pendingOpen = null\n\n      if (err) req.socket.destroy()\n      else this._attach(req.socket)\n\n      cb(err)\n    })\n  }\n\n  _onerror (err) {\n    this.destroy(err)\n  }\n\n  _onclose () {\n    this.destroy()\n  }\n\n  _ondata (data) {\n    if (this._buffer === null) this._buffer = data\n    else this._buffer = Buffer.concat([this._buffer, data])\n\n    while (this._buffer !== null) {\n      const state = { start: 0, end: this._buffer.length, buffer: this._buffer }\n\n      let frame\n      try {\n        frame = Frame.decode(state)\n      } catch (err) {\n        return this.destroy(err)\n      }\n\n      if (frame === null) return\n\n      this._buffer = state.start === state.end ? null : this._buffer.subarray(state.start)\n\n      try {\n        this._onframe(frame)\n      } catch (err) {\n        return this.destroy(err)\n      }\n    }\n  }\n\n  _onframe (frame) {\n    if (frame.rsv1) throw errors.UNEXPECTED_RSV1()\n\n    if (frame.rsv2) throw errors.UNEXPECTED_RSV2()\n\n    if (frame.rsv3) throw errors.UNEXPECTED_RSV3()\n\n    if (frame.payload.length > 0 && !frame.mask === this._isServer) {\n      throw this._isServer ? errors.EXPECTED_MASK() : errors.UNEXPECTED_MASK()\n    }\n\n    if (frame.fin === false) {\n      if (this._fragments.push(frame) === 1) { // First frame\n        if (frame.opcode === opcode.CONTINUATION) throw errors.UNEXPECTED_CONTINUATION()\n\n        if (frame.opcode >= opcode.CLOSE) throw errors.UNEXPECTED_CONTROL()\n\n        return\n      }\n\n      if (frame.opcode !== opcode.CONTINUATION) throw errors.EXPECTED_CONTINUATION()\n\n      return\n    }\n\n    switch (frame.opcode) {\n      case opcode.CLOSE:\n        this.push(null)\n        this.end()\n        return\n\n      case opcode.PING:\n        this.pong(frame.payload)\n        this.emit('ping', frame.payload)\n        return\n\n      case opcode.PONG:\n        this.emit('pong', frame.payload)\n        return\n\n      case opcode.CONTINUATION: {\n        if (this._fragments.length === 0) throw errors.UNEXPECTED_CONTINUATION()\n\n        frame.opcode = this._fragments[0].opcode\n\n        const payloads = this._fragments.map(frame => frame.payload)\n\n        payloads.push(frame.payload)\n\n        frame.payload = Buffer.concat(payloads)\n\n        this._fragments = []\n\n        break\n      }\n\n      default:\n        if (this._fragments.length > 0) throw errors.EXPECTED_CONTINUATION()\n    }\n\n    switch (frame.opcode) {\n      case opcode.TEXT:\n      case opcode.BINARY:\n        this.push(frame.payload)\n        break\n\n      default:\n        throw errors.INVALID_OPCODE()\n    }\n  }\n\n  _ondrain () {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite\n    this._pendingWrite = null\n    cb(null)\n  }\n\n  _open (cb) {\n    if (this._socket === null) this._pendingOpen = cb\n    else cb(null)\n  }\n\n  _write (data, encoding, cb) {\n    if (encoding !== 'buffer' && encoding !== 'utf8') {\n      return cb(errors.INVALID_ENCODING())\n    }\n\n    const frame = new Frame(encoding === 'buffer' ? opcode.BINARY : opcode.TEXT, data, { mask: this._mask })\n\n    if (this._socket.write(frame.toBuffer())) cb(null)\n    else this._pendingWrite = cb\n  }\n\n  _final (cb) {\n    this._socket.end(CLOSE)\n    cb(null)\n  }\n\n  _predestroy () {\n    this._socket.destroy()\n  }\n}\n\n// https://datatracker.ietf.org/doc/html/rfc6455#section-4.1\nconst handshake = exports.handshake = function handshake (req, cb) {\n  const key = crypto.randomBytes(16).toString('base64')\n\n  req.headers = {\n    ...req.headers,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    'Sec-WebSocket-Version': 13,\n    'Sec-WebSocket-Key': key\n  }\n\n  req.on('upgrade', (res, socket, head) => {\n    if (res.headers.upgrade.toLowerCase() !== 'websocket') {\n      return cb(errors.INVALID_UPGRADE_HEADER())\n    }\n\n    const digest = crypto.createHash('sha1')\n      .update(key)\n      .update(GUID)\n      .digest('base64')\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      return cb(errors.INVALID_ACCEPT_HEADER())\n    }\n\n    if (head.byteLength) socket.unshift(head)\n\n    cb(null)\n  })\n\n  req.end()\n}\n\n// https://url.spec.whatwg.org/#default-port\nfunction defaultPort (url) {\n  switch (url.protocol) {\n    case 'ftp:': return 21\n    case 'http:':\n    case 'ws:': return 80\n    case 'https:':\n    case 'wss:': return 443\n  }\n\n  return null\n}\n\n// https://url.spec.whatwg.org/#api\nfunction isURL (url) {\n  return (\n    url !== null &&\n    typeof url === 'object' &&\n    typeof url.protocol === 'string' &&\n    typeof url.hostname === 'string' &&\n    typeof url.pathname === 'string' &&\n    typeof url.search === 'string'\n  )\n}\n{\n  \"name\": \"bare-ws\",\n  \"version\": \"1.3.1\",\n  \"description\": \"WebSocket library for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\",\n    \"./constants\": \"./lib/constants.js\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-ws.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-ws/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-ws#readme\",\n  \"dependencies\": {\n    \"bare-crypto\": \"^1.2.0\",\n    \"bare-events\": \"^2.3.1\",\n    \"bare-http1\": \"^3.8.0\",\n    \"bare-https\": \"^1.3.0\",\n    \"bare-stream\": \"^2.1.2\"\n  },\n  \"devDependencies\": {\n    \"bare-fs\": \"^2.3.1\",\n    \"brittle\": \"^3.3.0\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst FACTOR = new Uint16Array(8)\n\nfunction factor4096 (i, n) {\n  while (n > 0) {\n    const f = i & 4095\n    FACTOR[--n] = f\n    i = (i - f) / 4096\n  }\n  return FACTOR\n}\n\nmodule.exports = class BigSparseArray {\n  constructor () {\n    this.tiny = new TinyArray()\n    this.maxLength = 4096\n    this.factor = 1\n  }\n\n  set (index, val) {\n    if (val !== undefined) {\n      while (index >= this.maxLength) {\n        this.maxLength *= 4096\n        this.factor++\n        if (!this.tiny.isEmptyish()) {\n          const t = new TinyArray()\n          t.set(0, this.tiny)\n          this.tiny = t\n        }\n      }\n    }\n\n    const f = factor4096(index, this.factor)\n    const last = this.factor - 1\n\n    let tiny = this.tiny\n    for (let i = 0; i < last; i++) {\n      const next = tiny.get(f[i])\n      if (next === undefined) {\n        if (val === undefined) return\n        tiny = tiny.set(f[i], new TinyArray())\n      } else {\n        tiny = next\n      }\n    }\n\n    return tiny.set(f[last], val)\n  }\n\n  get (index) {\n    if (index >= this.maxLength) return\n\n    const f = factor4096(index, this.factor)\n    const last = this.factor - 1\n\n    let tiny = this.tiny\n    for (let i = 0; i < last; i++) {\n      tiny = tiny.get(f[i])\n      if (tiny === undefined) return\n    }\n\n    return tiny.get(f[last])\n  }\n}\n\nclass TinyArray {\n  constructor () {\n    this.s = 0\n    this.b = new Array(1)\n    this.f = new Uint16Array(1)\n  }\n\n  isEmptyish () {\n    return this.b.length === 1 && this.b[0] === undefined\n  }\n\n  get (i) {\n    if (this.s === 12) return this.b[i]\n    const f = i >>> this.s\n    const r = i & (this.b.length - 1)\n    return this.f[r] === f ? this.b[r] : undefined\n  }\n\n  set (i, v) {\n    while (this.s !== 12) {\n      const f = i >>> this.s\n      const r = i & (this.b.length - 1)\n      const o = this.b[r]\n\n      if (o === undefined || f === this.f[r]) {\n        this.b[r] = v\n        this.f[r] = f\n        return v\n      }\n\n      this.grow()\n    }\n\n    this.b[i] = v\n    return v\n  }\n\n  grow () {\n    const os = this.s\n    const ob = this.b\n    const of = this.f\n\n    this.s += 4\n    this.b = new Array(this.b.length << 4)\n    this.f = this.s === 12 ? null : new Uint8Array(this.b.length)\n\n    const m = this.b.length - 1\n\n    for (let or = 0; or < ob.length; or++) {\n      if (ob[or] === undefined) continue\n\n      const i = of[or] << os | or\n      const f = i >>> this.s\n      const r = i & m\n\n      this.b[r] = ob[or]\n      if (this.s !== 12) this.f[r] = f\n    }\n  }\n}\n{\n  \"name\": \"big-sparse-array\",\n  \"version\": \"1.0.3\",\n  \"description\": \"A sparse array optimised for low memory whilst still being fast\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.1\",\n    \"standard\": \"^16.0.3\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/big-sparse-array.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/big-sparse-array/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/big-sparse-array\"\n}\nconst b4a = require('b4a')\n\nmodule.exports = function (a, b) {\n  return new Promise((resolve, reject) => binaryEquals(a, b, resolve, reject))\n}\n\nfunction binaryEquals (a, b, resolve, reject) {\n  let aBuf = null\n  let aEnded = false\n\n  let bBuf = null\n  let bEnded = false\n\n  let closed = 0\n  let done = false\n  let error = null\n  let equals = false\n\n  a.on('readable', tick)\n  a.on('end', onend)\n  a.on('error', onerror)\n  a.on('close', onclose)\n\n  b.on('readable', tick)\n  b.on('end', onend)\n  b.on('error', onerror)\n  b.on('close', onclose)\n\n  function onerror (err) {\n    error = err\n    a.destroy()\n    b.destroy()\n  }\n\n  function onclose () {\n    if (++closed !== 2) return\n    if (error !== null && done === false) reject(error)\n    else resolve(equals)\n  }\n\n  function ondone (eq) {\n    if (done) return\n    done = true\n\n    equals = eq\n\n    a.destroy()\n    b.destroy()\n  }\n\n  function onend () {\n    if (this === a) aEnded = true\n    else bEnded = true\n    tick()\n  }\n\n  function tick () {\n    while (done === false) {\n      if (aBuf === null) aBuf = a.read()\n      if (bBuf === null) bBuf = b.read()\n\n      if (aBuf === null && bBuf === null && aEnded && bEnded) {\n        ondone(true)\n        return\n      }\n\n      if (aBuf !== null && (bBuf === null && bEnded)) {\n        ondone(false)\n        return\n      }\n\n      if (bBuf !== null && (aBuf === null && aEnded)) {\n        ondone(false)\n        return\n      }\n\n      if (aBuf === null || bBuf === null) return // read pending\n\n      if (aBuf.byteLength === bBuf.byteLength) {\n        if (b4a.equals(aBuf, bBuf)) {\n          aBuf = bBuf = null\n          continue\n        }\n\n        ondone(false)\n        return\n      }\n\n      const min = Math.min(aBuf.byteLength, bBuf.byteLength)\n\n      if (b4a.equals(aBuf.subarray(0, min), bBuf.subarray(0, min))) {\n        aBuf = aBuf.byteLength === min ? null : aBuf.subarray(min)\n        bBuf = bBuf.byteLength === min ? null : bBuf.subarray(min)\n        continue\n      }\n\n      ondone(false)\n      return\n    }\n  }\n}\n{\n  \"name\": \"binary-stream-equals\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Check if two binary streams have the same content\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.3.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^2.2.7\",\n    \"standard\": \"^16.0.4\",\n    \"streamx\": \"^2.12.4\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/binary-stream-equals.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/binary-stream-equals/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/binary-stream-equals\"\n}\nconst b4a = require('b4a')\n\nfunction byteLength (size) {\n  return Math.ceil(size / 8)\n}\n\nfunction get (buffer, bit) {\n  const n = buffer.BYTES_PER_ELEMENT * 8\n\n  const offset = bit & (n - 1)\n  const i = (bit - offset) / n\n\n  return (buffer[i] & (1 << offset)) !== 0\n}\n\nfunction set (buffer, bit, value = true) {\n  const n = buffer.BYTES_PER_ELEMENT * 8\n\n  const offset = bit & (n - 1)\n  const i = (bit - offset) / n\n  const mask = 1 << offset\n\n  if (value) {\n    if ((buffer[i] & mask) !== 0) return false\n  } else {\n    if ((buffer[i] & mask) === 0) return false\n  }\n\n  buffer[i] ^= mask\n  return true\n}\n\nfunction setRange (buffer, start, end, value = true) {\n  const n = buffer.BYTES_PER_ELEMENT * 8\n\n  let remaining = end - start\n  let offset = start & (n - 1)\n  let i = (start - offset) / n\n\n  let changed = false\n\n  while (remaining > 0) {\n    const mask = (2 ** Math.min(remaining, n - offset) - 1) << offset\n\n    if (value) {\n      if ((buffer[i] & mask) !== mask) {\n        buffer[i] |= mask\n        changed = true\n      }\n    } else {\n      if ((buffer[i] & mask) !== 0) {\n        buffer[i] &= ~mask\n        changed = true\n      }\n    }\n\n    remaining -= n - offset\n    offset = 0\n    i++\n  }\n\n  return changed\n}\n\nfunction fill (buffer, value, start = 0, end = buffer.byteLength * 8) {\n  const n = buffer.BYTES_PER_ELEMENT * 8\n  let i, j\n\n  {\n    const offset = start & (n - 1)\n    i = (start - offset) / n\n\n    if (offset !== 0) {\n      const mask = (2 ** Math.min(n - offset, end - start) - 1) << offset\n\n      if (value) buffer[i] |= mask\n      else buffer[i] &= ~mask\n\n      i++\n    }\n  }\n\n  {\n    const offset = end & (n - 1)\n    j = (end - offset) / n\n\n    if (offset !== 0 && j >= i) {\n      const mask = (2 ** offset) - 1\n\n      if (value) buffer[j] |= mask\n      else buffer[j] &= ~mask\n    }\n  }\n\n  return buffer.fill(value ? (2 ** n) - 1 : 0, i, j)\n}\n\nfunction toggle (buffer, bit) {\n  const n = buffer.BYTES_PER_ELEMENT * 8\n\n  const offset = bit & (n - 1)\n  const i = (bit - offset) / n\n  const mask = 1 << offset\n\n  buffer[i] ^= mask\n  return (buffer[i] & mask) !== 0\n}\n\nfunction remove (buffer, bit) {\n  return set(buffer, bit, false)\n}\n\nfunction removeRange (buffer, start, end) {\n  return setRange(buffer, start, end, false)\n}\n\nfunction indexOf (buffer, value, position = 0) {\n  for (let i = position, n = buffer.byteLength * 8; i < n; i++) {\n    if (get(buffer, i) === value) return i\n  }\n\n  return -1\n}\n\nfunction lastIndexOf (buffer, value, position = buffer.byteLength * 8 - 1) {\n  for (let i = position; i >= 0; i--) {\n    if (get(buffer, i) === value) return i\n  }\n\n  return -1\n}\n\nfunction of (...bits) {\n  return from(bits)\n}\n\nfunction from (bits) {\n  const buffer = b4a.alloc(byteLength(bits.length))\n  for (let i = 0; i < bits.length; i++) set(buffer, i, bits[i])\n  return buffer\n}\n\nfunction * iterator (buffer) {\n  for (let i = 0, n = buffer.byteLength * 8; i < n; i++) yield get(buffer, i)\n}\n\nmodule.exports = {\n  byteLength,\n  get,\n  set,\n  setRange,\n  fill,\n  toggle,\n  remove,\n  removeRange,\n  indexOf,\n  lastIndexOf,\n  of,\n  from,\n  iterator\n}\n{\n  \"name\": \"bits-to-bytes\",\n  \"version\": \"1.3.0\",\n  \"description\": \"Functions for doing bit manipulation of typed arrays\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bits-to-bytes.git\"\n  },\n  \"author\": \"Kasper Isager Dalsgar <kasper@funktionel.co>\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bits-to-bytes/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bits-to-bytes#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.5.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^2.3.1\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst { EventEmitter } = require('events')\nconst sodium = require('sodium-universal')\nconst crypto = require('hypercore-crypto')\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\n\nconst {\n  Invite,\n  ResponsePayload,\n  InviteRequest,\n  InviteResponse,\n  InviteData,\n  InviteReceipt,\n  PersistedRequest,\n  AuthData\n} = require('./lib/messages')\n\nconst {\n  PAIRING_REJECTED,\n  INVITE_USED,\n  INVITE_EXPIRED\n} = require('./lib/errors')\n\nconst [\n  NS_SIGNATURE,\n  NS_TOKEN,\n  NS_INVITE_ID,\n  NS_REQUEST_ID,\n  NS_SESSION,\n  NS_SESSION_KEY,\n  NS_ENCRYPT,\n  NS_NONCE\n] = crypto.namespace('blind-pairing', 8)\n\nclass CandidateRequest extends EventEmitter {\n  constructor (invite, userData, opts = {}) {\n    super()\n\n    if (b4a.isBuffer(invite)) {\n      invite = c.decode(Invite, invite)\n    }\n\n    this.discoveryKey = invite.discoveryKey\n    this.seed = invite.seed\n\n    this.keyPair = crypto.keyPair(this.seed)\n    this.inviteId = deriveInviteId(this.keyPair.publicKey)\n    this.userData = userData\n\n    this.token = deriveToken(this.keyPair.publicKey, userData)\n    this.session = opts.session || createSessionToken(this.token)\n    this.id = deriveRequestId(this.session)\n\n    this.payload = createAuth(this.userData, this.keyPair, this.session)\n\n    this._encoded = null\n\n    // set in reply\n    this.auth = null\n  }\n\n  static from (buf) {\n    const info = c.decode(PersistedRequest, buf)\n    const { seed, discoveryKey, userData } = info\n    const request = new CandidateRequest({ discoveryKey, seed }, userData)\n\n    // clear completed request\n    if (info.key) {\n      request.key = info.key\n      request.token = null\n      request.payload = null\n    }\n\n    return request\n  }\n\n  handleResponse (payload) {\n    if (b4a.isBuffer(payload)) {\n      payload = this._decodeResponse(payload)\n    }\n\n    try {\n      this._openResponse(payload)\n    } catch (err) {\n      this.emit('rejected', err)\n      return null\n    }\n\n    this._onAccept()\n\n    return this.auth\n  }\n\n  _openResponse (payload) {\n    try {\n      const response = openReply(payload, this.payload.session, this.keyPair.publicKey)\n      this.response = c.decode(ResponsePayload, response)\n    } catch (e) {\n      throw new Error('Could not decrypt reply.')\n    }\n\n    const { status, key, encryptionKey, additional } = this.response\n\n    if (status !== 0) {\n      switch (status) {\n        case 1:\n          throw PAIRING_REJECTED()\n\n        case 2:\n          throw INVITE_USED()\n\n        case 3:\n          throw INVITE_EXPIRED()\n      }\n    }\n\n    if (b4a.compare(crypto.discoveryKey(key), this.discoveryKey)) {\n      throw new Error('Invite response does not match discoveryKey')\n    }\n\n    if (additional && !crypto.verify(additional.data, additional.signature, this.keyPair.publicKey)) {\n      throw new Error('Additional data failed verification')\n    }\n\n    this.auth = { key, encryptionKey, data: additional ? additional.data : null }\n  }\n\n  _onAccept () {\n    this.emit('accepted', this.auth)\n    this.destroy()\n  }\n\n  _decodeResponse (buf) {\n    try {\n      const { payload } = c.decode(InviteResponse, buf)\n      return payload\n    } catch {\n      throw new Error('Could not decode response.')\n    }\n  }\n\n  destroy () {\n    this.token = null\n    this.payload = null\n\n    this.emit('destroyed')\n  }\n\n  encode () {\n    if (!this._encoded) this._encoded = c.encode(InviteRequest, this)\n    return this._encoded\n  }\n}\n\nclass MemberRequest {\n  constructor (inviteId, requestData) {\n    this.inviteId = inviteId\n    this.requestData = requestData\n\n    this._opened = false\n    this._confirmed = false\n    this._denied = false\n\n    // set by transport\n    this.discoveryKey = null\n\n    // set in open\n    this.publicKey = null\n    this.userData = null\n    this.session = null\n    this.id = null\n    this.receipt = null\n\n    // set in confirm/respond\n    this._payload = null\n    this.response = null\n  }\n\n  static from (req) {\n    if (b4a.isBuffer(req)) {\n      return MemberRequest.from(c.decode(InviteRequest, req))\n    }\n\n    return new MemberRequest(\n      req.inviteId,\n      req.payload\n    )\n  }\n\n  confirm ({ key, encryptionKey, additional }) {\n    if (this._confirmed || this._denied || !this._opened) return\n    this._confirmed = true\n\n    const payload = c.encode(ResponsePayload, { status: 0, key, encryptionKey, additional })\n    this._payload = createReply(payload, this.session, this.publicKey)\n\n    this._respond()\n  }\n\n  deny ({ status = 1 } = {}) {\n    if (this._confirmed || this._denied) return\n    this._denied = true\n\n    if (!status) return\n\n    const payload = c.encode(ResponsePayload, {\n      status,\n      key: null,\n      encryptionKey: null,\n      additional: null\n    })\n    this._payload = createReply(payload, this.session, this.publicKey)\n\n    this._respond()\n  }\n\n  respond () {\n    return {\n      id: this.id,\n      payload: this._payload\n    }\n  }\n\n  _respond () {\n    this.response = c.encode(InviteResponse, this.respond())\n  }\n\n  open (publicKey) {\n    if (this._opened && b4a.equals(this.publicKey, publicKey)) return this.userData\n\n    try {\n      this.receipt = openAuth(this.requestData, publicKey)\n      const { userData, session } = c.decode(InviteReceipt, this.receipt)\n\n      this.userData = userData\n      this.session = session\n      this.token = deriveToken(publicKey, userData)\n      this.id = deriveRequestId(this.session)\n    } catch (e) {\n      throw new Error('Failed to open invite with provided key')\n    }\n\n    this.publicKey = publicKey\n    this._opened = true\n\n    return this.userData\n  }\n}\n\nmodule.exports.CandidateRequest = CandidateRequest\nmodule.exports.MemberRequest = MemberRequest\nmodule.exports.createInvite = createInvite\nmodule.exports.decodeInvite = decodeInvite\nmodule.exports.verifyReceipt = verifyReceipt\nmodule.exports.createReceipt = createReceipt\nmodule.exports.Invite = Invite\n\nfunction createReceipt (invite, userData) {\n  const req = new CandidateRequest(invite, userData) // yolo, refactor\n  const receipt = openAuth(req.payload, req.keyPair.publicKey)\n  return { id: deriveInviteId(req.keyPair.publicKey), receipt }\n}\n\nfunction verifyReceipt (receipt, publicKey) {\n  if (b4a.isBuffer(receipt)) {\n    receipt = c.decode(InviteReceipt, receipt)\n  }\n\n  const { session, signature, userData } = receipt\n  const signData = c.encode(AuthData, { userData, session })\n\n  if (!verifySignature(signData, signature, publicKey)) return null\n\n  return userData\n}\n\nfunction deriveInviteId (publicKey) {\n  return crypto.hash([NS_INVITE_ID, publicKey])\n}\n\nfunction deriveKey (publicKey) {\n  const out = b4a.allocUnsafe(sodium.crypto_aead_xchacha20poly1305_ietf_KEYBYTES)\n  return crypto.hash([NS_ENCRYPT, publicKey], out)\n}\n\nfunction deriveNonce (publicKey, sessionToken) {\n  const out = b4a.allocUnsafe(sodium.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES)\n  return crypto.hash([NS_NONCE, publicKey, sessionToken], out)\n}\n\nfunction deriveToken (publicKey, userData) {\n  return crypto.hash([NS_TOKEN, publicKey, userData])\n}\n\nfunction createSessionToken (token) {\n  return crypto.hash([NS_SESSION, token])\n}\n\nfunction deriveRequestId (sessionToken) {\n  return crypto.hash([NS_REQUEST_ID, sessionToken])\n}\n\nfunction createInvite (key, opts = {}) {\n  const {\n    discoveryKey = crypto.discoveryKey(key),\n    expires = 0,\n    seed = crypto.randomBytes(32),\n    sensitive = false,\n    data,\n    testInvitation = false\n  } = opts\n\n  const keyPair = crypto.keyPair(seed)\n  const additional = data\n    ? {\n        data,\n        signature: crypto.sign(data, keyPair.secretKey)\n      }\n    : null\n\n  return {\n    id: deriveInviteId(keyPair.publicKey),\n    invite: c.encode(Invite, { seed, discoveryKey, expires, sensitive, testInvitation }),\n    seed,\n    publicKey: keyPair.publicKey,\n    additional,\n    discoveryKey,\n    expires,\n    sensitive,\n    testInvitation\n  }\n}\n\nfunction decodeInvite (invite) {\n  const data = c.decode(Invite, invite)\n  return {\n    id: deriveInviteId(crypto.keyPair(data.seed).publicKey),\n    ...data\n  }\n}\n\nfunction encrypt (data, nonce, secretKey) {\n  const output = b4a.allocUnsafe(data.byteLength + sodium.crypto_aead_xchacha20poly1305_ietf_ABYTES)\n  sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(output, data, nonce, null, nonce, secretKey)\n  return output\n}\n\nfunction decrypt (data, nonce, secretKey) {\n  const output = b4a.allocUnsafe(data.byteLength - sodium.crypto_aead_xchacha20poly1305_ietf_ABYTES)\n  sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(output, null, data, nonce, nonce, secretKey)\n  return output\n}\n\nfunction createAuth (userData, invitationKeyPair, session) {\n  const secret = deriveKey(invitationKeyPair.publicKey)\n\n  const nonce = deriveNonce(invitationKeyPair.publicKey, session)\n  const signData = c.encode(AuthData, { userData, session })\n  const signature = createSignature(signData, invitationKeyPair.secretKey)\n\n  const inviteData = c.encode(InviteData, { userData, signature })\n  const data = encrypt(inviteData, nonce, secret)\n\n  return {\n    session,\n    data\n  }\n}\n\nfunction openAuth (payload, invitationKey) {\n  const secret = deriveKey(invitationKey)\n\n  const { session, data } = payload\n\n  const nonce = deriveNonce(invitationKey, session)\n\n  let plaintext\n  try {\n    plaintext = decrypt(data, nonce, secret)\n  } catch {\n    // todo stronger check\n    throw new Error('Decryption failed.')\n  }\n\n  const { userData, signature } = c.decode(InviteData, plaintext)\n  const receipt = { session, signature, userData }\n\n  if (!verifyReceipt(receipt, invitationKey)) {\n    throw new Error('Invalid reply')\n  }\n\n  return c.encode(InviteReceipt, { session, signature, userData })\n}\n\nfunction createReply (payload, sessionToken, invitationKey) {\n  const sessionKey = crypto.hash([NS_SESSION_KEY, invitationKey, sessionToken])\n  const secret = deriveKey(sessionKey)\n  const nonce = deriveNonce(sessionKey, sessionToken)\n\n  return encrypt(payload, nonce, secret)\n}\n\nfunction openReply (data, sessionToken, invitationKey) {\n  const sessionKey = crypto.hash([NS_SESSION_KEY, invitationKey, sessionToken])\n  const secret = deriveKey(sessionKey)\n  const nonce = deriveNonce(sessionKey, sessionToken)\n\n  return decrypt(data, nonce, secret)\n}\n\nfunction createSignature (data, secretKey) {\n  const signature = b4a.allocUnsafe(sodium.crypto_sign_BYTES)\n  const namespaced = b4a.allocUnsafe(32 + data.byteLength)\n\n  namespaced.set(NS_SIGNATURE, 0)\n  namespaced.set(data, 32)\n\n  sodium.crypto_sign_detached(signature, namespaced, secretKey)\n\n  return signature\n}\n\nfunction verifySignature (data, signature, publicKey) {\n  const namespaced = b4a.allocUnsafe(32 + data.byteLength)\n\n  namespaced.set(NS_SIGNATURE, 0)\n  namespaced.set(data, 32)\n\n  return sodium.crypto_sign_verify_detached(signature, namespaced, publicKey)\n}\nmodule.exports = class PairingError extends Error {\n  constructor (msg, code, fn = PairingError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name () {\n    return 'PairingError'\n  }\n\n  static PAIRING_REJECTED (msg = 'Pairing was rejected') {\n    return new PairingError(msg, 'PAIRING_REJECTED', PairingError.PAIRING_REJECTED)\n  }\n\n  static INVITE_USED (msg = 'Invite has been used') {\n    return new PairingError(msg, 'INVITE_USED', PairingError.INVITE_USED)\n  }\n\n  static INVITE_EXPIRED (msg = 'Invite has expireds') {\n    return new PairingError(msg, 'INVITE_EXPIRED', PairingError.INVITE_EXPIRED)\n  }\n}\nconst c = require('compact-encoding')\n\nconst Invite = {\n  preencode (state, i) {\n    state.end++ // version\n    state.end++ // flags\n    c.fixed32.preencode(state, i.seed)\n    if (i.discoveryKey) c.fixed32.preencode(state, i.discoveryKey)\n    if (i.expires) c.uint32.preencode(state, Math.floor(i.expires / 1000)) // store as secs\n  },\n  encode (state, i) {\n    c.uint.encode(state, 1) // version\n    c.uint.encode(state, (i.discoveryKey ? 1 : 0) | (i.expires ? 2 : 0) | (i.sensitive ? 4 : 0) | (i.testInvitation ? 8 : 0))\n    c.fixed32.encode(state, i.seed)\n    if (i.discoveryKey) c.fixed32.encode(state, i.discoveryKey)\n    if (i.expires) c.uint32.encode(state, Math.floor(i.expires / 1000))\n  },\n  decode (state) {\n    const version = c.uint.decode(state)\n    if (version !== 1) {\n      throw new Error('Unknown invite version')\n    }\n\n    const flags = c.uint.decode(state)\n\n    return {\n      seed: c.fixed32.decode(state),\n      discoveryKey: (flags & 1) ? c.fixed32.decode(state) : null,\n      expires: (flags & 2) ? c.uint32.decode(state) * 1000 : 0,\n      sensitive: (flags & 4) !== 0,\n      testInvitation: (flags & 8) !== 0\n    }\n  }\n}\n\nconst RequestPayload = {\n  preencode (state, p) {\n    c.buffer.preencode(state, p.session)\n    c.buffer.preencode(state, p.data)\n  },\n  encode (state, p) {\n    c.buffer.encode(state, p.session)\n    c.buffer.encode(state, p.data)\n  },\n  decode (state) {\n    return {\n      session: c.buffer.decode(state),\n      data: c.buffer.decode(state)\n    }\n  }\n}\n\nconst ResponseStatus = c.uint\n\nconst AdditionalData = {\n  preencode (state, m) {\n    c.buffer.preencode(state, m.data)\n    c.fixed64.preencode(state, m.signature)\n  },\n  encode (state, m) {\n    c.buffer.encode(state, m.data)\n    c.fixed64.encode(state, m.signature)\n  },\n  decode (state) {\n    return {\n      data: c.buffer.decode(state),\n      signature: c.fixed64.decode(state)\n    }\n  }\n}\n\nconst ResponsePayload = {\n  preencode (state, p) {\n    ResponseStatus.preencode(state, p.status)\n    if (p.status !== 0) return\n\n    let flags = 0\n    if (p.encryptionKey) flags |= 1\n    if (p.additional) flags |= 2\n    c.uint.preencode(state, flags) // flags\n\n    c.fixed32.preencode(state, p.key)\n    if (p.encryptionKey) c.fixed32.preencode(state, p.encryptionKey)\n    if (p.additional) AdditionalData.preencode(state, p.additional)\n  },\n  encode (state, p) {\n    ResponseStatus.encode(state, p.status)\n    if (p.status !== 0) return\n\n    let flags = 0\n    if (p.encryptionKey) flags |= 1\n    if (p.additional) flags |= 2\n    c.uint.encode(state, flags)\n\n    c.fixed32.encode(state, p.key)\n    if (p.encryptionKey) c.fixed32.encode(state, p.encryptionKey)\n    if (p.additional) AdditionalData.encode(state, p.additional)\n  },\n  decode (state) {\n    const status = ResponseStatus.decode(state)\n\n    if (status !== 0) {\n      return {\n        status,\n        key: null,\n        encryptionKey: null,\n        additional: null\n      }\n    }\n\n    const flags = c.uint.decode(state)\n    const key = c.fixed32.decode(state)\n    const encryptionKey = (flags & 1) !== 0 ? c.fixed32.decode(state) : null\n    const additional = (flags & 2) !== 0 ? AdditionalData.decode(state) : null\n\n    return {\n      status: 0,\n      key,\n      encryptionKey,\n      additional\n    }\n  }\n}\n\nconst InviteRequest = {\n  preencode (state, i) {\n    c.fixed32.preencode(state, i.inviteId)\n    RequestPayload.preencode(state, i.payload)\n  },\n  encode (state, i) {\n    c.fixed32.encode(state, i.inviteId)\n    RequestPayload.encode(state, i.payload)\n  },\n  decode (state) {\n    return {\n      inviteId: c.fixed32.decode(state),\n      payload: RequestPayload.decode(state)\n    }\n  }\n}\n\nconst InviteResponse = {\n  preencode (state, i) {\n    c.fixed32.preencode(state, i.id)\n    c.buffer.preencode(state, i.payload)\n  },\n  encode (state, i) {\n    c.fixed32.encode(state, i.id)\n    c.buffer.encode(state, i.payload)\n  },\n  decode (state) {\n    return {\n      id: c.fixed32.decode(state),\n      payload: c.buffer.decode(state)\n    }\n  }\n}\n\nconst InviteData = {\n  preencode (state, i) {\n    c.fixed64.preencode(state, i.signature)\n    c.buffer.preencode(state, i.userData)\n  },\n  encode (state, i) {\n    c.fixed64.encode(state, i.signature)\n    c.buffer.encode(state, i.userData)\n  },\n  decode (state) {\n    return {\n      signature: c.fixed64.decode(state),\n      userData: c.buffer.decode(state)\n    }\n  }\n}\n\nconst InviteReceipt = {\n  preencode (state, i) {\n    c.fixed32.preencode(state, i.session)\n    c.fixed64.preencode(state, i.signature)\n    c.buffer.preencode(state, i.userData)\n  },\n  encode (state, i) {\n    c.fixed32.encode(state, i.session)\n    c.fixed64.encode(state, i.signature)\n    c.buffer.encode(state, i.userData)\n  },\n  decode (state) {\n    return {\n      session: c.fixed32.decode(state),\n      signature: c.fixed64.decode(state),\n      userData: c.buffer.decode(state)\n    }\n  }\n}\n\nconst AuthData = {\n  preencode (state, i) {\n    c.buffer.preencode(state, i.session)\n    c.buffer.preencode(state, i.userData)\n  },\n  encode (state, i) {\n    c.buffer.encode(state, i.session)\n    c.buffer.encode(state, i.userData)\n  },\n  decode (state) {\n    return {\n      session: c.buffer.decode(state),\n      userData: c.buffer.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  Invite,\n  ResponsePayload,\n  InviteRequest,\n  InviteResponse,\n  InviteData,\n  InviteReceipt,\n  AuthData\n}\n{\n  \"name\": \"blind-pairing-core\",\n  \"version\": \"2.8.0\",\n  \"description\": \"Core blind pairing module\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib/**.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/blind-pairing-core.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/blind-pairing-core/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/blind-pairing-core#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.4\",\n    \"bare-events\": \"^2.5.0\",\n    \"compact-encoding\": \"^2.11.0\",\n    \"hypercore-crypto\": \"^3.4.0\",\n    \"sodium-universal\": \"^4.0.0\",\n    \"tiny-buffer-map\": \"^1.1.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.2.1\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst crypto = require('hypercore-crypto')\nconst b4a = require('b4a')\nconst safetyCatch = require('safety-catch')\nconst ReadyResource = require('ready-resource')\nconst Xache = require('xache')\nconst { MemberRequest, CandidateRequest, createInvite, decodeInvite, verifyReceipt, Invite } = require('blind-pairing-core')\nconst Protomux = require('protomux')\nconst c = require('compact-encoding')\nconst debounce = require('debounceify')\nconst isOptions = require('is-options')\n\nconst [NS_EPHEMERAL, NS_REPLY, NS_DISCOVERY] = crypto.namespace('blind-pairing/dht', 3)\n\nconst DEFAULT_POLL = 7 * 60 * 1000\nconst PEER_INTERVAL = 1000\n\nclass TimeoutPromise {\n  constructor (ms) {\n    this.ms = ms\n    this.resolve = null\n    this.timeout = null\n    this.destroyed = false\n    this.suspended = false\n\n    this._resolveBound = this._resolve.bind(this)\n    this._ontimerBound = this._ontimer.bind(this)\n  }\n\n  wait () {\n    if (this.destroyed) return Promise.resolve()\n    if (this.resolve) this._resolve()\n    return new Promise(this._ontimerBound)\n  }\n\n  suspend () {\n    this.suspended = true\n    if (this.timeout !== null) clearTimeout(this.timeout)\n    this.timeout = null\n  }\n\n  resume () {\n    this.suspended = false\n    if (this.resolve) this._resolve()\n  }\n\n  destroy () {\n    this.destroyed = true\n    if (this.resolve) this._resolve()\n  }\n\n  _ontimer (resolve) {\n    this.resolve = resolve\n    if (!this.suspended) this.timeout = setTimeout(this._resolveBound, this.ms)\n  }\n\n  _resolve () {\n    if (this.timeout !== null) clearTimeout(this.timeout)\n\n    const resolve = this.resolve\n    this.timeout = null\n    this.resolve = null\n\n    resolve()\n  }\n}\n\nclass BlindPairing extends ReadyResource {\n  constructor (swarm, { poll = DEFAULT_POLL, onincoming = noop } = {}) {\n    super()\n\n    this.swarm = swarm\n    this.poll = poll\n    this.active = new Map()\n    this.suspended = false\n\n    this._onincoming = onincoming\n    this._onconnectionBound = this._onconnection.bind(this)\n    this._refreshBound = this.refresh.bind(this)\n    this._refreshing = null\n\n    this.swarm.on('connection', this._onconnectionBound)\n    this.swarm.dht.on('network-change', this._refreshBound)\n  }\n\n  static Invite = Invite\n\n  static createInvite (key, opts) {\n    return createInvite(key, opts)\n  }\n\n  static decodeInvite (invite) {\n    return decodeInvite(invite)\n  }\n\n  static verifyReceipt (receipt, publicKey) {\n    return verifyReceipt(receipt, publicKey)\n  }\n\n  static createRequest (invite, userData) {\n    return new CandidateRequest(invite, userData)\n  }\n\n  async suspend () {\n    if (this.suspended) return\n    this.suspended = true\n\n    const all = []\n\n    for (const ref of this.active.values()) {\n      if (ref.candidate) all.push(ref.candidate._suspend())\n      if (ref.member) all.push(ref.member._suspend())\n    }\n\n    await Promise.allSettled(all)\n  }\n\n  resume () {\n    if (!this.suspended) return\n    this.suspended = false\n    this.refresh().catch(safetyCatch) // no need to wait for the refreshes\n  }\n\n  async refresh () {\n    if (this._refreshing) {\n      await this._refreshing\n      return\n    }\n\n    if (this.closing || this.suspended) return\n\n    const r = this._refreshing = this._refresh()\n\n    try {\n      await r\n    } finally {\n      if (r === this._refreshing) this._refreshing = null\n    }\n  }\n\n  async _refresh () {\n    if (this.closing || this.suspended) return\n\n    const all = []\n\n    for (const ref of this.active.values()) {\n      if (ref.candidate) all.push(ref.candidate.refresh())\n      if (ref.member) all.push(ref.member.refresh())\n    }\n\n    await Promise.allSettled(all)\n  }\n\n  addMember (opts) {\n    return new Member(this, opts)\n  }\n\n  addCandidate (request, opts) {\n    if (isOptions(request)) return this.addCandidate(null, request)\n    if (!request) request = new CandidateRequest(opts.invite, opts.userData)\n    return new Candidate(this, request, opts)\n  }\n\n  async _close () {\n    this.swarm.removeListener('connection', this._onconnectionBound)\n    this.swarm.dht.removeListener('network-change', this._refreshBound)\n\n    const all = []\n\n    for (const conn of this.swarm.connections) {\n      const mux = getMuxer(conn)\n      mux.unpair({ protocol: 'blind-pairing' })\n      for (const ref of this.active.values()) mux.unpair({ protocol: 'blind-pairing', id: ref.discoveryKey })\n    }\n\n    for (const ref of this.active.values()) {\n      if (ref.member) all.push(ref.member.close())\n      if (ref.candidate) all.push(ref.candidate.close())\n      if (ref.discovery) all.push(ref.discovery.destroy())\n    }\n\n    await Promise.allSettled(all)\n  }\n\n  _randomPoll () {\n    return randomInterval(this.poll)\n  }\n\n  _add (discoveryKey) {\n    const id = b4a.toString(discoveryKey, 'hex')\n    const t = this.active.get(id)\n    if (t) return t\n\n    const fresh = {\n      id,\n      discoveryKey,\n      member: null,\n      candidate: null,\n      channels: new Set(),\n      alwaysServer: false,\n      alwaysClient: false,\n      discovery: null\n    }\n\n    this.active.set(id, fresh)\n    return fresh\n  }\n\n  _swarm (ref) {\n    const server = ref.alwaysServer || !!ref.member\n    const client = ref.alwaysClient || !!ref.candidate\n\n    if (ref.discovery && ref.discovery.isServer === server && ref.discovery.isClient === client) {\n      return\n    }\n\n    if (ref.discovery) ref.discovery.destroy().catch(safetyCatch)\n\n    // just a sanity check, not needed but doesnt hurt\n    if (!server && !client) return\n\n    ref.discovery = this.swarm.join(ref.discoveryKey, { server, client })\n    this._attachToSwarm(ref)\n  }\n\n  _attachToSwarm (ref) {\n    for (const conn of this.swarm.connections) {\n      const mux = getMuxer(conn)\n      this._attachToMuxer(mux, ref.discoveryKey, ref)\n    }\n  }\n\n  _gc (ref) {\n    if (ref.member || ref.candidate) {\n      if (ref.discovery) this._swarm(ref) // in case it needs updating...\n      return false\n    }\n    this.active.delete(ref.id)\n    for (const ch of ref.channels) ch.close()\n    for (const conn of this.swarm.connections) {\n      const mux = getMuxer(conn)\n      mux.unpair({ protocol: 'blind-pairing', id: ref.discoveryKey })\n    }\n    if (ref.discovery) ref.discovery.destroy().catch(safetyCatch)\n    return true\n  }\n\n  _onconnection (conn) {\n    const mux = getMuxer(conn)\n\n    mux.pair({ protocol: 'blind-pairing' }, this._onincoming)\n\n    for (const ref of this.active.values()) {\n      this._attachToMuxer(mux, ref.discoveryKey, ref)\n    }\n  }\n\n  _attachToMuxer (mux, discoveryKey, ref) {\n    if (!ref) ref = this._add(discoveryKey)\n\n    const ch = mux.createChannel({\n      protocol: 'blind-pairing',\n      id: discoveryKey,\n      messages: [\n        { encoding: c.buffer, onmessage: (req) => this._onpairingrequest(ch, ref, req) },\n        { encoding: c.buffer, onmessage: (res) => this._onpairingresponse(ch, ref, res) }\n      ],\n      onclose: () => {\n        ref.channels.delete(ch)\n        if (ref.candidate) ref.candidate.visited.delete(ch)\n      }\n    })\n\n    if (ch === null) return\n\n    ch.open()\n    mux.pair({ protocol: 'blind-pairing', id: discoveryKey }, () => this._attachToMuxer(mux, discoveryKey, null))\n    ref.channels.add(ch)\n\n    if (ref.candidate) ref.candidate.broadcast()\n  }\n\n  async _onpairingrequest (ch, ref, req) {\n    if (!ref.member) return\n\n    const request = await ref.member._addRequest(req)\n    if (!request) return\n\n    ch.messages[1].send(request.response)\n  }\n\n  async _onpairingresponse (ch, ref, res) {\n    if (!ref.candidate) return\n\n    await ref.candidate._addResponse(res, false)\n  }\n}\n\nclass Member extends ReadyResource {\n  constructor (blind, { announce = true, discoveryKey, onadd = noop } = {}) {\n    super()\n\n    if (!discoveryKey) {\n      throw new Error('Must provide discoveryKey')\n    }\n\n    const ref = blind._add(discoveryKey)\n\n    if (ref.member) {\n      throw new Error('Active member already exist')\n    }\n\n    ref.member = this\n\n    this._pendingRequests = new Map()\n\n    this.blind = blind\n    this.dht = blind.swarm.dht\n    this.discoveryKey = discoveryKey\n    this.pairingDiscoveryKey = deriveDiscoveryKey(discoveryKey)\n    this.timeout = new TimeoutPromise(blind._randomPoll())\n    this.pairing = null\n    this.skip = new Xache({ maxSize: 512 })\n    this.ref = ref\n    this.onadd = onadd\n\n    this._activeQuery = null\n    this._activePoll = null\n    this._closestNodes = null\n    this._autoAnnounce = announce\n\n    this.ready()\n  }\n\n  announce () {\n    if (this.pairing) return this.pairing\n\n    this.blind._swarm(this.ref)\n    this.pairing = this._run()\n    this.pairing.catch(safetyCatch)\n\n    return this.pairing\n  }\n\n  async flushed () {\n    if (!this.ref.discovery) return\n    return this.ref.discovery.flushed()\n  }\n\n  _open () {\n    if (this._autoAnnounce) this.announce()\n    else this.blind._attachToSwarm(this.ref)\n  }\n\n  _suspend () {\n    this.timeout.suspend()\n    return this._abort()\n  }\n\n  async _abort () {\n    if (this._activeQuery) this._activeQuery.destroy()\n    while (this._activePoll !== null) await this._activePoll\n  }\n\n  async refresh () {\n    await this._abort()\n    this.timeout.resume()\n  }\n\n  async _close () {\n    this.ref.member = null\n    this.blind._gc(this.ref)\n    this.timeout.destroy()\n    await this._abort()\n\n    try {\n      await this.pairing\n    } catch {\n      // ignore errors since we teardown\n    }\n  }\n\n  async _run () {\n    while (!this.closing) {\n      this._activePoll = this._poll()\n      await this._activePoll\n      this._activePoll = null\n      await this.timeout.wait()\n    }\n  }\n\n  async _poll () {\n    const visited = new Set()\n    let alwaysClient = false\n\n    if (this._activeQuery) this._activeQuery.destroy()\n\n    const query = this._activeQuery = this.dht.lookup(this.pairingDiscoveryKey, { closestNodes: this._closestNodes })\n\n    try {\n      for await (const data of this._activeQuery) {\n        if (this.closing || this.blind.suspended) return\n\n        for (const peer of data.peers) {\n          const id = b4a.toString(peer.publicKey, 'hex')\n\n          if (visited.has(id) || this.skip.get(id)) continue\n          visited.add(id)\n\n          try {\n            if (await this._add(peer.publicKey, id)) alwaysClient = true\n          } catch (err) {\n            safetyCatch(err)\n          }\n\n          if (this.closing || this.blind.suspended) return\n\n          if (alwaysClient && !this.ref.alwaysClient) {\n            this.ref.alwaysClient = true\n            this.blind._swarm(this.ref)\n          }\n        }\n      }\n    } catch {\n      // do nothing\n    } finally {\n      const nodes = this._activeQuery.closestNodes\n      if (this._activeQuery === query) this._activeQuery = null\n      if (nodes && nodes.length > 0) this._closestNodes = nodes\n    }\n\n    if (alwaysClient) this._revertClientAfterFlush() // safe to do in bg\n  }\n\n  async _revertClientAfterFlush () {\n    try {\n      await this.blind.swarm.flush()\n    } catch {\n      return\n    }\n    if (this.closing || this.blind.suspended) return\n\n    this.ref.alwaysClient = false\n    this.blind._swarm(this.ref)\n  }\n\n  async _addRequest (value) {\n    let request = null\n    try {\n      request = MemberRequest.from(value)\n    } catch {\n      return null\n    }\n\n    request.discoveryKey = this.discoveryKey\n\n    const session = b4a.toString(request.requestData.session, 'hex')\n\n    if (!this._pendingRequests.has(session)) {\n      this._pendingRequests.set(session, {\n        request,\n        promise: this.onadd(request)\n      })\n    }\n\n    // laod existing request if it exists\n    const pending = this._pendingRequests.get(session)\n\n    try {\n      await pending.promise\n    } catch (e) {\n      safetyCatch(e)\n      return null\n    }\n\n    this._pendingRequests.delete(session)\n\n    if (!pending.request.response) return null\n\n    return pending.request\n  }\n\n  async _add (publicKey, id) {\n    const node = await this.dht.mutableGet(publicKey, { latest: false })\n    if (!node) return false\n\n    this.skip.set(id, true)\n\n    const request = await this._addRequest(node.value)\n    if (!request) return false\n\n    const replyKeyPair = deriveReplyKeyPair(request.token)\n    await this.dht.mutablePut(replyKeyPair, request.response)\n\n    return true\n  }\n}\n\nclass Candidate extends ReadyResource {\n  constructor (blind, request, { discoveryKey = request.discoveryKey, onadd = noop } = {}) {\n    super()\n\n    const ref = blind._add(discoveryKey)\n    if (ref.candidate) {\n      throw new Error('Active candidate already exist')\n    }\n\n    ref.candidate = this\n\n    this.blind = blind\n    this.discoveryKey = discoveryKey\n    this.pairingDiscoveryKey = deriveDiscoveryKey(discoveryKey)\n    this.dht = blind.swarm.dht\n    this.request = request\n    this.token = request.token\n    this.timeout = new TimeoutPromise(blind._randomPoll())\n    this.announced = false\n    this.gcing = null\n    this.ref = ref\n    this.paired = null\n    this.pairing = null\n    this.onadd = onadd\n\n    this.signal = null\n    this.visited = new Set()\n    this.broadcast = debounce(this._broadcast.bind(this))\n\n    this._activePoll = null\n\n    this.ready()\n  }\n\n  _open () {\n    this.blind._swarm(this.ref)\n    this.pairing = this._run()\n    this.broadcast()\n  }\n\n  _suspend () {\n    this.timeout.suspend()\n    // no good way to suspend the mut gets atm unfortunately so we just rely on the polls timing out\n  }\n\n  async refresh () {\n    while (this._activePoll !== null) await this._activePoll\n    this.announced = false\n    this.timeout.resume()\n  }\n\n  async _close () {\n    this.ref.candidate = null\n    this.blind._gc(this.ref)\n    this.timeout.destroy()\n    this.visited.clear()\n    await this.pairing\n    // gc never throws\n    if (this.gcing) await this.gcing\n  }\n\n  async _addResponse (value, gc) {\n    if (this.paired) return\n\n    const paired = this.request.handleResponse(value)\n    if (!paired) return\n\n    this.paired = paired\n    if (this.signal) this.signal.destroy()\n\n    if ((gc || this.announced) && !this.gcing) this.gcing = this._gc() // gc in the background\n    await this.onadd(paired)\n    this.timeout.destroy()\n  }\n\n  async _run () {\n    while (!this._done()) {\n      this._activePoll = this._poll()\n      await this._activePoll\n      this._activePoll = null\n      if (this._done()) break\n      await this.timeout.wait()\n    }\n\n    this.close().catch(safetyCatch)\n    return this.paired\n  }\n\n  _done () {\n    return !!(this.closing || this.paired)\n  }\n\n  async _announce () {\n    const eph = deriveEphemeralKeyPair(this.token)\n\n    await this.dht.mutablePut(eph, this.request.encode())\n    if (this._done()) return\n\n    await this.dht.announce(this.pairingDiscoveryKey, eph).finished()\n    if (this._done()) return\n\n    if (!this.paired) {\n      this.ref.alwaysServer = true\n      this.blind._swarm(this.ref)\n    }\n\n    this.emit('announce')\n  }\n\n  async _gc () {\n    const eph = deriveEphemeralKeyPair(this.token)\n\n    try {\n      await this.dht.unannounce(this.pairingDiscoveryKey, eph)\n    } catch (err) {\n      safetyCatch(err) // just gc, whatevs\n    }\n  }\n\n  _sendRequest (ch) {\n    ch.messages[0].send(this.request.encode())\n    this.visited.add(ch)\n  }\n\n  async _broadcast () {\n    for (const channel of this.closestPeers()) {\n      this.signal = new TimeoutPromise(randomInterval(PEER_INTERVAL))\n      if (channel) this._sendRequest(channel)\n\n      await this.signal.wait() // resolves on destroy\n\n      if (this.paired || this.suspended) break\n    }\n  }\n\n  * closestPeers () {\n    while (!this.paired) {\n      const closest = Infinity\n      let channel = null\n\n      for (const ch of this.ref.channels) {\n        if (this.visited.has(ch)) continue\n\n        const { rtt } = ch._mux.stream.rawStream\n        if (rtt < closest) channel = ch\n      }\n\n      if (!channel) return\n\n      yield channel\n    }\n  }\n\n  async _poll () {\n    try {\n      const value = await this._getReply()\n      if (this._done() || this.blind.suspended) return\n\n      if (value) {\n        await this._addResponse(value, true)\n        if (this._done() || this.blind.suspended) return\n      }\n\n      if (!this.announced) {\n        this.announced = true\n        await this._announce()\n      }\n    } catch {\n      // can run in bg, should never crash it\n    }\n  }\n\n  async _getReply () {\n    const { publicKey } = deriveReplyKeyPair(this.token)\n    const node = await this.dht.mutableGet(publicKey, { latest: false })\n    if (!node) return null\n    return node.value\n  }\n}\n\nmodule.exports = BlindPairing\n\nfunction noop () {}\n\nfunction deriveReplyKeyPair (token) {\n  return crypto.keyPair(crypto.hash([NS_REPLY, token]))\n}\n\nfunction deriveEphemeralKeyPair (token) {\n  return crypto.keyPair(crypto.hash([NS_EPHEMERAL, token]))\n}\n\nfunction deriveDiscoveryKey (discoveryKey) {\n  return crypto.hash([NS_DISCOVERY, discoveryKey])\n}\n\nfunction getMuxer (stream) {\n  if (stream.userData) return stream.userData\n  const protocol = Protomux.from(stream)\n  stream.setKeepAlive(5000)\n  stream.userData = protocol\n  return protocol\n}\n\nfunction randomInterval (n) {\n  return n + (n * 0.5 * Math.random()) | 0\n}\n{\n  \"name\": \"blind-pairing\",\n  \"version\": \"2.3.1\",\n  \"description\": \"Blind pairing using Hyperswarm\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {\n    \"blind-pairing-core\": \"^2.0.0\",\n    \"b4a\": \"^1.6.4\",\n    \"debounceify\": \"^1.1.0\",\n    \"hypercore-crypto\": \"^3.4.0\",\n    \"is-options\": \"^1.0.2\",\n    \"ready-resource\": \"^1.0.0\",\n    \"safety-catch\": \"^1.0.2\",\n    \"xache\": \"^1.2.0\"\n  },\n  \"devDependencies\": {\n    \"@hyperswarm/testnet\": \"^3.1.4\",\n    \"brittle\": \"^3.3.2\",\n    \"hyperdht\": \"^6.8.9\",\n    \"hyperswarm\": \"^4.7.3\",\n    \"minimist\": \"^1.2.8\",\n    \"standard\": \"^17.1.0\",\n    \"z32\": \"^1.0.1\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/blind-pairing.git\"\n  },\n  \"author\": \"Holepunch Inc\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/blind-pairing/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/blind-pairing\"\n}\nconst EventEmitter = require('events')\nconst Protomux = require('protomux')\nconst { Readable } = require('streamx')\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\nconst bitfield = require('compact-encoding-bitfield')\nconst bits = require('bits-to-bytes')\nconst errors = require('./lib/errors')\nconst { createTracer } = require('hypertrace')\n\nexports.Server = class BlindRelayServer extends EventEmitter {\n  constructor (opts = {}) {\n    super()\n\n    const {\n      createStream\n    } = opts\n\n    this._createStream = createStream\n    this._pairing = new Map()\n    this._sessions = new Set()\n  }\n\n  get sessions () {\n    return this._sessions[Symbol.iterator]()\n  }\n\n  accept (stream, opts) {\n    const session = new BlindRelaySession(this, stream, opts)\n\n    this._sessions.add(session)\n\n    return session\n  }\n\n  async close () {\n    const ending = []\n\n    for (const session of this._sessions) {\n      ending.push(session.end())\n    }\n\n    await Promise.all(ending)\n\n    this._pairing.clear()\n  }\n}\n\nclass BlindRelaySession extends EventEmitter {\n  constructor (server, stream, opts = {}) {\n    super()\n\n    const {\n      id,\n      handshake,\n      handshakeEncoding\n    } = opts\n\n    this.tracer = createTracer(this, {\n      props: {\n        id,\n        remotePublicKey: stream.remotePublicKey\n      }\n    })\n\n    this._server = server\n    this._mux = Protomux.from(stream)\n\n    this._channel = this._mux.createChannel({\n      protocol: 'blind-relay',\n      id,\n      handshake: handshake ? handshakeEncoding || c.raw : null,\n      onopen: this._onopen.bind(this),\n      onclose: this._onclose.bind(this),\n      ondestroy: this._ondestroy.bind(this)\n    })\n\n    this._pair = this._channel.addMessage({\n      encoding: m.pair,\n      onmessage: this._onpair.bind(this)\n    })\n\n    this._unpair = this._channel.addMessage({\n      encoding: m.unpair,\n      onmessage: this._onunpair.bind(this)\n    })\n\n    this._ending = null\n    this._destroyed = false\n    this._error = null\n    this._pairing = new Set()\n    this._streams = new Map()\n\n    this._onerror = (err) => this.emit('error', err)\n\n    this._channel.open(handshake)\n  }\n\n  get closed () {\n    return this._channel.closed\n  }\n\n  get mux () {\n    return this._mux\n  }\n\n  get stream () {\n    return this._mux.stream\n  }\n\n  _onopen () {\n    this.tracer.trace('open')\n    this.emit('open')\n  }\n\n  _onclose () {\n    this._ending = Promise.resolve()\n\n    const err = this._error || errors.CHANNEL_CLOSED()\n\n    for (const token of this._pairing) {\n      this._server._pairing.delete(token.toString('hex'))\n    }\n\n    for (const stream of this._streams.values()) {\n      stream\n        .off('error', this._onerror)\n        .on('error', noop)\n        .destroy(err)\n    }\n\n    this._pairing.clear()\n    this._streams.clear()\n\n    this._server._sessions.delete(this)\n\n    this.tracer.trace('close', { error: err })\n    this.emit('close')\n  }\n\n  _ondestroy () {\n    this._destroyed = true\n    this.emit('destroy')\n  }\n\n  _onpair ({ isInitiator, token, id: remoteId }) {\n    const keyString = token.toString('hex')\n\n    let pair = this._server._pairing.get(keyString)\n\n    if (pair === undefined) {\n      pair = new BlindRelayPair(token)\n      this._server._pairing.set(keyString, pair)\n    } else if (pair.links[+isInitiator]) return\n\n    this._pairing.add(keyString)\n\n    pair.links[+isInitiator] = new BlindRelayLink(this, isInitiator, remoteId)\n\n    if (!pair.paired) return\n\n    this._server._pairing.delete(keyString)\n\n    // 1st pass: Create the raw streams needed for each end of the link.\n    for (const link of pair.links) {\n      link.createStream()\n    }\n\n    // 2nd pass: Connect the raw streams and set up handlers.\n    for (const { isInitiator, session, stream } of pair.links) {\n      const remote = pair.remote(isInitiator)\n\n      stream\n        .on('error', session._onerror)\n        .on('close', () => session._streams.delete(keyString))\n        .relayTo(remote.stream)\n\n      session._pairing.delete(keyString)\n      session._streams.set(keyString, stream)\n    }\n\n    // 3rd pass: Let either end of the link know the streams were set up.\n    for (const { isInitiator, session, remoteId, stream } of pair.links) {\n      session._pair.send({\n        isInitiator,\n        token,\n        id: stream.id,\n        seq: 0\n      })\n\n      session._endMaybe()\n\n      session.emit('pair', isInitiator, token, stream, remoteId)\n    }\n  }\n\n  _onunpair ({ token }) {\n    const keyString = token.toString('hex')\n\n    const pair = this._server._pairing.get(keyString)\n\n    if (pair) {\n      for (const link of pair.links) {\n        if (link) link.session._pairing.delete(keyString)\n      }\n\n      return this._server._pairing.delete(keyString)\n    }\n\n    const stream = this._streams.get(keyString)\n\n    if (stream) {\n      stream\n        .off('error', this._onerror)\n        .on('error', noop)\n        .destroy(errors.PAIRING_CANCELLED())\n\n      this._streams.delete(keyString)\n    }\n  }\n\n  cork () {\n    this._channel.cork()\n  }\n\n  uncork () {\n    this._channel.uncork()\n  }\n\n  async end () {\n    if (this._ending) return this._ending\n\n    this._ending = EventEmitter.once(this, 'close')\n    this._endMaybe()\n\n    return this._ending\n  }\n\n  _endMaybe () {\n    if (this._ending && this._pairing.size === 0) {\n      this._channel.close()\n    }\n  }\n\n  destroy (err) {\n    if (this._destroyed) return\n    this._destroyed = true\n\n    this._error = err || errors.CHANNEL_DESTROYED()\n    this._channel.close()\n    this.tracer.trace('destroy', { error: this._error })\n  }\n}\n\nclass BlindRelayPair {\n  constructor (token) {\n    this.token = token\n    this.links = [null, null]\n  }\n\n  get paired () {\n    return this.links[0] !== null && this.links[1] !== null\n  }\n\n  remote (isInitiator) {\n    return this.links[isInitiator ? 0 : 1]\n  }\n}\n\nclass BlindRelayLink {\n  constructor (session, isInitiator, remoteId) {\n    this.session = session\n    this.isInitiator = isInitiator\n    this.remoteId = remoteId\n    this.stream = null\n  }\n\n  createStream () {\n    if (this.stream) return\n\n    this.stream = this.session._server._createStream({\n      firewall: this._onfirewall.bind(this)\n    })\n  }\n\n  _onfirewall (socket, port, host) {\n    this.stream.connect(socket, this.remoteId, port, host)\n\n    return false\n  }\n}\n\nexports.Client = class BlindRelayClient extends EventEmitter {\n  static _clients = new WeakMap()\n\n  static from (stream, opts) {\n    let client = this._clients.get(stream)\n    if (client) return client\n    client = new this(stream, opts)\n    this._clients.set(stream, client)\n    return client\n  }\n\n  constructor (stream, opts = {}) {\n    super()\n\n    const {\n      id,\n      handshake,\n      handshakeEncoding\n    } = opts\n\n    this.tracer = createTracer(this, {\n      props: {\n        id,\n        remotePublicKey: stream.remotePublicKey\n      }\n    })\n\n    this._mux = Protomux.from(stream)\n\n    this._channel = this._mux.createChannel({\n      protocol: 'blind-relay',\n      id,\n      handshake: handshake ? handshakeEncoding || c.raw : null,\n      onopen: this._onopen.bind(this),\n      onclose: this._onclose.bind(this),\n      ondestroy: this._ondestroy.bind(this)\n    })\n\n    this._pair = this._channel.addMessage({\n      encoding: m.pair,\n      onmessage: this._onpair.bind(this)\n    })\n\n    this._unpair = this._channel.addMessage({\n      encoding: m.unpair\n    })\n\n    this._ending = false\n    this._destroyed = false\n    this._error = null\n    this._requests = new Map()\n\n    this._channel.open(handshake)\n  }\n\n  get closed () {\n    return this._channel.closed\n  }\n\n  get mux () {\n    return this._mux\n  }\n\n  get stream () {\n    return this._mux.stream\n  }\n\n  get requests () {\n    return this._requests.values()\n  }\n\n  _onopen () {\n    this.tracer.trace('open')\n    this.emit('open')\n  }\n\n  _onclose () {\n    this._ending = Promise.resolve()\n\n    const err = this._error || errors.CHANNEL_CLOSED()\n\n    for (const request of this._requests.values()) {\n      request.destroy(err)\n    }\n\n    this._requests.clear()\n\n    this.constructor._clients.delete(this.stream)\n\n    this.tracer.trace('close', { error: err })\n    this.emit('close')\n  }\n\n  _ondestroy () {\n    this._destroyed = true\n    this.emit('destroy')\n  }\n\n  _onpair ({ isInitiator, token, id: remoteId }) {\n    const request = this._requests.get(token.toString('hex'))\n\n    if (request === undefined || request.isInitiator !== isInitiator) return\n\n    request.push(remoteId)\n    request.push(null)\n\n    this.emit('pair', request.isInitiator, request.token, request.stream, remoteId)\n  }\n\n  pair (isInitiator, token, stream) {\n    if (this._destroyed) throw errors.CHANNEL_DESTROYED()\n\n    const keyString = token.toString('hex')\n\n    if (this._requests.has(keyString)) throw errors.ALREADY_PAIRING()\n\n    const request = new BlindRelayRequest(this, isInitiator, token, stream)\n\n    this._requests.set(keyString, request)\n\n    return request\n  }\n\n  unpair (token) {\n    if (this._destroyed) throw errors.CHANNEL_DESTROYED()\n\n    const request = this._requests.get(token.toString('hex'))\n\n    if (request) request.destroy(errors.PAIRING_CANCELLED())\n\n    this._unpair.send({ token })\n  }\n\n  cork () {\n    this._channel.cork()\n  }\n\n  uncork () {\n    this._channel.uncork()\n  }\n\n  async end () {\n    if (this._ending) return this._ending\n\n    this._ending = EventEmitter.once(this, 'close')\n    this._endMaybe()\n\n    return this._ending\n  }\n\n  _endMaybe () {\n    if (this._ending && this._requests.size === 0) {\n      this._channel.close()\n    }\n  }\n\n  destroy (err) {\n    if (this._destroyed) return\n    this._destroyed = true\n\n    this._error = err || errors.CHANNEL_DESTROYED()\n    this._channel.close()\n    this.tracer.trace('destroy', { error: err })\n  }\n}\n\nclass BlindRelayRequest extends Readable {\n  constructor (client, isInitiator, token, stream) {\n    super()\n\n    this.client = client\n    this.isInitiator = isInitiator\n    this.token = token\n    this.stream = stream\n\n    this.tracer = createTracer(this, {\n      parent: client.tracer\n    })\n  }\n\n  _open (cb) {\n    if (this.client._destroyed) return cb(errors.CHANNEL_DESTROYED())\n\n    this.tracer.trace('open', {\n      isInitiator: this.isInitiator,\n      stream: this.stream\n    })\n\n    this.client._pair.send({\n      isInitiator: this.isInitiator,\n      token: this.token,\n      id: this.stream.id,\n      seq: 0\n    })\n\n    cb(null)\n  }\n\n  _destroy (cb) {\n    this.tracer.trace('destroy')\n\n    this.client._requests.delete(this.token.toString('hex'))\n\n    cb(null)\n\n    this.client._endMaybe()\n  }\n}\n\nexports.token = function token (buf = b4a.allocUnsafe(32)) {\n  sodium.randombytes_buf(buf)\n  return buf\n}\n\nfunction noop () {}\n\nconst m = exports.messages = {}\n\nconst flags = bitfield(7)\n\nm.pair = {\n  preencode (state, m) {\n    flags.preencode(state)\n    c.fixed32.preencode(state, m.token)\n    c.uint.preencode(state, m.id)\n    c.uint.preencode(state, m.seq)\n  },\n  encode (state, m) {\n    flags.encode(state, bits.of(m.isInitiator))\n    c.fixed32.encode(state, m.token)\n    c.uint.encode(state, m.id)\n    c.uint.encode(state, m.seq)\n  },\n  decode (state) {\n    const [isInitiator] = bits.iterator(flags.decode(state))\n\n    return {\n      isInitiator,\n      token: c.fixed32.decode(state),\n      id: c.uint.decode(state),\n      seq: c.uint.decode(state)\n    }\n  }\n}\n\nm.unpair = {\n  preencode (state, m) {\n    flags.preencode(state)\n    c.fixed32.preencode(state, m.token)\n  },\n  encode (state, m) {\n    flags.encode(state, bits.of())\n    c.fixed32.encode(state, m.token)\n  },\n  decode (state) {\n    flags.decode(state)\n\n    return {\n      token: c.fixed32.decode(state)\n    }\n  }\n}\nmodule.exports = class BlindRelayError extends Error {\n  constructor (msg, code, fn = BlindRelayError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name () {\n    return 'BlindRelayError'\n  }\n\n  static DUPLICATE_CHANNEL (msg = 'Duplicate channel') {\n    return new BlindRelayError(msg, 'DUPLICATE_CHANNEL', BlindRelayError.DUPLICATE_CHANNEL)\n  }\n\n  static CHANNEL_CLOSED (msg = 'Channel closed') {\n    return new BlindRelayError(msg, 'CHANNEL_CLOSED', BlindRelayError.CHANNEL_CLOSED)\n  }\n\n  static CHANNEL_DESTROYED (msg = 'Channel destroyed') {\n    return new BlindRelayError(msg, 'CHANNEL_DESTROYED', BlindRelayError.CHANNEL_DESTROYED)\n  }\n\n  static ALREADY_PAIRING (msg = 'Already pairing') {\n    return new BlindRelayError(msg, 'ALREADY_PAIRING', BlindRelayError.ALREADY_PAIRING)\n  }\n\n  static PAIRING_CANCELLED (msg = 'Pairing cancelled') {\n    return new BlindRelayError(msg, 'PAIRING_CANCELLED', BlindRelayError.PAIRING_CANCELLED)\n  }\n}\n{\n  \"name\": \"blind-relay\",\n  \"version\": \"1.3.3\",\n  \"description\": \"Blind relay for UDX over Protomux channels\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/blind-relay.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/blind-relay/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/blind-relay#readme\",\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.6.4\",\n    \"bare-events\": \"^2.2.0\",\n    \"bits-to-bytes\": \"^1.3.0\",\n    \"compact-encoding\": \"^2.12.0\",\n    \"compact-encoding-bitfield\": \"^1.0.0\",\n    \"hypertrace\": \"^1.4.1\",\n    \"protomux\": \"^3.5.1\",\n    \"sodium-universal\": \"^4.0.0\",\n    \"streamx\": \"^2.15.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.2.1\",\n    \"hyperdht\": \"^6.6.1\",\n    \"standard\": \"^17.0.0\",\n    \"udx-native\": \"^1.6.1\"\n  }\n}\n// https://ipinfo.io/bogon\n\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\nconst net = require('compact-encoding-net')\n\nmodule.exports = exports = function isBogon (ip) {\n  return isBogonIP(ensureBuffer(ip))\n}\n\nexports.isBogon = exports\n\nexports.isPrivate = function isPrivate (ip) {\n  return isPrivateIP(ensureBuffer(ip))\n}\n\nfunction isBogonIP (ip) {\n  return isPrivateIP(ip) || isReservedIP(ip)\n}\n\nfunction isPrivateIP (ip) {\n  return ip.byteLength === 4 ? isPrivateIPv4(ip) : false // IPv6 has no private IPs\n}\n\nfunction isPrivateIPv4 (ip) {\n  return (\n    // 10.0.0.0/8  Private-use networks\n    (ip[0] === 10) ||\n    // 100.64.0.0/10 Carrier-grade NAT\n    (ip[0] === 100 && ip[1] >= 64 && ip[1] <= 127) ||\n    // 127.0.0.0/8 Loopback + Name collision occurrence (127.0.53.53)\n    (ip[0] === 127) ||\n    // 169.254.0.0/16  Link local\n    (ip[0] === 169 && ip[1] === 254) ||\n    // 172.16.0.0/12 Private-use networks\n    (ip[0] === 172 && ip[1] >= 16 && ip[1] <= 31) ||\n    // 192.168.0.0/16  Private-use networks\n    (ip[0] === 192 && ip[1] === 168)\n  )\n}\n\nfunction isReservedIP (ip) {\n  return ip.byteLength === 4 ? isReservedIPv4(ip) : isReservedIPv6(ip)\n}\n\nfunction isReservedIPv4 (ip) {\n  return (\n    // 0.0.0.0/8 \"This\" network\n    (ip[0] === 0) ||\n    // 192.0.0.0/24  IETF protocol assignments\n    (ip[0] === 192 && ip[1] === 0 && ip[2] === 0) ||\n    // 192.0.2.0/24  TEST-NET-1\n    (ip[0] === 192 && ip[1] === 0 && ip[2] === 2) ||\n    // 198.18.0.0/15 Network interconnect device benchmark testing\n    (ip[0] === 198 && ip[1] >= 18 && ip[1] <= 19) ||\n    // 198.51.100.0/24 TEST-NET-2\n    (ip[0] === 198 && ip[1] === 51 && ip[2] === 100) ||\n    // 203.0.113.0/24  TEST-NET-3\n    (ip[0] === 203 && ip[1] === 0 && ip[2] === 113) ||\n    // 224.0.0.0/4 Multicast\n    (ip[0] >= 224 && ip[0] <= 239) ||\n    // 240.0.0.0/4 Reserved for future use\n    (ip[0] >= 240) ||\n    // 255.255.255.255/32\n    (ip[0] === 255 && ip[1] === 255 && ip[2] === 255 && ip[3] === 255)\n  )\n}\n\nfunction isReservedIPv6 (ip) {\n  return (\n    // ::/128 Node-scope unicast unspecified address\n    // ::1/128 Node-scope unicast loopback address\n    (\n      ip[0] === 0 && ip[1] === 0 && ip[2] === 0 && ip[3] === 0 && ip[4] === 0 &&\n      ip[5] === 0 && ip[6] === 0 && ip[7] === 0 && ip[8] === 0 && ip[9] === 0 &&\n      ip[10] === 0 && ip[11] === 0 && ip[12] === 0 && ip[13] === 0 && ip[14] === 0 &&\n      ip[15] <= 1\n    ) ||\n    // ::ffff:0:0/96 IPv4-mapped addresses\n    // ::/96 IPv4-compatible addresses\n    (\n      ip[0] === 0 && ip[1] === 0 && ip[2] === 0 && ip[3] === 0 && ip[4] === 0 &&\n      ip[5] === 0 && ip[6] === 0 && ip[7] === 0 && ip[8] === 0 && ip[9] === 0 &&\n      (ip[10] === 0 || ip[10] === 0xff) &&\n      (ip[11] === 0 || ip[11] === 0xff)\n    ) ||\n    // 100::/64 Remotely triggered black hole addresses\n    (ip[0] === 0x01 && ip[1] === 0 && ip[2] === 0 && ip[3] === 0 && ip[4] === 0 && ip[5] === 0 && ip[6] === 0 && ip[7] === 0) ||\n    // 2001:10::/28 Overlay routable cryptographic hash identifiers (ORCHID)\n    (ip[0] === 0x20 && ip[1] === 0x01 && ip[2] === 0 && ip[3] >= 0x10 && ip[3] <= 0x1f) ||\n    // 2001:20::/28 Overlay routable cryptographic hash identifiers version 2 (ORCHIDv2)\n    (ip[0] === 0x20 && ip[1] === 0x01 && ip[2] === 0 && ip[3] >= 0x20 && ip[3] <= 0x2f) ||\n    // 2001:db8::/32 Documentation prefix\n    (ip[0] === 0x20 && ip[1] === 0x01 && ip[2] === 0x0d && ip[3] === 0xb8) ||\n    // fc00::/7 Unique local addresses (ULA)\n    (ip[0] >= 0xfc && ip[0] <= 0xfd) ||\n    // fe80::/10 Link-local unicast\n    (ip[0] === 0xfe && ip[1] >= 0x80 && ip[1] <= 0xbf) ||\n    // ff00::/8 Multicast\n    (ip[0] === 0xff)\n  )\n}\n\nconst state = c.state(0, 0, b4a.allocUnsafe(1 /* family */ + 16))\n\nfunction ensureBuffer (ip) {\n  if (b4a.isBuffer(ip)) return ip\n\n  net.ip.preencode(state, ip)\n  net.ip.encode(state, ip)\n\n  const buffer = state.buffer.subarray(1 /* family */, state.end)\n\n  state.start = 0\n  state.end = 0\n\n  return buffer\n}\n{\n  \"name\": \"bogon\",\n  \"version\": \"1.1.0\",\n  \"description\": \"Check if an IP is a bogon\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"dependencies\": {\n    \"compact-encoding\": \"^2.11.0\",\n    \"compact-encoding-net\": \"^1.2.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.4\",\n    \"nanobench\": \"^2.1.1\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/bogon.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/bogon/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/bogon\"\n}\nconst b4a = require('b4a')\n\nmodule.exports = codecs\n\ncodecs.ascii = createString('ascii')\ncodecs.utf8 = createString('utf-8')\ncodecs.hex = createString('hex')\ncodecs.base64 = createString('base64')\ncodecs.ucs2 = createString('ucs2')\ncodecs.utf16le = createString('utf16le')\ncodecs.ndjson = createJSON(true)\ncodecs.json = createJSON(false)\ncodecs.binary = {\n  name: 'binary',\n  encode: function encodeBinary (obj) {\n    return typeof obj === 'string'\n      ? b4a.from(obj, 'utf-8')\n      : b4a.toBuffer(obj)\n  },\n  decode: function decodeBinary (buf) {\n    return b4a.toBuffer(buf)\n  }\n}\n\nfunction isCompactEncoding (c) {\n  return !!(c.encode && c.decode && c.preencode)\n}\n\nfunction fromCompactEncoding (c) {\n  return {\n    name: 'compact-encoding',\n    encode: function encodeWithCompact (value) {\n      const state = { start: 0, end: 0, buffer: null, cache: null }\n      c.preencode(state, value)\n      state.buffer = b4a.allocUnsafe(state.end)\n      c.encode(state, value)\n      return state.buffer\n    },\n    decode: function decodeWithCompact (buffer) {\n      return c.decode({ start: 0, end: buffer.byteLength, buffer, cache: null })\n    }\n  }\n}\n\nfunction codecs (fmt, fallback) {\n  if (typeof fmt === 'object' && fmt) {\n    return isCompactEncoding(fmt) ? fromCompactEncoding(fmt) : fmt\n  }\n\n  switch (fmt) {\n    case 'ndjson': return codecs.ndjson\n    case 'json': return codecs.json\n    case 'ascii': return codecs.ascii\n    case 'utf-8':\n    case 'utf8': return codecs.utf8\n    case 'hex': return codecs.hex\n    case 'base64': return codecs.base64\n    case 'ucs-2':\n    case 'ucs2': return codecs.ucs2\n    case 'utf16-le':\n    case 'utf16le': return codecs.utf16le\n  }\n\n  return fallback !== undefined ? fallback : codecs.binary\n}\n\nfunction createJSON (newline) {\n  return {\n    name: newline ? 'ndjson' : 'json',\n    encode: newline ? encodeNDJSON : encodeJSON,\n    decode: function decodeJSON (buf) {\n      return JSON.parse(b4a.toString(buf))\n    }\n  }\n\n  function encodeJSON (val) {\n    return b4a.from(JSON.stringify(val))\n  }\n\n  function encodeNDJSON (val) {\n    return b4a.from(JSON.stringify(val) + '\\n')\n  }\n}\n\nfunction createString (type) {\n  return {\n    name: type,\n    encode: function encodeString (val) {\n      if (typeof val !== 'string') val = val.toString()\n      return b4a.from(val, type)\n    },\n    decode: function decodeString (buf) {\n      return b4a.toString(buf, type)\n    }\n  }\n}\n{\n  \"name\": \"codecs\",\n  \"version\": \"3.1.0\",\n  \"description\": \"Create an binary encoder/decoder for json, utf-8 or custom types\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.3\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.2.1\",\n    \"compact-encoding\": \"^2.11.0\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/codecs.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/codecs/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/codecs\"\n}\nconst c = require('compact-encoding')\n\nmodule.exports = function bitfield (length) {\n  if (length > 64) throw new RangeError('Bitfield cannot be larger than 64 bits')\n\n  let byteLength\n  if (length < 8) byteLength = 1\n  else if (length <= 16) byteLength = 2\n  else if (length <= 32) byteLength = 4\n  else byteLength = 8\n\n  return {\n    preencode (state) {\n      state.end++ // Length byte, used for data when byteLength === 1\n\n      if (byteLength === 1) ;\n      else if (byteLength === 2) c.uint16.preencode(state)\n      else if (byteLength === 4) c.uint32.preencode(state)\n      else c.uint64.preencode(state)\n    },\n\n    encode (state, b) {\n      if (byteLength === 1) ;\n      else if (byteLength === 2) c.uint8.encode(state, 0xfd)\n      else if (byteLength === 4) c.uint8.encode(state, 0xfe)\n      else c.uint8.encode(state, 0xff)\n\n      if (typeof b === 'number') {\n        if (byteLength === 1) c.uint8.encode(state, b)\n        else if (byteLength === 2) c.uint16.encode(state, b)\n        else if (byteLength === 4) c.uint32.encode(state, b)\n        else c.uint64.encode(state, b)\n      } else {\n        state.buffer.set(b, state.start)\n\n        if (b.byteLength < byteLength) {\n          // Zero-fill the rest of the byte length.\n          state.buffer.fill(\n            0,\n            state.start + b.byteLength,\n            state.start + byteLength\n          )\n        }\n\n        state.start += byteLength\n      }\n    },\n\n    decode (state) {\n      const byte = state.buffer[state.start]\n\n      let byteLength\n      if (byte <= 0xfc) byteLength = 1\n      else if (byte === 0xfd) byteLength = 2\n      else if (byte === 0xfe) byteLength = 4\n      else byteLength = 8\n\n      if (byteLength > 1) state.start++ // Skip the length byte\n\n      if (state.end - state.start < byteLength) throw new Error('Out of bounds')\n\n      const b = state.buffer.subarray(state.start, (state.start += byteLength))\n\n      return length <= 8 ? b.subarray(0, 1) : b\n    }\n  }\n}\n{\n  \"name\": \"compact-encoding-bitfield\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Compact codec for bitfields\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/compact-encoding/compact-encoding-bitfield.git\"\n  },\n  \"author\": \"Kasper Isager Dalsgar <kasper@funktionel.co>\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/compact-encoding/compact-encoding-bitfield/issues\"\n  },\n  \"homepage\": \"https://github.com/compact-encoding/compact-encoding-bitfield#readme\",\n  \"dependencies\": {\n    \"compact-encoding\": \"^2.4.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^1.3.5\",\n    \"standard\": \"^16.0.3\"\n  },\n  \"standard\": {\n    \"ignore\": [\n      \"__snapshots__/**\"\n    ]\n  }\n}\nconst c = require('compact-encoding')\n\nconst port = c.uint16\n\nconst address = (host, family) => {\n  return {\n    preencode (state, m) {\n      host.preencode(state, m.host)\n      port.preencode(state, m.port)\n    },\n    encode (state, m) {\n      host.encode(state, m.host)\n      port.encode(state, m.port)\n    },\n    decode (state) {\n      return {\n        host: host.decode(state),\n        family,\n        port: port.decode(state)\n      }\n    }\n  }\n}\n\nconst ipv4 = {\n  preencode (state) {\n    state.end += 4\n  },\n  encode (state, string) {\n    const start = state.start\n    const end = start + 4\n\n    let i = 0\n\n    while (i < string.length) {\n      let n = 0\n      let c\n\n      while (i < string.length && (c = string.charCodeAt(i++)) !== /* . */ 0x2e) {\n        n = n * 10 + (c - /* 0 */ 0x30)\n      }\n\n      state.buffer[state.start++] = n\n    }\n\n    state.start = end\n  },\n  decode (state) {\n    if (state.end - state.start < 4) throw new Error('Out of bounds')\n    return (\n      state.buffer[state.start++] + '.' +\n      state.buffer[state.start++] + '.' +\n      state.buffer[state.start++] + '.' +\n      state.buffer[state.start++]\n    )\n  }\n}\n\nconst ipv4Address = address(ipv4, 4)\n\nconst ipv6 = {\n  preencode (state) {\n    state.end += 16\n  },\n  encode (state, string) {\n    const start = state.start\n    const end = start + 16\n\n    let i = 0\n    let split = null\n\n    while (i < string.length) {\n      let n = 0\n      let c\n\n      while (i < string.length && (c = string.charCodeAt(i++)) !== /* : */ 0x3a) {\n        if (c >= 0x30 && c <= 0x39) n = n * 0x10 + (c - /* 0 */ 0x30)\n        else if (c >= 0x41 && c <= 0x46) n = n * 0x10 + (c - /* A */ 0x41 + 10)\n        else if (c >= 0x61 && c <= 0x66) n = n * 0x10 + (c - /* a */ 0x61 + 10)\n      }\n\n      state.buffer[state.start++] = n >>> 8\n      state.buffer[state.start++] = n\n\n      if (i < string.length && string.charCodeAt(i) === /* : */ 0x3a) {\n        i++\n        split = state.start\n      }\n    }\n\n    if (split !== null) {\n      const offset = end - state.start\n      state.buffer\n        .copyWithin(split + offset, split)\n        .fill(0, split, split + offset)\n    }\n\n    state.start = end\n  },\n  decode (state) {\n    if (state.end - state.start < 16) throw new Error('Out of bounds')\n    return (\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16)\n    )\n  }\n}\n\nconst ipv6Address = address(ipv6, 6)\n\nconst ip = {\n  preencode (state, string) {\n    const family = string.includes(':') ? 6 : 4\n    c.uint8.preencode(state, family)\n    if (family === 4) ipv4.preencode(state)\n    else ipv6.preencode(state)\n  },\n  encode (state, string) {\n    const family = string.includes(':') ? 6 : 4\n    c.uint8.encode(state, family)\n    if (family === 4) ipv4.encode(state, string)\n    else ipv6.encode(state, string)\n  },\n  decode (state) {\n    const family = c.uint8.decode(state)\n    if (family === 4) return ipv4.decode(state)\n    else return ipv6.decode(state)\n  }\n}\n\nconst ipAddress = {\n  preencode (state, m) {\n    ip.preencode(state, m.host)\n    port.preencode(state, m.port)\n  },\n  encode (state, m) {\n    ip.encode(state, m.host)\n    port.encode(state, m.port)\n  },\n  decode (state) {\n    const family = c.uint8.decode(state)\n    return {\n      host: family === 4 ? ipv4.decode(state) : ipv6.decode(state),\n      family,\n      port: port.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  port,\n  ipv4,\n  ipv4Address,\n  ipv6,\n  ipv6Address,\n  ip,\n  ipAddress\n}\n{\n  \"name\": \"compact-encoding-net\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Compact codecs for net types\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/compact-encoding/compact-encoding-net.git\"\n  },\n  \"author\": \"Kasper Isager Dalsgar <kasper@funktionel.co>\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/compact-encoding/compact-encoding-net/issues\"\n  },\n  \"homepage\": \"https://github.com/compact-encoding/compact-encoding-net#readme\",\n  \"dependencies\": {\n    \"compact-encoding\": \"^2.4.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^1.3.5\",\n    \"nanobench\": \"^2.1.1\",\n    \"standard\": \"^16.0.3\"\n  }\n}\nconst LE = exports.LE = (new Uint8Array(new Uint16Array([0xff]).buffer))[0] === 0xff\n\nexports.BE = !LE\nconst b4a = require('b4a')\n\nconst { BE } = require('./endian')\n\nexports.state = function (start = 0, end = 0, buffer = null) {\n  return { start, end, buffer, cache: null }\n}\n\nconst raw = exports.raw = require('./raw')\n\nconst uint = exports.uint = {\n  preencode (state, n) {\n    state.end += n <= 0xfc ? 1 : n <= 0xffff ? 3 : n <= 0xffffffff ? 5 : 9\n  },\n  encode (state, n) {\n    if (n <= 0xfc) uint8.encode(state, n)\n    else if (n <= 0xffff) {\n      state.buffer[state.start++] = 0xfd\n      uint16.encode(state, n)\n    } else if (n <= 0xffffffff) {\n      state.buffer[state.start++] = 0xfe\n      uint32.encode(state, n)\n    } else {\n      state.buffer[state.start++] = 0xff\n      uint64.encode(state, n)\n    }\n  },\n  decode (state) {\n    const a = uint8.decode(state)\n    if (a <= 0xfc) return a\n    if (a === 0xfd) return uint16.decode(state)\n    if (a === 0xfe) return uint32.decode(state)\n    return uint64.decode(state)\n  }\n}\n\nconst uint8 = exports.uint8 = {\n  preencode (state, n) {\n    state.end += 1\n  },\n  encode (state, n) {\n    validateUint(n)\n    state.buffer[state.start++] = n\n  },\n  decode (state) {\n    if (state.start >= state.end) throw new Error('Out of bounds')\n    return state.buffer[state.start++]\n  }\n}\n\nconst uint16 = exports.uint16 = {\n  preencode (state, n) {\n    state.end += 2\n  },\n  encode (state, n) {\n    validateUint(n)\n    state.buffer[state.start++] = n\n    state.buffer[state.start++] = n >>> 8\n  },\n  decode (state) {\n    if (state.end - state.start < 2) throw new Error('Out of bounds')\n    return (\n      state.buffer[state.start++] +\n      state.buffer[state.start++] * 0x100\n    )\n  }\n}\n\nconst uint24 = exports.uint24 = {\n  preencode (state, n) {\n    state.end += 3\n  },\n  encode (state, n) {\n    validateUint(n)\n    state.buffer[state.start++] = n\n    state.buffer[state.start++] = n >>> 8\n    state.buffer[state.start++] = n >>> 16\n  },\n  decode (state) {\n    if (state.end - state.start < 3) throw new Error('Out of bounds')\n    return (\n      state.buffer[state.start++] +\n      state.buffer[state.start++] * 0x100 +\n      state.buffer[state.start++] * 0x10000\n    )\n  }\n}\n\nconst uint32 = exports.uint32 = {\n  preencode (state, n) {\n    state.end += 4\n  },\n  encode (state, n) {\n    validateUint(n)\n    state.buffer[state.start++] = n\n    state.buffer[state.start++] = n >>> 8\n    state.buffer[state.start++] = n >>> 16\n    state.buffer[state.start++] = n >>> 24\n  },\n  decode (state) {\n    if (state.end - state.start < 4) throw new Error('Out of bounds')\n    return (\n      state.buffer[state.start++] +\n      state.buffer[state.start++] * 0x100 +\n      state.buffer[state.start++] * 0x10000 +\n      state.buffer[state.start++] * 0x1000000\n    )\n  }\n}\n\nconst uint40 = exports.uint40 = {\n  preencode (state, n) {\n    state.end += 5\n  },\n  encode (state, n) {\n    validateUint(n)\n    const r = Math.floor(n / 0x100)\n    uint8.encode(state, n)\n    uint32.encode(state, r)\n  },\n  decode (state) {\n    if (state.end - state.start < 5) throw new Error('Out of bounds')\n    return uint8.decode(state) + 0x100 * uint32.decode(state)\n  }\n}\n\nconst uint48 = exports.uint48 = {\n  preencode (state, n) {\n    state.end += 6\n  },\n  encode (state, n) {\n    validateUint(n)\n    const r = Math.floor(n / 0x10000)\n    uint16.encode(state, n)\n    uint32.encode(state, r)\n  },\n  decode (state) {\n    if (state.end - state.start < 6) throw new Error('Out of bounds')\n    return uint16.decode(state) + 0x10000 * uint32.decode(state)\n  }\n}\n\nconst uint56 = exports.uint56 = {\n  preencode (state, n) {\n    state.end += 7\n  },\n  encode (state, n) {\n    validateUint(n)\n    const r = Math.floor(n / 0x1000000)\n    uint24.encode(state, n)\n    uint32.encode(state, r)\n  },\n  decode (state) {\n    if (state.end - state.start < 7) throw new Error('Out of bounds')\n    return uint24.decode(state) + 0x1000000 * uint32.decode(state)\n  }\n}\n\nconst uint64 = exports.uint64 = {\n  preencode (state, n) {\n    state.end += 8\n  },\n  encode (state, n) {\n    validateUint(n)\n    const r = Math.floor(n / 0x100000000)\n    uint32.encode(state, n)\n    uint32.encode(state, r)\n  },\n  decode (state) {\n    if (state.end - state.start < 8) throw new Error('Out of bounds')\n    return uint32.decode(state) + 0x100000000 * uint32.decode(state)\n  }\n}\n\nexports.int = zigZagInt(uint)\nexports.int8 = zigZagInt(uint8)\nexports.int16 = zigZagInt(uint16)\nexports.int24 = zigZagInt(uint24)\nexports.int32 = zigZagInt(uint32)\nexports.int40 = zigZagInt(uint40)\nexports.int48 = zigZagInt(uint48)\nexports.int56 = zigZagInt(uint56)\nexports.int64 = zigZagInt(uint64)\n\nconst biguint64 = exports.biguint64 = {\n  preencode (state, n) {\n    state.end += 8\n  },\n  encode (state, n) {\n    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8)\n    view.setBigUint64(0, n, true) // little endian\n    state.start += 8\n  },\n  decode (state) {\n    if (state.end - state.start < 8) throw new Error('Out of bounds')\n    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8)\n    const n = view.getBigUint64(0, true) // little endian\n    state.start += 8\n    return n\n  }\n}\n\nexports.bigint64 = zigZagBigInt(biguint64)\n\nconst biguint = exports.biguint = {\n  preencode (state, n) {\n    let len = 0\n    for (let m = n; m; m = m >> 64n) len++\n    uint.preencode(state, len)\n    state.end += 8 * len\n  },\n  encode (state, n) {\n    let len = 0\n    for (let m = n; m; m = m >> 64n) len++\n    uint.encode(state, len)\n    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8 * len)\n    for (let m = n, i = 0; m; m = m >> 64n, i += 8) {\n      view.setBigUint64(i, BigInt.asUintN(64, m), true) // little endian\n    }\n    state.start += 8 * len\n  },\n  decode (state) {\n    const len = uint.decode(state)\n    if (state.end - state.start < 8 * len) throw new Error('Out of bounds')\n    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8 * len)\n    let n = 0n\n    for (let i = len - 1; i >= 0; i--) n = (n << 64n) + view.getBigUint64(i * 8, true) // little endian\n    state.start += 8 * len\n    return n\n  }\n}\n\nexports.bigint = zigZagBigInt(biguint)\n\nexports.lexint = require('./lexint')\n\nexports.float32 = {\n  preencode (state, n) {\n    state.end += 4\n  },\n  encode (state, n) {\n    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 4)\n    view.setFloat32(0, n, true) // little endian\n    state.start += 4\n  },\n  decode (state) {\n    if (state.end - state.start < 4) throw new Error('Out of bounds')\n    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 4)\n    const float = view.getFloat32(0, true) // little endian\n    state.start += 4\n    return float\n  }\n}\n\nexports.float64 = {\n  preencode (state, n) {\n    state.end += 8\n  },\n  encode (state, n) {\n    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8)\n    view.setFloat64(0, n, true) // little endian\n    state.start += 8\n  },\n  decode (state) {\n    if (state.end - state.start < 8) throw new Error('Out of bounds')\n    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8)\n    const float = view.getFloat64(0, true) // little endian\n    state.start += 8\n    return float\n  }\n}\n\nconst buffer = exports.buffer = {\n  preencode (state, b) {\n    if (b) uint8array.preencode(state, b)\n    else state.end++\n  },\n  encode (state, b) {\n    if (b) uint8array.encode(state, b)\n    else state.buffer[state.start++] = 0\n  },\n  decode (state) {\n    const len = uint.decode(state)\n    if (len === 0) return null\n    if (state.end - state.start < len) throw new Error('Out of bounds')\n    return state.buffer.subarray(state.start, (state.start += len))\n  }\n}\n\nexports.binary = {\n  ...buffer,\n  preencode (state, b) {\n    if (typeof b === 'string') utf8.preencode(state, b)\n    else buffer.preencode(state, b)\n  },\n  encode (state, b) {\n    if (typeof b === 'string') utf8.encode(state, b)\n    else buffer.encode(state, b)\n  }\n}\n\nexports.arraybuffer = {\n  preencode (state, b) {\n    uint.preencode(state, b.byteLength)\n    state.end += b.byteLength\n  },\n  encode (state, b) {\n    uint.encode(state, b.byteLength)\n\n    const view = new Uint8Array(b)\n\n    state.buffer.set(view, state.start)\n    state.start += b.byteLength\n  },\n  decode (state) {\n    const len = uint.decode(state)\n\n    const b = new ArrayBuffer(len)\n    const view = new Uint8Array(b)\n\n    view.set(state.buffer.subarray(state.start, state.start += len))\n\n    return b\n  }\n}\n\nfunction typedarray (TypedArray, swap) {\n  const n = TypedArray.BYTES_PER_ELEMENT\n\n  return {\n    preencode (state, b) {\n      uint.preencode(state, b.length)\n      state.end += b.byteLength\n    },\n    encode (state, b) {\n      uint.encode(state, b.length)\n\n      const view = new Uint8Array(b.buffer, b.byteOffset, b.byteLength)\n\n      if (BE && swap) swap(view)\n\n      state.buffer.set(view, state.start)\n      state.start += b.byteLength\n    },\n    decode (state) {\n      const len = uint.decode(state)\n\n      let b = state.buffer.subarray(state.start, state.start += len * n)\n      if (b.byteLength !== len * n) throw new Error('Out of bounds')\n      if ((b.byteOffset % n) !== 0) b = new Uint8Array(b)\n\n      if (BE && swap) swap(b)\n\n      return new TypedArray(b.buffer, b.byteOffset, b.byteLength / n)\n    }\n  }\n}\n\nconst uint8array = exports.uint8array = typedarray(Uint8Array)\nexports.uint16array = typedarray(Uint16Array, b4a.swap16)\nexports.uint32array = typedarray(Uint32Array, b4a.swap32)\n\nexports.int8array = typedarray(Int8Array)\nexports.int16array = typedarray(Int16Array, b4a.swap16)\nexports.int32array = typedarray(Int32Array, b4a.swap32)\n\nexports.biguint64array = typedarray(BigUint64Array, b4a.swap64)\nexports.bigint64array = typedarray(BigInt64Array, b4a.swap64)\n\nexports.float32array = typedarray(Float32Array, b4a.swap32)\nexports.float64array = typedarray(Float64Array, b4a.swap64)\n\nfunction string (encoding) {\n  return {\n    preencode (state, s) {\n      const len = b4a.byteLength(s, encoding)\n      uint.preencode(state, len)\n      state.end += len\n    },\n    encode (state, s) {\n      const len = b4a.byteLength(s, encoding)\n      uint.encode(state, len)\n      b4a.write(state.buffer, s, state.start, encoding)\n      state.start += len\n    },\n    decode (state) {\n      const len = uint.decode(state)\n      if (state.end - state.start < len) throw new Error('Out of bounds')\n      return b4a.toString(state.buffer, encoding, state.start, (state.start += len))\n    },\n    fixed (n) {\n      return {\n        preencode (state) {\n          state.end += n\n        },\n        encode (state, s) {\n          b4a.write(state.buffer, s, state.start, n, encoding)\n          state.start += n\n        },\n        decode (state) {\n          if (state.end - state.start < n) throw new Error('Out of bounds')\n          return b4a.toString(state.buffer, encoding, state.start, (state.start += n))\n        }\n      }\n    }\n  }\n}\n\nconst utf8 = exports.string = exports.utf8 = string('utf-8')\nexports.ascii = string('ascii')\nexports.hex = string('hex')\nexports.base64 = string('base64')\nexports.ucs2 = exports.utf16le = string('utf16le')\n\nexports.bool = {\n  preencode (state, b) {\n    state.end++\n  },\n  encode (state, b) {\n    state.buffer[state.start++] = b ? 1 : 0\n  },\n  decode (state) {\n    if (state.start >= state.end) throw Error('Out of bounds')\n    return state.buffer[state.start++] === 1\n  }\n}\n\nconst fixed = exports.fixed = function fixed (n) {\n  return {\n    preencode (state, s) {\n      if (s.byteLength !== n) throw new Error('Incorrect buffer size')\n      state.end += n\n    },\n    encode (state, s) {\n      state.buffer.set(s, state.start)\n      state.start += n\n    },\n    decode (state) {\n      if (state.end - state.start < n) throw new Error('Out of bounds')\n      return state.buffer.subarray(state.start, (state.start += n))\n    }\n  }\n}\n\nexports.fixed32 = fixed(32)\nexports.fixed64 = fixed(64)\n\nexports.array = function array (enc) {\n  return {\n    preencode (state, list) {\n      uint.preencode(state, list.length)\n      for (let i = 0; i < list.length; i++) enc.preencode(state, list[i])\n    },\n    encode (state, list) {\n      uint.encode(state, list.length)\n      for (let i = 0; i < list.length; i++) enc.encode(state, list[i])\n    },\n    decode (state) {\n      const len = uint.decode(state)\n      if (len > 0x100000) throw new Error('Array is too big')\n      const arr = new Array(len)\n      for (let i = 0; i < len; i++) arr[i] = enc.decode(state)\n      return arr\n    }\n  }\n}\n\nexports.frame = function frame (enc) {\n  const dummy = exports.state()\n\n  return {\n    preencode (state, m) {\n      const end = state.end\n      enc.preencode(state, m)\n      uint.preencode(state, state.end - end)\n    },\n    encode (state, m) {\n      dummy.end = 0\n      enc.preencode(dummy, m)\n      uint.encode(state, dummy.end)\n      enc.encode(state, m)\n    },\n    decode (state) {\n      const end = state.end\n      const len = uint.decode(state)\n      state.end = state.start + len\n      const m = enc.decode(state)\n      state.start = state.end\n      state.end = end\n      return m\n    }\n  }\n}\n\nexports.date = {\n  preencode (state, d) {\n    uint.preencode(state, d.getTime())\n  },\n  encode (state, d) {\n    uint.encode(state, d.getTime())\n  },\n  decode (state, d) {\n    return new Date(uint.decode(state))\n  }\n}\n\nexports.json = {\n  preencode (state, v) {\n    utf8.preencode(state, JSON.stringify(v))\n  },\n  encode (state, v) {\n    utf8.encode(state, JSON.stringify(v))\n  },\n  decode (state) {\n    return JSON.parse(utf8.decode(state))\n  }\n}\n\nexports.ndjson = {\n  preencode (state, v) {\n    utf8.preencode(state, JSON.stringify(v) + '\\n')\n  },\n  encode (state, v) {\n    utf8.encode(state, JSON.stringify(v) + '\\n')\n  },\n  decode (state) {\n    return JSON.parse(utf8.decode(state))\n  }\n}\n\n// simple helper for when you want to just express nothing\nexports.none = {\n  preencode (state, n) {\n    // do nothing\n  },\n  encode (state, n) {\n    // do nothing\n  },\n  decode (state) {\n    return null\n  }\n}\n\n// \"any\" encoders here for helping just structure any object without schematising it\n\nconst anyArray = {\n  preencode (state, arr) {\n    uint.preencode(state, arr.length)\n    for (let i = 0; i < arr.length; i++) {\n      any.preencode(state, arr[i])\n    }\n  },\n  encode (state, arr) {\n    uint.encode(state, arr.length)\n    for (let i = 0; i < arr.length; i++) {\n      any.encode(state, arr[i])\n    }\n  },\n  decode (state) {\n    const arr = []\n    let len = uint.decode(state)\n    while (len-- > 0) {\n      arr.push(any.decode(state))\n    }\n    return arr\n  }\n}\n\nconst anyObject = {\n  preencode (state, o) {\n    const keys = Object.keys(o)\n    uint.preencode(state, keys.length)\n    for (const key of keys) {\n      utf8.preencode(state, key)\n      any.preencode(state, o[key])\n    }\n  },\n  encode (state, o) {\n    const keys = Object.keys(o)\n    uint.encode(state, keys.length)\n    for (const key of keys) {\n      utf8.encode(state, key)\n      any.encode(state, o[key])\n    }\n  },\n  decode (state) {\n    let len = uint.decode(state)\n    const o = {}\n    while (len-- > 0) {\n      const key = utf8.decode(state)\n      o[key] = any.decode(state)\n    }\n    return o\n  }\n}\n\nconst anyTypes = [\n  exports.none,\n  exports.bool,\n  exports.string,\n  exports.buffer,\n  exports.uint,\n  exports.int,\n  exports.float64,\n  anyArray,\n  anyObject,\n  exports.date\n]\n\nconst any = exports.any = {\n  preencode (state, o) {\n    const t = getType(o)\n    uint.preencode(state, t)\n    anyTypes[t].preencode(state, o)\n  },\n  encode (state, o) {\n    const t = getType(o)\n    uint.encode(state, t)\n    anyTypes[t].encode(state, o)\n  },\n  decode (state) {\n    const t = uint.decode(state)\n    if (t >= anyTypes.length) throw new Error('Unknown type: ' + t)\n    return anyTypes[t].decode(state)\n  }\n}\n\nfunction getType (o) {\n  if (o === null || o === undefined) return 0\n  if (typeof o === 'boolean') return 1\n  if (typeof o === 'string') return 2\n  if (b4a.isBuffer(o)) return 3\n  if (typeof o === 'number') {\n    if (Number.isInteger(o)) return o >= 0 ? 4 : 5\n    return 6\n  }\n  if (Array.isArray(o)) return 7\n  if (o instanceof Date) return 9\n  if (typeof o === 'object') return 8\n\n  throw new Error('Unsupported type for ' + o)\n}\n\nexports.from = function from (enc) {\n  if (typeof enc === 'string') return fromNamed(enc)\n  if (enc.preencode) return enc\n  if (enc.encodingLength) return fromAbstractEncoder(enc)\n  return fromCodec(enc)\n}\n\nfunction fromNamed (enc) {\n  switch (enc) {\n    case 'ascii': return raw.ascii\n    case 'utf-8':\n    case 'utf8': return raw.utf8\n    case 'hex': return raw.hex\n    case 'base64': return raw.base64\n    case 'utf16-le':\n    case 'utf16le':\n    case 'ucs-2':\n    case 'ucs2': return raw.ucs2\n    case 'ndjson': return raw.ndjson\n    case 'json': return raw.json\n    case 'binary':\n    default: return raw.binary\n  }\n}\n\nfunction fromCodec (enc) {\n  let tmpM = null\n  let tmpBuf = null\n\n  return {\n    preencode (state, m) {\n      tmpM = m\n      tmpBuf = enc.encode(m)\n      state.end += tmpBuf.byteLength\n    },\n    encode (state, m) {\n      raw.encode(state, m === tmpM ? tmpBuf : enc.encode(m))\n      tmpM = tmpBuf = null\n    },\n    decode (state) {\n      return enc.decode(raw.decode(state))\n    }\n  }\n}\n\nfunction fromAbstractEncoder (enc) {\n  return {\n    preencode (state, m) {\n      state.end += enc.encodingLength(m)\n    },\n    encode (state, m) {\n      enc.encode(m, state.buffer, state.start)\n      state.start += enc.encode.bytes\n    },\n    decode (state) {\n      const m = enc.decode(state.buffer, state.start, state.end)\n      state.start += enc.decode.bytes\n      return m\n    }\n  }\n}\n\nexports.encode = function encode (enc, m) {\n  const state = exports.state()\n  enc.preencode(state, m)\n  state.buffer = b4a.allocUnsafe(state.end)\n  enc.encode(state, m)\n  return state.buffer\n}\n\nexports.decode = function decode (enc, buffer) {\n  return enc.decode(exports.state(0, buffer.byteLength, buffer))\n}\n\nfunction zigZagInt (enc) {\n  return {\n    preencode (state, n) {\n      enc.preencode(state, zigZagEncodeInt(n))\n    },\n    encode (state, n) {\n      enc.encode(state, zigZagEncodeInt(n))\n    },\n    decode (state) {\n      return zigZagDecodeInt(enc.decode(state))\n    }\n  }\n}\n\nfunction zigZagDecodeInt (n) {\n  return n === 0 ? n : (n & 1) === 0 ? n / 2 : -(n + 1) / 2\n}\n\nfunction zigZagEncodeInt (n) {\n  // 0, -1, 1, -2, 2, ...\n  return n < 0 ? (2 * -n) - 1 : n === 0 ? 0 : 2 * n\n}\n\nfunction zigZagBigInt (enc) {\n  return {\n    preencode (state, n) {\n      enc.preencode(state, zigZagEncodeBigInt(n))\n    },\n    encode (state, n) {\n      enc.encode(state, zigZagEncodeBigInt(n))\n    },\n    decode (state) {\n      return zigZagDecodeBigInt(enc.decode(state))\n    }\n  }\n}\n\nfunction zigZagDecodeBigInt (n) {\n  return n === 0n ? n : (n & 1n) === 0n ? n / 2n : -(n + 1n) / 2n\n}\n\nfunction zigZagEncodeBigInt (n) {\n  // 0, -1, 1, -2, 2, ...\n  return n < 0n ? (2n * -n) - 1n : n === 0n ? 0n : 2n * n\n}\n\nfunction validateUint (n) {\n  if ((n >= 0) === false /* Handles NaN as well */) throw new Error('uint must be positive')\n}\nmodule.exports = {\n  preencode,\n  encode,\n  decode\n}\n\nfunction preencode (state, num) {\n  if (num < 251) {\n    state.end++\n  } else if (num < 256) {\n    state.end += 2\n  } else if (num < 0x10000) {\n    state.end += 3\n  } else if (num < 0x1000000) {\n    state.end += 4\n  } else if (num < 0x100000000) {\n    state.end += 5\n  } else {\n    state.end++\n    const exp = Math.floor(Math.log(num) / Math.log(2)) - 32\n    preencode(state, exp)\n    state.end += 6\n  }\n}\n\nfunction encode (state, num) {\n  const max = 251\n  const x = num - max\n\n  if (num < max) {\n    state.buffer[state.start++] = num\n  } else if (num < 256) {\n    state.buffer[state.start++] = max\n    state.buffer[state.start++] = x\n  } else if (num < 0x10000) {\n    state.buffer[state.start++] = max + 1\n    state.buffer[state.start++] = x >> 8 & 0xff\n    state.buffer[state.start++] = x & 0xff\n  } else if (num < 0x1000000) {\n    state.buffer[state.start++] = max + 2\n    state.buffer[state.start++] = x >> 16\n    state.buffer[state.start++] = x >> 8 & 0xff\n    state.buffer[state.start++] = x & 0xff\n  } else if (num < 0x100000000) {\n    state.buffer[state.start++] = max + 3\n    state.buffer[state.start++] = x >> 24\n    state.buffer[state.start++] = x >> 16 & 0xff\n    state.buffer[state.start++] = x >> 8 & 0xff\n    state.buffer[state.start++] = x & 0xff\n  } else {\n    // need to use Math here as bitwise ops are 32 bit\n    const exp = Math.floor(Math.log(x) / Math.log(2)) - 32\n    state.buffer[state.start++] = 0xff\n\n    encode(state, exp)\n    const rem = x / Math.pow(2, exp - 11)\n\n    for (let i = 5; i >= 0; i--) {\n      state.buffer[state.start++] = rem / Math.pow(2, 8 * i) & 0xff\n    }\n  }\n}\n\nfunction decode (state) {\n  const max = 251\n\n  if (state.end - state.start < 1) throw new Error('Out of bounds')\n\n  const flag = state.buffer[state.start++]\n\n  if (flag < max) return flag\n\n  if (state.end - state.start < flag - max + 1) {\n    throw new Error('Out of bounds.')\n  }\n\n  if (flag < 252) {\n    return state.buffer[state.start++] +\n      max\n  }\n\n  if (flag < 253) {\n    return (state.buffer[state.start++] << 8) +\n      state.buffer[state.start++] +\n      max\n  }\n\n  if (flag < 254) {\n    return (state.buffer[state.start++] << 16) +\n      (state.buffer[state.start++] << 8) +\n      state.buffer[state.start++] +\n      max\n  }\n\n  // << 24 result may be interpreted as negative\n  if (flag < 255) {\n    return (state.buffer[state.start++] * 0x1000000) +\n      (state.buffer[state.start++] << 16) +\n      (state.buffer[state.start++] << 8) +\n      state.buffer[state.start++] +\n      max\n  }\n\n  const exp = decode(state)\n\n  if (state.end - state.start < 6) throw new Error('Out of bounds')\n\n  let rem = 0\n  for (let i = 5; i >= 0; i--) {\n    rem += state.buffer[state.start++] * Math.pow(2, 8 * i)\n  }\n\n  return (rem * Math.pow(2, exp - 11)) + max\n}\n{\n  \"name\": \"compact-encoding\",\n  \"version\": \"2.16.0\",\n  \"description\": \"A series of compact encoding schemes for building small and fast parsers and serializers\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.3.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.0\",\n    \"standard\": \"^16.0.3\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/compact-encoding/compact-encoding.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/compact-encoding/compact-encoding/issues\"\n  },\n  \"homepage\": \"https://github.com/compact-encoding/compact-encoding\"\n}\nconst b4a = require('b4a')\n\nconst { BE } = require('./endian')\n\nexports = module.exports = {\n  preencode (state, b) {\n    state.end += b.byteLength\n  },\n  encode (state, b) {\n    state.buffer.set(b, state.start)\n    state.start += b.byteLength\n  },\n  decode (state) {\n    const b = state.buffer.subarray(state.start, state.end)\n    state.start = state.end\n    return b\n  }\n}\n\nconst buffer = exports.buffer = {\n  preencode (state, b) {\n    if (b) uint8array.preencode(state, b)\n    else state.end++\n  },\n  encode (state, b) {\n    if (b) uint8array.encode(state, b)\n    else state.buffer[state.start++] = 0\n  },\n  decode (state) {\n    const b = state.buffer.subarray(state.start)\n    if (b.byteLength === 0) return null\n    state.start = state.end\n    return b\n  }\n}\n\nexports.binary = {\n  ...buffer,\n  preencode (state, b) {\n    if (typeof b === 'string') utf8.preencode(state, b)\n    else buffer.preencode(state, b)\n  },\n  encode (state, b) {\n    if (typeof b === 'string') utf8.encode(state, b)\n    else buffer.encode(state, b)\n  }\n}\n\nexports.arraybuffer = {\n  preencode (state, b) {\n    state.end += b.byteLength\n  },\n  encode (state, b) {\n    const view = new Uint8Array(b)\n\n    state.buffer.set(view, state.start)\n    state.start += b.byteLength\n  },\n  decode (state) {\n    const b = new ArrayBuffer(state.end - state.start)\n    const view = new Uint8Array(b)\n\n    view.set(state.buffer.subarray(state.start))\n\n    state.start = state.end\n\n    return b\n  }\n}\n\nfunction typedarray (TypedArray, swap) {\n  const n = TypedArray.BYTES_PER_ELEMENT\n\n  return {\n    preencode (state, b) {\n      state.end += b.byteLength\n    },\n    encode (state, b) {\n      const view = new Uint8Array(b.buffer, b.byteOffset, b.byteLength)\n\n      if (BE && swap) swap(view)\n\n      state.buffer.set(view, state.start)\n      state.start += b.byteLength\n    },\n    decode (state) {\n      let b = state.buffer.subarray(state.start)\n      if ((b.byteOffset % n) !== 0) b = new Uint8Array(b)\n\n      if (BE && swap) swap(b)\n\n      state.start = state.end\n\n      return new TypedArray(b.buffer, b.byteOffset, b.byteLength / n)\n    }\n  }\n}\n\nconst uint8array = exports.uint8array = typedarray(Uint8Array)\nexports.uint16array = typedarray(Uint16Array, b4a.swap16)\nexports.uint32array = typedarray(Uint32Array, b4a.swap32)\n\nexports.int8array = typedarray(Int8Array)\nexports.int16array = typedarray(Int16Array, b4a.swap16)\nexports.int32array = typedarray(Int32Array, b4a.swap32)\n\nexports.biguint64array = typedarray(BigUint64Array, b4a.swap64)\nexports.bigint64array = typedarray(BigInt64Array, b4a.swap64)\n\nexports.float32array = typedarray(Float32Array, b4a.swap32)\nexports.float64array = typedarray(Float64Array, b4a.swap64)\n\nfunction string (encoding) {\n  return {\n    preencode (state, s) {\n      state.end += b4a.byteLength(s, encoding)\n    },\n    encode (state, s) {\n      state.start += b4a.write(state.buffer, s, state.start, encoding)\n    },\n    decode (state) {\n      const s = b4a.toString(state.buffer, encoding, state.start)\n      state.start = state.end\n      return s\n    }\n  }\n}\n\nconst utf8 = exports.string = exports.utf8 = string('utf-8')\nexports.ascii = string('ascii')\nexports.hex = string('hex')\nexports.base64 = string('base64')\nexports.ucs2 = exports.utf16le = string('utf16le')\n\nexports.array = function array (enc) {\n  return {\n    preencode (state, list) {\n      for (const value of list) enc.preencode(state, value)\n    },\n    encode (state, list) {\n      for (const value of list) enc.encode(state, value)\n    },\n    decode (state) {\n      const arr = []\n      while (state.start < state.end) arr.push(enc.decode(state))\n      return arr\n    }\n  }\n}\n\nexports.json = {\n  preencode (state, v) {\n    utf8.preencode(state, JSON.stringify(v))\n  },\n  encode (state, v) {\n    utf8.encode(state, JSON.stringify(v))\n  },\n  decode (state) {\n    return JSON.parse(utf8.decode(state))\n  }\n}\n\nexports.ndjson = {\n  preencode (state, v) {\n    utf8.preencode(state, JSON.stringify(v) + '\\n')\n  },\n  encode (state, v) {\n    utf8.encode(state, JSON.stringify(v) + '\\n')\n  },\n  decode (state) {\n    return JSON.parse(utf8.decode(state))\n  }\n}\nconst safetyCatch = require('safety-catch')\n\nmodule.exports = class CoreCoupler {\n  constructor (target, wakeup) {\n    this.target = target\n    this.wakeup = wakeup\n    this.coupled = new Set()\n\n    this._onpeeraddBound = this._onpeeradd.bind(this)\n    this.target.on('peer-add', this._onpeeraddBound)\n  }\n\n  add (core) {\n    this.coupled.add(core)\n    this._couple(core)\n  }\n\n  remove (core) {\n    this.coupled.delete(core)\n  }\n\n  destroy () {\n    this.target.off('peer-add', this._onpeeraddBound)\n  }\n\n  async _couple (core) {\n    try {\n      let wakeup = null\n\n      for (const peer of this.target.peers) {\n        if (await this._hasPeer(core, peer)) continue\n        if (wakeup === null) wakeup = []\n        wakeup.push(peer)\n      }\n\n      if (wakeup !== null && this.coupled.has(core)) {\n        for (const peer of wakeup) this.wakeup(peer, [core])\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  async _onpeeradd (peer) {\n    try {\n      let wakeup = null\n\n      for (const core of this.coupled) {\n        if (await this._hasPeer(core, peer)) continue\n        if (wakeup === null) wakeup = []\n        wakeup.push(core)\n      }\n\n      if (wakeup !== null) {\n        this.wakeup(peer, wakeup)\n      }\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  _hasPeer (core, peer) { // TODO: make proper\n    const ch = peer.protomux.getLastChannel({ protocol: 'hypercore', id: core.discoveryKey })\n    if (ch) return ch.fullyOpened()\n    return Promise.resolve(false)\n  }\n}\n{\n  \"name\": \"core-coupler\",\n  \"version\": \"1.1.1\",\n  \"description\": \"Couple the peers of cores\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard\"\n  },\n  \"dependencies\": {\n    \"safety-catch\": \"^1.0.2\"\n  },\n  \"devDependencies\": {\n    \"corestore\": \"^6.18.2\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/core-coupler.git\"\n  },\n  \"author\": \"Holepunch Inc\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/core-coupler/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/core-coupler\"\n}\nconst safetyCatch = require('safety-catch')\nconst crypto = require('hypercore-crypto')\nconst sodium = require('sodium-universal')\nconst Hypercore = require('hypercore')\nconst hypercoreId = require('hypercore-id-encoding')\nconst Xache = require('xache')\nconst b4a = require('b4a')\nconst ReadyResource = require('ready-resource')\nconst RW = require('read-write-mutexify')\n\nconst [NS] = crypto.namespace('corestore', 1)\nconst DEFAULT_NAMESPACE = b4a.alloc(32) // This is meant to be 32 0-bytes\n\nconst CORES_DIR = 'cores'\nconst PRIMARY_KEY_FILE_NAME = 'primary-key'\nconst USERDATA_NAME_KEY = 'corestore/name'\nconst USERDATA_NAMESPACE_KEY = 'corestore/namespace'\nconst POOL_SIZE = 512 // how many open fds to aim for before cycling them\nconst DEFAULT_MANIFEST = 0 // bump to 1 when this is more widely deployed\nconst DEFAULT_COMPAT = true\n\nmodule.exports = class Corestore extends ReadyResource {\n  constructor (storage, opts = {}) {\n    super()\n\n    const root = opts._root\n\n    this.storage = Hypercore.defaultStorage(storage, { lock: PRIMARY_KEY_FILE_NAME, poolSize: opts.poolSize || POOL_SIZE, rmdir: true })\n    this.cores = root ? root.cores : new Map()\n    this.cache = !!opts.cache\n    this.primaryKey = opts.primaryKey || null\n    this.passive = !!opts.passive\n    this.manifestVersion = typeof opts.manifestVersion === 'number' ? opts.manifestVersion : (root ? root.manifestVersion : DEFAULT_MANIFEST)\n    this.compat = typeof opts.compat === 'boolean' ? opts.compat : (root ? root.compat : DEFAULT_COMPAT)\n    this.inflightRange = opts.inflightRange || null\n    this.globalCache = opts.globalCache || null\n\n    this._keyStorage = null\n    this._bootstrap = opts._bootstrap || null\n    this._namespace = opts.namespace || DEFAULT_NAMESPACE\n    this._noCoreCache = root ? root._noCoreCache : new Xache({ maxSize: 65536 })\n\n    this._root = root || this\n    this._replicationStreams = root ? root._replicationStreams : []\n    this._overwrite = opts.overwrite === true\n    this._readonly = opts.writable === false\n    this._attached = opts._attached || null\n    this._notDownloadingLinger = opts.notDownloadingLinger\n\n    this._sessions = new Set() // sessions for THIS namespace\n    this._rootStoreSessions = new Set()\n    this._locks = root ? root._locks : new Map()\n\n    this._findingPeersCount = 0\n    this._findingPeers = []\n    this._isCorestore = true\n\n    if (this._namespace.byteLength !== 32) throw new Error('Namespace must be a 32-byte Buffer or Uint8Array')\n    this.ready().catch(safetyCatch)\n  }\n\n  static isCorestore (obj) {\n    return !!(typeof obj === 'object' && obj && obj._isCorestore)\n  }\n\n  static from (storage, opts) {\n    return this.isCorestore(storage) ? storage : new this(storage, opts)\n  }\n\n  // for now just release the lock...\n  async suspend () {\n    if (this._root !== this) return this._root.suspend()\n\n    await this.ready()\n\n    if (this._keyStorage !== null) {\n      await new Promise((resolve, reject) => {\n        this._keyStorage.suspend((err) => {\n          if (err) return reject(err)\n          resolve()\n        })\n      })\n    }\n  }\n\n  async resume () {\n    if (this._root !== this) return this._root.resume()\n\n    await this.ready()\n\n    if (this._keyStorage !== null) {\n      await new Promise((resolve, reject) => {\n        this._keyStorage.open((err) => {\n          if (err) return reject(err)\n          resolve()\n        })\n      })\n    }\n  }\n\n  findingPeers () {\n    let done = false\n    this._incFindingPeers()\n\n    return () => {\n      if (done) return\n      done = true\n      this._decFindingPeers()\n    }\n  }\n\n  _emitCore (name, core) {\n    this.emit(name, core)\n    for (const session of this._root._rootStoreSessions) {\n      if (session !== this) {\n        session.emit(name, core)\n      }\n    }\n    if (this !== this._root) this._root.emit(name, core)\n  }\n\n  _incFindingPeers () {\n    if (++this._findingPeersCount !== 1) return\n\n    for (const core of this._sessions) {\n      this._findingPeers.push(core.findingPeers())\n    }\n  }\n\n  _decFindingPeers () {\n    if (--this._findingPeersCount !== 0) return\n\n    while (this._findingPeers.length > 0) {\n      this._findingPeers.pop()()\n    }\n  }\n\n  async _openNamespaceFromBootstrap () {\n    const ns = await this._bootstrap.getUserData(USERDATA_NAMESPACE_KEY)\n    if (ns) {\n      this._namespace = ns\n    }\n  }\n\n  async _open () {\n    if (this._root !== this) {\n      await this._root.ready()\n      if (!this.primaryKey) this.primaryKey = this._root.primaryKey\n      if (this._bootstrap) await this._openNamespaceFromBootstrap()\n      return\n    }\n\n    this._keyStorage = this.storage(PRIMARY_KEY_FILE_NAME)\n\n    this.primaryKey = await new Promise((resolve, reject) => {\n      this._keyStorage.stat((err, st) => {\n        if (err && err.code !== 'ENOENT') return reject(err)\n        if (err || st.size < 32 || this._overwrite) {\n          const key = this.primaryKey || crypto.randomBytes(32)\n          return this._keyStorage.write(0, key, err => {\n            if (err) return reject(err)\n            return resolve(key)\n          })\n        }\n        this._keyStorage.read(0, 32, (err, key) => {\n          if (err) return reject(err)\n          if (this.primaryKey) return resolve(this.primaryKey)\n          return resolve(key)\n        })\n      })\n    })\n\n    if (this._bootstrap) await this._openNamespaceFromBootstrap()\n  }\n\n  async _exists (discoveryKey) {\n    const id = b4a.toString(discoveryKey, 'hex')\n    const storageRoot = getStorageRoot(id)\n\n    const st = this.storage(storageRoot + '/oplog')\n\n    const exists = await new Promise((resolve) => st.stat((err, st) => resolve(!err && st.size > 0)))\n    await new Promise(resolve => st.close(resolve))\n\n    return exists\n  }\n\n  async _generateKeys (opts) {\n    if (opts._discoveryKey) {\n      return {\n        manifest: null,\n        keyPair: null,\n        key: null,\n        discoveryKey: opts._discoveryKey\n      }\n    }\n\n    const keyPair = opts.name\n      ? await this.createKeyPair(opts.name)\n      : (opts.secretKey)\n          ? { secretKey: opts.secretKey, publicKey: opts.publicKey }\n          : null\n\n    if (opts.manifest) {\n      const key = Hypercore.key(opts.manifest)\n\n      return {\n        manifest: opts.manifest,\n        keyPair,\n        key,\n        discoveryKey: crypto.discoveryKey(key)\n      }\n    }\n\n    if (opts.key) {\n      return {\n        manifest: null,\n        keyPair,\n        key: opts.key,\n        discoveryKey: crypto.discoveryKey(opts.key)\n      }\n    }\n\n    const publicKey = opts.publicKey || keyPair.publicKey\n\n    if (opts.compat === false || (opts.compat !== true && !this.compat)) {\n      let manifest = { version: this.manifestVersion, signers: [{ publicKey }] } // default manifest\n      let key = Hypercore.key(manifest)\n      let discoveryKey = crypto.discoveryKey(key)\n\n      if (!(await this._exists(discoveryKey)) && manifest.version !== 0) {\n        const manifestV0 = { version: 0, signers: [{ publicKey }] }\n        const keyV0 = Hypercore.key(manifestV0)\n        const discoveryKeyV0 = crypto.discoveryKey(keyV0)\n\n        if (await this._exists(discoveryKeyV0)) {\n          manifest = manifestV0\n          key = keyV0\n          discoveryKey = discoveryKeyV0\n        }\n      }\n\n      return {\n        manifest,\n        keyPair,\n        key,\n        discoveryKey\n      }\n    }\n\n    return {\n      manifest: null,\n      keyPair,\n      key: publicKey,\n      discoveryKey: crypto.discoveryKey(publicKey)\n    }\n  }\n\n  _getPrereadyUserData (core, key) {\n    // Need to manually read the header values before the Hypercore is ready, hence the ugliness.\n    for (const { key: savedKey, value } of core.core.header.userData) {\n      if (key === savedKey) return value\n    }\n    return null\n  }\n\n  async _preready (core) {\n    const name = this._getPrereadyUserData(core, USERDATA_NAME_KEY)\n    if (!name) return\n\n    const namespace = this._getPrereadyUserData(core, USERDATA_NAMESPACE_KEY)\n    const keyPair = await this.createKeyPair(b4a.toString(name), namespace)\n    core.setKeyPair(keyPair)\n  }\n\n  _getLock (id) {\n    let rw = this._locks.get(id)\n\n    if (!rw) {\n      rw = new RW()\n      this._locks.set(id, rw)\n    }\n\n    return rw\n  }\n\n  async _preload (id, keys, opts) {\n    const { manifest, keyPair, key } = keys\n\n    while (this.cores.has(id)) {\n      const existing = this.cores.get(id)\n      if (existing.opened && !existing.closing) return { from: existing, keyPair, manifest, cache: !!opts.cache }\n      if (existing.closing) {\n        await existing.close()\n      } else {\n        await existing.ready().catch(safetyCatch)\n      }\n    }\n\n    const hasKeyPair = !!(keyPair && keyPair.secretKey)\n    const userData = {}\n    if (opts.name) {\n      userData[USERDATA_NAME_KEY] = b4a.from(opts.name)\n      userData[USERDATA_NAMESPACE_KEY] = this._namespace\n    }\n\n    // No more async ticks allowed after this point -- necessary for caching\n\n    const storageRoot = getStorageRoot(id)\n    const core = new Hypercore(p => this.storage(storageRoot + '/' + p), {\n      _preready: this._preready.bind(this),\n      notDownloadingLinger: this._notDownloadingLinger,\n      inflightRange: this.inflightRange,\n      autoClose: true,\n      active: false,\n      encryptionKey: opts.encryptionKey || null,\n      isBlockKey: !!opts.isBlockKey,\n      userData,\n      manifest,\n      key,\n      compat: opts.compat,\n      cache: opts.cache,\n      globalCache: this.globalCache,\n      createIfMissing: opts.createIfMissing === false ? false : !opts._discoveryKey,\n      keyPair: hasKeyPair ? keyPair : null\n    })\n\n    if (this._root.closing) {\n      try {\n        await core.close()\n      } catch {}\n      throw new Error('The corestore is closed')\n    }\n\n    this.cores.set(id, core)\n    this._noCoreCache.delete(id)\n    core.ready().then(() => {\n      if (core.closing) return // extra safety here as ready is a tick after open\n      if (hasKeyPair) core.setKeyPair(keyPair)\n      this._emitCore('core-open', core)\n      if (this.passive) return\n\n      const ondownloading = () => {\n        for (const { stream } of this._replicationStreams) {\n          core.replicate(stream, { session: true })\n        }\n      }\n      // when the replicator says we are downloading, answer the call\n      core.replicator.ondownloading = ondownloading\n      // trigger once if the condition is already true\n      if (core.replicator.downloading) ondownloading()\n    }, () => {\n      this._noCoreCache.set(id, true)\n      this.cores.delete(id)\n    })\n    core.once('close', () => {\n      this._emitCore('core-close', core)\n      this.cores.delete(id)\n    })\n    core.on('conflict', (len, fork, proof) => {\n      this.emit('conflict', core, len, fork, proof)\n    })\n\n    return { from: core, keyPair, manifest, cache: !!opts.cache }\n  }\n\n  async createKeyPair (name, namespace = this._namespace) {\n    if (!this.opened) await this.ready()\n\n    const keyPair = {\n      publicKey: b4a.allocUnsafeSlow(sodium.crypto_sign_PUBLICKEYBYTES),\n      secretKey: b4a.alloc(sodium.crypto_sign_SECRETKEYBYTES)\n    }\n\n    const seed = deriveSeed(this.primaryKey, namespace, name)\n    sodium.crypto_sign_seed_keypair(keyPair.publicKey, keyPair.secretKey, seed)\n\n    return keyPair\n  }\n\n  get (opts = {}) {\n    if (this.closing || this._root.closing) throw new Error('The corestore is closed')\n    opts = validateGetOptions(opts)\n\n    if (opts.cache !== false) {\n      opts.cache = opts.cache === true || (this.cache && !opts.cache) ? defaultCache() : opts.cache\n    }\n    if (this._readonly && opts.writable !== false) {\n      opts.writable = false\n    }\n\n    let rw = null\n    let id = null\n\n    const core = new Hypercore(null, {\n      ...opts,\n      globalCache: this.globalCache,\n      name: null,\n      preload: async () => {\n        if (opts.preload) opts = { ...opts, ...(await opts.preload()) }\n        if (!this.opened) await this.ready()\n\n        const keys = await this._generateKeys(opts)\n\n        id = b4a.toString(keys.discoveryKey, 'hex')\n        rw = (opts.exclusive && opts.writable !== false) ? this._getLock(id) : null\n\n        if (rw) await rw.write.lock()\n        return await this._preload(id, keys, opts)\n      }\n    })\n\n    this._sessions.add(core)\n    if (this._findingPeersCount > 0) {\n      this._findingPeers.push(core.findingPeers())\n    }\n\n    const gc = () => {\n      // technically better to also clear _findingPeers if we added it,\n      // but the lifecycle for those are pretty short so prob not worth the complexity\n      // as _decFindingPeers clear them all.\n      this._sessions.delete(core)\n\n      if (!rw) return\n      rw.write.unlock()\n      if (!rw.write.locked) this._locks.delete(id)\n    }\n\n    core.ready().catch(gc)\n    core.once('close', gc)\n\n    return core\n  }\n\n  replicate (isInitiator, opts) {\n    const isExternal = isStream(isInitiator) || !!(opts && opts.stream)\n    const stream = Hypercore.createProtocolStream(isInitiator, {\n      ...opts,\n      ondiscoverykey: async discoveryKey => {\n        if (this.closing) return\n\n        const id = b4a.toString(discoveryKey, 'hex')\n        if (this._noCoreCache.get(id)) return\n\n        const core = this.get({ _discoveryKey: discoveryKey, active: false })\n\n        try {\n          await core.ready()\n        } catch {\n          return\n        }\n\n        // remote is asking for the core so we HAVE to answer even if not downloading\n        if (!core.closing) core.replicate(stream, { session: true })\n        await core.close()\n      }\n    })\n\n    if (!this.passive) {\n      const muxer = stream.noiseStream.userData\n      muxer.cork()\n      for (const core of this.cores.values()) {\n        // If the core is not opened, it will be replicated in preload.\n        if (!core.opened || core.closing || !core.replicator.downloading) continue\n        core.replicate(stream, { session: true })\n      }\n      stream.noiseStream.opened.then(() => muxer.uncork())\n    }\n\n    const streamRecord = { stream, isExternal }\n    this._replicationStreams.push(streamRecord)\n\n    stream.once('close', () => {\n      this._replicationStreams.splice(this._replicationStreams.indexOf(streamRecord), 1)\n    })\n\n    return stream\n  }\n\n  namespace (name, opts) {\n    if (name instanceof Hypercore) {\n      return this.session({ ...opts, _bootstrap: name })\n    }\n    return this.session({ ...opts, namespace: generateNamespace(this._namespace, name) })\n  }\n\n  session (opts) {\n    const session = new Corestore(this.storage, {\n      namespace: this._namespace,\n      cache: this.cache,\n      writable: !this._readonly,\n      _attached: opts && opts.detach === false ? this : null,\n      _root: this._root,\n      inflightRange: this.inflightRange,\n      globalCache: this.globalCache,\n      ...opts\n    })\n    if (this === this._root) this._rootStoreSessions.add(session)\n    return session\n  }\n\n  _closeNamespace () {\n    const closePromises = []\n    for (const session of this._sessions) {\n      closePromises.push(session.close())\n    }\n    return Promise.allSettled(closePromises)\n  }\n\n  async _closePrimaryNamespace () {\n    const closePromises = []\n    // At this point, the primary namespace is closing.\n    for (const { stream, isExternal } of this._replicationStreams) {\n      // Only close streams that were created by the Corestore\n      if (!isExternal) stream.destroy()\n    }\n    for (const core of this.cores.values()) {\n      closePromises.push(forceClose(core))\n    }\n    await Promise.allSettled(closePromises)\n    await new Promise((resolve, reject) => {\n      this._keyStorage.close(err => {\n        if (err) return reject(err)\n        return resolve(null)\n      })\n    })\n  }\n\n  async _close () {\n    this._root._rootStoreSessions.delete(this)\n\n    await this._closeNamespace()\n\n    if (this._root === this) {\n      await this._closePrimaryNamespace()\n    } else if (this._attached) {\n      await this._attached.close()\n    }\n  }\n}\n\nfunction validateGetOptions (opts) {\n  const key = (b4a.isBuffer(opts) || typeof opts === 'string') ? hypercoreId.decode(opts) : null\n  if (key) return { key }\n\n  if (opts.key) {\n    opts.key = hypercoreId.decode(opts.key)\n  }\n  if (opts.keyPair) {\n    opts.publicKey = opts.keyPair.publicKey\n    opts.secretKey = opts.keyPair.secretKey\n  }\n\n  if (opts.name && typeof opts.name !== 'string') throw new Error('name option must be a String')\n  if (opts.name && opts.secretKey) throw new Error('Cannot provide both a name and a secret key')\n  if (opts.publicKey && !b4a.isBuffer(opts.publicKey)) throw new Error('publicKey option must be a Buffer or Uint8Array')\n  if (opts.secretKey && !b4a.isBuffer(opts.secretKey)) throw new Error('secretKey option must be a Buffer or Uint8Array')\n  if (!opts._discoveryKey && (!opts.name && !opts.publicKey && !opts.manifest && !opts.key && !opts.preload)) throw new Error('Must provide either a name or a publicKey')\n  return opts\n}\n\nfunction generateNamespace (namespace, name) {\n  if (!b4a.isBuffer(name)) name = b4a.from(name)\n  const out = b4a.allocUnsafeSlow(32)\n  sodium.crypto_generichash_batch(out, [namespace, name])\n  return out\n}\n\nfunction deriveSeed (primaryKey, namespace, name) {\n  if (!b4a.isBuffer(name)) name = b4a.from(name)\n  const out = b4a.alloc(32)\n  sodium.crypto_generichash_batch(out, [NS, namespace, name], primaryKey)\n  return out\n}\n\nfunction defaultCache () {\n  return new Xache({ maxSize: 65536, maxAge: 0 })\n}\n\nfunction isStream (s) {\n  return typeof s === 'object' && s && typeof s.pipe === 'function'\n}\n\nasync function forceClose (core) {\n  await core.ready()\n  return Promise.all(core.sessions.map(s => s.close()))\n}\n\nfunction getStorageRoot (id) {\n  return CORES_DIR + '/' + id.slice(0, 2) + '/' + id.slice(2, 4) + '/' + id\n}\n{\n  \"name\": \"corestore\",\n  \"version\": \"6.18.4\",\n  \"description\": \"A Hypercore factory that simplifies managing collections of cores.\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/corestore.git\"\n  },\n  \"keywords\": [\n    \"corestore\"\n  ],\n  \"author\": \"Andrew Osheroff <andrewosh@gmail.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/corestore/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/corestore#readme\",\n  \"files\": [\n    \"index.js\",\n    \"lib/**.js\"\n  ],\n  \"devDependencies\": {\n    \"brittle\": \"^3.2.2\",\n    \"rache\": \"^1.0.0\",\n    \"random-access-memory\": \"^6.2.0\",\n    \"standard\": \"^17.1.0\",\n    \"test-tmp\": \"^1.0.2\"\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.6.4\",\n    \"hypercore\": \"^10.37.10\",\n    \"hypercore-crypto\": \"^3.4.0\",\n    \"hypercore-id-encoding\": \"^1.2.0\",\n    \"read-write-mutexify\": \"^2.1.0\",\n    \"ready-resource\": \"^1.0.0\",\n    \"safety-catch\": \"^1.0.1\",\n    \"sodium-universal\": \"^4.0.0\",\n    \"xache\": \"^1.1.0\"\n  }\n}\nmodule.exports = require('node-gyp-build')(__dirname)\nconst binding = require('./binding')\n\nexports.crc32 = function crc32 (buffer) {\n  return binding.crc_u32_napi(buffer)\n}\n{\n  \"name\": \"crc-native\",\n  \"version\": \"1.1.6\",\n  \"description\": \"libcrc JavaScript bindings for Node.js\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"macros.h\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"npm run lint && npm run test:bare && npm run test:node\",\n    \"test:bare\": \"bare test.mjs\",\n    \"test:node\": \"node test.mjs\",\n    \"lint\": \"standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/crc-native.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/crc-native/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/crc-native#readme\",\n  \"dependencies\": {\n    \"node-gyp-build\": \"^4.8.2\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.0\",\n    \"cmake-bare\": \"^1.1.7\",\n    \"cmake-fetch\": \"^1.1.0\",\n    \"cmake-napi\": \"^1.0.2\",\n    \"standard\": \"^17.0.0\"\n  }\n}\n/**\n * The JavaScript implementation of CRC32 is a version of the slice-by-16 algorithm\n * as implemented by Stephan Brumme, see https://github.com/stbrumme/crc32.\n *\n * Copyright (c) 2011-2016 Stephan Brumme\n *\n * This software is provided 'as-is', without any express or implied warranty.\n * In no event will the authors be held liable for any damages arising from the\n * use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it freely,\n * subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not claim\n *    that you wrote the original software.\n *    If you use this software in a product, an acknowledgment in the product\n *    documentation would be appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n *    misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\nconst lookup = require('./lookup')\n\nexports.crc32 = function crc32 (buffer) {\n  let crc = ~0\n  let i = 0\n  let length = buffer.byteLength\n\n  while (length >= 16) {\n    crc = lookup[15][buffer[i++] ^ (crc & 0xff)] ^\n          lookup[14][buffer[i++] ^ ((crc >>> 8) & 0xff)] ^\n          lookup[13][buffer[i++] ^ ((crc >>> 16) & 0xff)] ^\n          lookup[12][buffer[i++] ^ (crc >>> 24)] ^\n          lookup[11][buffer[i++]] ^\n          lookup[10][buffer[i++]] ^\n          lookup[9][buffer[i++]] ^\n          lookup[8][buffer[i++]] ^\n          lookup[7][buffer[i++]] ^\n          lookup[6][buffer[i++]] ^\n          lookup[5][buffer[i++]] ^\n          lookup[4][buffer[i++]] ^\n          lookup[3][buffer[i++]] ^\n          lookup[2][buffer[i++]] ^\n          lookup[1][buffer[i++]] ^\n          lookup[0][buffer[i++]]\n\n    length -= 16\n  }\n\n  while (length-- > 0) {\n    crc = (crc >>> 8) ^ lookup[0][(crc & 0xff) ^ buffer[i++]]\n  }\n\n  return ~crc >>> 0\n}\nconst fallback = require('./fallback')\n\ntry {\n  const native = require('crc-native')\n\n  exports.crc32 = function crc32 (buffer) {\n    return buffer.byteLength <= 24 ? fallback.crc32(buffer) : native.crc32(buffer)\n  }\n} catch {\n  module.exports = fallback\n}\nconst lookup = new Array(16)\n\nfor (let i = 0; i < 16; i++) {\n  lookup[i] = new Uint32Array(0x100)\n}\n\nfor (let i = 0; i <= 0xff; i++) {\n  let crc = i\n\n  for (let j = 0; j < 8; j++) {\n    crc = (crc >>> 1) ^ ((crc & 1) * 0xedb88320)\n  }\n\n  lookup[0][i] = crc\n}\n\nfor (let i = 0; i <= 0xff; i++) {\n  for (let j = 1; j < 16; j++) {\n    lookup[j][i] = (lookup[j - 1][i] >>> 8) ^ lookup[0][lookup[j - 1][i] & 0xff]\n  }\n}\n\nmodule.exports = lookup\n{\n  \"name\": \"crc-universal\",\n  \"version\": \"1.0.4\",\n  \"description\": \"Universal wrapper for libcrc with a JavaScript fallback\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"fallback.js\",\n    \"index.js\",\n    \"lookup.js\"\n  ],\n  \"browser\": {\n    \"./index.js\": \"./fallback.js\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/crc-universal.git\"\n  },\n  \"author\": \"Kasper Isager Dalsgar <kasper@funktionel.co>\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/crc-universal/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/crc-universal#readme\",\n  \"optionalDependencies\": {\n    \"crc-native\": \"^1.0.3\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.0\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nmodule.exports = function debounce (worker, context = null) {\n  debounced.running = null\n  return debounced\n\n  async function debounced () {\n    if (debounced.running !== null) {\n      try {\n        await debounced.running\n      } catch (_) {\n        // ignore - do not fail on old errors\n      }\n    }\n\n    // another \"thread\" beat us to it, just piggy pack on that one\n    if (debounced.running !== null) return debounced.running\n\n    debounced.running = worker.call(context)\n\n    try {\n      return await debounced.running\n    } finally {\n      debounced.running = null\n    }\n  }\n}\n{\n  \"name\": \"debounceify\",\n  \"version\": \"1.1.0\",\n  \"description\": \"Tiny async debouncer\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^16.0.3\",\n    \"tape\": \"^5.1.1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/debounceify.git\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/debounceify/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/debounceify\"\n}\nconst { EventEmitter } = require('events')\nconst Table = require('kademlia-routing-table')\nconst TOS = require('time-ordered-set')\nconst UDX = require('udx-native')\nconst sodium = require('sodium-universal')\nconst c = require('compact-encoding')\nconst NatSampler = require('nat-sampler')\nconst b4a = require('b4a')\nconst IO = require('./lib/io')\nconst Query = require('./lib/query')\nconst Session = require('./lib/session')\nconst peer = require('./lib/peer')\nconst { UNKNOWN_COMMAND, INVALID_TOKEN } = require('./lib/errors')\nconst { PING, PING_NAT, FIND_NODE, DOWN_HINT } = require('./lib/commands')\n\nconst TMP = b4a.allocUnsafe(32)\nconst TICK_INTERVAL = 5000\nconst SLEEPING_INTERVAL = 3 * TICK_INTERVAL\nconst STABLE_TICKS = 240 // if nothing major bad happens in ~20mins we can consider this node stable (if nat is friendly)\nconst MORE_STABLE_TICKS = 3 * STABLE_TICKS\nconst REFRESH_TICKS = 60 // refresh every ~5min when idle\nconst RECENT_NODE = 12 // we've heard from a node less than 1min ago\nconst OLD_NODE = 360 // if an node has been around more than 30 min we consider it old\n\nclass DHT extends EventEmitter {\n  constructor (opts = {}) {\n    super()\n\n    this.bootstrapNodes = opts.bootstrap === false ? [] : (opts.bootstrap || []).map(parseNode)\n    this.table = new Table(randomBytes(32))\n    this.nodes = new TOS()\n    this.udx = opts.udx || new UDX()\n    this.io = new IO(this.table, this.udx, {\n      ...opts,\n      onrequest: this._onrequest.bind(this),\n      onresponse: this._onresponse.bind(this),\n      ontimeout: this._ontimeout.bind(this)\n    })\n\n    this.concurrency = opts.concurrency || 10\n    this.bootstrapped = false\n    this.ephemeral = true\n    this.firewalled = this.io.firewalled\n    this.adaptive = typeof opts.ephemeral !== 'boolean' && opts.adaptive !== false\n    this.destroyed = false\n    this.suspended = false\n    this.online = true\n    this.stats = {\n      queries: { active: 0, total: 0 },\n      commands: {\n        ping: this.io.stats.commands[PING],\n        pingNat: this.io.stats.commands[PING_NAT],\n        findNode: this.io.stats.commands[FIND_NODE],\n        downHint: this.io.stats.commands[DOWN_HINT]\n      }\n    }\n\n    this._nat = new NatSampler()\n    this._quickFirewall = opts.quickFirewall !== false\n    this._forcePersistent = opts.ephemeral === false\n    this._repinging = 0\n    this._checks = 0\n    this._tick = randomOffset(100) // make sure to random offset all the network ticks\n    this._refreshTicks = randomOffset(REFRESH_TICKS)\n    this._stableTicks = this.adaptive ? STABLE_TICKS : 0\n    this._tickInterval = setInterval(this._ontick.bind(this), TICK_INTERVAL)\n    this._lastTick = Date.now()\n    this._lastHost = null\n    this._filterNode = opts.filterNode || opts.addNode || null // opts.addNode is deprecating, use opts.filterNode instead\n    this._onrow = (row) => row.on('full', (node) => this._onfullrow(node, row))\n    this._nonePersistentSamples = []\n    this._bootstrapping = this._bootstrap()\n    this._bootstrapping.catch(noop)\n\n    this.table.on('row', this._onrow)\n\n    this.io.networkInterfaces.on('change', (interfaces) => this._onnetworkchange(interfaces))\n\n    if (opts.nodes) {\n      for (let i = opts.nodes.length - 1; i >= 0; i--) {\n        this.addNode(opts.nodes[i])\n      }\n    }\n  }\n\n  static bootstrapper (port, host, opts) {\n    if (!port) throw new Error('Port is required')\n    if (!host) throw new Error('Host is required')\n    if (host === '0.0.0.0' || host === '::') throw new Error('Invalid host')\n    if (!UDX.isIPv4(host)) throw new Error('Host must be a IPv4 address')\n\n    const dht = new this({ port, ephemeral: false, firewalled: false, anyPort: false, bootstrap: [], ...opts })\n    dht._nat.add(host, port)\n    return dht\n  }\n\n  get id () {\n    return this.ephemeral ? null : this.table.id\n  }\n\n  get host () {\n    return this._nat.host\n  }\n\n  get port () {\n    return this._nat.port\n  }\n\n  get randomized () {\n    return this._nat.host !== null && (this._nat.port === 0)\n  }\n\n  get socket () {\n    return this.firewalled ? this.io.clientSocket : this.io.serverSocket\n  }\n\n  onmessage (socket, buf, rinfo) {\n    if (buf.byteLength > 1) this.io.onmessage(socket, buf, rinfo)\n  }\n\n  bind () {\n    return this.io.bind()\n  }\n\n  async suspend () {\n    await this.io.bind()\n    if (this.suspended || this.destroyed) return\n    this.suspended = true\n    this.io.suspend()\n    this.emit('suspend')\n  }\n\n  async resume () {\n    if (!this.suspended || this.destroyed) return\n    this.suspended = false\n    this._onwakeup()\n    await this.io.resume()\n    this.refresh()\n    this.emit('resume')\n  }\n\n  address () {\n    const socket = this.socket\n    return socket ? socket.address() : null\n  }\n\n  localAddress () {\n    if (!this.io.serverSocket) return null\n\n    return {\n      host: localIP(this.udx),\n      port: this.io.serverSocket.address().port\n    }\n  }\n\n  remoteAddress () {\n    if (!this.host) return null\n    if (!this.port) return null\n    if (this.firewalled) return null\n    if (!this.io.serverSocket) return null\n\n    const port = this.io.serverSocket.address().port\n    if (port !== this.port) return null\n\n    return {\n      host: this.host,\n      port\n    }\n  }\n\n  addNode ({ host, port }) {\n    this._addNode({\n      id: peer.id(host, port),\n      port,\n      host,\n      token: null,\n      to: null,\n      sampled: 0,\n      added: this._tick,\n      pinged: 0,\n      seen: 0,\n      downHints: 0,\n      prev: null,\n      next: null\n    })\n  }\n\n  toArray (opts) {\n    const limit = (opts && opts.limit)\n    if (limit === 0) return []\n    return this.nodes.toArray({ limit, reverse: true }).map(({ host, port }) => ({ host, port }))\n  }\n\n  async fullyBootstrapped () {\n    return this._bootstrapping\n  }\n\n  ready () {\n    // Deprecating, use fullyBootstrapped instead (removed on next major)\n    return this.fullyBootstrapped()\n  }\n\n  findNode (target, opts) {\n    if (this.destroyed) throw new Error('Node destroyed')\n    this._refreshTicks = REFRESH_TICKS\n    return new Query(this, target, true, FIND_NODE, null, opts)\n  }\n\n  query ({ target, command, value }, opts) {\n    if (this.destroyed) throw new Error('Node destroyed')\n    this._refreshTicks = REFRESH_TICKS\n    return new Query(this, target, false, command, value || null, opts)\n  }\n\n  ping ({ host, port }, opts) {\n    let value = null\n\n    if (opts && opts.size && opts.size > 0) value = b4a.alloc(opts.size)\n\n    const req = this.io.createRequest({ id: null, host, port }, null, true, PING, null, value, (opts && opts.session) || null, (opts && opts.ttl))\n    return this._requestToPromise(req, opts)\n  }\n\n  request ({ token = null, command, target = null, value = null }, { host, port }, opts) {\n    const req = this.io.createRequest({ id: null, host, port }, token, false, command, target, value, (opts && opts.session) || null, (opts && opts.ttl))\n    return this._requestToPromise(req, opts)\n  }\n\n  session () {\n    return new Session(this)\n  }\n\n  _requestToPromise (req, opts) {\n    if (req === null) return Promise.reject(new Error('Node destroyed'))\n\n    if (opts && opts.socket) req.socket = opts.socket\n    if (opts && opts.retry === false) req.retries = 0\n\n    return new Promise((resolve, reject) => {\n      req.onresponse = resolve\n      req.onerror = reject\n      req.send()\n    })\n  }\n\n  async _bootstrap () {\n    const self = this\n\n    await Promise.resolve() // wait a tick, so apis can be used from the outside\n    await this.io.bind()\n\n    this.emit('listening')\n\n    // TODO: some papers describe more advanced ways of bootstrapping - we should prob look into that\n\n    let first = this.firewalled && this._quickFirewall && !this._forcePersistent\n    let testNat = false\n\n    const onlyFirewall = !this._forcePersistent\n\n    for (let i = 0; i < 2; i++) {\n      await this._backgroundQuery(this.table.id).on('data', ondata).finished()\n\n      if (this.bootstrapped || (!testNat && !this._forcePersistent)) break\n      if (!(await this._updateNetworkState(onlyFirewall))) break\n    }\n\n    if (this.bootstrapped) return\n    this.bootstrapped = true\n\n    this.emit('ready')\n\n    function ondata (data) {\n      // Simple QUICK nat heuristic.\n      // If we get ONE positive nat ping before the bootstrap query finishes\n      // then we always to a nat test, no matter if we are adaptive...\n      // This should be expanded in the future to try more than one node etc, not always hit the first etc\n      // If this fails, then nbd, as the onstable hook will pick it up later.\n\n      if (!first) return\n      first = false\n\n      const value = b4a.allocUnsafe(2)\n      c.uint16.encode({ start: 0, end: 2, buffer: value }, self.io.serverSocket.address().port)\n\n      self._request(data.from, true, PING_NAT, null, value, null, () => { testNat = true }, noop)\n    }\n  }\n\n  refresh () {\n    const node = this.table.random()\n    this._backgroundQuery(node ? node.id : this.table.id).on('error', noop)\n  }\n\n  async destroy () {\n    const emitClose = !this.destroyed\n    this.destroyed = true\n    clearInterval(this._tickInterval)\n    await this.io.destroy()\n    if (emitClose) this.emit('close')\n  }\n\n  _request (to, internal, command, target, value, session, onresponse, onerror) {\n    const req = this.io.createRequest(to, null, internal, command, target, value, session)\n    if (req === null) return null\n\n    req.onresponse = onresponse\n    req.onerror = onerror\n    req.send()\n\n    return req\n  }\n\n  _natAdd (host, port) {\n    const prevHost = this._nat.host\n    const prevPort = this._nat.port\n\n    this._nat.add(host, port)\n\n    if (prevHost === this._nat.host && prevPort === this._nat.port) return\n\n    this.emit('nat-update', this._nat.host, this._nat.port)\n  }\n\n  // we don't check that this is a bootstrap node but we limit the sample size to very few nodes, so fine\n  _sampleBootstrapMaybe (from, to) {\n    if (this._nonePersistentSamples.length >= Math.max(1, this.bootstrapNodes.length)) return\n    const id = from.host + ':' + from.port\n    if (this._nonePersistentSamples.indexOf(id) > -1) return\n    this._nonePersistentSamples.push(id)\n    this._natAdd(to.host, to.port)\n  }\n\n  _addNodeFromNetwork (sample, from, to) {\n    if (this._filterNode !== null && !this._filterNode(from)) {\n      return\n    }\n\n    if (from.id === null) {\n      this._sampleBootstrapMaybe(from, to)\n      return\n    }\n\n    const oldNode = this.table.get(from.id)\n\n    // refresh it, if we've seen this before\n    if (oldNode) {\n      if (sample && (oldNode.sampled === 0 || (this._tick - oldNode.sampled) >= OLD_NODE)) {\n        oldNode.to = to\n        oldNode.sampled = this._tick\n        this._natAdd(to.host, to.port)\n      }\n\n      oldNode.pinged = oldNode.seen = this._tick\n      this.nodes.add(oldNode)\n      return\n    }\n\n    this._addNode({\n      id: from.id,\n      port: from.port,\n      host: from.host,\n      to,\n      sampled: 0,\n      added: this._tick,\n      pinged: this._tick, // last time we interacted with them\n      seen: this._tick, // last time we heard from them\n      downHints: 0,\n      prev: null,\n      next: null\n    })\n  }\n\n  _addNode (node) {\n    if (this.nodes.has(node) || b4a.equals(node.id, this.table.id)) return\n\n    node.added = node.pinged = node.seen = this._tick\n\n    if (!this.table.add(node)) return\n    this.nodes.add(node)\n\n    if (node.to && node.sampled === 0) {\n      node.sampled = this._tick\n      this._natAdd(node.to.host, node.to.port)\n    }\n\n    this.emit('add-node', node)\n  }\n\n  _removeStaleNode (node, lastSeen) {\n    if (node.seen <= lastSeen) this._removeNode(node)\n  }\n\n  _removeNode (node) {\n    if (!this.nodes.has(node)) return\n\n    this.table.remove(node.id)\n    this.nodes.remove(node)\n\n    this.emit('remove-node', node)\n  }\n\n  _onwakeup () {\n    this._tick += 2 * OLD_NODE // bump the tick enough that everything appears old.\n    this._tick += 8 - (this._tick & 7) - 2 // triggers a series of pings in two ticks\n    this._stableTicks = MORE_STABLE_TICKS\n    this._refreshTicks = 1 // triggers a refresh next tick (allow network time to wake up also)\n    this._lastHost = null // clear network cache check\n\n    if (this.adaptive) {\n      // TODO: re-enable this as soon as we find out why this is over triggering in some edge cases\n      // this.firewalled = true\n      // this.io.firewalled = true\n\n      if (!this.ephemeral) {\n        this.ephemeral = true\n        this.io.ephemeral = true\n        this.emit('ephemeral')\n      }\n    }\n\n    this.emit('wakeup')\n  }\n\n  _onfullrow (newNode, row) {\n    if (!this.bootstrapped || this._repinging >= 3) return\n\n    let oldest = null\n    for (const node of row.nodes) {\n      if (node.pinged === this._tick) continue\n      if (oldest === null || oldest.pinged > node.pinged || (oldest.pinged === node.pinged && oldest.added > node.added)) oldest = node\n    }\n\n    if (oldest === null) return\n    if ((this._tick - oldest.pinged) < RECENT_NODE && (this._tick - oldest.added) > OLD_NODE) return\n\n    this._repingAndSwap(newNode, oldest)\n  }\n\n  _onnetworkchange (interfaces) {\n    this.emit('network-change', interfaces)\n    this.emit('network-update')\n  }\n\n  _repingAndSwap (newNode, oldNode) {\n    const self = this\n    const lastSeen = oldNode.seen\n\n    oldNode.pinged = this._tick\n\n    this._repinging++\n    this._request({ id: null, host: oldNode.host, port: oldNode.port }, true, PING, null, null, null, onsuccess, onswap)\n\n    function onsuccess (m) {\n      if (oldNode.seen <= lastSeen) return onswap()\n      self._repinging--\n    }\n\n    function onswap (e) {\n      self._repinging--\n      self._removeNode(oldNode)\n      self._addNode(newNode)\n    }\n  }\n\n  _onrequest (req, external) {\n    if (req.from.id !== null) {\n      this._addNodeFromNetwork(!external, req.from, req.to)\n    }\n\n    if (req.internal) {\n      switch (req.command) {\n        // standard keep alive call\n        case PING: {\n          req.sendReply(0, null, false, false)\n          return\n        }\n        // check if the other side can receive a message to their other socket\n        case PING_NAT: {\n          if (req.value === null || req.value.byteLength < 2) return\n          const port = c.uint16.decode({ start: 0, end: 2, buffer: req.value })\n          if (port === 0) return\n          req.from.port = port\n          req.sendReply(0, null, false, false)\n          return\n        }\n        // empty dht reply back\n        case FIND_NODE: {\n          if (!req.target) return\n          req.sendReply(0, null, false, true)\n          return\n        }\n        // \"this is node you sent me is down\" - let's try to ping it\n        case DOWN_HINT: {\n          if (req.value === null || req.value.byteLength < 6) return\n          if (this._checks < 10) {\n            sodium.crypto_generichash(TMP, req.value.subarray(0, 6))\n            const node = this.table.get(TMP)\n            if (node && (node.pinged < this._tick || node.downHints === 0)) {\n              node.downHints++\n              this._check(node)\n            }\n          }\n          req.sendReply(0, null, false, false)\n          return\n        }\n      }\n\n      req.sendReply(UNKNOWN_COMMAND, null, false, req.target !== null)\n      return\n    }\n\n    // ask the user to handle it or reply back with a bad command\n    if (this.onrequest(req) === false) {\n      req.sendReply(UNKNOWN_COMMAND, null, false, req.target !== null)\n    }\n  }\n\n  onrequest (req) {\n    return this.emit('request', req)\n  }\n\n  _onresponse (res, external) {\n    this._addNodeFromNetwork(!external, res.from, res.to)\n  }\n\n  _ontimeout (req) {\n    if (!req.to.id) return\n    const node = this.table.get(req.to.id)\n    if (node) this._removeNode(node)\n  }\n\n  _pingSome () {\n    let cnt = this.io.inflight.length > 2 ? 3 : 5\n    let oldest = this.nodes.oldest\n\n    // tiny dht, pinged the bootstrap again\n    if (!oldest) {\n      this.refresh()\n      return\n    }\n\n    // we've recently pinged the oldest one, so only trigger a couple of repings\n    if ((this._tick - oldest.pinged) < RECENT_NODE) {\n      cnt = 2\n    }\n\n    while (cnt--) {\n      if (!oldest || this._tick === oldest.pinged) continue\n      this._check(oldest)\n      oldest = oldest.next\n    }\n  }\n\n  _check (node) {\n    node.pinged = this._tick\n\n    const lastSeen = node.seen\n    const onresponse = () => {\n      this._checks--\n      this._removeStaleNode(node, lastSeen)\n    }\n    const onerror = () => {\n      this._checks--\n      this._removeNode(node)\n    }\n\n    this._checks++\n    this._request({ id: null, host: node.host, port: node.port }, true, PING, null, null, null, onresponse, onerror)\n  }\n\n  _ontick () {\n    const time = Date.now()\n\n    if (time - this._lastTick > SLEEPING_INTERVAL && this.suspended === false) {\n      this._onwakeup()\n    } else {\n      this._tick++\n    }\n\n    this._lastTick = time\n\n    if (!this.bootstrapped || this.suspended) return\n\n    if (this.adaptive && this.ephemeral && --this._stableTicks <= 0) {\n      if (this._lastHost === this._nat.host) { // do not recheck the same network...\n        this._stableTicks = MORE_STABLE_TICKS\n      } else {\n        this._updateNetworkState() // the promise returned here never fails so just ignore it\n      }\n    }\n\n    if ((this._tick & 7) === 0) {\n      this._pingSome()\n    }\n\n    if (((this._tick & 63) === 0 && this.nodes.length < this.table.k) || --this._refreshTicks <= 0) {\n      this.refresh()\n    }\n  }\n\n  async _updateNetworkState (onlyFirewall = false) {\n    if (!this.ephemeral) return false\n    if (onlyFirewall && !this.firewalled) return false\n\n    const { host, port } = this._nat\n\n    if (!onlyFirewall) {\n      // remember what host we checked and reset the counter\n      this._stableTicks = MORE_STABLE_TICKS\n      this._lastHost = host\n    }\n\n    // check if we have a consistent host and port\n    if (host === null || port === 0) {\n      return false\n    }\n\n    const natSampler = this.firewalled ? new NatSampler() : this._nat\n\n    // ask remote nodes to ping us on our server socket to see if we have the port open\n    const firewalled = this.firewalled && await this._checkIfFirewalled(natSampler)\n    if (firewalled) return false\n\n    this.firewalled = this.io.firewalled = false\n\n    // incase it's called in parallel for some reason, or if our nat status somehow changed\n    if (!this.ephemeral || host !== this._nat.host || port !== this._nat.port) return false\n    // if the firewall probe returned a different host / non consistent port, bail as well\n    if (natSampler.host !== host || natSampler.port === 0) return false\n\n    const id = peer.id(natSampler.host, natSampler.port)\n\n    if (!onlyFirewall) {\n      this.ephemeral = this.io.ephemeral = false\n    }\n\n    if (natSampler !== this._nat) {\n      const prevHost = this._nat.host\n      const prevPort = this._nat.port\n\n      this._nonePersistentSamples = []\n      this._nat = natSampler\n\n      if (prevHost !== this._nat.host || prevPort !== this._nat.port) {\n        this.emit('nat-update', this._nat.host, this._nat.port)\n      }\n    }\n\n    // TODO: we should make this a bit more defensive in terms of using more\n    // resources to make sure that the new routing table contains as many alive nodes\n    // as possible, vs blindly copying them over...\n\n    // all good! copy over the old routing table to the new one\n    if (!b4a.equals(this.table.id, id)) {\n      const nodes = this.table.toArray()\n\n      this.table = this.io.table = new Table(id)\n\n      for (const node of nodes) {\n        if (b4a.equals(node.id, id)) continue\n        if (!this.table.add(node)) this.nodes.remove(node)\n      }\n\n      this.table.on('row', this._onrow)\n\n      // we need to rebootstrap/refresh since we updated our id\n      if (this.bootstrapped) this.refresh()\n    }\n\n    if (!this.ephemeral) {\n      this.emit('persistent')\n    }\n\n    return true\n  }\n\n  async * _resolveBootstrapNodes () {\n    for (let { host, port } of this.bootstrapNodes) {\n      let doLookup = false\n\n      if (host.indexOf('@') === -1) {\n        doLookup = true\n      } else {\n        const [suggestedIP, fallbackHost] = host.split('@')\n        try {\n          await this.ping({ host: suggestedIP, port })\n          host = suggestedIP\n        } catch {\n          host = fallbackHost\n          doLookup = true\n        }\n      }\n\n      if (doLookup) {\n        try {\n          host = UDX.isIPv4(host) ? host : (await this.udx.lookup(host, { family: 4 })).host\n        } catch {\n          continue\n        }\n      }\n\n      yield {\n        id: peer.id(host, port),\n        host,\n        port\n      }\n    }\n  }\n\n  async _addBootstrapNodes (nodes) {\n    for await (const node of this._resolveBootstrapNodes()) {\n      nodes.push(node)\n    }\n  }\n\n  async _checkIfFirewalled (natSampler = new NatSampler()) {\n    const nodes = []\n    for (let node = this.nodes.latest; node && nodes.length < 5; node = node.prev) {\n      nodes.push(node)\n    }\n\n    if (nodes.length < 5) await this._addBootstrapNodes(nodes)\n    // if no nodes are available, including bootstrappers - bail\n    if (nodes.length === 0) return true\n\n    const hosts = new Set()\n    const value = b4a.allocUnsafe(2)\n\n    c.uint16.encode({ start: 0, end: 2, buffer: value }, this.io.serverSocket.address().port)\n\n    // double check they actually came on the server socket...\n    this.io.serverSocket.on('message', onmessage)\n\n    const pongs = await requestAll(this, true, PING_NAT, value, nodes)\n\n    let count = 0\n    for (const res of pongs) {\n      if (hosts.has(res.from.host)) {\n        count++\n        natSampler.add(res.to.host, res.to.port)\n      }\n    }\n\n    this.io.serverSocket.removeListener('message', onmessage)\n\n    // if we got no or very few replies, consider it a fluke\n    if (count < (nodes.length >= 5 ? 3 : 1)) return true\n\n    // check that the server socket has the same ip as the client socket\n    if (natSampler.host === null || this._nat.host !== natSampler.host) return true\n\n    // check that the local port of the server socket is the same as the remote port\n    // TODO: we might want a flag to opt out of this heuristic for specific remapped port servers\n    if (natSampler.port === 0 || natSampler.port !== this.io.serverSocket.address().port) return true\n\n    return false\n\n    function onmessage (_, { host }) {\n      hosts.add(host)\n    }\n  }\n\n  _backgroundQuery (target) {\n    this._refreshTicks = REFRESH_TICKS\n\n    const backgroundCon = Math.min(this.concurrency, Math.max(2, (this.concurrency / 8) | 0))\n    const q = new Query(this, target, true, FIND_NODE, null, { concurrency: backgroundCon, maxSlow: 0 })\n\n    q.on('data', () => {\n      // yield to other traffic\n      q.concurrency = this.io.inflight.length < 3\n        ? this.concurrency\n        : backgroundCon\n    })\n\n    return q\n  }\n\n  // called by the query\n  _online () {\n    if (this.online) return\n    this.online = true\n    this.emit('network-update')\n  }\n\n  // called by the query\n  _offline () {\n    if (!this.online) return\n    this.online = false\n    this.emit('network-update')\n  }\n}\n\nDHT.OK = 0\nDHT.ERROR_UNKNOWN_COMMAND = UNKNOWN_COMMAND\nDHT.ERROR_INVALID_TOKEN = INVALID_TOKEN\n\nmodule.exports = DHT\n\nfunction localIP (udx, family = 4) {\n  let host = null\n\n  for (const n of udx.networkInterfaces()) {\n    if (n.family !== family || n.internal) continue\n\n    // mac really likes en0, mb a better way but this shouldnt be bad anywhere so return now\n    if (n.name === 'en0') return n.host\n\n    // otherwise pick the first non internal host (let the loop continue in case we see en0)\n    if (host === null) host = n.host\n  }\n\n  return host || (family === 4 ? '127.0.0.1' : '::1')\n}\n\nfunction parseNode (s) {\n  if (typeof s === 'object') return s\n  if (typeof s === 'number') return { host: '127.0.0.1', port: s }\n  const [host, port] = s.split(':')\n  if (!port) throw new Error('Bootstrap node format is host:port')\n\n  return {\n    host,\n    port: Number(port)\n  }\n}\n\nfunction randomBytes (n) {\n  const b = b4a.alloc(n)\n  sodium.randombytes_buf(b)\n  return b\n}\n\nfunction randomOffset (n) {\n  return n - ((Math.random() * 0.5 * n) | 0)\n}\n\nfunction requestAll (dht, internal, command, value, nodes) {\n  let missing = nodes.length\n  const replies = []\n\n  return new Promise((resolve) => {\n    for (const node of nodes) {\n      const req = dht._request(node, internal, command, null, value, null, onsuccess, onerror)\n      if (!req) return resolve(replies)\n    }\n\n    function onsuccess (res) {\n      replies.push(res)\n      if (--missing === 0) resolve(replies)\n    }\n\n    function onerror () {\n      if (--missing === 0) resolve(replies)\n    }\n  })\n}\n\nfunction noop () {}\nexports.PING = 0\nexports.PING_NAT = 1\nexports.FIND_NODE = 2\nexports.DOWN_HINT = 3\nmodule.exports = class DHTError extends Error {\n  constructor (msg, code, fn = DHTError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name () {\n    return 'DHTError'\n  }\n\n  static UNKNOWN_COMMAND = 1\n  static INVALID_TOKEN = 2\n\n  static REQUEST_TIMEOUT (msg = 'Request timed out') {\n    return new DHTError(msg, 'REQUEST_TIMEOUT', DHTError.REQUEST_TIMEOUT)\n  }\n\n  static REQUEST_DESTROYED (msg = 'Request destroyed') {\n    return new DHTError(msg, 'REQUEST_DESTROYED', DHTError.REQUEST_DESTROYED)\n  }\n\n  static IO_SUSPENDED (msg = 'I/O suspended') {\n    return new DHTError(msg, 'IO_SUSPENDED', DHTError.IO_SUSPENDED)\n  }\n}\nconst FIFO = require('fast-fifo')\nconst sodium = require('sodium-universal')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst peer = require('./peer')\nconst {\n  INVALID_TOKEN,\n  REQUEST_TIMEOUT,\n  REQUEST_DESTROYED,\n  IO_SUSPENDED\n} = require('./errors')\n\nconst VERSION = 0b11\nconst RESPONSE_ID = (0b0001 << 4) | VERSION\nconst REQUEST_ID = (0b0000 << 4) | VERSION\nconst EMPTY_ARRAY = []\n\nmodule.exports = class IO {\n  constructor (table, udx, { maxWindow = 80, port = 0, host = '0.0.0.0', anyPort = true, firewalled = true, onrequest, onresponse = noop, ontimeout = noop } = {}) {\n    this.table = table\n    this.udx = udx\n    this.inflight = []\n    this.clientSocket = null\n    this.serverSocket = null\n    this.firewalled = firewalled !== false\n    this.ephemeral = true\n    this.congestion = new CongestionWindow(maxWindow)\n    this.networkInterfaces = udx.watchNetworkInterfaces()\n    this.suspended = false\n\n    this.stats = {\n      commands: [\n        { tx: 0, rx: 0 }, // tx = transmitted, rx = received\n        { tx: 0, rx: 0 },\n        { tx: 0, rx: 0 },\n        { tx: 0, rx: 0 }\n      ]\n    }\n\n    this.onrequest = onrequest\n    this.onresponse = onresponse\n    this.ontimeout = ontimeout\n\n    this._pending = new FIFO()\n    this._rotateSecrets = 10\n    this._tid = (Math.random() * 65536) | 0\n    this._secrets = null\n    this._drainInterval = null\n    this._destroying = null\n    this._binding = null\n\n    // port can be a number or a range [start, to]\n    this.portRange = port.length\n      ? port\n      : port === 0 ? [0, 0] : [port, port + 5]\n\n    this._host = host\n    this._anyPort = anyPort !== false\n    this._boundServerPort = 0\n    this._boundClientPort = 0\n  }\n\n  onmessage (socket, buffer, { host, port }) {\n    if (buffer.byteLength < 2 || !(port > 0 && port < 65536) || this.suspended === true) return\n\n    const from = { id: null, host, port }\n    const state = { start: 1, end: buffer.byteLength, buffer }\n    const expectedSocket = this.firewalled ? this.clientSocket : this.serverSocket\n    const external = socket !== expectedSocket\n\n    if (buffer[0] === REQUEST_ID) {\n      const req = Request.decode(this, socket, from, state)\n      if (req === null) return\n      if (req.token !== null && !b4a.equals(req.token, this.token(req.from, 1)) && !b4a.equals(req.token, this.token(req.from, 0))) {\n        req.error(INVALID_TOKEN, { token: true })\n        return\n      }\n      this.onrequest(req, external)\n      return\n    }\n\n    if (buffer[0] === RESPONSE_ID) {\n      const res = decodeReply(from, state)\n      if (res === null) return\n\n      for (let i = 0; i < this.inflight.length; i++) {\n        const req = this.inflight[i]\n        if (req.tid !== res.tid) continue\n\n        res.rtt = Date.now() - req._timestamp\n\n        if (i === this.inflight.length - 1) this.inflight.pop()\n        else this.inflight[i] = this.inflight.pop()\n\n        if (req.session) req.session._detach(req)\n\n        // TODO: Auto retry here if errors.INVALID_TOKEN is returned?\n\n        if (req._timeout) {\n          clearTimeout(req._timeout)\n          req._timeout = null\n        }\n\n        this.congestion.recv()\n\n        if (req.internal && req.command < this.stats.commands.length) {\n          this.stats.commands[req.command].rx++\n        }\n\n        this.onresponse(res, external)\n        req.onresponse(res, req)\n        break\n      }\n    }\n  }\n\n  token (addr, i) {\n    if (this._secrets === null) {\n      const buf = b4a.alloc(64)\n      this._secrets = [buf.subarray(0, 32), buf.subarray(32, 64)]\n      sodium.randombytes_buf(this._secrets[0])\n      sodium.randombytes_buf(this._secrets[1])\n    }\n\n    const token = b4a.allocUnsafe(32)\n    sodium.crypto_generichash(token, b4a.from(addr.host), this._secrets[i])\n    return token\n  }\n\n  async destroy () {\n    if (this._destroying) return this._destroying\n    this._destroying = this._destroy()\n    return this._destroying\n  }\n\n  async _destroy () {\n    // simplifies timing to await the bind here also, although it might be unneeded\n    await this.bind()\n    await this._clear(false)\n  }\n\n  async _clear (suspended) {\n    if (this._drainInterval) {\n      clearInterval(this._drainInterval)\n      this._drainInterval = null\n    }\n\n    while (this.inflight.length) {\n      const req = this.inflight.pop()\n      if (req._timeout) clearTimeout(req._timeout)\n      req._timeout = null\n      req.destroyed = true\n\n      if (req.session) req.session._detach(req)\n\n      req.onerror(suspended ? IO_SUSPENDED() : REQUEST_DESTROYED(), req)\n    }\n\n    await Promise.allSettled([\n      this.serverSocket.close(),\n      this.clientSocket.close()\n    ])\n\n    if (!suspended) this.networkInterfaces.destroy()\n  }\n\n  async _rebind (binding) {\n    if (binding) await binding\n    if (this._destroying) return this._destroying\n    await this._clear(true)\n    await this._bindSockets()\n  }\n\n  suspend () {\n    this.suspended = true\n    if (this._drainInterval) {\n      clearInterval(this._drainInterval)\n      this._drainInterval = null\n    }\n  }\n\n  resume () {\n    this.suspended = false\n    const binding = this._binding\n    this._binding = this._rebind(binding)\n    return this._binding\n  }\n\n  bind () {\n    if (this._binding) return this._binding\n    this._binding = this._bindSockets()\n    return this._binding\n  }\n\n  async _bindSockets () {\n    const serverSocket = this.udx.createSocket()\n\n    const candidatePorts = []\n\n    // Retrying previous port always has precedence\n    if (this._boundServerPort) candidatePorts.push(this._boundServerPort)\n\n    for (let i = this.portRange[0]; i < this.portRange[1]; i++) candidatePorts.push(i)\n\n    for (const port of candidatePorts) {\n      if (serverSocket.bound) break\n\n      try {\n        serverSocket.bind(port, this._host)\n      } catch (err) {\n        if (!this._anyPort) {\n          await serverSocket.close()\n          throw err\n        }\n      }\n    }\n\n    if (!serverSocket.bound) {\n      try {\n        serverSocket.bind(0, this._host)\n      } catch (err) {\n        await serverSocket.close()\n        throw err\n      }\n    }\n\n    const clientSocket = this.udx.createSocket()\n\n    try {\n      clientSocket.bind(this._boundClientPort || 0, this._host)\n    } catch {\n      try {\n        clientSocket.bind(0, this._host)\n      } catch (err) {\n        await serverSocket.close()\n        await clientSocket.close()\n        throw err\n      }\n    }\n\n    this._boundServerPort = serverSocket.address().port\n    this._boundClientPort = clientSocket.address().port\n\n    this.clientSocket = clientSocket\n    this.serverSocket = serverSocket\n\n    this.serverSocket.on('message', this.onmessage.bind(this, this.serverSocket))\n    this.clientSocket.on('message', this.onmessage.bind(this, this.clientSocket))\n\n    if (this._drainInterval === null) {\n      this._drainInterval = setInterval(this._drain.bind(this), 750)\n      if (this._drainInterval.unref) this._drainInterval.unref()\n    }\n\n    for (const req of this.inflight) {\n      if (!req.socket) req.socket = this.firewalled ? this.clientSocket : this.serverSocket\n      req.sent = 0\n      req.send(false)\n    }\n  }\n\n  _drain () {\n    if (this._secrets !== null && --this._rotateSecrets === 0) {\n      this._rotateSecrets = 10\n      const tmp = this._secrets[0]\n      this._secrets[0] = this._secrets[1]\n      this._secrets[1] = tmp\n      sodium.crypto_generichash(tmp, tmp)\n    }\n\n    this.congestion.drain()\n\n    while (!this.congestion.isFull()) {\n      const p = this._pending.shift()\n      if (p === undefined) return\n      p._sendNow()\n    }\n  }\n\n  createRequest (to, token, internal, command, target, value, session, ttl) {\n    if (this._destroying !== null) return null\n\n    if (this._tid === 65536) this._tid = 0\n\n    const tid = this._tid++\n    const socket = this.firewalled ? this.clientSocket : this.serverSocket\n\n    const req = new Request(this, socket, tid, null, to, token, internal, command, target, value, session, ttl || 0)\n    this.inflight.push(req)\n    if (session) session._attach(req)\n\n    if (internal && command < this.stats.commands.length) {\n      this.stats.commands[command].tx++\n    }\n\n    return req\n  }\n}\n\nclass Request {\n  constructor (io, socket, tid, from, to, token, internal, command, target, value, session, ttl) {\n    this.socket = socket\n    this.tid = tid\n    this.from = from\n    this.to = to\n    this.token = token\n    this.command = command\n    this.target = target\n    this.value = value\n    this.internal = internal\n    this.session = session\n    this.ttl = ttl\n    this.index = -1\n    this.sent = 0\n    this.retries = 3\n    this.destroyed = false\n\n    this.oncycle = noop\n    this.onerror = noop\n    this.onresponse = noop\n\n    this._buffer = null\n    this._io = io\n    this._timeout = null\n    this._timestamp = Date.now()\n  }\n\n  static decode (io, socket, from, state) {\n    try {\n      const flags = c.uint.decode(state)\n      const tid = c.uint16.decode(state)\n      const to = peer.ipv4.decode(state)\n      const id = flags & 1 ? c.fixed32.decode(state) : null\n      const token = flags & 2 ? c.fixed32.decode(state) : null\n      const internal = (flags & 4) !== 0\n      const command = c.uint.decode(state)\n      const target = flags & 8 ? c.fixed32.decode(state) : null\n      const value = flags & 16 ? c.buffer.decode(state) : null\n\n      if (id !== null) from.id = validateId(id, from)\n\n      return new Request(io, socket, tid, from, to, token, internal, command, target, value, null, 0)\n    } catch {\n      return null\n    }\n  }\n\n  reply (value, opts = {}) {\n    const socket = opts.socket || this.socket\n    const to = opts.to || this.from\n    this._sendReply(0, value || null, opts.token !== false, opts.closerNodes !== false, to, socket)\n  }\n\n  error (code, opts = {}) {\n    const socket = opts.socket || this.socket\n    const to = opts.to || this.from\n    this._sendReply(code, null, opts.token === true, opts.closerNodes !== false, to, socket)\n  }\n\n  relay (value, to, opts) {\n    const socket = (opts && opts.socket) || this.socket\n    const buffer = this._encodeRequest(null, value, to, socket)\n    socket.trySend(buffer, to.port, to.host, this.ttl)\n  }\n\n  send (force = false) {\n    if (this.destroyed) return\n\n    if (this.socket === null) return\n    if (this._buffer === null) this._buffer = this._encodeRequest(this.token, this.value, this.to, this.socket)\n\n    if (!force && this._io.congestion.isFull()) {\n      this._io._pending.push(this)\n      return\n    }\n\n    this._sendNow()\n  }\n\n  sendReply (error, value, token, hasCloserNodes) {\n    this._sendReply(error, value, token, hasCloserNodes, this.from, this.socket, null)\n  }\n\n  _sendNow () {\n    if (this.destroyed) return\n    this.sent++\n    this._io.congestion.send()\n    this.socket.trySend(this._buffer, this.to.port, this.to.host, this.ttl)\n    if (this._timeout) clearTimeout(this._timeout)\n    this._timeout = setTimeout(oncycle, 1000, this)\n  }\n\n  destroy (err) {\n    if (this.destroyed) return\n    this.destroyed = true\n\n    if (this._timeout) {\n      clearTimeout(this._timeout)\n      this._timeout = null\n    }\n\n    const i = this._io.inflight.indexOf(this)\n    if (i === -1) return\n\n    if (i === this._io.inflight.length - 1) this._io.inflight.pop()\n    else this._io.inflight[i] = this._io.inflight.pop()\n\n    if (this.session) this.session._detach(this)\n\n    this.onerror(err || REQUEST_DESTROYED(), this)\n  }\n\n  _sendReply (error, value, token, hasCloserNodes, from, socket) {\n    if (socket === null || this.destroyed) return\n\n    const id = this._io.ephemeral === false && socket === this._io.serverSocket\n    const closerNodes = (this.target !== null && hasCloserNodes) ? this._io.table.closest(this.target) : EMPTY_ARRAY\n    const state = { start: 0, end: 1 + 1 + 6 + 2, buffer: null } // (type | version) + flags + to + tid\n\n    if (id) state.end += 32\n    if (token) state.end += 32\n    if (closerNodes.length > 0) peer.ipv4Array.preencode(state, closerNodes)\n    if (error > 0) c.uint.preencode(state, error)\n    if (value) c.buffer.preencode(state, value)\n\n    state.buffer = b4a.allocUnsafe(state.end)\n    state.buffer[state.start++] = RESPONSE_ID\n    state.buffer[state.start++] = (id ? 1 : 0) | (token ? 2 : 0) | (closerNodes.length > 0 ? 4 : 0) | (error > 0 ? 8 : 0) | (value ? 16 : 0)\n\n    c.uint16.encode(state, this.tid)\n    peer.ipv4.encode(state, from)\n\n    if (id) c.fixed32.encode(state, this._io.table.id)\n    if (token) c.fixed32.encode(state, this._io.token(from, 1))\n    if (closerNodes.length > 0) peer.ipv4Array.encode(state, closerNodes)\n    if (error > 0) c.uint.encode(state, error)\n    if (value) c.buffer.encode(state, value)\n\n    socket.trySend(state.buffer, from.port, from.host, this.ttl)\n  }\n\n  _encodeRequest (token, value, to, socket) {\n    const id = this._io.ephemeral === false && socket === this._io.serverSocket\n    const state = { start: 0, end: 1 + 1 + 6 + 2, buffer: null } // (type | version) + flags + to + tid\n\n    if (id) state.end += 32\n    if (token) state.end += 32\n\n    c.uint.preencode(state, this.command)\n\n    if (this.target) state.end += 32\n    if (value) c.buffer.preencode(state, value)\n\n    state.buffer = b4a.allocUnsafe(state.end)\n    state.buffer[state.start++] = REQUEST_ID\n    state.buffer[state.start++] = (id ? 1 : 0) | (token ? 2 : 0) | (this.internal ? 4 : 0) | (this.target ? 8 : 0) | (value ? 16 : 0)\n\n    c.uint16.encode(state, this.tid)\n    peer.ipv4.encode(state, to)\n\n    if (id) c.fixed32.encode(state, this._io.table.id)\n    if (token) c.fixed32.encode(state, token)\n\n    c.uint.encode(state, this.command)\n\n    if (this.target) c.fixed32.encode(state, this.target)\n    if (value) c.buffer.encode(state, value)\n\n    return state.buffer\n  }\n}\n\nclass CongestionWindow {\n  constructor (maxWindow) {\n    this._i = 0\n    this._total = 0\n    this._window = [0, 0, 0, 0]\n    this._maxWindow = maxWindow\n  }\n\n  isFull () {\n    return this._total >= 2 * this._maxWindow || this._window[this._i] >= this._maxWindow\n  }\n\n  recv () {\n    if (this._window[this._i] > 0) {\n      this._window[this._i]--\n      this._total--\n    }\n  }\n\n  send () {\n    this._total++\n    this._window[this._i]++\n  }\n\n  drain () {\n    this._i = (this._i + 1) & 3\n    this._total -= this._window[this._i]\n    this._window[this._i] = 0 // clear oldest\n  }\n}\n\nfunction noop () {}\n\nfunction oncycle (req) {\n  req._timeout = null\n  req.oncycle(req)\n  if (req.sent >= req.retries) {\n    req.destroy(REQUEST_TIMEOUT())\n    req._io.ontimeout(req)\n  } else {\n    req.send()\n  }\n}\n\nfunction decodeReply (from, state) {\n  try {\n    const flags = c.uint.decode(state)\n    const tid = c.uint16.decode(state)\n    const to = peer.ipv4.decode(state)\n    const id = flags & 1 ? c.fixed32.decode(state) : null\n    const token = flags & 2 ? c.fixed32.decode(state) : null\n    const closerNodes = flags & 4 ? peer.ipv4Array.decode(state) : null\n    const error = flags & 8 ? c.uint.decode(state) : 0\n    const value = flags & 16 ? c.buffer.decode(state) : null\n\n    if (id !== null) from.id = validateId(id, from)\n\n    return { tid, rtt: 0, from, to, token, closerNodes, error, value }\n  } catch {\n    return null\n  }\n}\n\nfunction validateId (id, from) {\n  const expected = peer.id(from.host, from.port)\n  return b4a.equals(expected, id) ? expected : null\n}\nconst sodium = require('sodium-universal')\nconst c = require('compact-encoding')\nconst net = require('compact-encoding-net')\nconst b4a = require('b4a')\n\nconst ipv4 = {\n  ...net.ipv4Address,\n  decode (state) {\n    const ip = net.ipv4Address.decode(state)\n    return {\n      id: null, // populated by the callee\n      host: ip.host,\n      port: ip.port\n    }\n  }\n}\n\nmodule.exports = { id, ipv4, ipv4Array: c.array(ipv4) }\n\nfunction id (host, port, out = b4a.allocUnsafeSlow(32)) {\n  const addr = out.subarray(0, 6)\n  ipv4.encode(\n    { start: 0, end: 6, buffer: addr },\n    { host, port }\n  )\n  sodium.crypto_generichash(out, addr)\n  return out\n}\nconst { Readable } = require('streamx')\nconst b4a = require('b4a')\nconst peer = require('./peer')\nconst { DOWN_HINT } = require('./commands')\n\nconst DONE = []\nconst DOWN = []\n\nmodule.exports = class Query extends Readable {\n  constructor (dht, target, internal, command, value, opts = {}) {\n    super()\n\n    dht.stats.queries.total++\n    dht.stats.queries.active++\n\n    this.dht = dht\n    this.k = this.dht.table.k\n    this.target = target\n    this.internal = internal\n    this.command = command\n    this.value = value\n    this.errors = 0\n    this.successes = 0\n    this.concurrency = opts.concurrency || this.dht.concurrency\n    this.inflight = 0\n    this.map = opts.map || defaultMap\n    this.maxSlow = opts.maxSlow === 0 ? 0 : (opts.maxSlow || 5)\n    this.closestReplies = []\n\n    this._slow = 0\n    this._online = false\n    this._slowdown = false\n    this._seen = new Map()\n    this._pending = []\n    this._fromTable = false\n    this._commit = opts.commit === true ? autoCommit : (opts.commit || null)\n    this._commiting = false\n    this._session = opts.session || dht.session()\n    this._autoDestroySession = !opts.session\n    this._onlyClosestNodes = false\n\n    this._onvisitbound = this._onvisit.bind(this)\n    this._onerrorbound = this._onerror.bind(this)\n    this._oncyclebound = this._oncycle.bind(this)\n\n    const nodes = opts.nodes || opts.closestNodes\n    const replies = opts.replies || opts.closestReplies\n\n    // add them reverse as we pop below\n    if (nodes) {\n      for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i]\n        this._addPending({ id: node.id || peer.id(node.host, node.port), host: node.host, port: node.port }, null)\n      }\n    } else if (replies) {\n      for (let i = replies.length - 1; i >= 0; i--) {\n        this._addPending(replies[i].from, null)\n      }\n    }\n\n    if (opts.onlyClosestNodes) this._onlyClosestNodes = true\n  }\n\n  get closestNodes () {\n    const nodes = new Array(this.closestReplies.length)\n\n    for (let i = 0; i < nodes.length; i++) {\n      nodes[i] = this.closestReplies[i].from\n    }\n\n    return nodes\n  }\n\n  finished () {\n    return new Promise((resolve, reject) => {\n      const self = this\n      let error = null\n\n      this.resume()\n      this.on('error', onerror)\n      this.on('close', onclose)\n\n      function onclose () {\n        self.removeListener('error', onerror)\n        self.removeListener('close', onclose)\n        if (error) reject(error)\n        else resolve()\n      }\n\n      function onerror (err) {\n        error = err\n      }\n    })\n  }\n\n  _addFromTable () {\n    if (this._pending.length >= this.k) return\n    this._fromTable = true\n\n    const closest = this.dht.table.closest(this.target, this.k - this._pending.length)\n\n    for (const node of closest) {\n      this._addPending({ id: node.id, host: node.host, port: node.port }, null)\n    }\n  }\n\n  async _open (cb) {\n    this._addFromTable()\n    if (this._pending.length >= this.k) return cb(null)\n\n    for await (const node of this.dht._resolveBootstrapNodes()) {\n      this._addPending(node, null)\n    }\n\n    cb(null)\n  }\n\n  _isCloser (id) {\n    return this.closestReplies.length < this.k || this._compare(id, this.closestReplies[this.closestReplies.length - 1].from.id) < 0\n  }\n\n  _addPending (node, ref) {\n    if (this._onlyClosestNodes) return false\n\n    const addr = node.host + ':' + node.port\n    const refs = this._seen.get(addr)\n    const isCloser = this._isCloser(node.id)\n\n    if (refs === DONE) {\n      return isCloser\n    }\n\n    if (refs === DOWN) {\n      if (ref) this._downHint(ref, node)\n      return isCloser\n    }\n\n    if (refs) {\n      if (ref !== null) refs.push(ref)\n      return isCloser\n    }\n\n    if (!isCloser) {\n      return false\n    }\n\n    this._seen.set(addr, ref === null ? [] : [ref])\n    this._pending.push(node)\n\n    return true\n  }\n\n  _read (cb) {\n    this._readMore()\n    cb(null)\n  }\n\n  _readMore () {\n    if (this.destroying || this._commiting) return\n\n    const concurrency = (this._slowdown ? 3 : this.concurrency) + this._slow\n\n    while (this.inflight < concurrency && this._pending.length > 0) {\n      const next = this._pending.pop()\n      if (next && next.id && !this._isCloser(next.id)) continue\n      this._visit(next)\n    }\n\n    // if reusing closest nodes, slow down after the first readMore tick to allow\n    // the closest node a chance to reply before going broad to question more\n    if (!this._fromTable && this.successes === 0 && this.errors === 0) {\n      this._slowdown = true\n    }\n\n    if (this._pending.length > 0) return\n\n    // if no inflight OR all the queries we are waiting on are marked as slow (within our limits) and we have a full result.\n    if (this.inflight === 0 || (this._slow <= this.maxSlow && this._slow === this.inflight && this.closestReplies.length >= this.k)) {\n      // if more than 3/4 failed and we only used cached nodes, try again from the routing table\n      if (!this._fromTable && this.successes < this.k / 4) {\n        this._addFromTable()\n        this._readMore()\n        return\n      }\n\n      this._flush()\n    }\n  }\n\n  _flush () {\n    if (this._commiting) return\n    this._commiting = true\n\n    if (this._commit === null) {\n      this.push(null)\n      return\n    }\n\n    const p = []\n    for (const m of this.closestReplies) p.push(this._commit(m, this.dht, this))\n    this._endAfterCommit(p)\n  }\n\n  _endAfterCommit (ps) {\n    if (!ps.length) {\n      this.destroy(new Error('Too few nodes responded'))\n      return\n    }\n\n    const self = this\n\n    let pending = ps.length\n    let success = 0\n\n    for (const p of ps) p.then(ondone, onerror)\n\n    function ondone () {\n      success++\n      if (--pending === 0) self.push(null)\n    }\n\n    function onerror (err) {\n      if (--pending > 0) return\n      if (success) self.push(null)\n      else self.destroy(err)\n    }\n  }\n\n  _dec (req) {\n    if (req.oncycle === noop) {\n      this._slow--\n    } else {\n      req.oncycle = noop\n    }\n    this.inflight--\n  }\n\n  _onvisit (m, req) {\n    this._dec(req)\n\n    this._online = true\n    if (!this.dht.online) this.dht._online()\n\n    const addr = req.to.host + ':' + req.to.port\n    this._seen.set(addr, DONE)\n\n    if (this._commiting) return\n\n    if (m.error === 0) this.successes++\n    else this.errors++\n\n    if (m.error === 0 && m.from.id !== null && this._isCloser(m.from.id)) this._pushClosest(m)\n\n    if (m.closerNodes !== null) {\n      for (const node of m.closerNodes) {\n        node.id = peer.id(node.host, node.port)\n        if (this.dht._filterNode !== null && !this.dht._filterNode(node)) continue\n        if (b4a.equals(node.id, this.dht.table.id)) continue\n        // TODO: we could continue here instead of breaking to ensure that one of the nodes in the closer list\n        // is later marked as DOWN that we gossip that back\n        if (!this._addPending(node, m.from)) break\n      }\n    }\n\n    if (!this._fromTable && this.successes + this.errors >= this.concurrency) {\n      this._slowdown = false\n    }\n\n    if (m.error !== 0) {\n      this._readMore()\n      return\n    }\n\n    const data = this.map(m)\n    if (!data || this.push(data) !== false) {\n      this._readMore()\n    }\n  }\n\n  _onerror (err, req) {\n    const addr = req.to.host + ':' + req.to.port\n    const refs = this._seen.get(addr)\n\n    if (err.code === 'REQUEST_TIMEOUT') {\n      this._seen.set(addr, DOWN)\n      for (const node of refs) this._downHint(node, req.to)\n    }\n\n    this._dec(req)\n    this.errors++\n    this._readMore()\n  }\n\n  _oncycle (req) {\n    req.oncycle = noop\n    this._slow++\n    this._readMore()\n  }\n\n  _downHint (node, down) {\n    const state = { start: 0, end: 6, buffer: b4a.allocUnsafe(6) }\n    peer.ipv4.encode(state, down)\n    this.dht._request(node, true, DOWN_HINT, null, state.buffer, this._session, noop, noop)\n  }\n\n  _pushClosest (m) {\n    this.closestReplies.push(m)\n    for (let i = this.closestReplies.length - 2; i >= 0; i--) {\n      const prev = this.closestReplies[i]\n      const cmp = this._compare(prev.from.id, m.from.id)\n      // if sorted, done!\n      if (cmp < 0) break\n      // if dup, splice it out (rare)\n      if (cmp === 0) {\n        this.closestReplies.splice(i + 1, 1)\n        break\n      }\n      // swap and continue down\n      this.closestReplies[i + 1] = prev\n      this.closestReplies[i] = m\n    }\n    if (this.closestReplies.length > this.k) this.closestReplies.pop()\n  }\n\n  _compare (a, b) {\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] === b[i]) continue\n      const t = this.target[i]\n      return (t ^ a[i]) - (t ^ b[i])\n    }\n    return 0\n  }\n\n  _visit (to) {\n    this.inflight++\n\n    const req = this.dht._request(to, this.internal, this.command, this.target, this.value, this._session, this._onvisitbound, this._onerrorbound)\n    if (req === null) {\n      this.destroy(new Error('Node was destroyed'))\n      return\n    }\n    req.oncycle = this._oncyclebound\n  }\n\n  _destroy (cb) {\n    this.dht.stats.queries.active--\n    if (!this._online && this.dht.online) this.dht._offline()\n    if (this._autoDestroySession) this._session.destroy()\n    cb(null)\n  }\n}\n\nfunction autoCommit (reply, dht, query) {\n  if (!reply.token) return Promise.reject(new Error('No token received for closest node'))\n  return dht.request({ token: reply.token, target: query.target, command: query.command, value: query.value }, reply.from)\n}\n\nfunction defaultMap (m) {\n  return m\n}\n\nfunction noop () {}\nmodule.exports = class Session {\n  constructor (dht) {\n    this.dht = dht\n    this.inflight = []\n  }\n\n  _attach (req) {\n    req.index = this.inflight.push(req) - 1\n  }\n\n  _detach (req) {\n    const i = req.index\n    if (i === -1) return\n    req.index = -1\n\n    if (i === this.inflight.length - 1) this.inflight.pop()\n    else {\n      const req = this.inflight[i] = this.inflight.pop()\n      req.index = i\n    }\n  }\n\n  query ({ target, command, value }, opts = {}) {\n    return this.dht.query({ target, command, value }, { ...opts, session: this })\n  }\n\n  request ({ token, command, target, value }, { host, port }, opts = {}) {\n    return this.dht.request({ token, command, target, value }, { host, port }, { ...opts, session: this })\n  }\n\n  ping ({ host, port }, opts = {}) {\n    return this.dht.ping({ host, port }, { ...opts, session: this })\n  }\n\n  destroy (err) {\n    while (this.inflight.length) {\n      const req = this.inflight[0]\n      // prevent destroyed requests from contributing to congestion counts\n      this.dht.io.congestion.recv()\n      req.destroy(err)\n    }\n  }\n}\n{\n  \"name\": \"dht-rpc\",\n  \"version\": \"6.16.2\",\n  \"description\": \"Make RPC calls over a Kademlia based DHT\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib/*.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.6.1\",\n    \"bare-events\": \"^2.2.0\",\n    \"compact-encoding\": \"^2.11.0\",\n    \"compact-encoding-net\": \"^1.2.0\",\n    \"fast-fifo\": \"^1.1.0\",\n    \"kademlia-routing-table\": \"^1.0.1\",\n    \"nat-sampler\": \"^1.0.1\",\n    \"sodium-universal\": \"^4.0.0\",\n    \"streamx\": \"^2.13.2\",\n    \"time-ordered-set\": \"^2.0.0\",\n    \"udx-native\": \"^1.5.3\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.0\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/dht-rpc.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/dht-rpc/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/dht-rpc\"\n}\nmodule.exports = class FixedFIFO {\n  constructor (hwm) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  clear () {\n    this.top = this.btm = 0\n    this.next = null\n    this.buffer.fill(undefined)\n  }\n\n  push (data) {\n    if (this.buffer[this.top] !== undefined) return false\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n    return true\n  }\n\n  shift () {\n    const last = this.buffer[this.btm]\n    if (last === undefined) return undefined\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  peek () {\n    return this.buffer[this.btm]\n  }\n\n  isEmpty () {\n    return this.buffer[this.btm] === undefined\n  }\n}\nconst FixedFIFO = require('./fixed-size')\n\nmodule.exports = class FastFIFO {\n  constructor (hwm) {\n    this.hwm = hwm || 16\n    this.head = new FixedFIFO(this.hwm)\n    this.tail = this.head\n    this.length = 0\n  }\n\n  clear () {\n    this.head = this.tail\n    this.head.clear()\n    this.length = 0\n  }\n\n  push (val) {\n    this.length++\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift () {\n    if (this.length !== 0) this.length--\n    const val = this.tail.shift()\n    if (val === undefined && this.tail.next) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      return this.tail.shift()\n    }\n\n    return val\n  }\n\n  peek () {\n    const val = this.tail.peek()\n    if (val === undefined && this.tail.next) return this.tail.next.peek()\n    return val\n  }\n\n  isEmpty () {\n    return this.length === 0\n  }\n}\n{\n  \"name\": \"fast-fifo\",\n  \"version\": \"1.3.2\",\n  \"description\": \"A fast fifo implementation similar to the one powering nextTick in Node.js core\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"./index.js\",\n    \"./fixed-size.js\"\n  ],\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^17.1.0\",\n    \"brittle\": \"^3.3.2\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/fast-fifo.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/fast-fifo/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/fast-fifo\"\n}\nexports.fullRoots = function (index, result) {\n  if (index & 1) throw new Error('You can only look up roots for depth(0) blocks')\n  if (!result) result = []\n\n  index /= 2\n\n  let offset = 0\n  let factor = 1\n\n  while (true) {\n    if (!index) return result\n    while (factor * 2 <= index) factor *= 2\n    result.push(offset + factor - 1)\n    offset = offset + 2 * factor\n    index -= factor\n    factor = 1\n  }\n}\n\nexports.futureRoots = function (index, result) {\n  if (index & 1) throw new Error('You can only look up future roots for depth(0) blocks')\n  if (!result) result = []\n\n  let factor = 1\n\n  // make first root\n  while (factor * 2 <= index) factor *= 2\n\n  // full factor of 2 - done\n  if (factor * 2 - 2 === index) return result\n\n  let pos = factor / 2 - 1\n\n  // while its not a full tree\n  while ((pos + factor / 2 - 1) !== index) {\n    pos += factor\n\n    // read too far, to to left child\n    while ((pos + factor / 2 - 1) > index) {\n      factor /= 2\n      pos -= factor / 2\n    }\n\n    // the \"gap\" is a future root\n    result.push(pos - factor / 2)\n  }\n\n  return result\n}\n\nexports.patch = function (from, to) {\n  if (from === 0 || from >= to) return []\n\n  const roots = exports.fullRoots(from)\n  const target = exports.fullRoots(to)\n\n  // first find the first root that is different\n\n  let i = 0\n  for (; i < target.length; i++) {\n    if (i >= roots.length || roots[i] !== target[i]) break\n  }\n\n  const patch = []\n\n  if (i < roots.length) {\n    // now we need to grow the newest root until it hits the diff one\n    let prev = roots.length - 1\n\n    const ite = exports.iterator(roots[prev--])\n\n    while (ite.index !== target[i]) {\n      ite.sibling()\n\n      if (prev >= 0 && ite.index === roots[prev]) {\n        prev--\n      } else {\n        patch.push(ite.index)\n      }\n\n      patch.push(ite.parent())\n    }\n\n    i++ // patched to next root, so inc\n  }\n\n  // include the rest\n\n  for (; i < target.length; i++) patch.push(target[i])\n\n  return patch\n}\n\nexports.depth = function (index) {\n  let depth = 0\n\n  index += 1\n  while (!(index & 1)) {\n    depth++\n    index = rightShift(index)\n  }\n\n  return depth\n}\n\nexports.sibling = function (index, depth) {\n  if (!depth) depth = exports.depth(index)\n  const offset = exports.offset(index, depth)\n\n  return exports.index(depth, offset & 1 ? offset - 1 : offset + 1)\n}\n\nexports.parent = function (index, depth) {\n  if (!depth) depth = exports.depth(index)\n  const offset = exports.offset(index, depth)\n\n  return exports.index(depth + 1, rightShift(offset))\n}\n\nexports.leftChild = function (index, depth) {\n  if (!(index & 1)) return -1\n  if (!depth) depth = exports.depth(index)\n  return exports.index(depth - 1, exports.offset(index, depth) * 2)\n}\n\nexports.rightChild = function (index, depth) {\n  if (!(index & 1)) return -1\n  if (!depth) depth = exports.depth(index)\n  return exports.index(depth - 1, 1 + (exports.offset(index, depth) * 2))\n}\n\nexports.children = function (index, depth) {\n  if (!(index & 1)) return null\n\n  if (!depth) depth = exports.depth(index)\n  const offset = exports.offset(index, depth) * 2\n\n  return [\n    exports.index(depth - 1, offset),\n    exports.index(depth - 1, offset + 1)\n  ]\n}\n\nexports.leftSpan = function (index, depth) {\n  if (!(index & 1)) return index\n  if (!depth) depth = exports.depth(index)\n  return exports.offset(index, depth) * twoPow(depth + 1)\n}\n\nexports.rightSpan = function (index, depth) {\n  if (!(index & 1)) return index\n  if (!depth) depth = exports.depth(index)\n  return (exports.offset(index, depth) + 1) * twoPow(depth + 1) - 2\n}\n\nexports.nextLeaf = function (index) {\n  let factor = 1\n  let r = index\n\n  while ((r & 1) === 1) {\n    r = (r - 1) / 2\n    factor *= 2\n  }\n\n  return index + factor + 1\n}\n\nexports.count = function (index, depth) {\n  if (!(index & 1)) return 1\n  if (!depth) depth = exports.depth(index)\n  return twoPow(depth + 1) - 1\n}\n\nexports.countLeaves = function (index) {\n  return (exports.count(index) + 1) / 2\n}\n\nexports.spans = function (index, depth) {\n  if (!(index & 1)) return [index, index]\n  if (!depth) depth = exports.depth(index)\n\n  const offset = exports.offset(index, depth)\n  const width = twoPow(depth + 1)\n\n  return [offset * width, (offset + 1) * width - 2]\n}\n\nexports.index = function (depth, offset) {\n  return (1 + 2 * offset) * twoPow(depth) - 1\n}\n\nexports.offset = function (index, depth) {\n  if (!(index & 1)) return index / 2\n  if (!depth) depth = exports.depth(index)\n\n  return ((index + 1) / twoPow(depth) - 1) / 2\n}\n\nexports.iterator = function (index) {\n  const ite = new Iterator()\n  ite.seek(index || 0)\n  return ite\n}\n\nfunction twoPow (n) {\n  return n < 31 ? 1 << n : ((1 << 30) * (1 << (n - 30)))\n}\n\nfunction rightShift (n) {\n  return (n - (n & 1)) / 2\n}\n\nfunction Iterator () {\n  this.index = 0\n  this.offset = 0\n  this.factor = 0\n}\n\nIterator.prototype.seek = function (index) {\n  this.index = index\n  if (this.index & 1) {\n    this.offset = exports.offset(index)\n    this.factor = twoPow(exports.depth(index) + 1)\n  } else {\n    this.offset = index / 2\n    this.factor = 2\n  }\n}\n\nIterator.prototype.isLeft = function () {\n  return (this.offset & 1) === 0\n}\n\nIterator.prototype.isRight = function () {\n  return (this.offset & 1) === 1\n}\n\nIterator.prototype.contains = function (index) {\n  return index > this.index\n    ? index < (this.index + this.factor / 2)\n    : index < this.index\n      ? index > (this.index - this.factor / 2)\n      : true\n}\n\nIterator.prototype.prev = function () {\n  if (!this.offset) return this.index\n  this.offset--\n  this.index -= this.factor\n  return this.index\n}\n\nIterator.prototype.next = function () {\n  this.offset++\n  this.index += this.factor\n  return this.index\n}\n\nIterator.prototype.count = function () {\n  if (!(this.index & 1)) return 1\n  return this.factor - 1\n}\n\nIterator.prototype.countLeaves = function () {\n  return (this.count() + 1) / 2\n}\n\nIterator.prototype.sibling = function () {\n  return this.isLeft() ? this.next() : this.prev()\n}\n\nIterator.prototype.parent = function () {\n  if (this.offset & 1) {\n    this.index -= this.factor / 2\n    this.offset = (this.offset - 1) / 2\n  } else {\n    this.index += this.factor / 2\n    this.offset /= 2\n  }\n  this.factor *= 2\n  return this.index\n}\n\nIterator.prototype.leftSpan = function () {\n  this.index = this.index - this.factor / 2 + 1\n  this.offset = this.index / 2\n  this.factor = 2\n  return this.index\n}\n\nIterator.prototype.rightSpan = function () {\n  this.index = this.index + this.factor / 2 - 1\n  this.offset = this.index / 2\n  this.factor = 2\n  return this.index\n}\n\nIterator.prototype.leftChild = function () {\n  if (this.factor === 2) return this.index\n  this.factor /= 2\n  this.index -= this.factor / 2\n  this.offset *= 2\n  return this.index\n}\n\nIterator.prototype.rightChild = function () {\n  if (this.factor === 2) return this.index\n  this.factor /= 2\n  this.index += this.factor / 2\n  this.offset = 2 * this.offset + 1\n  return this.index\n}\n\nIterator.prototype.nextTree = function () {\n  this.index = this.index + this.factor / 2 + 1\n  this.offset = this.index / 2\n  this.factor = 2\n  return this.index\n}\n\nIterator.prototype.prevTree = function () {\n  if (!this.offset) {\n    this.index = 0\n    this.factor = 2\n  } else {\n    this.index = this.index - this.factor / 2 - 1\n    this.offset = this.index / 2\n    this.factor = 2\n  }\n  return this.index\n}\n\nIterator.prototype.fullRoot = function (index) {\n  if (index <= this.index || (this.index & 1) > 0) return false\n  while (index > this.index + this.factor + this.factor / 2) {\n    this.index += this.factor / 2\n    this.factor *= 2\n    this.offset /= 2\n  }\n  return true\n}\n{\n  \"name\": \"flat-tree\",\n  \"version\": \"1.12.1\",\n  \"description\": \"A series of functions to map a binary tree to a list\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/flat-tree.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/flat-tree/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/flat-tree\"\n}\nmodule.exports = require('node-gyp-build')(__dirname)\nconst { isWindows } = require('which-runtime')\nconst binding = require('./binding')\n\nfunction onwork (err) {\n  if (err) this.reject(err)\n  else this.resolve()\n}\n\nexports.tryLock = function tryLock (fd, offset = 0, length = 0, opts = {}) {\n  if (typeof offset === 'object') {\n    opts = offset\n    offset = 0\n  }\n\n  if (typeof length === 'object') {\n    opts = length\n    length = 0\n  }\n\n  if (typeof opts !== 'object') {\n    opts = {}\n  }\n\n  try {\n    binding.fs_ext_napi_try_lock(fd, offset, length, opts.shared ? 0 : 1)\n  } catch (err) {\n    if (err.code === 'EAGAIN') return false\n    throw err\n  }\n\n  return true\n}\n\nexports.waitForLock = function waitForLock (fd, offset = 0, length = 0, opts = {}) {\n  if (typeof offset === 'object') {\n    opts = offset\n    offset = 0\n  }\n\n  if (typeof length === 'object') {\n    opts = length\n    length = 0\n  }\n\n  if (typeof opts !== 'object') {\n    opts = {}\n  }\n\n  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_lock_t)\n  const ctx = {\n    req,\n    resolve: null,\n    reject: null\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    ctx.resolve = resolve\n    ctx.reject = reject\n  })\n\n  try {\n    binding.fs_ext_napi_wait_for_lock(req, fd, offset, length, opts.shared ? 0 : 1, ctx, onwork)\n  } catch (err) {\n    return Promise.reject(err)\n  }\n\n  return promise\n}\n\nexports.tryDowngradeLock = function tryDowngradeLock (fd, offset = 0, length = 0) {\n  try {\n    binding.fs_ext_napi_try_downgrade_lock(fd, offset, length)\n  } catch (err) {\n    if (err.code === 'EAGAIN') return false\n    throw err\n  }\n\n  return true\n}\n\nexports.waitForDowngradeLock = function downgradeLock (fd, offset = 0, length = 0) {\n  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_lock_t)\n  const ctx = {\n    req,\n    resolve: null,\n    reject: null\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    ctx.resolve = resolve\n    ctx.reject = reject\n  })\n\n  try {\n    binding.fs_ext_napi_wait_for_downgrade_lock(req, fd, offset, length, ctx, onwork)\n  } catch (err) {\n    return Promise.reject(err)\n  }\n\n  return promise\n}\n\nexports.tryUpgradeLock = function tryUpgradeLock (fd, offset = 0, length = 0) {\n  try {\n    binding.fs_ext_napi_try_upgrade_lock(fd, offset, length)\n  } catch (err) {\n    if (err.code === 'EAGAIN') return false\n    throw err\n  }\n\n  return true\n}\n\nexports.waitForUpgradeLock = function upgradeLock (fd, offset = 0, length = 0) {\n  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_lock_t)\n  const ctx = {\n    req,\n    resolve: null,\n    reject: null\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    ctx.resolve = resolve\n    ctx.reject = reject\n  })\n\n  try {\n    binding.fs_ext_napi_wait_for_upgrade_lock(req, fd, offset, length, ctx, onwork)\n  } catch (err) {\n    return Promise.reject(err)\n  }\n\n  return promise\n}\n\nexports.unlock = function unlock (fd, offset = 0, length = 0) {\n  binding.fs_ext_napi_unlock(fd, offset, length)\n}\n\nexports.trim = function trim (fd, offset, length) {\n  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_trim_t)\n  const ctx = {\n    req,\n    resolve: null,\n    reject: null\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    ctx.resolve = resolve\n    ctx.reject = reject\n  })\n\n  try {\n    binding.fs_ext_napi_trim(req, fd, offset, length, ctx, onwork)\n  } catch (err) {\n    return Promise.reject(err)\n  }\n\n  return promise\n}\n\nexports.sparse = function sparse (fd) {\n  // Short circuit on everything but Windows\n  if (!isWindows) return Promise.resolve()\n\n  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_sparse_t)\n  const ctx = {\n    req,\n    resolve: null,\n    reject: null\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    ctx.resolve = resolve\n    ctx.reject = reject\n  })\n\n  try {\n    binding.fs_ext_napi_sparse(req, fd, ctx, onwork)\n  } catch (err) {\n    return Promise.reject(err)\n  }\n\n  return promise\n}\n\nexports.swap = function swap (from, to) {\n  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_swap_t)\n  const ctx = {\n    req,\n    resolve: null,\n    reject: null\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    ctx.resolve = resolve\n    ctx.reject = reject\n  })\n\n  try {\n    binding.fs_ext_napi_swap(req, from, to, ctx, onwork)\n  } catch (err) {\n    return Promise.reject(err)\n  }\n\n  return promise\n}\n{\n  \"name\": \"fs-native-extensions\",\n  \"version\": \"1.3.3\",\n  \"description\": \"Native file system extensions for advanced file operations\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"macros.h\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"include\",\n    \"src\",\n    \"prebuilds\"\n  ],\n  \"imports\": {\n    \"child_process\": {\n      \"bare\": \"bare-subprocess\",\n      \"default\": \"child_process\"\n    },\n    \"fs\": {\n      \"bare\": \"bare-fs\",\n      \"default\": \"fs\"\n    },\n    \"fs/*\": {\n      \"bare\": \"bare-fs/*\",\n      \"default\": \"fs/*\"\n    },\n    \"path\": {\n      \"bare\": \"bare-path\",\n      \"default\": \"path\"\n    }\n  },\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"npm run lint && npm run test:bare && npm run test:node\",\n    \"test:bare\": \"bare test/all.mjs\",\n    \"test:node\": \"node test/all.mjs\",\n    \"lint\": \"standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/fs-native-extensions.git\"\n  },\n  \"author\": \"Kasper Isager Dalsgar <kasper@funktionel.co>\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/fs-native-extensions/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/fs-native-extensions#readme\",\n  \"dependencies\": {\n    \"node-gyp-build\": \"^4.8.2\",\n    \"which-runtime\": \"^1.2.0\"\n  },\n  \"devDependencies\": {\n    \"bare-fs\": \"^3.0.2\",\n    \"bare-path\": \"^3.0.0\",\n    \"bare-subprocess\": \"^4.0.1\",\n    \"brittle\": \"^3.1.1\",\n    \"cmake-bare\": \"^1.1.10\",\n    \"cmake-napi\": \"^1.0.5\",\n    \"minimist\": \"^1.2.6\",\n    \"standard\": \"^17.0.0\",\n    \"test-tmp\": \"^1.2.1\"\n  }\n}\nconst m = {\n  ez: { type: 'application/andrew-inset', charset: null },\n  aw: { type: 'application/applixware', charset: null },\n  atom: { type: 'application/atom+xml', charset: null },\n  atomcat: { type: 'application/atomcat+xml', charset: null },\n  atomdeleted: { type: 'application/atomdeleted+xml', charset: null },\n  atomsvc: { type: 'application/atomsvc+xml', charset: null },\n  dwd: { type: 'application/atsc-dwd+xml', charset: null },\n  held: { type: 'application/atsc-held+xml', charset: null },\n  rsat: { type: 'application/atsc-rsat+xml', charset: null },\n  bdoc: { type: 'application/bdoc', charset: null },\n  xcs: { type: 'application/calendar+xml', charset: null },\n  ccxml: { type: 'application/ccxml+xml', charset: null },\n  cdfx: { type: 'application/cdfx+xml', charset: null },\n  cdmia: { type: 'application/cdmi-capability', charset: null },\n  cdmic: { type: 'application/cdmi-container', charset: null },\n  cdmid: { type: 'application/cdmi-domain', charset: null },\n  cdmio: { type: 'application/cdmi-object', charset: null },\n  cdmiq: { type: 'application/cdmi-queue', charset: null },\n  cpl: { type: 'application/cpl+xml', charset: null },\n  cu: { type: 'application/cu-seeme', charset: null },\n  mpd: { type: 'application/dash+xml', charset: null },\n  mpp: { type: 'application/dash-patch+xml', charset: null },\n  davmount: { type: 'application/davmount+xml', charset: null },\n  dbk: { type: 'application/docbook+xml', charset: null },\n  dssc: { type: 'application/dssc+der', charset: null },\n  xdssc: { type: 'application/dssc+xml', charset: null },\n  es: { type: 'application/ecmascript', charset: null },\n  ecma: null,\n  emma: { type: 'application/emma+xml', charset: null },\n  emotionml: { type: 'application/emotionml+xml', charset: null },\n  epub: { type: 'application/epub+zip', charset: null },\n  exi: { type: 'application/exi', charset: null },\n  exp: { type: 'application/express', charset: null },\n  fdt: { type: 'application/fdt+xml', charset: null },\n  pfr: { type: 'application/font-tdpfr', charset: null },\n  geojson: { type: 'application/geo+json', charset: null },\n  gml: { type: 'application/gml+xml', charset: null },\n  gpx: { type: 'application/gpx+xml', charset: null },\n  gxf: { type: 'application/gxf', charset: null },\n  gz: { type: 'application/gzip', charset: null },\n  hjson: { type: 'application/hjson', charset: null },\n  stk: { type: 'application/hyperstudio', charset: null },\n  ink: { type: 'application/inkml+xml', charset: null },\n  inkml: null,\n  ipfix: { type: 'application/ipfix', charset: null },\n  its: { type: 'application/its+xml', charset: null },\n  jar: { type: 'application/java-archive', charset: null },\n  war: null,\n  ear: null,\n  ser: { type: 'application/java-serialized-object', charset: null },\n  class: { type: 'application/java-vm', charset: null },\n  js: { type: 'application/javascript', charset: 'UTF-8' },\n  mjs: null,\n  json: { type: 'application/json', charset: 'UTF-8' },\n  map: null,\n  json5: { type: 'application/json5', charset: null },\n  jsonml: { type: 'application/jsonml+json', charset: null },\n  jsonld: { type: 'application/ld+json', charset: null },\n  lgr: { type: 'application/lgr+xml', charset: null },\n  lostxml: { type: 'application/lost+xml', charset: null },\n  hqx: { type: 'application/mac-binhex40', charset: null },\n  cpt: { type: 'application/mac-compactpro', charset: null },\n  mads: { type: 'application/mads+xml', charset: null },\n  webmanifest: { type: 'application/manifest+json', charset: 'UTF-8' },\n  mrc: { type: 'application/marc', charset: null },\n  mrcx: { type: 'application/marcxml+xml', charset: null },\n  ma: { type: 'application/mathematica', charset: null },\n  nb: null,\n  mb: null,\n  mathml: { type: 'application/mathml+xml', charset: null },\n  mbox: { type: 'application/mbox', charset: null },\n  mpf: { type: 'application/media-policy-dataset+xml', charset: null },\n  mscml: { type: 'application/mediaservercontrol+xml', charset: null },\n  metalink: { type: 'application/metalink+xml', charset: null },\n  meta4: { type: 'application/metalink4+xml', charset: null },\n  mets: { type: 'application/mets+xml', charset: null },\n  maei: { type: 'application/mmt-aei+xml', charset: null },\n  musd: { type: 'application/mmt-usd+xml', charset: null },\n  mods: { type: 'application/mods+xml', charset: null },\n  m21: { type: 'application/mp21', charset: null },\n  mp21: null,\n  mp4s: { type: 'application/mp4', charset: null },\n  m4p: null,\n  doc: { type: 'application/msword', charset: null },\n  dot: null,\n  mxf: { type: 'application/mxf', charset: null },\n  nq: { type: 'application/n-quads', charset: null },\n  nt: { type: 'application/n-triples', charset: null },\n  cjs: { type: 'application/node', charset: null },\n  bin: { type: 'application/octet-stream', charset: null },\n  dms: null,\n  lrf: null,\n  mar: null,\n  so: null,\n  dist: null,\n  distz: null,\n  pkg: null,\n  bpk: null,\n  dump: null,\n  elc: null,\n  deploy: null,\n  exe: null,\n  dll: null,\n  deb: null,\n  dmg: null,\n  iso: null,\n  img: null,\n  msi: null,\n  msp: null,\n  msm: null,\n  buffer: null,\n  oda: { type: 'application/oda', charset: null },\n  opf: { type: 'application/oebps-package+xml', charset: null },\n  ogx: { type: 'application/ogg', charset: null },\n  omdoc: { type: 'application/omdoc+xml', charset: null },\n  onetoc: { type: 'application/onenote', charset: null },\n  onetoc2: null,\n  onetmp: null,\n  onepkg: null,\n  oxps: { type: 'application/oxps', charset: null },\n  relo: { type: 'application/p2p-overlay+xml', charset: null },\n  xer: { type: 'application/patch-ops-error+xml', charset: null },\n  pdf: { type: 'application/pdf', charset: null },\n  pgp: { type: 'application/pgp-encrypted', charset: null },\n  asc: { type: 'application/pgp-keys', charset: null },\n  sig: null,\n  prf: { type: 'application/pics-rules', charset: null },\n  p10: { type: 'application/pkcs10', charset: null },\n  p7m: { type: 'application/pkcs7-mime', charset: null },\n  p7c: null,\n  p7s: { type: 'application/pkcs7-signature', charset: null },\n  p8: { type: 'application/pkcs8', charset: null },\n  ac: { type: 'application/pkix-attr-cert', charset: null },\n  cer: { type: 'application/pkix-cert', charset: null },\n  crl: { type: 'application/pkix-crl', charset: null },\n  pkipath: { type: 'application/pkix-pkipath', charset: null },\n  pki: { type: 'application/pkixcmp', charset: null },\n  pls: { type: 'application/pls+xml', charset: null },\n  ai: { type: 'application/postscript', charset: null },\n  eps: null,\n  ps: null,\n  provx: { type: 'application/provenance+xml', charset: null },\n  cww: { type: 'application/prs.cww', charset: null },\n  pskcxml: { type: 'application/pskc+xml', charset: null },\n  raml: { type: 'application/raml+yaml', charset: null },\n  rdf: { type: 'application/rdf+xml', charset: null },\n  owl: null,\n  rif: { type: 'application/reginfo+xml', charset: null },\n  rnc: { type: 'application/relax-ng-compact-syntax', charset: null },\n  rl: { type: 'application/resource-lists+xml', charset: null },\n  rld: { type: 'application/resource-lists-diff+xml', charset: null },\n  rs: { type: 'application/rls-services+xml', charset: null },\n  rapd: { type: 'application/route-apd+xml', charset: null },\n  sls: { type: 'application/route-s-tsid+xml', charset: null },\n  rusd: { type: 'application/route-usd+xml', charset: null },\n  gbr: { type: 'application/rpki-ghostbusters', charset: null },\n  mft: { type: 'application/rpki-manifest', charset: null },\n  roa: { type: 'application/rpki-roa', charset: null },\n  rsd: { type: 'application/rsd+xml', charset: null },\n  rss: { type: 'application/rss+xml', charset: null },\n  rtf: { type: 'application/rtf', charset: null },\n  sbml: { type: 'application/sbml+xml', charset: null },\n  scq: { type: 'application/scvp-cv-request', charset: null },\n  scs: { type: 'application/scvp-cv-response', charset: null },\n  spq: { type: 'application/scvp-vp-request', charset: null },\n  spp: { type: 'application/scvp-vp-response', charset: null },\n  sdp: { type: 'application/sdp', charset: null },\n  senmlx: { type: 'application/senml+xml', charset: null },\n  sensmlx: { type: 'application/sensml+xml', charset: null },\n  setpay: { type: 'application/set-payment-initiation', charset: null },\n  setreg: { type: 'application/set-registration-initiation', charset: null },\n  shf: { type: 'application/shf+xml', charset: null },\n  siv: { type: 'application/sieve', charset: null },\n  sieve: null,\n  smi: { type: 'application/smil+xml', charset: null },\n  smil: null,\n  rq: { type: 'application/sparql-query', charset: null },\n  srx: { type: 'application/sparql-results+xml', charset: null },\n  gram: { type: 'application/srgs', charset: null },\n  grxml: { type: 'application/srgs+xml', charset: null },\n  sru: { type: 'application/sru+xml', charset: null },\n  ssdl: { type: 'application/ssdl+xml', charset: null },\n  ssml: { type: 'application/ssml+xml', charset: null },\n  swidtag: { type: 'application/swid+xml', charset: null },\n  tei: { type: 'application/tei+xml', charset: null },\n  teicorpus: null,\n  tfi: { type: 'application/thraud+xml', charset: null },\n  tsd: { type: 'application/timestamped-data', charset: null },\n  toml: { type: 'application/toml', charset: null },\n  trig: { type: 'application/trig', charset: null },\n  ttml: { type: 'application/ttml+xml', charset: null },\n  ubj: { type: 'application/ubjson', charset: null },\n  rsheet: { type: 'application/urc-ressheet+xml', charset: null },\n  td: { type: 'application/urc-targetdesc+xml', charset: null },\n  '1km': { type: 'application/vnd.1000minds.decision-model+xml', charset: null },\n  plb: { type: 'application/vnd.3gpp.pic-bw-large', charset: null },\n  psb: { type: 'application/vnd.3gpp.pic-bw-small', charset: null },\n  pvb: { type: 'application/vnd.3gpp.pic-bw-var', charset: null },\n  tcap: { type: 'application/vnd.3gpp2.tcap', charset: null },\n  pwn: { type: 'application/vnd.3m.post-it-notes', charset: null },\n  aso: { type: 'application/vnd.accpac.simply.aso', charset: null },\n  imp: { type: 'application/vnd.accpac.simply.imp', charset: null },\n  acu: { type: 'application/vnd.acucobol', charset: null },\n  atc: { type: 'application/vnd.acucorp', charset: null },\n  acutc: null,\n  air: { type: 'application/vnd.adobe.air-application-installer-package+zip', charset: null },\n  fcdt: { type: 'application/vnd.adobe.formscentral.fcdt', charset: null },\n  fxp: { type: 'application/vnd.adobe.fxp', charset: null },\n  fxpl: null,\n  xdp: { type: 'application/vnd.adobe.xdp+xml', charset: null },\n  xfdf: { type: 'application/vnd.adobe.xfdf', charset: null },\n  age: { type: 'application/vnd.age', charset: null },\n  ahead: { type: 'application/vnd.ahead.space', charset: null },\n  azf: { type: 'application/vnd.airzip.filesecure.azf', charset: null },\n  azs: { type: 'application/vnd.airzip.filesecure.azs', charset: null },\n  azw: { type: 'application/vnd.amazon.ebook', charset: null },\n  acc: { type: 'application/vnd.americandynamics.acc', charset: null },\n  ami: { type: 'application/vnd.amiga.ami', charset: null },\n  apk: { type: 'application/vnd.android.package-archive', charset: null },\n  cii: { type: 'application/vnd.anser-web-certificate-issue-initiation', charset: null },\n  fti: { type: 'application/vnd.anser-web-funds-transfer-initiation', charset: null },\n  atx: { type: 'application/vnd.antix.game-component', charset: null },\n  mpkg: { type: 'application/vnd.apple.installer+xml', charset: null },\n  key: { type: 'application/vnd.apple.keynote', charset: null },\n  m3u8: { type: 'application/vnd.apple.mpegurl', charset: null },\n  numbers: { type: 'application/vnd.apple.numbers', charset: null },\n  pages: { type: 'application/vnd.apple.pages', charset: null },\n  pkpass: { type: 'application/vnd.apple.pkpass', charset: null },\n  swi: { type: 'application/vnd.aristanetworks.swi', charset: null },\n  iota: { type: 'application/vnd.astraea-software.iota', charset: null },\n  aep: { type: 'application/vnd.audiograph', charset: null },\n  bmml: { type: 'application/vnd.balsamiq.bmml+xml', charset: null },\n  mpm: { type: 'application/vnd.blueice.multipass', charset: null },\n  bmi: { type: 'application/vnd.bmi', charset: null },\n  rep: { type: 'application/vnd.businessobjects', charset: null },\n  cdxml: { type: 'application/vnd.chemdraw+xml', charset: null },\n  mmd: { type: 'application/vnd.chipnuts.karaoke-mmd', charset: null },\n  cdy: { type: 'application/vnd.cinderella', charset: null },\n  csl: { type: 'application/vnd.citationstyles.style+xml', charset: null },\n  cla: { type: 'application/vnd.claymore', charset: null },\n  rp9: { type: 'application/vnd.cloanto.rp9', charset: null },\n  c4g: { type: 'application/vnd.clonk.c4group', charset: null },\n  c4d: null,\n  c4f: null,\n  c4p: null,\n  c4u: null,\n  c11amc: { type: 'application/vnd.cluetrust.cartomobile-config', charset: null },\n  c11amz: { type: 'application/vnd.cluetrust.cartomobile-config-pkg', charset: null },\n  csp: { type: 'application/vnd.commonspace', charset: null },\n  cdbcmsg: { type: 'application/vnd.contact.cmsg', charset: null },\n  cmc: { type: 'application/vnd.cosmocaller', charset: null },\n  clkx: { type: 'application/vnd.crick.clicker', charset: null },\n  clkk: { type: 'application/vnd.crick.clicker.keyboard', charset: null },\n  clkp: { type: 'application/vnd.crick.clicker.palette', charset: null },\n  clkt: { type: 'application/vnd.crick.clicker.template', charset: null },\n  clkw: { type: 'application/vnd.crick.clicker.wordbank', charset: null },\n  wbs: { type: 'application/vnd.criticaltools.wbs+xml', charset: null },\n  pml: { type: 'application/vnd.ctc-posml', charset: null },\n  ppd: { type: 'application/vnd.cups-ppd', charset: null },\n  car: { type: 'application/vnd.curl.car', charset: null },\n  pcurl: { type: 'application/vnd.curl.pcurl', charset: null },\n  dart: { type: 'application/vnd.dart', charset: null },\n  rdz: { type: 'application/vnd.data-vision.rdz', charset: null },\n  dbf: { type: 'application/vnd.dbf', charset: null },\n  uvf: { type: 'application/vnd.dece.data', charset: null },\n  uvvf: null,\n  uvd: null,\n  uvvd: null,\n  uvt: { type: 'application/vnd.dece.ttml+xml', charset: null },\n  uvvt: null,\n  uvx: { type: 'application/vnd.dece.unspecified', charset: null },\n  uvvx: null,\n  uvz: { type: 'application/vnd.dece.zip', charset: null },\n  uvvz: null,\n  fe_launch: { type: 'application/vnd.denovo.fcselayout-link', charset: null },\n  dna: { type: 'application/vnd.dna', charset: null },\n  mlp: { type: 'application/vnd.dolby.mlp', charset: null },\n  dpg: { type: 'application/vnd.dpgraph', charset: null },\n  dfac: { type: 'application/vnd.dreamfactory', charset: null },\n  kpxx: { type: 'application/vnd.ds-keypoint', charset: null },\n  ait: { type: 'application/vnd.dvb.ait', charset: null },\n  svc: { type: 'application/vnd.dvb.service', charset: null },\n  geo: { type: 'application/vnd.dynageo', charset: null },\n  mag: { type: 'application/vnd.ecowin.chart', charset: null },\n  nml: { type: 'application/vnd.enliven', charset: null },\n  esf: { type: 'application/vnd.epson.esf', charset: null },\n  msf: { type: 'application/vnd.epson.msf', charset: null },\n  qam: { type: 'application/vnd.epson.quickanime', charset: null },\n  slt: { type: 'application/vnd.epson.salt', charset: null },\n  ssf: { type: 'application/vnd.epson.ssf', charset: null },\n  es3: { type: 'application/vnd.eszigno3+xml', charset: null },\n  et3: null,\n  ez2: { type: 'application/vnd.ezpix-album', charset: null },\n  ez3: { type: 'application/vnd.ezpix-package', charset: null },\n  fdf: { type: 'application/vnd.fdf', charset: null },\n  mseed: { type: 'application/vnd.fdsn.mseed', charset: null },\n  seed: { type: 'application/vnd.fdsn.seed', charset: null },\n  dataless: null,\n  gph: { type: 'application/vnd.flographit', charset: null },\n  ftc: { type: 'application/vnd.fluxtime.clip', charset: null },\n  fm: { type: 'application/vnd.framemaker', charset: null },\n  frame: null,\n  maker: null,\n  book: null,\n  fnc: { type: 'application/vnd.frogans.fnc', charset: null },\n  ltf: { type: 'application/vnd.frogans.ltf', charset: null },\n  fsc: { type: 'application/vnd.fsc.weblaunch', charset: null },\n  oas: { type: 'application/vnd.fujitsu.oasys', charset: null },\n  oa2: { type: 'application/vnd.fujitsu.oasys2', charset: null },\n  oa3: { type: 'application/vnd.fujitsu.oasys3', charset: null },\n  fg5: { type: 'application/vnd.fujitsu.oasysgp', charset: null },\n  bh2: { type: 'application/vnd.fujitsu.oasysprs', charset: null },\n  ddd: { type: 'application/vnd.fujixerox.ddd', charset: null },\n  xdw: { type: 'application/vnd.fujixerox.docuworks', charset: null },\n  xbd: { type: 'application/vnd.fujixerox.docuworks.binder', charset: null },\n  fzs: { type: 'application/vnd.fuzzysheet', charset: null },\n  txd: { type: 'application/vnd.genomatix.tuxedo', charset: null },\n  ggb: { type: 'application/vnd.geogebra.file', charset: null },\n  ggt: { type: 'application/vnd.geogebra.tool', charset: null },\n  gex: { type: 'application/vnd.geometry-explorer', charset: null },\n  gre: null,\n  gxt: { type: 'application/vnd.geonext', charset: null },\n  g2w: { type: 'application/vnd.geoplan', charset: null },\n  g3w: { type: 'application/vnd.geospace', charset: null },\n  gmx: { type: 'application/vnd.gmx', charset: null },\n  gdoc: { type: 'application/vnd.google-apps.document', charset: null },\n  gslides: { type: 'application/vnd.google-apps.presentation', charset: null },\n  gsheet: { type: 'application/vnd.google-apps.spreadsheet', charset: null },\n  kml: { type: 'application/vnd.google-earth.kml+xml', charset: null },\n  kmz: { type: 'application/vnd.google-earth.kmz', charset: null },\n  gqf: { type: 'application/vnd.grafeq', charset: null },\n  gqs: null,\n  gac: { type: 'application/vnd.groove-account', charset: null },\n  ghf: { type: 'application/vnd.groove-help', charset: null },\n  gim: { type: 'application/vnd.groove-identity-message', charset: null },\n  grv: { type: 'application/vnd.groove-injector', charset: null },\n  gtm: { type: 'application/vnd.groove-tool-message', charset: null },\n  tpl: { type: 'application/vnd.groove-tool-template', charset: null },\n  vcg: { type: 'application/vnd.groove-vcard', charset: null },\n  hal: { type: 'application/vnd.hal+xml', charset: null },\n  zmm: { type: 'application/vnd.handheld-entertainment+xml', charset: null },\n  hbci: { type: 'application/vnd.hbci', charset: null },\n  les: { type: 'application/vnd.hhe.lesson-player', charset: null },\n  hpgl: { type: 'application/vnd.hp-hpgl', charset: null },\n  hpid: { type: 'application/vnd.hp-hpid', charset: null },\n  hps: { type: 'application/vnd.hp-hps', charset: null },\n  jlt: { type: 'application/vnd.hp-jlyt', charset: null },\n  pcl: { type: 'application/vnd.hp-pcl', charset: null },\n  pclxl: { type: 'application/vnd.hp-pclxl', charset: null },\n  'sfd-hdstx': { type: 'application/vnd.hydrostatix.sof-data', charset: null },\n  mpy: { type: 'application/vnd.ibm.minipay', charset: null },\n  afp: { type: 'application/vnd.ibm.modcap', charset: null },\n  listafp: null,\n  list3820: null,\n  irm: { type: 'application/vnd.ibm.rights-management', charset: null },\n  sc: { type: 'application/vnd.ibm.secure-container', charset: null },\n  icc: { type: 'application/vnd.iccprofile', charset: null },\n  icm: null,\n  igl: { type: 'application/vnd.igloader', charset: null },\n  ivp: { type: 'application/vnd.immervision-ivp', charset: null },\n  ivu: { type: 'application/vnd.immervision-ivu', charset: null },\n  igm: { type: 'application/vnd.insors.igm', charset: null },\n  xpw: { type: 'application/vnd.intercon.formnet', charset: null },\n  xpx: null,\n  i2g: { type: 'application/vnd.intergeo', charset: null },\n  qbo: { type: 'application/vnd.intu.qbo', charset: null },\n  qfx: { type: 'application/vnd.intu.qfx', charset: null },\n  rcprofile: { type: 'application/vnd.ipunplugged.rcprofile', charset: null },\n  irp: { type: 'application/vnd.irepository.package+xml', charset: null },\n  xpr: { type: 'application/vnd.is-xpr', charset: null },\n  fcs: { type: 'application/vnd.isac.fcs', charset: null },\n  jam: { type: 'application/vnd.jam', charset: null },\n  rms: { type: 'application/vnd.jcp.javame.midlet-rms', charset: null },\n  jisp: { type: 'application/vnd.jisp', charset: null },\n  joda: { type: 'application/vnd.joost.joda-archive', charset: null },\n  ktz: { type: 'application/vnd.kahootz', charset: null },\n  ktr: null,\n  karbon: { type: 'application/vnd.kde.karbon', charset: null },\n  chrt: { type: 'application/vnd.kde.kchart', charset: null },\n  kfo: { type: 'application/vnd.kde.kformula', charset: null },\n  flw: { type: 'application/vnd.kde.kivio', charset: null },\n  kon: { type: 'application/vnd.kde.kontour', charset: null },\n  kpr: { type: 'application/vnd.kde.kpresenter', charset: null },\n  kpt: null,\n  ksp: { type: 'application/vnd.kde.kspread', charset: null },\n  kwd: { type: 'application/vnd.kde.kword', charset: null },\n  kwt: null,\n  htke: { type: 'application/vnd.kenameaapp', charset: null },\n  kia: { type: 'application/vnd.kidspiration', charset: null },\n  kne: { type: 'application/vnd.kinar', charset: null },\n  knp: null,\n  skp: { type: 'application/vnd.koan', charset: null },\n  skd: null,\n  skt: null,\n  skm: null,\n  sse: { type: 'application/vnd.kodak-descriptor', charset: null },\n  lasxml: { type: 'application/vnd.las.las+xml', charset: null },\n  lbd: { type: 'application/vnd.llamagraphics.life-balance.desktop', charset: null },\n  lbe: { type: 'application/vnd.llamagraphics.life-balance.exchange+xml', charset: null },\n  123: { type: 'application/vnd.lotus-1-2-3', charset: null },\n  apr: { type: 'application/vnd.lotus-approach', charset: null },\n  pre: { type: 'application/vnd.lotus-freelance', charset: null },\n  nsf: { type: 'application/vnd.lotus-notes', charset: null },\n  org: { type: 'application/vnd.lotus-organizer', charset: null },\n  scm: { type: 'application/vnd.lotus-screencam', charset: null },\n  lwp: { type: 'application/vnd.lotus-wordpro', charset: null },\n  portpkg: { type: 'application/vnd.macports.portpkg', charset: null },\n  mvt: { type: 'application/vnd.mapbox-vector-tile', charset: null },\n  mcd: { type: 'application/vnd.mcd', charset: null },\n  mc1: { type: 'application/vnd.medcalcdata', charset: null },\n  cdkey: { type: 'application/vnd.mediastation.cdkey', charset: null },\n  mwf: { type: 'application/vnd.mfer', charset: null },\n  mfm: { type: 'application/vnd.mfmp', charset: null },\n  flo: { type: 'application/vnd.micrografx.flo', charset: null },\n  igx: { type: 'application/vnd.micrografx.igx', charset: null },\n  mif: { type: 'application/vnd.mif', charset: null },\n  daf: { type: 'application/vnd.mobius.daf', charset: null },\n  dis: { type: 'application/vnd.mobius.dis', charset: null },\n  mbk: { type: 'application/vnd.mobius.mbk', charset: null },\n  mqy: { type: 'application/vnd.mobius.mqy', charset: null },\n  msl: { type: 'application/vnd.mobius.msl', charset: null },\n  plc: { type: 'application/vnd.mobius.plc', charset: null },\n  txf: { type: 'application/vnd.mobius.txf', charset: null },\n  mpn: { type: 'application/vnd.mophun.application', charset: null },\n  mpc: { type: 'application/vnd.mophun.certificate', charset: null },\n  xul: { type: 'application/vnd.mozilla.xul+xml', charset: null },\n  cil: { type: 'application/vnd.ms-artgalry', charset: null },\n  cab: { type: 'application/vnd.ms-cab-compressed', charset: null },\n  xls: { type: 'application/vnd.ms-excel', charset: null },\n  xlm: null,\n  xla: null,\n  xlc: null,\n  xlt: null,\n  xlw: null,\n  xlam: { type: 'application/vnd.ms-excel.addin.macroenabled.12', charset: null },\n  xlsb: { type: 'application/vnd.ms-excel.sheet.binary.macroenabled.12', charset: null },\n  xlsm: { type: 'application/vnd.ms-excel.sheet.macroenabled.12', charset: null },\n  xltm: { type: 'application/vnd.ms-excel.template.macroenabled.12', charset: null },\n  eot: { type: 'application/vnd.ms-fontobject', charset: null },\n  chm: { type: 'application/vnd.ms-htmlhelp', charset: null },\n  ims: { type: 'application/vnd.ms-ims', charset: null },\n  lrm: { type: 'application/vnd.ms-lrm', charset: null },\n  thmx: { type: 'application/vnd.ms-officetheme', charset: null },\n  msg: { type: 'application/vnd.ms-outlook', charset: null },\n  cat: { type: 'application/vnd.ms-pki.seccat', charset: null },\n  stl: { type: 'application/vnd.ms-pki.stl', charset: null },\n  ppt: { type: 'application/vnd.ms-powerpoint', charset: null },\n  pps: null,\n  pot: null,\n  ppam: { type: 'application/vnd.ms-powerpoint.addin.macroenabled.12', charset: null },\n  pptm: { type: 'application/vnd.ms-powerpoint.presentation.macroenabled.12', charset: null },\n  sldm: { type: 'application/vnd.ms-powerpoint.slide.macroenabled.12', charset: null },\n  ppsm: { type: 'application/vnd.ms-powerpoint.slideshow.macroenabled.12', charset: null },\n  potm: { type: 'application/vnd.ms-powerpoint.template.macroenabled.12', charset: null },\n  mpt: null,\n  docm: { type: 'application/vnd.ms-word.document.macroenabled.12', charset: null },\n  dotm: { type: 'application/vnd.ms-word.template.macroenabled.12', charset: null },\n  wps: { type: 'application/vnd.ms-works', charset: null },\n  wks: null,\n  wcm: null,\n  wdb: null,\n  wpl: { type: 'application/vnd.ms-wpl', charset: null },\n  xps: { type: 'application/vnd.ms-xpsdocument', charset: null },\n  mseq: { type: 'application/vnd.mseq', charset: null },\n  mus: { type: 'application/vnd.musician', charset: null },\n  msty: { type: 'application/vnd.muvee.style', charset: null },\n  taglet: { type: 'application/vnd.mynfc', charset: null },\n  nlu: { type: 'application/vnd.neurolanguage.nlu', charset: null },\n  ntf: { type: 'application/vnd.nitf', charset: null },\n  nitf: null,\n  nnd: { type: 'application/vnd.noblenet-directory', charset: null },\n  nns: { type: 'application/vnd.noblenet-sealer', charset: null },\n  nnw: { type: 'application/vnd.noblenet-web', charset: null },\n  ngdat: { type: 'application/vnd.nokia.n-gage.data', charset: null },\n  'n-gage': { type: 'application/vnd.nokia.n-gage.symbian.install', charset: null },\n  rpst: { type: 'application/vnd.nokia.radio-preset', charset: null },\n  rpss: { type: 'application/vnd.nokia.radio-presets', charset: null },\n  edm: { type: 'application/vnd.novadigm.edm', charset: null },\n  edx: { type: 'application/vnd.novadigm.edx', charset: null },\n  ext: { type: 'application/vnd.novadigm.ext', charset: null },\n  odc: { type: 'application/vnd.oasis.opendocument.chart', charset: null },\n  otc: { type: 'application/vnd.oasis.opendocument.chart-template', charset: null },\n  odb: { type: 'application/vnd.oasis.opendocument.database', charset: null },\n  odf: { type: 'application/vnd.oasis.opendocument.formula', charset: null },\n  odft: { type: 'application/vnd.oasis.opendocument.formula-template', charset: null },\n  odg: { type: 'application/vnd.oasis.opendocument.graphics', charset: null },\n  otg: { type: 'application/vnd.oasis.opendocument.graphics-template', charset: null },\n  odi: { type: 'application/vnd.oasis.opendocument.image', charset: null },\n  oti: { type: 'application/vnd.oasis.opendocument.image-template', charset: null },\n  odp: { type: 'application/vnd.oasis.opendocument.presentation', charset: null },\n  otp: { type: 'application/vnd.oasis.opendocument.presentation-template', charset: null },\n  ods: { type: 'application/vnd.oasis.opendocument.spreadsheet', charset: null },\n  ots: { type: 'application/vnd.oasis.opendocument.spreadsheet-template', charset: null },\n  odt: { type: 'application/vnd.oasis.opendocument.text', charset: null },\n  odm: { type: 'application/vnd.oasis.opendocument.text-master', charset: null },\n  ott: { type: 'application/vnd.oasis.opendocument.text-template', charset: null },\n  oth: { type: 'application/vnd.oasis.opendocument.text-web', charset: null },\n  xo: { type: 'application/vnd.olpc-sugar', charset: null },\n  dd2: { type: 'application/vnd.oma.dd2+xml', charset: null },\n  obgx: { type: 'application/vnd.openblox.game+xml', charset: null },\n  oxt: { type: 'application/vnd.openofficeorg.extension', charset: null },\n  osm: { type: 'application/vnd.openstreetmap.data+xml', charset: null },\n  pptx: { type: 'application/vnd.openxmlformats-officedocument.presentationml.presentation', charset: null },\n  sldx: { type: 'application/vnd.openxmlformats-officedocument.presentationml.slide', charset: null },\n  ppsx: { type: 'application/vnd.openxmlformats-officedocument.presentationml.slideshow', charset: null },\n  potx: { type: 'application/vnd.openxmlformats-officedocument.presentationml.template', charset: null },\n  xlsx: { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', charset: null },\n  xltx: { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template', charset: null },\n  docx: { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', charset: null },\n  dotx: { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template', charset: null },\n  mgp: { type: 'application/vnd.osgeo.mapguide.package', charset: null },\n  dp: { type: 'application/vnd.osgi.dp', charset: null },\n  esa: { type: 'application/vnd.osgi.subsystem', charset: null },\n  pdb: { type: 'application/vnd.palm', charset: null },\n  pqa: null,\n  oprc: null,\n  paw: { type: 'application/vnd.pawaafile', charset: null },\n  str: { type: 'application/vnd.pg.format', charset: null },\n  ei6: { type: 'application/vnd.pg.osasli', charset: null },\n  efif: { type: 'application/vnd.picsel', charset: null },\n  wg: { type: 'application/vnd.pmi.widget', charset: null },\n  plf: { type: 'application/vnd.pocketlearn', charset: null },\n  pbd: { type: 'application/vnd.powerbuilder6', charset: null },\n  box: { type: 'application/vnd.previewsystems.box', charset: null },\n  mgz: { type: 'application/vnd.proteus.magazine', charset: null },\n  qps: { type: 'application/vnd.publishare-delta-tree', charset: null },\n  ptid: { type: 'application/vnd.pvi.ptid1', charset: null },\n  qxd: { type: 'application/vnd.quark.quarkxpress', charset: null },\n  qxt: null,\n  qwd: null,\n  qwt: null,\n  qxl: null,\n  qxb: null,\n  rar: { type: 'application/vnd.rar', charset: null },\n  bed: { type: 'application/vnd.realvnc.bed', charset: null },\n  mxl: { type: 'application/vnd.recordare.musicxml', charset: null },\n  musicxml: { type: 'application/vnd.recordare.musicxml+xml', charset: null },\n  cryptonote: { type: 'application/vnd.rig.cryptonote', charset: null },\n  cod: { type: 'application/vnd.rim.cod', charset: null },\n  rm: { type: 'application/vnd.rn-realmedia', charset: null },\n  rmvb: { type: 'application/vnd.rn-realmedia-vbr', charset: null },\n  link66: { type: 'application/vnd.route66.link66+xml', charset: null },\n  st: { type: 'application/vnd.sailingtracker.track', charset: null },\n  see: { type: 'application/vnd.seemail', charset: null },\n  sema: { type: 'application/vnd.sema', charset: null },\n  semd: { type: 'application/vnd.semd', charset: null },\n  semf: { type: 'application/vnd.semf', charset: null },\n  ifm: { type: 'application/vnd.shana.informed.formdata', charset: null },\n  itp: { type: 'application/vnd.shana.informed.formtemplate', charset: null },\n  iif: { type: 'application/vnd.shana.informed.interchange', charset: null },\n  ipk: { type: 'application/vnd.shana.informed.package', charset: null },\n  twd: { type: 'application/vnd.simtech-mindmapper', charset: null },\n  twds: null,\n  mmf: { type: 'application/vnd.smaf', charset: null },\n  teacher: { type: 'application/vnd.smart.teacher', charset: null },\n  fo: { type: 'application/vnd.software602.filler.form+xml', charset: null },\n  sdkm: { type: 'application/vnd.solent.sdkm+xml', charset: null },\n  sdkd: null,\n  dxp: { type: 'application/vnd.spotfire.dxp', charset: null },\n  sfs: { type: 'application/vnd.spotfire.sfs', charset: null },\n  sdc: { type: 'application/vnd.stardivision.calc', charset: null },\n  sda: { type: 'application/vnd.stardivision.draw', charset: null },\n  sdd: { type: 'application/vnd.stardivision.impress', charset: null },\n  smf: { type: 'application/vnd.stardivision.math', charset: null },\n  sdw: { type: 'application/vnd.stardivision.writer', charset: null },\n  vor: null,\n  sgl: { type: 'application/vnd.stardivision.writer-global', charset: null },\n  smzip: { type: 'application/vnd.stepmania.package', charset: null },\n  sm: { type: 'application/vnd.stepmania.stepchart', charset: null },\n  wadl: { type: 'application/vnd.sun.wadl+xml', charset: null },\n  sxc: { type: 'application/vnd.sun.xml.calc', charset: null },\n  stc: { type: 'application/vnd.sun.xml.calc.template', charset: null },\n  sxd: { type: 'application/vnd.sun.xml.draw', charset: null },\n  std: { type: 'application/vnd.sun.xml.draw.template', charset: null },\n  sxi: { type: 'application/vnd.sun.xml.impress', charset: null },\n  sti: { type: 'application/vnd.sun.xml.impress.template', charset: null },\n  sxm: { type: 'application/vnd.sun.xml.math', charset: null },\n  sxw: { type: 'application/vnd.sun.xml.writer', charset: null },\n  sxg: { type: 'application/vnd.sun.xml.writer.global', charset: null },\n  stw: { type: 'application/vnd.sun.xml.writer.template', charset: null },\n  sus: { type: 'application/vnd.sus-calendar', charset: null },\n  susp: null,\n  svd: { type: 'application/vnd.svd', charset: null },\n  sis: { type: 'application/vnd.symbian.install', charset: null },\n  sisx: null,\n  xsm: { type: 'application/vnd.syncml+xml', charset: 'UTF-8' },\n  bdm: { type: 'application/vnd.syncml.dm+wbxml', charset: 'UTF-8' },\n  xdm: { type: 'application/vnd.syncml.dm+xml', charset: 'UTF-8' },\n  ddf: { type: 'application/vnd.syncml.dmddf+xml', charset: 'UTF-8' },\n  tao: { type: 'application/vnd.tao.intent-module-archive', charset: null },\n  pcap: { type: 'application/vnd.tcpdump.pcap', charset: null },\n  cap: null,\n  dmp: null,\n  tmo: { type: 'application/vnd.tmobile-livetv', charset: null },\n  tpt: { type: 'application/vnd.trid.tpt', charset: null },\n  mxs: { type: 'application/vnd.triscape.mxs', charset: null },\n  tra: { type: 'application/vnd.trueapp', charset: null },\n  ufd: { type: 'application/vnd.ufdl', charset: null },\n  ufdl: null,\n  utz: { type: 'application/vnd.uiq.theme', charset: null },\n  umj: { type: 'application/vnd.umajin', charset: null },\n  unityweb: { type: 'application/vnd.unity', charset: null },\n  uoml: { type: 'application/vnd.uoml+xml', charset: null },\n  vcx: { type: 'application/vnd.vcx', charset: null },\n  vsd: { type: 'application/vnd.visio', charset: null },\n  vst: null,\n  vss: null,\n  vsw: null,\n  vis: { type: 'application/vnd.visionary', charset: null },\n  vsf: { type: 'application/vnd.vsf', charset: null },\n  wbxml: { type: 'application/vnd.wap.wbxml', charset: 'UTF-8' },\n  wmlc: { type: 'application/vnd.wap.wmlc', charset: null },\n  wmlsc: { type: 'application/vnd.wap.wmlscriptc', charset: null },\n  wtb: { type: 'application/vnd.webturbo', charset: null },\n  nbp: { type: 'application/vnd.wolfram.player', charset: null },\n  wpd: { type: 'application/vnd.wordperfect', charset: null },\n  wqd: { type: 'application/vnd.wqd', charset: null },\n  stf: { type: 'application/vnd.wt.stf', charset: null },\n  xar: { type: 'application/vnd.xara', charset: null },\n  xfdl: { type: 'application/vnd.xfdl', charset: null },\n  hvd: { type: 'application/vnd.yamaha.hv-dic', charset: null },\n  hvs: { type: 'application/vnd.yamaha.hv-script', charset: null },\n  hvp: { type: 'application/vnd.yamaha.hv-voice', charset: null },\n  osf: { type: 'application/vnd.yamaha.openscoreformat', charset: null },\n  osfpvg: { type: 'application/vnd.yamaha.openscoreformat.osfpvg+xml', charset: null },\n  saf: { type: 'application/vnd.yamaha.smaf-audio', charset: null },\n  spf: { type: 'application/vnd.yamaha.smaf-phrase', charset: null },\n  cmp: { type: 'application/vnd.yellowriver-custom-menu', charset: null },\n  zir: { type: 'application/vnd.zul', charset: null },\n  zirz: null,\n  zaz: { type: 'application/vnd.zzazz.deck+xml', charset: null },\n  vxml: { type: 'application/voicexml+xml', charset: null },\n  wasm: { type: 'application/wasm', charset: null },\n  wif: { type: 'application/watcherinfo+xml', charset: null },\n  wgt: { type: 'application/widget', charset: null },\n  hlp: { type: 'application/winhlp', charset: null },\n  wsdl: { type: 'application/wsdl+xml', charset: null },\n  wspolicy: { type: 'application/wspolicy+xml', charset: null },\n  '7z': { type: 'application/x-7z-compressed', charset: null },\n  abw: { type: 'application/x-abiword', charset: null },\n  ace: { type: 'application/x-ace-compressed', charset: null },\n  arj: { type: 'application/x-arj', charset: null },\n  aab: { type: 'application/x-authorware-bin', charset: null },\n  x32: null,\n  u32: null,\n  vox: null,\n  aam: { type: 'application/x-authorware-map', charset: null },\n  aas: { type: 'application/x-authorware-seg', charset: null },\n  bcpio: { type: 'application/x-bcpio', charset: null },\n  torrent: { type: 'application/x-bittorrent', charset: null },\n  blb: { type: 'application/x-blorb', charset: null },\n  blorb: null,\n  bz: { type: 'application/x-bzip', charset: null },\n  bz2: { type: 'application/x-bzip2', charset: null },\n  boz: null,\n  cbr: { type: 'application/x-cbr', charset: null },\n  cba: null,\n  cbt: null,\n  cbz: null,\n  cb7: null,\n  vcd: { type: 'application/x-cdlink', charset: null },\n  cfs: { type: 'application/x-cfs-compressed', charset: null },\n  chat: { type: 'application/x-chat', charset: null },\n  pgn: { type: 'application/x-chess-pgn', charset: null },\n  crx: { type: 'application/x-chrome-extension', charset: null },\n  cco: { type: 'application/x-cocoa', charset: null },\n  nsc: { type: 'application/x-conference', charset: null },\n  cpio: { type: 'application/x-cpio', charset: null },\n  csh: { type: 'application/x-csh', charset: null },\n  udeb: null,\n  dgc: { type: 'application/x-dgc-compressed', charset: null },\n  dir: { type: 'application/x-director', charset: null },\n  dcr: null,\n  dxr: null,\n  cst: null,\n  cct: null,\n  cxt: null,\n  w3d: null,\n  fgd: null,\n  swa: null,\n  wad: { type: 'application/x-doom', charset: null },\n  ncx: { type: 'application/x-dtbncx+xml', charset: null },\n  dtb: { type: 'application/x-dtbook+xml', charset: null },\n  res: { type: 'application/x-dtbresource+xml', charset: null },\n  dvi: { type: 'application/x-dvi', charset: null },\n  evy: { type: 'application/x-envoy', charset: null },\n  eva: { type: 'application/x-eva', charset: null },\n  bdf: { type: 'application/x-font-bdf', charset: null },\n  gsf: { type: 'application/x-font-ghostscript', charset: null },\n  psf: { type: 'application/x-font-linux-psf', charset: null },\n  pcf: { type: 'application/x-font-pcf', charset: null },\n  snf: { type: 'application/x-font-snf', charset: null },\n  pfa: { type: 'application/x-font-type1', charset: null },\n  pfb: null,\n  pfm: null,\n  afm: null,\n  arc: { type: 'application/x-freearc', charset: null },\n  spl: { type: 'application/x-futuresplash', charset: null },\n  gca: { type: 'application/x-gca-compressed', charset: null },\n  ulx: { type: 'application/x-glulx', charset: null },\n  gnumeric: { type: 'application/x-gnumeric', charset: null },\n  gramps: { type: 'application/x-gramps-xml', charset: null },\n  gtar: { type: 'application/x-gtar', charset: null },\n  hdf: { type: 'application/x-hdf', charset: null },\n  php: { type: 'application/x-httpd-php', charset: null },\n  install: { type: 'application/x-install-instructions', charset: null },\n  jardiff: { type: 'application/x-java-archive-diff', charset: null },\n  jnlp: { type: 'application/x-java-jnlp-file', charset: null },\n  kdbx: { type: 'application/x-keepass2', charset: null },\n  latex: { type: 'application/x-latex', charset: null },\n  luac: { type: 'application/x-lua-bytecode', charset: null },\n  lzh: { type: 'application/x-lzh-compressed', charset: null },\n  lha: null,\n  run: { type: 'application/x-makeself', charset: null },\n  mie: { type: 'application/x-mie', charset: null },\n  prc: { type: 'application/x-mobipocket-ebook', charset: null },\n  mobi: null,\n  application: { type: 'application/x-ms-application', charset: null },\n  lnk: { type: 'application/x-ms-shortcut', charset: null },\n  wmd: { type: 'application/x-ms-wmd', charset: null },\n  wmz: { type: 'application/x-ms-wmz', charset: null },\n  xbap: { type: 'application/x-ms-xbap', charset: null },\n  mdb: { type: 'application/x-msaccess', charset: null },\n  obd: { type: 'application/x-msbinder', charset: null },\n  crd: { type: 'application/x-mscardfile', charset: null },\n  clp: { type: 'application/x-msclip', charset: null },\n  com: null,\n  bat: null,\n  mvb: { type: 'application/x-msmediaview', charset: null },\n  m13: null,\n  m14: null,\n  wmf: { type: 'application/x-msmetafile', charset: null },\n  emf: null,\n  emz: null,\n  mny: { type: 'application/x-msmoney', charset: null },\n  pub: { type: 'application/x-mspublisher', charset: null },\n  scd: { type: 'application/x-msschedule', charset: null },\n  trm: { type: 'application/x-msterminal', charset: null },\n  wri: { type: 'application/x-mswrite', charset: null },\n  nc: { type: 'application/x-netcdf', charset: null },\n  cdf: null,\n  pac: { type: 'application/x-ns-proxy-autoconfig', charset: null },\n  nzb: { type: 'application/x-nzb', charset: null },\n  pl: { type: 'application/x-perl', charset: null },\n  pm: null,\n  p12: { type: 'application/x-pkcs12', charset: null },\n  pfx: null,\n  p7b: { type: 'application/x-pkcs7-certificates', charset: null },\n  spc: null,\n  p7r: { type: 'application/x-pkcs7-certreqresp', charset: null },\n  rpm: { type: 'application/x-redhat-package-manager', charset: null },\n  ris: { type: 'application/x-research-info-systems', charset: null },\n  sea: { type: 'application/x-sea', charset: null },\n  sh: { type: 'application/x-sh', charset: null },\n  shar: { type: 'application/x-shar', charset: null },\n  swf: { type: 'application/x-shockwave-flash', charset: null },\n  xap: { type: 'application/x-silverlight-app', charset: null },\n  sql: { type: 'application/x-sql', charset: null },\n  sit: { type: 'application/x-stuffit', charset: null },\n  sitx: { type: 'application/x-stuffitx', charset: null },\n  srt: { type: 'application/x-subrip', charset: null },\n  sv4cpio: { type: 'application/x-sv4cpio', charset: null },\n  sv4crc: { type: 'application/x-sv4crc', charset: null },\n  t3: { type: 'application/x-t3vm-image', charset: null },\n  gam: { type: 'application/x-tads', charset: null },\n  tar: { type: 'application/x-tar', charset: null },\n  tcl: { type: 'application/x-tcl', charset: null },\n  tk: null,\n  tex: { type: 'application/x-tex', charset: null },\n  tfm: { type: 'application/x-tex-tfm', charset: null },\n  texinfo: { type: 'application/x-texinfo', charset: null },\n  texi: null,\n  obj: { type: 'application/x-tgif', charset: null },\n  ustar: { type: 'application/x-ustar', charset: null },\n  hdd: { type: 'application/x-virtualbox-hdd', charset: null },\n  ova: { type: 'application/x-virtualbox-ova', charset: null },\n  ovf: { type: 'application/x-virtualbox-ovf', charset: null },\n  vbox: { type: 'application/x-virtualbox-vbox', charset: null },\n  'vbox-extpack': { type: 'application/x-virtualbox-vbox-extpack', charset: null },\n  vdi: { type: 'application/x-virtualbox-vdi', charset: null },\n  vhd: { type: 'application/x-virtualbox-vhd', charset: null },\n  vmdk: { type: 'application/x-virtualbox-vmdk', charset: null },\n  src: { type: 'application/x-wais-source', charset: null },\n  webapp: { type: 'application/x-web-app-manifest+json', charset: null },\n  der: { type: 'application/x-x509-ca-cert', charset: null },\n  crt: null,\n  pem: null,\n  fig: { type: 'application/x-xfig', charset: null },\n  xlf: { type: 'application/x-xliff+xml', charset: null },\n  xpi: { type: 'application/x-xpinstall', charset: null },\n  xz: { type: 'application/x-xz', charset: null },\n  z1: { type: 'application/x-zmachine', charset: null },\n  z2: null,\n  z3: null,\n  z4: null,\n  z5: null,\n  z6: null,\n  z7: null,\n  z8: null,\n  xaml: { type: 'application/xaml+xml', charset: null },\n  xav: { type: 'application/xcap-att+xml', charset: null },\n  xca: { type: 'application/xcap-caps+xml', charset: null },\n  xdf: { type: 'application/xcap-diff+xml', charset: null },\n  xel: { type: 'application/xcap-el+xml', charset: null },\n  xns: { type: 'application/xcap-ns+xml', charset: null },\n  xenc: { type: 'application/xenc+xml', charset: null },\n  xhtml: { type: 'application/xhtml+xml', charset: null },\n  xht: null,\n  xml: { type: 'application/xml', charset: null },\n  xsl: null,\n  xsd: null,\n  rng: null,\n  dtd: { type: 'application/xml-dtd', charset: null },\n  xop: { type: 'application/xop+xml', charset: null },\n  xpl: { type: 'application/xproc+xml', charset: null },\n  xslt: null,\n  xspf: { type: 'application/xspf+xml', charset: null },\n  mxml: { type: 'application/xv+xml', charset: null },\n  xhvml: null,\n  xvml: null,\n  xvm: null,\n  yang: { type: 'application/yang', charset: null },\n  yin: { type: 'application/yin+xml', charset: null },\n  zip: { type: 'application/zip', charset: null },\n  '3gpp': { type: 'audio/3gpp', charset: null },\n  adp: { type: 'audio/adpcm', charset: null },\n  amr: { type: 'audio/amr', charset: null },\n  au: { type: 'audio/basic', charset: null },\n  snd: null,\n  mid: { type: 'audio/midi', charset: null },\n  midi: null,\n  kar: null,\n  rmi: null,\n  mxmf: { type: 'audio/mobile-xmf', charset: null },\n  mp3: { type: 'audio/mp3', charset: null },\n  m4a: { type: 'audio/mp4', charset: null },\n  mp4a: null,\n  mpga: { type: 'audio/mpeg', charset: null },\n  mp2: null,\n  mp2a: null,\n  m2a: null,\n  m3a: null,\n  oga: { type: 'audio/ogg', charset: null },\n  ogg: null,\n  spx: null,\n  opus: null,\n  s3m: { type: 'audio/s3m', charset: null },\n  sil: { type: 'audio/silk', charset: null },\n  uva: { type: 'audio/vnd.dece.audio', charset: null },\n  uvva: null,\n  eol: { type: 'audio/vnd.digital-winds', charset: null },\n  dra: { type: 'audio/vnd.dra', charset: null },\n  dts: { type: 'audio/vnd.dts', charset: null },\n  dtshd: { type: 'audio/vnd.dts.hd', charset: null },\n  lvp: { type: 'audio/vnd.lucent.voice', charset: null },\n  pya: { type: 'audio/vnd.ms-playready.media.pya', charset: null },\n  ecelp4800: { type: 'audio/vnd.nuera.ecelp4800', charset: null },\n  ecelp7470: { type: 'audio/vnd.nuera.ecelp7470', charset: null },\n  ecelp9600: { type: 'audio/vnd.nuera.ecelp9600', charset: null },\n  rip: { type: 'audio/vnd.rip', charset: null },\n  wav: { type: 'audio/wav', charset: null },\n  weba: { type: 'audio/webm', charset: null },\n  aac: { type: 'audio/x-aac', charset: null },\n  aif: { type: 'audio/x-aiff', charset: null },\n  aiff: null,\n  aifc: null,\n  caf: { type: 'audio/x-caf', charset: null },\n  flac: { type: 'audio/x-flac', charset: null },\n  mka: { type: 'audio/x-matroska', charset: null },\n  m3u: { type: 'audio/x-mpegurl', charset: null },\n  wax: { type: 'audio/x-ms-wax', charset: null },\n  wma: { type: 'audio/x-ms-wma', charset: null },\n  ram: { type: 'audio/x-pn-realaudio', charset: null },\n  ra: null,\n  rmp: { type: 'audio/x-pn-realaudio-plugin', charset: null },\n  xm: { type: 'audio/xm', charset: null },\n  cdx: { type: 'chemical/x-cdx', charset: null },\n  cif: { type: 'chemical/x-cif', charset: null },\n  cmdf: { type: 'chemical/x-cmdf', charset: null },\n  cml: { type: 'chemical/x-cml', charset: null },\n  csml: { type: 'chemical/x-csml', charset: null },\n  xyz: { type: 'chemical/x-xyz', charset: null },\n  ttc: { type: 'font/collection', charset: null },\n  otf: { type: 'font/otf', charset: null },\n  ttf: { type: 'font/ttf', charset: null },\n  woff: { type: 'font/woff', charset: null },\n  woff2: { type: 'font/woff2', charset: null },\n  exr: { type: 'image/aces', charset: null },\n  apng: { type: 'image/apng', charset: null },\n  avci: { type: 'image/avci', charset: null },\n  avcs: { type: 'image/avcs', charset: null },\n  avif: { type: 'image/avif', charset: null },\n  bmp: { type: 'image/bmp', charset: null },\n  cgm: { type: 'image/cgm', charset: null },\n  drle: { type: 'image/dicom-rle', charset: null },\n  fits: { type: 'image/fits', charset: null },\n  g3: { type: 'image/g3fax', charset: null },\n  gif: { type: 'image/gif', charset: null },\n  heic: { type: 'image/heic', charset: null },\n  heics: { type: 'image/heic-sequence', charset: null },\n  heif: { type: 'image/heif', charset: null },\n  heifs: { type: 'image/heif-sequence', charset: null },\n  hej2: { type: 'image/hej2k', charset: null },\n  hsj2: { type: 'image/hsj2', charset: null },\n  ief: { type: 'image/ief', charset: null },\n  jls: { type: 'image/jls', charset: null },\n  jp2: { type: 'image/jp2', charset: null },\n  jpg2: null,\n  jpeg: { type: 'image/jpeg', charset: null },\n  jpg: null,\n  jpe: null,\n  jph: { type: 'image/jph', charset: null },\n  jhc: { type: 'image/jphc', charset: null },\n  jpm: { type: 'image/jpm', charset: null },\n  jpx: { type: 'image/jpx', charset: null },\n  jpf: null,\n  jxr: { type: 'image/jxr', charset: null },\n  jxra: { type: 'image/jxra', charset: null },\n  jxrs: { type: 'image/jxrs', charset: null },\n  jxs: { type: 'image/jxs', charset: null },\n  jxsc: { type: 'image/jxsc', charset: null },\n  jxsi: { type: 'image/jxsi', charset: null },\n  jxss: { type: 'image/jxss', charset: null },\n  ktx: { type: 'image/ktx', charset: null },\n  ktx2: { type: 'image/ktx2', charset: null },\n  png: { type: 'image/png', charset: null },\n  btif: { type: 'image/prs.btif', charset: null },\n  pti: { type: 'image/prs.pti', charset: null },\n  sgi: { type: 'image/sgi', charset: null },\n  svg: { type: 'image/svg+xml', charset: null },\n  svgz: null,\n  t38: { type: 'image/t38', charset: null },\n  tif: { type: 'image/tiff', charset: null },\n  tiff: null,\n  tfx: { type: 'image/tiff-fx', charset: null },\n  psd: { type: 'image/vnd.adobe.photoshop', charset: null },\n  azv: { type: 'image/vnd.airzip.accelerator.azv', charset: null },\n  uvi: { type: 'image/vnd.dece.graphic', charset: null },\n  uvvi: null,\n  uvg: null,\n  uvvg: null,\n  djvu: { type: 'image/vnd.djvu', charset: null },\n  djv: null,\n  sub: { type: 'image/vnd.dvb.subtitle', charset: null },\n  dwg: { type: 'image/vnd.dwg', charset: null },\n  dxf: { type: 'image/vnd.dxf', charset: null },\n  fbs: { type: 'image/vnd.fastbidsheet', charset: null },\n  fpx: { type: 'image/vnd.fpx', charset: null },\n  fst: { type: 'image/vnd.fst', charset: null },\n  mmr: { type: 'image/vnd.fujixerox.edmics-mmr', charset: null },\n  rlc: { type: 'image/vnd.fujixerox.edmics-rlc', charset: null },\n  ico: { type: 'image/vnd.microsoft.icon', charset: null },\n  dds: { type: 'image/vnd.ms-dds', charset: null },\n  mdi: { type: 'image/vnd.ms-modi', charset: null },\n  wdp: { type: 'image/vnd.ms-photo', charset: null },\n  npx: { type: 'image/vnd.net-fpx', charset: null },\n  b16: { type: 'image/vnd.pco.b16', charset: null },\n  tap: { type: 'image/vnd.tencent.tap', charset: null },\n  vtf: { type: 'image/vnd.valve.source.texture', charset: null },\n  wbmp: { type: 'image/vnd.wap.wbmp', charset: null },\n  xif: { type: 'image/vnd.xiff', charset: null },\n  pcx: { type: 'image/vnd.zbrush.pcx', charset: null },\n  webp: { type: 'image/webp', charset: null },\n  '3ds': { type: 'image/x-3ds', charset: null },\n  ras: { type: 'image/x-cmu-raster', charset: null },\n  cmx: { type: 'image/x-cmx', charset: null },\n  fh: { type: 'image/x-freehand', charset: null },\n  fhc: null,\n  fh4: null,\n  fh5: null,\n  fh7: null,\n  jng: { type: 'image/x-jng', charset: null },\n  sid: { type: 'image/x-mrsid-image', charset: null },\n  pic: { type: 'image/x-pict', charset: null },\n  pct: null,\n  pnm: { type: 'image/x-portable-anymap', charset: null },\n  pbm: { type: 'image/x-portable-bitmap', charset: null },\n  pgm: { type: 'image/x-portable-graymap', charset: null },\n  ppm: { type: 'image/x-portable-pixmap', charset: null },\n  rgb: { type: 'image/x-rgb', charset: null },\n  tga: { type: 'image/x-tga', charset: null },\n  xbm: { type: 'image/x-xbitmap', charset: null },\n  xpm: { type: 'image/x-xpixmap', charset: null },\n  xwd: { type: 'image/x-xwindowdump', charset: null },\n  'disposition-notification': { type: 'message/disposition-notification', charset: null },\n  u8msg: { type: 'message/global', charset: null },\n  u8dsn: { type: 'message/global-delivery-status', charset: null },\n  u8mdn: { type: 'message/global-disposition-notification', charset: null },\n  u8hdr: { type: 'message/global-headers', charset: null },\n  eml: { type: 'message/rfc822', charset: null },\n  mime: null,\n  wsc: { type: 'message/vnd.wfa.wsc', charset: null },\n  '3mf': { type: 'model/3mf', charset: null },\n  gltf: { type: 'model/gltf+json', charset: null },\n  glb: { type: 'model/gltf-binary', charset: null },\n  igs: { type: 'model/iges', charset: null },\n  iges: null,\n  msh: { type: 'model/mesh', charset: null },\n  mesh: null,\n  silo: null,\n  mtl: { type: 'model/mtl', charset: null },\n  stpx: { type: 'model/step+xml', charset: null },\n  stpz: { type: 'model/step+zip', charset: null },\n  stpxz: { type: 'model/step-xml+zip', charset: null },\n  dae: { type: 'model/vnd.collada+xml', charset: null },\n  dwf: { type: 'model/vnd.dwf', charset: null },\n  gdl: { type: 'model/vnd.gdl', charset: null },\n  gtw: { type: 'model/vnd.gtw', charset: null },\n  mts: { type: 'model/vnd.mts', charset: null },\n  ogex: { type: 'model/vnd.opengex', charset: null },\n  x_b: { type: 'model/vnd.parasolid.transmit.binary', charset: null },\n  x_t: { type: 'model/vnd.parasolid.transmit.text', charset: null },\n  vds: { type: 'model/vnd.sap.vds', charset: null },\n  usdz: { type: 'model/vnd.usdz+zip', charset: null },\n  bsp: { type: 'model/vnd.valve.source.compiled-map', charset: null },\n  vtu: { type: 'model/vnd.vtu', charset: null },\n  wrl: { type: 'model/vrml', charset: null },\n  vrml: null,\n  x3db: { type: 'model/x3d+binary', charset: null },\n  x3dbz: null,\n  x3dv: { type: 'model/x3d+vrml', charset: null },\n  x3dvz: null,\n  x3d: { type: 'model/x3d+xml', charset: null },\n  x3dz: null,\n  appcache: { type: 'text/cache-manifest', charset: null },\n  manifest: null,\n  ics: { type: 'text/calendar', charset: null },\n  ifb: null,\n  coffee: { type: 'text/coffeescript', charset: null },\n  litcoffee: null,\n  css: { type: 'text/css', charset: 'UTF-8' },\n  csv: { type: 'text/csv', charset: null },\n  html: { type: 'text/html', charset: null },\n  htm: null,\n  shtml: null,\n  jade: { type: 'text/jade', charset: null },\n  jsx: { type: 'text/jsx', charset: null },\n  less: { type: 'text/less', charset: null },\n  markdown: { type: 'text/markdown', charset: null },\n  md: null,\n  mml: { type: 'text/mathml', charset: null },\n  mdx: { type: 'text/mdx', charset: null },\n  n3: { type: 'text/n3', charset: 'UTF-8' },\n  txt: { type: 'text/plain', charset: null },\n  text: null,\n  conf: null,\n  def: null,\n  list: null,\n  log: null,\n  in: null,\n  ini: null,\n  dsc: { type: 'text/prs.lines.tag', charset: null },\n  rtx: { type: 'text/richtext', charset: null },\n  sgml: { type: 'text/sgml', charset: null },\n  sgm: null,\n  shex: { type: 'text/shex', charset: null },\n  slim: { type: 'text/slim', charset: null },\n  slm: null,\n  spdx: { type: 'text/spdx', charset: null },\n  stylus: { type: 'text/stylus', charset: null },\n  styl: null,\n  tsv: { type: 'text/tab-separated-values', charset: null },\n  t: { type: 'text/troff', charset: null },\n  tr: null,\n  roff: null,\n  man: null,\n  me: null,\n  ms: null,\n  ttl: { type: 'text/turtle', charset: 'UTF-8' },\n  uri: { type: 'text/uri-list', charset: null },\n  uris: null,\n  urls: null,\n  vcard: { type: 'text/vcard', charset: null },\n  curl: { type: 'text/vnd.curl', charset: null },\n  dcurl: { type: 'text/vnd.curl.dcurl', charset: null },\n  mcurl: { type: 'text/vnd.curl.mcurl', charset: null },\n  scurl: { type: 'text/vnd.curl.scurl', charset: null },\n  ged: { type: 'text/vnd.familysearch.gedcom', charset: null },\n  fly: { type: 'text/vnd.fly', charset: null },\n  flx: { type: 'text/vnd.fmi.flexstor', charset: null },\n  gv: { type: 'text/vnd.graphviz', charset: null },\n  '3dml': { type: 'text/vnd.in3d.3dml', charset: null },\n  spot: { type: 'text/vnd.in3d.spot', charset: null },\n  jad: { type: 'text/vnd.sun.j2me.app-descriptor', charset: 'UTF-8' },\n  wml: { type: 'text/vnd.wap.wml', charset: null },\n  wmls: { type: 'text/vnd.wap.wmlscript', charset: null },\n  vtt: { type: 'text/vtt', charset: 'UTF-8' },\n  s: { type: 'text/x-asm', charset: null },\n  asm: null,\n  c: { type: 'text/x-c', charset: null },\n  cc: null,\n  cxx: null,\n  cpp: null,\n  h: null,\n  hh: null,\n  dic: null,\n  htc: { type: 'text/x-component', charset: null },\n  f: { type: 'text/x-fortran', charset: null },\n  for: null,\n  f77: null,\n  f90: null,\n  hbs: { type: 'text/x-handlebars-template', charset: null },\n  java: { type: 'text/x-java-source', charset: null },\n  lua: { type: 'text/x-lua', charset: null },\n  mkd: { type: 'text/x-markdown', charset: null },\n  nfo: { type: 'text/x-nfo', charset: null },\n  opml: { type: 'text/x-opml', charset: null },\n  p: { type: 'text/x-pascal', charset: null },\n  pas: null,\n  pde: { type: 'text/x-processing', charset: null },\n  sass: { type: 'text/x-sass', charset: null },\n  scss: { type: 'text/x-scss', charset: null },\n  etx: { type: 'text/x-setext', charset: null },\n  sfv: { type: 'text/x-sfv', charset: null },\n  ymp: { type: 'text/x-suse-ymp', charset: null },\n  uu: { type: 'text/x-uuencode', charset: null },\n  vcs: { type: 'text/x-vcalendar', charset: null },\n  vcf: { type: 'text/x-vcard', charset: null },\n  yaml: { type: 'text/yaml', charset: null },\n  yml: null,\n  '3gp': { type: 'video/3gpp', charset: null },\n  '3g2': { type: 'video/3gpp2', charset: null },\n  h261: { type: 'video/h261', charset: null },\n  h263: { type: 'video/h263', charset: null },\n  h264: { type: 'video/h264', charset: null },\n  m4s: { type: 'video/iso.segment', charset: null },\n  jpgv: { type: 'video/jpeg', charset: null },\n  jpgm: null,\n  mj2: { type: 'video/mj2', charset: null },\n  mjp2: null,\n  ts: { type: 'video/mp2t', charset: null },\n  mp4: { type: 'video/mp4', charset: null },\n  mp4v: null,\n  mpg4: null,\n  mpeg: { type: 'video/mpeg', charset: null },\n  mpg: null,\n  mpe: null,\n  m1v: null,\n  m2v: null,\n  ogv: { type: 'video/ogg', charset: null },\n  qt: { type: 'video/quicktime', charset: null },\n  mov: null,\n  uvh: { type: 'video/vnd.dece.hd', charset: null },\n  uvvh: null,\n  uvm: { type: 'video/vnd.dece.mobile', charset: null },\n  uvvm: null,\n  uvp: { type: 'video/vnd.dece.pd', charset: null },\n  uvvp: null,\n  uvs: { type: 'video/vnd.dece.sd', charset: null },\n  uvvs: null,\n  uvv: { type: 'video/vnd.dece.video', charset: null },\n  uvvv: null,\n  dvb: { type: 'video/vnd.dvb.file', charset: null },\n  fvt: { type: 'video/vnd.fvt', charset: null },\n  mxu: { type: 'video/vnd.mpegurl', charset: null },\n  m4u: null,\n  pyv: { type: 'video/vnd.ms-playready.media.pyv', charset: null },\n  uvu: { type: 'video/vnd.uvvu.mp4', charset: null },\n  uvvu: null,\n  viv: { type: 'video/vnd.vivo', charset: null },\n  webm: { type: 'video/webm', charset: null },\n  f4v: { type: 'video/x-f4v', charset: null },\n  fli: { type: 'video/x-fli', charset: null },\n  flv: { type: 'video/x-flv', charset: null },\n  m4v: { type: 'video/x-m4v', charset: null },\n  mkv: { type: 'video/x-matroska', charset: null },\n  mk3d: null,\n  mks: null,\n  mng: { type: 'video/x-mng', charset: null },\n  asf: { type: 'video/x-ms-asf', charset: null },\n  asx: null,\n  vob: { type: 'video/x-ms-vob', charset: null },\n  wm: { type: 'video/x-ms-wm', charset: null },\n  wmv: { type: 'video/x-ms-wmv', charset: null },\n  wmx: { type: 'video/x-ms-wmx', charset: null },\n  wvx: { type: 'video/x-ms-wvx', charset: null },\n  avi: { type: 'video/x-msvideo', charset: null },\n  movie: { type: 'video/x-sgi-movie', charset: null },\n  smv: { type: 'video/x-smv', charset: null },\n  ice: { type: 'x-conference/x-cooltalk', charset: null }\n}\n\nm.ecma = m.es\nm.inkml = m.ink\nm.war = m.jar\nm.ear = m.jar\nm.mjs = m.js\nm.map = m.json\nm.nb = m.ma\nm.mb = m.ma\nm.mp21 = m.m21\nm.m4p = m.mp4s\nm.dot = m.doc\nm.dms = m.bin\nm.lrf = m.bin\nm.mar = m.bin\nm.so = m.bin\nm.dist = m.bin\nm.distz = m.bin\nm.pkg = m.bin\nm.bpk = m.bin\nm.dump = m.bin\nm.elc = m.bin\nm.deploy = m.bin\nm.exe = m.bin\nm.dll = m.bin\nm.deb = m.bin\nm.dmg = m.bin\nm.iso = m.bin\nm.img = m.bin\nm.msi = m.bin\nm.msp = m.bin\nm.msm = m.bin\nm.buffer = m.bin\nm.onetoc2 = m.onetoc\nm.onetmp = m.onetoc\nm.onepkg = m.onetoc\nm.sig = m.asc\nm.p7c = m.p7m\nm.eps = m.ai\nm.ps = m.ai\nm.owl = m.rdf\nm.sieve = m.siv\nm.smil = m.smi\nm.teicorpus = m.tei\nm.acutc = m.atc\nm.fxpl = m.fxp\nm.c4d = m.c4g\nm.c4f = m.c4g\nm.c4p = m.c4g\nm.c4u = m.c4g\nm.uvvf = m.uvf\nm.uvd = m.uvf\nm.uvvd = m.uvf\nm.uvvt = m.uvt\nm.uvvx = m.uvx\nm.uvvz = m.uvz\nm.et3 = m.es3\nm.dataless = m.seed\nm.frame = m.fm\nm.maker = m.fm\nm.book = m.fm\nm.gre = m.gex\nm.gqs = m.gqf\nm.listafp = m.afp\nm.list3820 = m.afp\nm.icm = m.icc\nm.xpx = m.xpw\nm.ktr = m.ktz\nm.kpt = m.kpr\nm.kwt = m.kwd\nm.knp = m.kne\nm.skd = m.skp\nm.skt = m.skp\nm.skm = m.skp\nm.xlm = m.xls\nm.xla = m.xls\nm.xlc = m.xls\nm.xlt = m.xls\nm.xlw = m.xls\nm.pps = m.ppt\nm.pot = m.ppt\nm.mpt = m.mpp\nm.wks = m.wps\nm.wcm = m.wps\nm.wdb = m.wps\nm.nitf = m.ntf\nm.pqa = m.pdb\nm.oprc = m.pdb\nm.qxt = m.qxd\nm.qwd = m.qxd\nm.qwt = m.qxd\nm.qxl = m.qxd\nm.qxb = m.qxd\nm.twds = m.twd\nm.sdkd = m.sdkm\nm.vor = m.sdw\nm.susp = m.sus\nm.sisx = m.sis\nm.cap = m.pcap\nm.dmp = m.pcap\nm.ufdl = m.ufd\nm.vst = m.vsd\nm.vss = m.vsd\nm.vsw = m.vsd\nm.zirz = m.zir\nm.x32 = m.aab\nm.u32 = m.aab\nm.vox = m.aab\nm.blorb = m.blb\nm.boz = m.bz2\nm.cba = m.cbr\nm.cbt = m.cbr\nm.cbz = m.cbr\nm.cb7 = m.cbr\nm.udeb = m.deb\nm.dcr = m.dir\nm.dxr = m.dir\nm.cst = m.dir\nm.cct = m.dir\nm.cxt = m.dir\nm.w3d = m.dir\nm.fgd = m.dir\nm.swa = m.dir\nm.pfb = m.pfa\nm.pfm = m.pfa\nm.afm = m.pfa\nm.lha = m.lzh\nm.mobi = m.prc\nm.com = m.exe\nm.bat = m.exe\nm.m13 = m.mvb\nm.m14 = m.mvb\nm.emf = m.wmf\nm.emz = m.wmf\nm.cdf = m.nc\nm.pm = m.pl\nm.pfx = m.p12\nm.spc = m.p7b\nm.tk = m.tcl\nm.texi = m.texinfo\nm.crt = m.der\nm.pem = m.der\nm.z2 = m.z1\nm.z3 = m.z1\nm.z4 = m.z1\nm.z5 = m.z1\nm.z6 = m.z1\nm.z7 = m.z1\nm.z8 = m.z1\nm.xht = m.xhtml\nm.xsl = m.xml\nm.xsd = m.xml\nm.rng = m.xml\nm.xslt = m.xsl\nm.xhvml = m.mxml\nm.xvml = m.mxml\nm.xvm = m.mxml\nm.snd = m.au\nm.midi = m.mid\nm.kar = m.mid\nm.rmi = m.mid\nm.mp4a = m.m4a\nm.mp2 = m.mpga\nm.mp2a = m.mpga\nm.m2a = m.mpga\nm.m3a = m.mpga\nm.ogg = m.oga\nm.spx = m.oga\nm.opus = m.oga\nm.uvva = m.uva\nm.aiff = m.aif\nm.aifc = m.aif\nm.ra = m.ram\nm.jpg2 = m.jp2\nm.jpg = m.jpeg\nm.jpe = m.jpeg\nm.jpf = m.jpx\nm.svgz = m.svg\nm.tiff = m.tif\nm.uvvi = m.uvi\nm.uvg = m.uvi\nm.uvvg = m.uvi\nm.djv = m.djvu\nm.fhc = m.fh\nm.fh4 = m.fh\nm.fh5 = m.fh\nm.fh7 = m.fh\nm.pct = m.pic\nm.mime = m.eml\nm.iges = m.igs\nm.mesh = m.msh\nm.silo = m.msh\nm.vrml = m.wrl\nm.x3dbz = m.x3db\nm.x3dvz = m.x3dv\nm.x3dz = m.x3d\nm.manifest = m.appcache\nm.ifb = m.ics\nm.litcoffee = m.coffee\nm.htm = m.html\nm.shtml = m.html\nm.md = m.markdown\nm.text = m.txt\nm.conf = m.txt\nm.def = m.txt\nm.list = m.txt\nm.log = m.txt\nm.in = m.txt\nm.ini = m.txt\nm.sgm = m.sgml\nm.slm = m.slim\nm.styl = m.stylus\nm.tr = m.t\nm.roff = m.t\nm.man = m.t\nm.me = m.t\nm.ms = m.t\nm.uris = m.uri\nm.urls = m.uri\nm.asm = m.s\nm.cc = m.c\nm.cxx = m.c\nm.cpp = m.c\nm.h = m.c\nm.hh = m.c\nm.dic = m.c\nm.for = m.f\nm.f77 = m.f\nm.f90 = m.f\nm.pas = m.p\nm.yml = m.yaml\nm.jpgm = m.jpm\nm.mjp2 = m.mj2\nm.mp4v = m.mp4\nm.mpg4 = m.mp4\nm.mpg = m.mpeg\nm.mpe = m.mpeg\nm.m1v = m.mpeg\nm.m2v = m.mpeg\nm.mov = m.qt\nm.uvvh = m.uvh\nm.uvvm = m.uvm\nm.uvvp = m.uvp\nm.uvvs = m.uvs\nm.uvvv = m.uvv\nm.m4u = m.mxu\nm.uvvu = m.uvu\nm.mk3d = m.mkv\nm.mks = m.mkv\nm.asx = m.asf\n\nmodule.exports = function getMimeType (name, charset = true) {\n  const e = m[name.slice(name.lastIndexOf('.') + 1).toLowerCase()]\n  if (!e) return null\n  return e.type + (charset && e.charset ? '; charset=' + e.charset : '')\n}\n{\n  \"name\": \"get-mime-type\",\n  \"version\": \"1.0.2\",\n  \"description\": \"Simple extension to mime-type\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/get-mime-type.git\"\n  },\n  \"author\": \"Holepunch Inc\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/get-mime-type/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/get-mime-type#readme\",\n  \"devDependencies\": {\n    \"mime-db\": \"^1.52.0\"\n  }\n}\nconst Union = require('sorted-union-stream')\nconst b4a = require('b4a')\nconst codecs = require('codecs')\n\nfunction getKey (diffEntry) {\n  const { left, right } = diffEntry\n  return left ? left.key : right.key\n}\n\nfunction areEqual (diff1, diff2) {\n  if (diff1 === null && diff2 === null) return true\n  if (diff1 === null || diff2 === null) return false\n  return b4a.equals(diff1.value, diff2.value)\n}\n\nfunction unionCompare (e1, e2) {\n  const k1 = getKey(e1)\n  const k2 = getKey(e2)\n\n  return b4a.compare(k1, k2)\n}\n\nfunction decodeEntry (diffEntry, keyEncoding, valueEncoding) {\n  if (!diffEntry) return diffEntry\n  if (keyEncoding) diffEntry.key = keyEncoding.decode(diffEntry.key)\n  if (valueEncoding && diffEntry.value !== null) diffEntry.value = valueEncoding.decode(diffEntry.value)\n  return diffEntry\n}\n\nfunction createUnionMap (keyEncoding, valueEncoding) {\n  const decode = diffEntry => decodeEntry(diffEntry, keyEncoding, valueEncoding)\n  const filterSameValue = ({ left, right }) => {\n    // Diffs are also yielded when the value is the same, but the sequence\n    // is not. This filters out that case.\n    if (left?.value === right?.value) return null\n    return { left, right }\n  }\n\n  return function unionMap (undoDiffEntry, applyDiffEntry) {\n    if (undoDiffEntry === null) {\n      return filterSameValue({\n        left: decode(applyDiffEntry.left),\n        right: decode(applyDiffEntry.right)\n      }\n      )\n    }\n    if (applyDiffEntry === null) {\n      // requires undoing, so reverse\n      return filterSameValue({\n        left: decode(undoDiffEntry.right),\n        right: decode(undoDiffEntry.left)\n      })\n    }\n\n    const haveSameNewValue = areEqual(undoDiffEntry.left, applyDiffEntry.left)\n\n    if (!haveSameNewValue) {\n      // apply-entry wins, but the previous state (.right) is not the value\n      // at the last indexedLength, since a diffEntry to undo exists for the same key\n      // So we yield that to-undo diffEntry's final state as previous state for this change\n      return filterSameValue({\n        left: decode(applyDiffEntry.left),\n        right: decode(undoDiffEntry.left)\n      })\n    }\n    // else: already processed in prev getDiffs, so filter out\n    return null\n  }\n}\n\nfunction encodeKey (enc, key) {\n  return key ? (enc ? enc.encode(key) : key) : null\n}\n\nclass BeeDiffStream extends Union {\n  constructor (leftSnapshot, rightSnapshot, opts = {}) {\n    const valueEncoding = opts.valueEncoding ? codecs(opts.valueEncoding) : leftSnapshot.valueEncoding\n    const keyEncoding = opts.keyEncoding ? codecs(opts.keyEncoding) : leftSnapshot.keyEncoding\n\n    const gt = encodeKey(keyEncoding, opts.gt)\n    const gte = encodeKey(keyEncoding, opts.gte)\n    const lt = encodeKey(keyEncoding, opts.lt)\n    const lte = encodeKey(keyEncoding, opts.lte)\n\n    // Binary encodings for easier comparison later\n    opts = { ...opts, gt, gte, lt, lte, valueEncoding: 'binary', keyEncoding: 'binary' }\n\n    if (leftSnapshot.core.indexedLength === undefined) {\n      throw new Error('Incompatible Hypercore version--must have indexedLength property')\n    }\n\n    // We know that everything indexed in both snapshots is shared\n    const sharedIndexedL = Math.min(\n      leftSnapshot.core.indexedLength, rightSnapshot.core.indexedLength\n    )\n\n    // TODO: consider optimisation for case where the version of both streams\n    // is lower than the sharedIndexedL (in which case only the changes from\n    // the oldest version to the newest must be calculated, on the newest stream)\n    // --currently it redundantly calcs diffStreams for both and filters out the\n    //   shared entries\n    const toUndoDiffStream = leftSnapshot.createDiffStream(sharedIndexedL, opts)\n    const toApplyDiffStream = rightSnapshot.createDiffStream(sharedIndexedL, opts)\n\n    super(toUndoDiffStream, toApplyDiffStream, {\n      compare: unionCompare,\n      map: createUnionMap(keyEncoding, valueEncoding)\n    })\n\n    this.closeSnapshots = !(opts.closeSnapshots === false)\n\n    this._leftSnapshot = leftSnapshot\n    this._rightSnapshot = rightSnapshot\n  }\n\n  _destroy (cb) {\n    super._destroy((err) => {\n      if (!this.closeSnapshots) return cb(err)\n\n      const onclose = () => cb(err)\n      Promise.all([this._leftSnapshot.close(), this._rightSnapshot.close()]).then(onclose, cb)\n    })\n  }\n}\n\nmodule.exports = BeeDiffStream\n{\n  \"name\": \"hyperbee-diff-stream\",\n  \"version\": \"1.0.4\",\n  \"description\": \"Get the diff stream between two versions of a hyperbee (supports autobase views)\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js --coverage\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/hyperbee-diff-stream.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hyperbee-diff-stream/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hyperbee-diff-stream#readme\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"devDependencies\": {\n    \"autobase\": \"^6.0.0\",\n    \"autobase-test-helpers\": \"^2.0.4\",\n    \"brittle\": \"^3.1.1\",\n    \"corestore\": \"^6.5.0\",\n    \"hyperbee\": \"^2.5.0\",\n    \"random-access-memory\": \"^6.1.0\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.6.1\",\n    \"codecs\": \"^3.0.0\",\n    \"sorted-union-stream\": \"^3.2.3\"\n  }\n}\nconst codecs = require('codecs')\nconst { Readable } = require('streamx')\nconst mutexify = require('mutexify/promise')\nconst b4a = require('b4a')\nconst safetyCatch = require('safety-catch')\nconst ReadyResource = require('ready-resource')\nconst debounce = require('debounceify')\nconst Rache = require('rache')\n\nconst { all: unslabAll } = require('unslab')\n\nconst RangeIterator = require('./iterators/range')\nconst HistoryIterator = require('./iterators/history')\nconst DiffIterator = require('./iterators/diff')\nconst Extension = require('./lib/extension')\nconst { YoloIndex, Node, Header } = require('./lib/messages')\nconst { BLOCK_NOT_AVAILABLE, DECODING_ERROR } = require('hypercore-errors')\n\nconst T = 5\nconst MIN_KEYS = T - 1\nconst MAX_CHILDREN = MIN_KEYS * 2 + 1\n\nconst SEP = b4a.alloc(1)\nconst EMPTY = b4a.alloc(0)\n\nclass Key {\n  constructor (seq, value) {\n    this.seq = seq\n    this.value = value\n  }\n}\n\nclass Child {\n  constructor (seq, offset, value) {\n    this.seq = seq\n    this.offset = offset\n    this.value = value\n  }\n}\n\nclass Cache {\n  constructor (rache) {\n    this.keys = rache\n    this.length = 0\n  }\n\n  get (seq) {\n    return this.keys.get(seq) || null\n  }\n\n  set (seq, key) {\n    this.keys.set(seq, key)\n    if (seq >= this.length) this.length = seq + 1\n  }\n\n  gc (length) {\n    // if we need to \"work\" more than 128 ticks, just bust the cache...\n    if (this.length - length > 128) {\n      this.keys.clear()\n    } else {\n      for (let i = length; i < this.length; i++) {\n        this.keys.delete(i)\n      }\n    }\n\n    this.length = length\n  }\n}\n\nclass Pointers {\n  constructor (decoded) {\n    this.levels = decoded.levels.map(l => {\n      const children = []\n      const keys = []\n\n      for (let i = 0; i < l.keys.length; i++) {\n        keys.push(new Key(l.keys[i], null))\n      }\n\n      for (let i = 0; i < l.children.length; i += 2) {\n        children.push(new Child(l.children[i], l.children[i + 1], null))\n      }\n\n      return { keys, children }\n    })\n  }\n\n  get (i) {\n    return this.levels[i]\n  }\n\n  hasKey (seq) {\n    for (const lvl of this.levels) {\n      for (const key of lvl.keys) {\n        if (key.seq === seq) return true\n      }\n    }\n    return false\n  }\n}\n\nfunction inflate (entry) {\n  if (entry.inflated === null) {\n    entry.inflated = YoloIndex.decode(entry.index)\n    entry.index = null\n  }\n  return new Pointers(entry.inflated)\n}\n\nfunction deflate (index) {\n  const levels = index.map(l => {\n    const keys = []\n    const children = []\n\n    for (let i = 0; i < l.value.keys.length; i++) {\n      keys.push(l.value.keys[i].seq)\n    }\n\n    for (let i = 0; i < l.value.children.length; i++) {\n      children.push(l.value.children[i].seq, l.value.children[i].offset)\n    }\n\n    return { keys, children }\n  })\n\n  return YoloIndex.encode({ levels })\n}\n\nfunction preloadBlock (core, index) {\n  if (core.replicator._blocks.get(index)) return\n  core.get(index).catch(safetyCatch)\n}\n\nclass TreeNode {\n  constructor (block, keys, children, offset) {\n    this.block = block\n    this.offset = offset\n    this.keys = keys\n    this.children = children\n    this.changed = false\n\n    this.preload()\n  }\n\n  preload () {\n    if (this.block === null) return\n\n    const core = getBackingCore(this.block.tree.core)\n    const indexedLength = getIndexedLength(this.block.tree.core)\n    const bitfield = core.core.bitfield\n\n    for (let i = 0; i < this.keys.length; i++) {\n      const k = this.keys[i]\n      if (k.value) continue\n      if (k.seq >= indexedLength || bitfield.get(k.seq)) continue\n      preloadBlock(core, k.seq)\n    }\n    for (let i = 0; i < this.children.length; i++) {\n      const c = this.children[i]\n      if (c.value) continue\n      if (c.seq >= indexedLength || bitfield.get(c.seq)) continue\n      preloadBlock(core, c.seq)\n    }\n  }\n\n  async insertKey (key, value, child, node, encoding, cas) {\n    let s = 0\n    let e = this.keys.length\n    let c\n\n    while (s < e) {\n      const mid = (s + e) >> 1\n      c = b4a.compare(key.value, await this.getKey(mid))\n\n      if (c === 0) {\n        if (cas) {\n          const prev = await this.getKeyNode(mid)\n          if (!(await cas(prev.final(encoding), node))) return true\n        }\n        if (!this.block.tree.tree.alwaysDuplicate) {\n          const prev = await this.getKeyNode(mid)\n          if (sameValue(prev.value, value)) return true\n        }\n        this.changed = true\n        this.keys[mid] = key\n        return true\n      }\n\n      if (c < 0) e = mid\n      else s = mid + 1\n    }\n\n    const i = c < 0 ? e : s\n    this.keys.splice(i, 0, key)\n    if (child) this.children.splice(i + 1, 0, new Child(0, 0, child))\n    this.changed = true\n\n    return this.keys.length < MAX_CHILDREN\n  }\n\n  removeKey (index) {\n    this.keys.splice(index, 1)\n    if (this.children.length) {\n      this.children[index + 1].seq = 0 // mark as freed\n      this.children.splice(index + 1, 1)\n    }\n    this.changed = true\n  }\n\n  async siblings (parent) {\n    for (let i = 0; i < parent.children.length; i++) {\n      if (parent.children[i].value === this) {\n        const left = i ? parent.getChildNode(i - 1) : null\n        const right = i < parent.children.length - 1 ? parent.getChildNode(i + 1) : null\n        return { left: await left, index: i, right: await right }\n      }\n    }\n\n    throw new Error('Bad parent')\n  }\n\n  merge (node, median) {\n    this.changed = true\n    this.keys.push(median)\n    for (let i = 0; i < node.keys.length; i++) this.keys.push(node.keys[i])\n    for (let i = 0; i < node.children.length; i++) this.children.push(node.children[i])\n  }\n\n  async split () {\n    const len = this.keys.length >> 1\n    const right = TreeNode.create(this.block)\n\n    while (right.keys.length < len) right.keys.push(this.keys.pop())\n    right.keys.reverse()\n\n    await this.getKey(this.keys.length - 1) // make sure the median is loaded\n    const median = this.keys.pop()\n\n    if (this.children.length) {\n      while (right.children.length < len + 1) right.children.push(this.children.pop())\n      right.children.reverse()\n    }\n\n    this.changed = true\n\n    return {\n      left: this,\n      median,\n      right\n    }\n  }\n\n  getKeyNode (index) {\n    return this.block.tree.getBlock(this.keys[index].seq)\n  }\n\n  async getChildNode (index) {\n    const child = this.children[index]\n    if (child.value) return child.value\n    const block = child.seq === this.block.seq ? this.block : await this.block.tree.getBlock(child.seq)\n    return (child.value = block.getTreeNode(child.offset))\n  }\n\n  setKey (index, key) {\n    this.keys[index] = key\n    this.changed = true\n  }\n\n  async getKey (index) {\n    const key = this.keys[index]\n    if (key.value) return key.value\n    const k = key.seq === this.block.seq ? this.block.key : await this.block.tree.getKey(key.seq)\n    return (key.value = k)\n  }\n\n  indexChanges (index, seq) {\n    const offset = index.push(null) - 1\n    this.changed = false\n\n    for (const child of this.children) {\n      if (!child.value || !child.value.changed) continue\n      child.seq = seq\n      child.offset = child.value.indexChanges(index, seq)\n      index[child.offset] = child\n    }\n\n    return offset\n  }\n\n  updateChildren (seq, block) {\n    for (const child of this.children) {\n      if (!child.value || child.seq !== seq) continue\n      child.value.block = block\n      child.value.updateChildren(seq, block)\n    }\n  }\n\n  static create (block) {\n    const node = new TreeNode(block, [], [], 0)\n    node.changed = true\n    return node\n  }\n}\n\nclass BlockEntry {\n  constructor (seq, tree, entry) {\n    this.seq = seq\n    this.tree = tree\n    this.index = null\n    this.entry = entry\n    this.key = entry.key\n    this.value = entry.value\n  }\n\n  isTarget (key) {\n    return b4a.equals(this.key, key)\n  }\n\n  isDeletion () {\n    if (this.value !== null) return false\n\n    if (this.index === null) {\n      this.index = inflate(this.entry)\n    }\n\n    return !this.index.hasKey(this.seq)\n  }\n\n  final (encoding) {\n    return {\n      seq: this.seq,\n      key: encoding.key ? encoding.key.decode(this.key) : this.key,\n      value: this.value && (encoding.value ? encoding.value.decode(this.value) : this.value)\n    }\n  }\n\n  getTreeNode (offset) {\n    if (this.index === null) {\n      this.index = inflate(this.entry)\n    }\n    const entry = this.index.get(offset)\n    return new TreeNode(this, entry.keys, entry.children, offset)\n  }\n}\n\nclass BatchEntry extends BlockEntry {\n  constructor (seq, tree, key, value, index) {\n    super(seq, tree, { key, value, index: null, inflated: null })\n    this.pendingIndex = index\n  }\n\n  isTarget (key) {\n    return false\n  }\n\n  getTreeNode (offset) {\n    return this.pendingIndex[offset].value\n  }\n}\n\nclass Hyperbee extends ReadyResource {\n  constructor (core, opts = {}) {\n    super()\n    // this.feed is now deprecated, and will be this.core going forward\n    this.feed = core\n    this.core = core\n\n    this.keyEncoding = opts.keyEncoding ? codecs(opts.keyEncoding) : null\n    this.valueEncoding = opts.valueEncoding ? codecs(opts.valueEncoding) : null\n    this.extension = opts.extension !== false ? opts.extension || Extension.register(this) : null\n    this.metadata = opts.metadata || null\n    this.lock = opts.lock || mutexify()\n    this.sep = opts.sep || SEP\n    this.readonly = !!opts.readonly\n    this.prefix = opts.prefix || null\n\n    // In a future version, this should be false by default\n    this.alwaysDuplicate = opts.alwaysDuplicate !== false\n\n    this._unprefixedKeyEncoding = this.keyEncoding\n    this._sub = !!this.prefix\n    this._checkout = opts.checkout || 0\n    this._view = !!opts._view\n\n    this._onappendBound = this._view ? null : this._onappend.bind(this)\n    this._ontruncateBound = this._view ? null : this._ontruncate.bind(this)\n    this._watchers = this._onappendBound ? [] : null\n    this._entryWatchers = this._onappendBound ? [] : null\n    this._sessions = opts.sessions !== false\n\n    this._keyCache = null\n    this._nodeCache = null\n\n    this._batches = []\n\n    if (this._watchers) {\n      this.core.on('append', this._onappendBound)\n      this.core.on('truncate', this._ontruncateBound)\n    }\n\n    if (this.prefix && opts._sub) {\n      this.keyEncoding = prefixEncoding(this.prefix, this.keyEncoding)\n    }\n\n    this.ready().catch(safetyCatch)\n  }\n\n  async _open () {\n    if (this.core.opened === false) await this.core.ready()\n\n    // snapshot\n    if (this._checkout === -1) this._checkout = Math.max(1, this.core.length)\n\n    const baseCache = Rache.from(this.core.globalCache)\n    this._keyCache = new Cache(baseCache)\n    this._nodeCache = new Cache(Rache.from(baseCache))\n  }\n\n  get version () {\n    return Math.max(1, this._checkout || this.core.length)\n  }\n\n  get id () {\n    return this.core.id\n  }\n\n  get key () {\n    return this.core.key\n  }\n\n  get discoveryKey () {\n    return this.core.discoveryKey\n  }\n\n  get writable () {\n    return this.core.writable\n  }\n\n  get readable () {\n    return this.core.readable\n  }\n\n  replicate (isInitiator, opts) {\n    return this.core.replicate(isInitiator, opts)\n  }\n\n  update (opts) {\n    return this.core.update(opts)\n  }\n\n  peek (range, opts) {\n    return iteratorPeek(this.createRangeIterator(range, { ...opts, limit: 1 }))\n  }\n\n  createRangeIterator (range, opts = {}) {\n    // backwards compat range arg\n    opts = opts ? { ...opts, ...range } : range\n\n    const extension = (opts.extension === false && opts.limit !== 0) ? null : this.extension\n    const keyEncoding = opts.keyEncoding ? codecs(opts.keyEncoding) : this.keyEncoding\n\n    if (extension) {\n      const { onseq, onwait } = opts\n      let version = 0\n      let next = 0\n\n      opts = encRange(keyEncoding, {\n        ...opts,\n        sub: this._sub,\n        onseq (seq) {\n          if (!version) version = seq + 1\n          if (next) next--\n          if (onseq) onseq(seq)\n        },\n        onwait (seq) {\n          if (!next) {\n            next = Extension.BATCH_SIZE\n            extension.iterator(ite.snapshot(version))\n          }\n          if (onwait) onwait(seq)\n        }\n      })\n    } else {\n      opts = encRange(keyEncoding, { ...opts, sub: this._sub })\n    }\n\n    const ite = new RangeIterator(new Batch(this, this._makeSnapshot(), null, false, opts), null, opts)\n    return ite\n  }\n\n  createReadStream (range, opts) {\n    const signal = (opts && opts.signal) || null\n    return iteratorToStream(this.createRangeIterator(range, opts), signal)\n  }\n\n  createHistoryStream (opts) {\n    const session = (opts && opts.live) ? this.core.session() : this._makeSnapshot()\n    const signal = (opts && opts.signal) || null\n    return iteratorToStream(new HistoryIterator(new Batch(this, session, null, false, opts), opts), signal)\n  }\n\n  createDiffStream (right, range, opts) {\n    if (typeof right === 'number') right = this.checkout(Math.max(1, right), { reuseSession: true })\n\n    // backwards compat range arg\n    opts = opts ? { ...opts, ...range } : range\n\n    const snapshot = right.version > this.version ? right._makeSnapshot() : this._makeSnapshot()\n    const signal = (opts && opts.signal) || null\n\n    const keyEncoding = opts && opts.keyEncoding ? codecs(opts.keyEncoding) : this.keyEncoding\n    if (keyEncoding) opts = encRange(keyEncoding, { ...opts, sub: this._sub })\n\n    return iteratorToStream(new DiffIterator(new Batch(this, snapshot, null, false, opts), new Batch(right, snapshot, null, false, opts), opts), signal)\n  }\n\n  get (key, opts) {\n    const b = new Batch(this, this._makeSnapshot(), null, true, opts)\n    return b.get(key)\n  }\n\n  getBySeq (seq, opts) {\n    const b = new Batch(this, this._makeSnapshot(), null, true, opts)\n    return b.getBySeq(seq)\n  }\n\n  put (key, value, opts) {\n    const b = new Batch(this, this.core, null, true, opts)\n    return b.put(key, value, opts)\n  }\n\n  batch (opts) {\n    return new Batch(this, this.core, mutexify(), true, opts)\n  }\n\n  del (key, opts) {\n    const b = new Batch(this, this.core, null, true, opts)\n    return b.del(key, opts)\n  }\n\n  watch (range, opts) {\n    if (!this._watchers) throw new Error('Can only watch the main bee instance')\n    return new Watcher(this, range, opts)\n  }\n\n  async getAndWatch (key, opts) {\n    if (!this._watchers) throw new Error('Can only watch the main bee instance')\n\n    const watcher = new EntryWatcher(this, key, opts)\n    await watcher._debouncedUpdate()\n\n    if (this.closing) {\n      await watcher.close()\n      throw new Error('Bee closed')\n    }\n\n    return watcher\n  }\n\n  _onappend () {\n    for (const watcher of this._watchers) {\n      watcher._onappend()\n    }\n\n    for (const watcher of this._entryWatchers) {\n      watcher._onappend()\n    }\n  }\n\n  _ontruncate (length) {\n    for (const watcher of this._watchers) {\n      watcher._ontruncate()\n    }\n\n    for (const watcher of this._entryWatchers) {\n      watcher._ontruncate()\n    }\n\n    this._nodeCache.gc(length)\n    this._keyCache.gc(length)\n  }\n\n  _makeSnapshot () {\n    if (this._sessions === false) return this.core\n    // TODO: better if we could encapsulate this in hypercore in the future\n    return (this._checkout <= this.core.length || this._checkout <= 1) ? this.core.snapshot() : this.core.session({ snapshot: false })\n  }\n\n  checkout (version, opts = {}) {\n    if (version === 0) version = 1\n\n    // same as above, just checkout isn't set yet...\n    const snap = (opts.reuseSession || this._sessions === false)\n      ? this.core\n      : (version <= this.core.length || version <= 1) ? this.core.snapshot() : this.core.session({ snapshot: false })\n\n    return new Hyperbee(snap, {\n      _view: true,\n      _sub: false,\n      prefix: this.prefix,\n      sep: this.sep,\n      lock: this.lock,\n      checkout: version,\n      keyEncoding: opts.keyEncoding || this.keyEncoding,\n      valueEncoding: opts.valueEncoding || this.valueEncoding,\n      extension: this.extension !== null ? this.extension : false\n    })\n  }\n\n  snapshot (opts) {\n    return this.checkout(this.core.opened === false ? -1 : Math.max(1, this.version), opts)\n  }\n\n  sub (prefix, opts = {}) {\n    let sep = opts.sep || this.sep\n    if (!b4a.isBuffer(sep)) sep = b4a.from(sep)\n\n    prefix = b4a.concat([this.prefix || EMPTY, b4a.from(prefix), sep])\n\n    const valueEncoding = codecs(opts.valueEncoding || this.valueEncoding)\n    const keyEncoding = codecs(opts.keyEncoding || this._unprefixedKeyEncoding)\n\n    return new Hyperbee(this.core, {\n      _view: true,\n      _sub: true,\n      prefix,\n      sep: this.sep,\n      lock: this.lock,\n      checkout: this._checkout,\n      valueEncoding,\n      keyEncoding,\n      extension: this.extension !== null ? this.extension : false,\n      metadata: this.metadata\n    })\n  }\n\n  async getHeader (opts) {\n    const blk = await this.core.get(0, opts)\n    try {\n      return blk && Header.decode(blk)\n    } catch {\n      throw DECODING_ERROR()\n    }\n  }\n\n  async _close () {\n    if (this._watchers) {\n      this.core.off('append', this._onappendBound)\n      this.core.off('truncate', this._ontruncateBound)\n\n      while (this._watchers.length) {\n        await this._watchers[this._watchers.length - 1].close()\n      }\n    }\n\n    if (this._entryWatchers) {\n      while (this._entryWatchers.length) {\n        await this._entryWatchers[this._entryWatchers.length - 1].close()\n      }\n    }\n\n    while (this._batches.length) {\n      await this._batches[this._batches.length - 1].close()\n    }\n\n    return this.core.close()\n  }\n\n  static async isHyperbee (core, opts) {\n    await core.ready()\n\n    const blk0 = await core.get(0, opts)\n    if (blk0 === null) throw BLOCK_NOT_AVAILABLE()\n\n    try {\n      return Header.decode(blk0).protocol === 'hyperbee'\n    } catch (err) { // undecodable\n      return false\n    }\n  }\n}\n\nclass Batch {\n  constructor (tree, core, batchLock, cache, options = {}) {\n    this.tree = tree\n    // this.feed is now deprecated, and will be this.core going forward\n    this.feed = core\n    this.core = core\n    this.index = tree._batches.push(this) - 1\n    this.blocks = cache ? new Map() : null\n    this.autoFlush = !batchLock\n    this.rootSeq = 0\n    this.root = null\n    this.length = 0\n    this.options = options\n    this.locked = null\n    this.batchLock = batchLock\n    this.onseq = this.options.onseq || noop\n    this.appending = null\n    this.isSnapshot = this.core !== this.tree.core\n    this.shouldUpdate = this.options.update !== false\n    this.updating = null\n    this.encoding = {\n      key: options.keyEncoding ? codecs(options.keyEncoding) : tree.keyEncoding,\n      value: options.valueEncoding ? codecs(options.valueEncoding) : tree.valueEncoding\n    }\n  }\n\n  ready () {\n    return this.tree.ready()\n  }\n\n  async lock () {\n    if (this.tree.readonly) throw new Error('Hyperbee is marked as read-only')\n    if (this.locked === null) this.locked = await this.tree.lock()\n  }\n\n  get version () {\n    return Math.max(1, this.tree._checkout ? this.tree._checkout : this.core.length + this.length)\n  }\n\n  async getRoot (ensureHeader) {\n    await this.ready()\n    if (ensureHeader) {\n      if (this.core.length === 0 && this.core.writable && !this.tree.readonly) {\n        await this.core.append(Header.encode({\n          protocol: 'hyperbee',\n          metadata: this.tree.metadata\n        }))\n      }\n    }\n    if (this.tree._checkout === 0 && this.shouldUpdate) {\n      if (this.updating === null) this.updating = this.core.update()\n      await this.updating\n    }\n    if (this.version < 2) return null\n    return (await this.getBlock(this.version - 1)).getTreeNode(0)\n  }\n\n  async getKey (seq) {\n    const k = this.core.fork === this.tree.core.fork ? this.tree._keyCache.get(seq) : null\n    if (k !== null) return k\n    const key = (await this.getBlock(seq)).key\n    if (this.core.fork === this.tree.core.fork) this.tree._keyCache.set(seq, key)\n    return key\n  }\n\n  async _getNode (seq) {\n    const cached = this.tree._nodeCache !== null && this.core.fork === this.tree.core.fork ? this.tree._nodeCache.get(seq) : null\n    if (cached !== null) return cached\n    const entry = await this.core.get(seq, { ...this.options, valueEncoding: Node })\n    if (entry === null) throw BLOCK_NOT_AVAILABLE()\n    const wrap = copyEntry(entry)\n    if (this.core.fork === this.tree.core.fork && this.tree._nodeCache !== null) this.tree._nodeCache.set(seq, wrap)\n    return wrap\n  }\n\n  async getBlock (seq) {\n    if (this.rootSeq === 0) this.rootSeq = seq\n    let b = this.blocks && this.blocks.get(seq)\n    if (b) return b\n    this.onseq(seq)\n    const entry = await this._getNode(seq)\n    b = new BlockEntry(seq, this, entry)\n    if (this.blocks && (this.blocks.size - this.length) < 128) this.blocks.set(seq, b)\n    return b\n  }\n\n  _onwait (key) {\n    this.options.onwait = null\n    this.tree.extension.get(this.rootSeq + 1, key)\n  }\n\n  _getEncoding (opts) {\n    if (!opts) return this.encoding\n    return {\n      key: opts.keyEncoding ? codecs(opts.keyEncoding) : this.encoding.key,\n      value: opts.valueEncoding ? codecs(opts.valueEncoding) : this.encoding.value\n    }\n  }\n\n  peek (range, opts) {\n    return iteratorPeek(this.createRangeIterator(range, { ...opts, limit: 1 }))\n  }\n\n  createRangeIterator (range, opts = {}) {\n    // backwards compat range arg\n    opts = opts ? { ...opts, ...range } : range\n\n    const encoding = this._getEncoding(opts)\n    return new RangeIterator(this, encoding, encRange(encoding.key, { ...opts, sub: this.tree._sub }))\n  }\n\n  createReadStream (range, opts) {\n    const signal = (opts && opts.signal) || null\n    return iteratorToStream(this.createRangeIterator(range, opts), signal)\n  }\n\n  async getBySeq (seq, opts) {\n    const encoding = this._getEncoding(opts)\n\n    try {\n      const block = (await this.getBlock(seq)).final(encoding)\n      return { key: block.key, value: block.value }\n    } finally {\n      await this._closeSnapshot()\n    }\n  }\n\n  async get (key, opts) {\n    const encoding = this._getEncoding(opts)\n\n    try {\n      return await this._get(key, encoding)\n    } finally {\n      await this._closeSnapshot()\n    }\n  }\n\n  async _get (key, encoding) {\n    key = enc(encoding.key, key)\n\n    if (this.tree.extension !== null && this.options.extension !== false) {\n      this.options.onwait = this._onwait.bind(this, key)\n    }\n\n    let node = await this.getRoot(false)\n    if (!node) return null\n\n    while (true) {\n      if (node.block.isTarget(key)) {\n        return node.block.isDeletion() ? null : node.block.final(encoding)\n      }\n\n      let s = 0\n      let e = node.keys.length\n      let c\n\n      while (s < e) {\n        const mid = (s + e) >> 1\n\n        c = b4a.compare(key, await node.getKey(mid))\n\n        if (c === 0) return (await this.getBlock(node.keys[mid].seq)).final(encoding)\n\n        if (c < 0) e = mid\n        else s = mid + 1\n      }\n\n      if (!node.children.length) return null\n\n      const i = c < 0 ? e : s\n      node = await node.getChildNode(i)\n    }\n  }\n\n  async put (key, value, opts) {\n    const release = this.batchLock ? await this.batchLock() : null\n\n    const cas = (opts && opts.cas) || null\n    const encoding = this._getEncoding(opts)\n\n    if (!this.locked) await this.lock()\n    if (!release) return this._put(key, value, encoding, cas)\n\n    try {\n      return await this._put(key, value, encoding, cas)\n    } finally {\n      release()\n    }\n  }\n\n  async _put (key, value, encoding, cas) {\n    const newNode = {\n      seq: 0,\n      key,\n      value\n    }\n    key = enc(encoding.key, key)\n    value = enc(encoding.value, value)\n\n    const stack = []\n\n    let root\n    let node = root = await this.getRoot(true)\n    if (!node) node = root = TreeNode.create(null)\n\n    const seq = newNode.seq = this.core.length + this.length\n    const target = new Key(seq, key)\n\n    while (node.children.length) {\n      stack.push(node)\n      node.changed = true // changed, but compressible\n\n      let s = 0\n      let e = node.keys.length\n      let c\n\n      while (s < e) {\n        const mid = (s + e) >> 1\n        c = b4a.compare(target.value, await node.getKey(mid))\n\n        if (c === 0) {\n          if (cas) {\n            const prev = await node.getKeyNode(mid)\n            if (!(await cas(prev.final(encoding), newNode))) return this._unlockMaybe()\n          }\n          if (!this.tree.alwaysDuplicate) {\n            const prev = await node.getKeyNode(mid)\n            if (sameValue(prev.value, value)) return this._unlockMaybe()\n          }\n          node.setKey(mid, target)\n          return this._append(root, seq, key, value)\n        }\n\n        if (c < 0) e = mid\n        else s = mid + 1\n      }\n\n      const i = c < 0 ? e : s\n      node = await node.getChildNode(i)\n    }\n\n    let needsSplit = !(await node.insertKey(target, value, null, newNode, encoding, cas))\n    if (!node.changed) return this._unlockMaybe()\n\n    while (needsSplit) {\n      const parent = stack.pop()\n      const { median, right } = await node.split()\n\n      if (parent) {\n        needsSplit = !(await parent.insertKey(median, value, right, null, encoding, null))\n        node = parent\n      } else {\n        root = TreeNode.create(node.block)\n        root.changed = true\n        root.keys.push(median)\n        root.children.push(new Child(0, 0, node), new Child(0, 0, right))\n        needsSplit = false\n      }\n    }\n\n    return this._append(root, seq, key, value)\n  }\n\n  async del (key, opts) {\n    const release = this.batchLock ? await this.batchLock() : null\n    const cas = (opts && opts.cas) || null\n    const encoding = this._getEncoding(opts)\n\n    if (!this.locked) await this.lock()\n    if (!release) return this._del(key, encoding, cas)\n\n    try {\n      return await this._del(key, encoding, cas)\n    } finally {\n      release()\n    }\n  }\n\n  async _del (key, encoding, cas) {\n    const delNode = {\n      seq: 0,\n      key,\n      value: null\n    }\n\n    key = enc(encoding.key, key)\n\n    const stack = []\n\n    let node = await this.getRoot(true)\n    if (!node) return this._unlockMaybe()\n\n    const seq = delNode.seq = this.core.length + this.length\n\n    while (true) {\n      stack.push(node)\n\n      let s = 0\n      let e = node.keys.length\n      let c\n\n      while (s < e) {\n        const mid = (s + e) >> 1\n        c = b4a.compare(key, await node.getKey(mid))\n\n        if (c === 0) {\n          if (cas) {\n            const prev = await node.getKeyNode(mid)\n            if (!(await cas(prev.final(encoding), delNode))) return this._unlockMaybe()\n          }\n          if (node.children.length) await setKeyToNearestLeaf(node, mid, stack)\n          else node.removeKey(mid)\n          // we mark these as changed late, so we don't rewrite them if it is a 404\n          for (const node of stack) node.changed = true\n          return this._append(await rebalance(stack), seq, key, null)\n        }\n\n        if (c < 0) e = mid\n        else s = mid + 1\n      }\n\n      if (!node.children.length) return this._unlockMaybe()\n\n      const i = c < 0 ? e : s\n      node = await node.getChildNode(i)\n    }\n  }\n\n  async _closeSnapshot () {\n    if (this.isSnapshot) {\n      await this.core.close()\n      this._finalize()\n    }\n  }\n\n  async close () {\n    if (this.isSnapshot) return this._closeSnapshot()\n\n    this.root = null\n    if (this.blocks) this.blocks.clear()\n    this.length = 0\n    this._unlock()\n  }\n\n  destroy () { // compat, remove later\n    this.close().catch(noop)\n  }\n\n  toBlocks () {\n    if (this.appending) return this.appending\n\n    const batch = new Array(this.length)\n\n    for (let i = 0; i < this.length; i++) {\n      const seq = this.core.length + i\n      const { pendingIndex, key, value } = this.blocks.get(seq)\n\n      if (i < this.length - 1) {\n        pendingIndex[0] = null\n        let j = 0\n\n        while (j < pendingIndex.length) {\n          const idx = pendingIndex[j]\n          if (idx !== null && idx.seq === seq) {\n            idx.offset = j++\n            continue\n          }\n          if (j === pendingIndex.length - 1) pendingIndex.pop()\n          else pendingIndex[j] = pendingIndex.pop()\n        }\n      }\n\n      batch[i] = Node.encode({\n        key,\n        value,\n        index: deflate(pendingIndex)\n      })\n    }\n\n    this.appending = batch\n    return batch\n  }\n\n  flush () {\n    if (!this.length) return this.close()\n\n    const batch = this.toBlocks()\n\n    this.root = null\n    this.blocks.clear()\n    this.length = 0\n\n    return this._appendBatch(batch)\n  }\n\n  _unlockMaybe () {\n    if (this.autoFlush) this._unlock()\n  }\n\n  _unlock () {\n    const locked = this.locked\n    this.locked = null\n    if (locked !== null) locked()\n    this._finalize()\n  }\n\n  _finalize () {\n    // technically finalize can be called more than once, so here we just check if we already have been removed\n    if (this.index >= this.tree._batches.length || this.tree._batches[this.index] !== this) return\n    const top = this.tree._batches.pop()\n    if (top === this) return\n    top.index = this.index\n    this.tree._batches[top.index] = top\n  }\n\n  _append (root, seq, key, value) {\n    const index = []\n    root.indexChanges(index, seq)\n    index[0] = new Child(seq, 0, root)\n\n    if (!this.autoFlush) {\n      const block = new BatchEntry(seq, this, key, value, index)\n      root.block = block\n      this.root = root\n      this.length++\n      this.blocks.set(seq, block)\n\n      root.updateChildren(seq, block)\n      return\n    }\n\n    return this._appendBatch(Node.encode({\n      key,\n      value,\n      index: deflate(index)\n    }))\n  }\n\n  async _appendBatch (raw) {\n    try {\n      await this.core.append(raw)\n    } finally {\n      this._unlock()\n    }\n  }\n}\n\nclass EntryWatcher extends ReadyResource {\n  constructor (bee, key, opts = {}) {\n    super()\n\n    this.keyEncoding = opts.keyEncoding || bee.keyEncoding\n    this.valueEncoding = opts.valueEncoding || bee.valueEncoding\n\n    this.index = bee._entryWatchers.push(this) - 1\n    this.bee = bee\n\n    this.key = key\n    this.node = null\n\n    this._forceUpdate = false\n    this._debouncedUpdate = debounce(this._processUpdate.bind(this))\n    this._updateOnce = !!opts.updateOnce\n  }\n\n  _close () {\n    const top = this.bee._entryWatchers.pop()\n    if (top !== this) {\n      top.index = this.index\n      this.bee._entryWatchers[top.index] = top\n    }\n  }\n\n  _onappend () {\n    this._debouncedUpdate()\n  }\n\n  _ontruncate () {\n    this._forceUpdate = true\n    this._debouncedUpdate()\n  }\n\n  async _processUpdate () {\n    const force = this._forceUpdate\n    this._forceUpdate = false\n\n    if (this._updateOnce) {\n      this._updateOnce = false\n      await this.bee.update({ wait: true })\n    }\n\n    let newNode\n    try {\n      newNode = await this.bee.get(this.key, {\n        keyEncoding: this.keyEncoding,\n        valueEncoding: this.valueEncoding\n      })\n    } catch (e) {\n      if (e.code === 'SNAPSHOT_NOT_AVAILABLE') {\n        // There was a truncate event before the get resolved\n        // So this handler will run again anyway\n        return\n      } else if (this.bee.closing) {\n        this.close().catch(safetyCatch)\n        return\n      }\n      this.emit('error', e)\n      return\n    }\n\n    if (force || newNode?.seq !== this.node?.seq) {\n      this.node = newNode\n      this.emit('update')\n    }\n  }\n}\n\nclass Watcher extends ReadyResource {\n  constructor (bee, range, opts = {}) {\n    super()\n\n    this.keyEncoding = opts.keyEncoding || bee.keyEncoding\n    this.valueEncoding = opts.valueEncoding || bee.valueEncoding\n    this.index = bee._watchers.push(this) - 1\n    this.bee = bee\n    this.core = bee.core\n\n    this.latestDiff = 0\n    this.range = range\n    this.map = opts.map || defaultWatchMap\n\n    this.current = null\n    this.previous = null\n    this.currentMapped = null\n    this.previousMapped = null\n    this.stream = null\n\n    this._lock = mutexify()\n    this._flowing = false\n    this._resolveOnChange = null\n    this._differ = opts.differ || defaultDiffer\n    this._eager = !!opts.eager\n    this._updateOnce = !!opts.updateOnce\n    this._onchange = opts.onchange || null\n    this._flush = opts.flush !== false && this.core.isAutobase\n\n    this.on('newListener', autoFlowOnUpdate)\n\n    this.ready().catch(safetyCatch)\n  }\n\n  async _consume () {\n    if (this._flowing) return\n    try {\n      for await (const _ of this) {} // eslint-disable-line\n    } catch {}\n  }\n\n  async _open () {\n    await this.bee.ready()\n\n    const opts = {\n      keyEncoding: this.keyEncoding,\n      valueEncoding: this.valueEncoding\n    }\n\n    // Point from which to start watching\n    this.current = this._eager ? this.bee.checkout(1, opts) : this.bee.snapshot(opts)\n\n    if (this._onchange) {\n      if (this._eager) await this._onchange()\n      this._consume()\n    }\n  }\n\n  [Symbol.asyncIterator] () {\n    this._flowing = true\n    return this\n  }\n\n  _ontruncate () {\n    if (this.core.isAutobase) this._onappend()\n  }\n\n  _onappend () {\n    // TODO: this is a light hack / fix for non-sparse session reporting .length's inside batches\n    // the better solution is propably just to change non-sparse sessions to not report a fake length\n    if (!this.closing && !this.core.isAutobase && (!this.core.core || this.core.core.tree.length !== this.core.length)) return\n\n    const resolve = this._resolveOnChange\n    this._resolveOnChange = null\n    if (resolve) resolve()\n  }\n\n  async _waitForChanges () {\n    if (this.current.version < this.bee.version || this.closing) return\n\n    await new Promise(resolve => {\n      this._resolveOnChange = resolve\n    })\n  }\n\n  async next () {\n    try {\n      return await this._next()\n    } catch (err) {\n      if (this.closing) return { value: undefined, done: true }\n      await this.close()\n      throw err\n    }\n  }\n\n  async _next () {\n    const release = await this._lock()\n\n    try {\n      if (this.closing) return { value: undefined, done: true }\n\n      if (!this.opened) await this.ready()\n\n      while (true) {\n        await this._waitForChanges()\n\n        if (this.closing) return { value: undefined, done: true }\n\n        if (this._updateOnce) {\n          this._updateOnce = false\n          await this.bee.update({ wait: true })\n        }\n\n        if (this._flush) await this.core.base.flush()\n        if (this.closing) return { value: undefined, done: true }\n\n        await this._closePrevious()\n        this.previous = this.current.snapshot()\n\n        await this._closeCurrent()\n        this.current = this.bee.snapshot({\n          keyEncoding: this.keyEncoding,\n          valueEncoding: this.valueEncoding\n        })\n\n        if (this.current.core.fork !== this.previous.core.fork) {\n          return await this._yield()\n        }\n\n        this.stream = this._differ(this.current, this.previous, this.range)\n\n        try {\n          for await (const data of this.stream) { // eslint-disable-line\n            return await this._yield()\n          }\n        } finally {\n          this.stream = null\n        }\n      }\n    } finally {\n      release()\n    }\n  }\n\n  async _yield () {\n    this.currentMapped = this.map(this.current)\n    this.previousMapped = this.map(this.previous)\n\n    if (this._onchange) {\n      try {\n        await this._onchange()\n      } catch (err) {\n        safetyCatch(err)\n      }\n    }\n\n    this.emit('update')\n    return { done: false, value: [this.currentMapped, this.previousMapped] }\n  }\n\n  async return () {\n    await this.close()\n    return { done: true }\n  }\n\n  async _close () {\n    const top = this.bee._watchers.pop()\n    if (top !== this) {\n      top.index = this.index\n      this.bee._watchers[top.index] = top\n    }\n\n    if (this.stream && !this.stream.destroying) {\n      this.stream.destroy()\n    }\n\n    this._onappend() // Continue execution being closed\n\n    await this._closeCurrent().catch(safetyCatch)\n    await this._closePrevious().catch(safetyCatch)\n\n    const release = await this._lock()\n    release()\n  }\n\n  destroy () {\n    return this.close()\n  }\n\n  async _closeCurrent () {\n    if (this.currentMapped) await this.currentMapped.close()\n    if (this.current) await this.current.close()\n    this.current = this.currentMapped = null\n  }\n\n  async _closePrevious () {\n    if (this.previousMapped) await this.previousMapped.close()\n    if (this.previous) await this.previous.close()\n    this.previous = this.previousMapped = null\n  }\n}\n\nfunction autoFlowOnUpdate (name) {\n  if (name === 'update') this._consume()\n}\n\nfunction defaultWatchMap (snapshot) {\n  return snapshot\n}\n\nasync function leafSize (node, goLeft) {\n  while (node.children.length) node = await node.getChildNode(goLeft ? 0 : node.children.length - 1)\n  return node.keys.length\n}\n\nasync function setKeyToNearestLeaf (node, index, stack) {\n  let [left, right] = await Promise.all([node.getChildNode(index), node.getChildNode(index + 1)])\n  const [ls, rs] = await Promise.all([leafSize(left, false), leafSize(right, true)])\n\n  if (ls < rs) { // if fewer leaves on the left\n    stack.push(right)\n    while (right.children.length) stack.push(right = right.children[0].value)\n    node.keys[index] = right.keys.shift()\n  } else { // if fewer leaves on the right\n    stack.push(left)\n    while (left.children.length) stack.push(left = left.children[left.children.length - 1].value)\n    node.keys[index] = left.keys.pop()\n  }\n}\n\nasync function rebalance (stack) {\n  const root = stack[0]\n\n  while (stack.length > 1) {\n    const node = stack.pop()\n    const parent = stack[stack.length - 1]\n\n    if (node.keys.length >= MIN_KEYS) return root\n\n    let { left, index, right } = await node.siblings(parent)\n\n    // maybe borrow from left sibling?\n    if (left && left.keys.length > MIN_KEYS) {\n      left.changed = true\n      node.keys.unshift(parent.keys[index - 1])\n      if (left.children.length) node.children.unshift(left.children.pop())\n      parent.keys[index - 1] = left.keys.pop()\n      return root\n    }\n\n    // maybe borrow from right sibling?\n    if (right && right.keys.length > MIN_KEYS) {\n      right.changed = true\n      node.keys.push(parent.keys[index])\n      if (right.children.length) node.children.push(right.children.shift())\n      parent.keys[index] = right.keys.shift()\n      return root\n    }\n\n    // merge node with another sibling\n    if (left) {\n      index--\n      right = node\n    } else {\n      left = node\n    }\n\n    left.merge(right, parent.keys[index])\n    parent.removeKey(index)\n  }\n\n  // check if the tree shrunk\n  if (!root.keys.length && root.children.length) return root.getChildNode(0)\n  return root\n}\n\nfunction iteratorToStream (ite, signal) {\n  let done\n  let closing\n\n  const rs = new Readable({\n    signal,\n    open (cb) {\n      done = cb\n      ite.open().then(fin, fin)\n    },\n    read (cb) {\n      done = cb\n      ite.next().then(push, fin)\n    },\n    predestroy () {\n      closing = ite.close()\n      closing.catch(noop)\n    },\n    destroy (cb) {\n      done = cb\n      if (!closing) closing = ite.close()\n      closing.then(fin, fin)\n    }\n  })\n\n  return rs\n\n  function fin (err) {\n    done(err)\n  }\n\n  function push (val) {\n    rs.push(val)\n    done(null)\n  }\n}\n\nasync function iteratorPeek (ite) {\n  try {\n    await ite.open()\n    return await ite.next()\n  } finally {\n    await ite.close()\n  }\n}\n\nfunction encRange (e, opts) {\n  if (!e) return opts\n\n  if (e.encodeRange) {\n    const r = e.encodeRange({ gt: opts.gt, gte: opts.gte, lt: opts.lt, lte: opts.lte })\n    opts.gt = r.gt\n    opts.gte = r.gte\n    opts.lt = r.lt\n    opts.lte = r.lte\n    return opts\n  }\n\n  if (opts.gt !== undefined) opts.gt = enc(e, opts.gt)\n  if (opts.gte !== undefined) opts.gte = enc(e, opts.gte)\n  if (opts.lt !== undefined) opts.lt = enc(e, opts.lt)\n  if (opts.lte !== undefined) opts.lte = enc(e, opts.lte)\n  if (opts.sub && !opts.gt && !opts.gte) opts.gt = enc(e, SEP)\n  if (opts.sub && !opts.lt && !opts.lte) opts.lt = bump(enc(e, EMPTY))\n\n  return opts\n}\n\nfunction bump (key) {\n  // key should have been copied by enc above before hitting this\n  key[key.length - 1]++\n  return key\n}\n\nfunction enc (e, v) {\n  if (v === undefined || v === null) return null\n  if (e !== null) return e.encode(v)\n  if (typeof v === 'string') return b4a.from(v)\n  return v\n}\n\nfunction prefixEncoding (prefix, keyEncoding) {\n  return {\n    encode (key) {\n      return b4a.concat([prefix, b4a.isBuffer(key) ? key : enc(keyEncoding, key)])\n    },\n    decode (key) {\n      const sliced = key.slice(prefix.length, key.length)\n      return keyEncoding ? keyEncoding.decode(sliced) : sliced\n    }\n  }\n}\n\nfunction copyEntry (entry) {\n  let key = entry.key\n  let value = entry.value\n  let index = entry.index\n\n  // key, value and index all refer to the same buffer (one hypercore block)\n  // If together they are larger than half the buffer's byteLength,\n  // this means that they got their own private slab (see Buffer.allocUnsafe docs)\n  // so no need to unslab\n  const size = key.byteLength + (value === null ? 0 : value.byteLength) + (index === null ? 0 : index.byteLength)\n  if (2 * size < key.buffer.byteLength) {\n    const [newKey, newValue, newIndex] = unslabAll([entry.key, entry.value, entry.index])\n    key = newKey\n    value = newValue\n    index = newIndex\n  }\n\n  return {\n    key,\n    value,\n    index,\n    inflated: null\n  }\n}\n\nfunction defaultDiffer (currentSnap, previousSnap, opts) {\n  return currentSnap.createDiffStream(previousSnap, opts)\n}\n\nfunction getBackingCore (core) {\n  if (core._source) return core._source.originalCore\n  if (core.flush) return core.session\n  return core\n}\n\nfunction getIndexedLength (core) {\n  if (core._source) return core._source.core.indexedLength\n  if (core.flush) return core.indexedLength\n  return core.length\n}\n\nfunction sameValue (a, b) {\n  return a === b || (a !== null && b !== null && b4a.equals(a, b))\n}\n\nfunction noop () {}\n\nmodule.exports = Hyperbee\nconst b4a = require('b4a')\n\nclass SubTree {\n  constructor (node, parent) {\n    this.node = node\n    this.parent = parent\n\n    this.isKey = node.children.length === 0\n    this.i = this.isKey ? 1 : 0\n    this.n = 0\n\n    const child = this.isKey ? null : this.node.children[0]\n    this.seq = child !== null ? child.seq : this.node.keys[0].seq\n    this.offset = child !== null ? child.offset : 0\n  }\n\n  next () {\n    this.i++\n    this.isKey = (this.i & 1) === 1\n    if (!this.isKey && !this.node.children.length) this.i++\n    return this.update()\n  }\n\n  async bisect (key, incl) {\n    let s = 0\n    let e = this.node.keys.length\n    let c\n\n    while (s < e) {\n      const mid = (s + e) >> 1\n      c = cmp(key, await this.node.getKey(mid))\n\n      if (c === 0) {\n        if (incl) this.i = mid * 2 + 1\n        else this.i = mid * 2 + (this.node.children.length ? 2 : 3)\n        return true\n      }\n\n      if (c < 0) e = mid\n      else s = mid + 1\n    }\n\n    const i = c < 0 ? e : s\n    this.i = 2 * i + (this.node.children.length ? 0 : 1)\n    return this.node.children.length === 0\n  }\n\n  update () {\n    this.isKey = (this.i & 1) === 1\n    this.n = this.i >> 1\n    if (this.n >= (this.isKey ? this.node.keys.length : this.node.children.length)) return false\n    const child = this.isKey ? null : this.node.children[this.n]\n    this.seq = child !== null ? child.seq : this.node.keys[this.n].seq\n    this.offset = child !== null ? child.offset : 0\n    return true\n  }\n\n  async key () {\n    return this.n < this.node.keys.length ? this.node.getKey(this.n) : (this.parent && this.parent.key())\n  }\n\n  async compare (tree) {\n    const [a, b] = await Promise.all([this.key(), tree.key()])\n    return cmp(a, b)\n  }\n}\n\nclass TreeIterator {\n  constructor (batch, opts) {\n    this.batch = batch\n    this.stack = []\n    this.lt = opts.lt || opts.lte || null\n    this.lte = !!opts.lte\n    this.gt = opts.gt || opts.gte || null\n    this.gte = !!opts.gte\n    this.seeking = !!this.gt\n    this.encoding = opts.encoding || batch.encoding\n  }\n\n  async open () {\n    const node = await this.batch.getRoot(false)\n    if (!node || !node.keys.length) return\n    const tree = new SubTree(node, null)\n    if (this.seeking && !(await this._seek(tree))) return\n    this.stack.push(tree)\n  }\n\n  async _seek (tree) {\n    const done = await tree.bisect(this.gt, this.gte)\n    const oob = !tree.update()\n    if (done || oob) {\n      this.seeking = false\n      if (oob) return false\n    }\n    return true\n  }\n\n  peek () {\n    if (!this.stack.length) return null\n    return this.stack[this.stack.length - 1]\n  }\n\n  skip () {\n    if (!this.stack.length) return\n    if (!this.stack[this.stack.length - 1].next()) this.stack.pop()\n  }\n\n  async nextKey () {\n    let n = null\n    while (this.stack.length && n === null) n = await this.next()\n    if (n === null) return null\n    if (!this.lt) return n.final(this.encoding)\n\n    const c = cmp(n.key, this.lt)\n    if (this.lte ? c <= 0 : c < 0) return n.final(this.encoding)\n    this.stack = []\n    return null\n  }\n\n  async next () {\n    if (!this.stack.length) return null\n\n    const top = this.stack[this.stack.length - 1]\n    const { isKey, n, seq } = top\n\n    if (!top.next()) {\n      this.stack.pop()\n    }\n\n    if (isKey) {\n      this.seeking = false\n      return this.batch.getBlock(seq)\n    }\n\n    const child = await top.node.getChildNode(n)\n    top.node.children[n] = null // unlink to save memory\n    const tree = new SubTree(child, top)\n    if (this.seeking && !(await this._seek(tree))) return null\n    this.stack.push(tree)\n\n    return null\n  }\n\n  close () {\n    return this.batch._closeSnapshot()\n  }\n}\n\nmodule.exports = class DiffIterator {\n  constructor (left, right, opts = {}) {\n    this.left = new TreeIterator(left, opts)\n    this.right = new TreeIterator(right, opts)\n    this.limit = typeof opts.limit === 'number' ? opts.limit : -1\n  }\n\n  async open () {\n    await Promise.all([this.left.open(), this.right.open()])\n  }\n\n  async next () {\n    if (this.limit === 0) return null\n    const res = await this._next()\n    if (!res || (res.left === null && res.right === null)) return null\n    this.limit--\n    return res\n  }\n\n  async _next () {\n    const a = this.left\n    const b = this.right\n\n    while (true) {\n      const [l, r] = await Promise.all([a.peek(), b.peek()])\n\n      if (!l && !r) return null\n      if (!l) return { left: null, right: await b.nextKey() }\n      if (!r) return { left: await a.nextKey(), right: null }\n\n      if (l.seq === r.seq && l.isKey === r.isKey && l.offset === r.offset) {\n        a.skip()\n        b.skip()\n        continue\n      }\n\n      const c = await l.compare(r)\n\n      if (l.isKey && !r.isKey) {\n        await b.next()\n        continue\n      }\n\n      if (!l.isKey && r.isKey) {\n        await a.next()\n        continue\n      }\n\n      if (l.isKey && r.isKey) {\n        if (c === 0) return { left: await a.nextKey(), right: await b.nextKey() }\n        if (c < 0) return { left: await a.nextKey(), right: null }\n        return { left: null, right: await b.nextKey() }\n      }\n\n      if (c === 0) await Promise.all([a.next(), b.next()])\n      else if (c < 0) await b.next()\n      else await a.next()\n    }\n  }\n\n  async close () {\n    await Promise.all([this.left.close(), this.right.close()])\n  }\n}\n\nfunction cmp (a, b) {\n  if (!a) return b ? 1 : 0\n  if (!b) return a ? -1 : 0\n  return b4a.compare(a, b)\n}\nmodule.exports = class HistoryIterator {\n  constructor (batch, opts = {}) {\n    this.batch = batch\n    this.options = opts\n    this.live = !!opts.live\n    this.gte = 0\n    this.lt = 0\n    this.reverse = !!opts.reverse\n    this.limit = typeof opts.limit === 'number' ? opts.limit : -1\n    this.encoding = opts.encoding || batch.encoding\n    if (this.live && this.reverse) {\n      throw new Error('Cannot have both live and reverse enabled')\n    }\n  }\n\n  async open () {\n    await this.batch.getRoot(false) // does the update dance\n    this.gte = gte(this.options, this.batch.version)\n    this.lt = this.live ? Infinity : lt(this.options, this.batch.version)\n  }\n\n  async next () {\n    if (this.limit === 0) return null\n    if (this.limit > 0) this.limit--\n\n    if (this.gte >= this.lt) return null\n\n    if (this.reverse) {\n      if (this.lt <= 1) return null\n      return final(await this.batch.getBlock(--this.lt), this.encoding)\n    }\n\n    return final(await this.batch.getBlock(this.gte++), this.encoding)\n  }\n\n  close () {\n    return this.batch._closeSnapshot()\n  }\n}\n\nfunction final (node, encoding) {\n  const type = node.isDeletion() ? 'del' : 'put'\n  return { type, ...node.final(encoding) }\n}\n\nfunction gte (opts, version) {\n  if (opts.gt) return (opts.gt < 0 ? (opts.gt + version) : opts.gt) + 1\n  const gte = opts.gte || opts.since || 1\n  return gte < 0 ? gte + version : gte\n}\n\nfunction lt (opts, version) {\n  if (opts.lte === 0 || opts.lt === 0 || opts.end === 0) return 0\n  if (opts.lte) return (opts.lte < 0 ? (opts.lte + version) : opts.lte) + 1\n  const lt = opts.lt || opts.end || version\n  return lt < 0 ? lt + version : lt\n}\nconst b4a = require('b4a')\n\nmodule.exports = class RangeIterator {\n  constructor (batch, encoding, opts = {}) {\n    this.batch = batch\n    this.stack = []\n    this.opened = false\n    this.encoding = encoding || batch.encoding\n\n    this._limit = typeof opts.limit === 'number' ? opts.limit : -1\n    this._gIncl = !opts.gt\n    this._gKey = opts.gt || opts.gte || null\n    this._lIncl = !opts.lt\n    this._lKey = opts.lt || opts.lte || null\n    this._reverse = !!opts.reverse\n    this._version = 0\n    this._checkpoint = (opts.checkpoint && opts.checkpoint.length) ? opts.checkpoint : null\n    this._nexting = false\n  }\n\n  snapshot (version = this.batch.version) {\n    const checkpoint = []\n    for (const s of this.stack) {\n      let { node, i } = s\n      if (this._nexting && s === this.stack[this.stack.length - 1]) i = this._reverse ? i + 1 : i - 1\n      if (!node.block) continue\n      if (i < 0) continue\n      checkpoint.push(node.block.seq, node.offset, i)\n    }\n\n    return {\n      version,\n      gte: this._gIncl ? this._gKey : null,\n      gt: this._gIncl ? null : this._gKey,\n      lte: this._lIncl ? this._lKey : null,\n      lt: this._lIncl ? null : this._lKey,\n      limit: this._limit,\n      reverse: this._reverse,\n      ended: this.opened && !checkpoint.length,\n      checkpoint: this.opened ? checkpoint : []\n    }\n  }\n\n  async open () {\n    await this._open()\n    this.opened = true\n  }\n\n  async _open () {\n    if (this._checkpoint) {\n      for (let j = 0; j < this._checkpoint.length; j += 3) {\n        const seq = this._checkpoint[j]\n        const offset = this._checkpoint[j + 1]\n        const i = this._checkpoint[j + 2]\n        this.stack.push({\n          node: (await this.batch.getBlock(seq)).getTreeNode(offset),\n          i\n        })\n      }\n      return\n    }\n\n    this._nexting = true\n\n    let node = await this.batch.getRoot(false)\n    if (!node) {\n      this._nexting = false\n      return\n    }\n\n    const incl = this._reverse ? this._lIncl : this._gIncl\n    const start = this._reverse ? this._lKey : this._gKey\n\n    if (!start) {\n      this.stack.push({ node, i: this._reverse ? node.keys.length << 1 : 0 })\n      this._nexting = false\n      return\n    }\n\n    while (true) {\n      const entry = { node, i: this._reverse ? node.keys.length << 1 : 0 }\n\n      let s = 0\n      let e = node.keys.length\n      let c\n\n      while (s < e) {\n        const mid = (s + e) >> 1\n        c = b4a.compare(start, await node.getKey(mid))\n\n        if (c === 0) {\n          if (incl) entry.i = mid * 2 + 1\n          else entry.i = mid * 2 + (this._reverse ? 0 : 2)\n          this.stack.push(entry)\n          this._nexting = false\n          return\n        }\n\n        if (c < 0) e = mid\n        else s = mid + 1\n      }\n\n      const i = c < 0 ? e : s\n      entry.i = 2 * i + (this._reverse ? -1 : 1)\n\n      if (entry.i >= 0 && entry.i <= (node.keys.length << 1)) this.stack.push(entry)\n      if (!node.children.length) {\n        this._nexting = false\n        return\n      }\n\n      node = await node.getChildNode(i)\n    }\n  }\n\n  async next () {\n    // TODO: this nexting flag is only needed if someone asks for a snapshot during\n    // a lookup (ie the extension, pretty important...).\n    // A better solution would be to refactor this so top.i is incremented eagerly\n    // to get the current block instead of the way it is done now (++i vs i++)\n    this._nexting = true\n\n    const end = this._reverse ? this._gKey : this._lKey\n    const incl = this._reverse ? this._gIncl : this._lIncl\n\n    while (this.stack.length && (this._limit === -1 || this._limit > 0)) {\n      const top = this.stack[this.stack.length - 1]\n      const isKey = (top.i & 1) === 1\n      const n = this._reverse\n        ? (top.i < 0 ? top.node.keys.length : top.i-- >> 1)\n        : top.i++ >> 1\n\n      if (!isKey) {\n        if (!top.node.children.length) continue\n        const node = await top.node.getChildNode(n)\n        if (top.node.block.seq < this.batch.core.length) {\n          top.node.children[n].value = null // unlink it to save memory\n        }\n        this.stack.push({ i: this._reverse ? node.keys.length << 1 : 0, node })\n        continue\n      }\n\n      if (n >= top.node.keys.length) {\n        this.stack.pop()\n        continue\n      }\n\n      const key = top.node.keys[n]\n      const block = await this.batch.getBlock(key.seq)\n      if (end) {\n        const c = b4a.compare(block.key, end)\n        if (c === 0 ? !incl : (this._reverse ? c < 0 : c > 0)) {\n          this._limit = 0\n          break\n        }\n      }\n      if (this._limit > 0) this._limit--\n      this._nexting = false\n      return block.final(this.encoding)\n    }\n\n    this._nexting = false\n    return null\n  }\n\n  close () {\n    return this.batch._closeSnapshot()\n  }\n}\nconst { Extension } = require('./messages')\n\n// const MAX_ACTIVE = 32\nconst FLUSH_BATCH = 128\nconst MAX_PASSIVE_BATCH = 2048\nconst MAX_ACTIVE_BATCH = MAX_PASSIVE_BATCH + FLUSH_BATCH\n\nclass Batch {\n  constructor (outgoing, from) {\n    this.blocks = []\n    this.start = 0\n    this.end = 0\n    this.outgoing = outgoing\n    this.from = from\n  }\n\n  push (seq) {\n    const len = this.blocks.push(seq)\n    if (len === 1 || seq < this.start) this.start = seq\n    if (len === 1 || seq >= this.end) this.end = seq + 1\n    if (len >= FLUSH_BATCH) {\n      this.send()\n      this.clear()\n    }\n  }\n\n  send () {\n    if (!this.blocks.length) return\n    this.outgoing.send(Extension.encode({ cache: { blocks: this.blocks, start: this.start, end: this.end } }), this.from)\n  }\n\n  clear () {\n    this.start = this.end = 0\n    this.blocks = []\n  }\n}\n\nclass HyperbeeExtension {\n  constructor (db) {\n    this.encoding = null\n    this.outgoing = null\n    this.db = db\n    this.active = 0\n  }\n\n  get (version, key) {\n    this.outgoing.broadcast(Extension.encode({ get: { version, key } }))\n  }\n\n  iterator (snapshot) {\n    if (snapshot.ended) return\n    if (snapshot.limit === 0) return\n    if (snapshot.limit === -1) snapshot.limit = 0\n    this.outgoing.broadcast(Extension.encode({ iterator: snapshot }))\n  }\n\n  onmessage (buf, from) {\n    // TODO: handle max active extension messages\n    // this.active++\n\n    const message = decode(buf)\n    if (!message) return\n\n    if (message.cache) this.oncache(message.cache, from)\n    if (message.get) this.onget(message.get, from)\n    if (message.iterator) this.oniterator(message.iterator, from)\n  }\n\n  oncache (message, from) {\n    if (!message.blocks.length) return\n    this.db.core.download(message)\n  }\n\n  onget (message, from) {\n    if (!message.version || message.version > this.db.version) return\n\n    const b = new Batch(this.outgoing, from)\n    const db = this.db.checkout(message.version)\n\n    db.get(message.key, { extension: false, wait: false, update: false, onseq }).then(done, done)\n\n    function done () {\n      db.close().catch(noop)\n      b.send()\n    }\n\n    function onseq (seq) {\n      b.push(seq)\n    }\n  }\n\n  async oniterator (message, from) {\n    if (!message.version || message.version > this.db.version) return\n\n    const b = new Batch(this.outgoing, from)\n    const seqs = new Set()\n\n    let skip = message.checkpoint.length\n    let work = 0\n\n    const db = this.db.checkout(message.version)\n    const ite = db.createRangeIterator({\n      ...message,\n      wait: false,\n      extension: false,\n      update: false,\n      limit: message.limit === 0 ? -1 : message.limit,\n      onseq (seq) {\n        if (skip && skip--) return\n        if (seqs.has(seq)) return\n        work++\n        seqs.add(seq)\n        b.push(seq)\n      }\n    })\n\n    try {\n      await ite.open()\n      // eslint-disable-next-line no-unmodified-loop-condition\n      while (work < MAX_ACTIVE_BATCH) {\n        if (!(await ite.next())) break\n      }\n    } catch (_) {\n      // do nothing\n    } finally {\n      ite.close().catch(noop)\n      db.close().catch(noop)\n      b.send()\n    }\n  }\n\n  static register (db) {\n    const e = new this(db)\n    e.outgoing = db.core.registerExtension('hyperbee', e)\n    return e\n  }\n}\n\nHyperbeeExtension.BATCH_SIZE = MAX_PASSIVE_BATCH\n\nmodule.exports = HyperbeeExtension\n\nfunction decode (buf) {\n  try {\n    return Extension.decode(buf)\n  } catch (err) {\n    return null\n  }\n}\n\nfunction noop () {}\n// This file is auto generated by the protocol-buffers compiler\n\n/* eslint-disable quotes */\n/* eslint-disable indent */\n/* eslint-disable no-redeclare */\n/* eslint-disable camelcase */\n/* eslint-disable no-var */\n\n// Remember to `npm install --save protocol-buffers-encodings`\nvar encodings = require('protocol-buffers-encodings')\nvar b4a = require('b4a')\nvar varint = encodings.varint\nvar skip = encodings.skip\n\nvar YoloIndex = exports.YoloIndex = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Header = exports.Header = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Node = exports.Node = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Extension = exports.Extension = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\ndefineYoloIndex()\ndefineHeader()\ndefineNode()\ndefineExtension()\n\nfunction defineYoloIndex () {\n  var Level = YoloIndex.Level = {\n    buffer: true,\n    encodingLength: null,\n    encode: null,\n    decode: null\n  }\n\n  defineLevel()\n\n  function defineLevel () {\n    Level.encodingLength = encodingLength\n    Level.encode = encode\n    Level.decode = decode\n\n    function encodingLength (obj) {\n      var length = 0\n      if (defined(obj.keys)) {\n        var packedLen = 0\n        for (var i = 0; i < obj.keys.length; i++) {\n          if (!defined(obj.keys[i])) continue\n          var len = encodings.varint.encodingLength(obj.keys[i])\n          packedLen += len\n        }\n        if (packedLen) {\n          length += 1 + packedLen + varint.encodingLength(packedLen)\n        }\n      }\n      if (defined(obj.children)) {\n        var packedLen = 0\n        for (var i = 0; i < obj.children.length; i++) {\n          if (!defined(obj.children[i])) continue\n          var len = encodings.varint.encodingLength(obj.children[i])\n          packedLen += len\n        }\n        if (packedLen) {\n          length += 1 + packedLen + varint.encodingLength(packedLen)\n        }\n      }\n      return length\n    }\n\n    function encode (obj, buf, offset) {\n      if (!offset) offset = 0\n      if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))\n      var oldOffset = offset\n      if (defined(obj.keys)) {\n        var packedLen = 0\n        for (var i = 0; i < obj.keys.length; i++) {\n          if (!defined(obj.keys[i])) continue\n          packedLen += encodings.varint.encodingLength(obj.keys[i])\n        }\n        if (packedLen) {\n          buf[offset++] = 10\n          varint.encode(packedLen, buf, offset)\n          offset += varint.encode.bytes\n        }\n        for (var i = 0; i < obj.keys.length; i++) {\n          if (!defined(obj.keys[i])) continue\n          encodings.varint.encode(obj.keys[i], buf, offset)\n          offset += encodings.varint.encode.bytes\n        }\n      }\n      if (defined(obj.children)) {\n        var packedLen = 0\n        for (var i = 0; i < obj.children.length; i++) {\n          if (!defined(obj.children[i])) continue\n          packedLen += encodings.varint.encodingLength(obj.children[i])\n        }\n        if (packedLen) {\n          buf[offset++] = 18\n          varint.encode(packedLen, buf, offset)\n          offset += varint.encode.bytes\n        }\n        for (var i = 0; i < obj.children.length; i++) {\n          if (!defined(obj.children[i])) continue\n          encodings.varint.encode(obj.children[i], buf, offset)\n          offset += encodings.varint.encode.bytes\n        }\n      }\n      encode.bytes = offset - oldOffset\n      return buf\n    }\n\n    function decode (buf, offset, end) {\n      if (!offset) offset = 0\n      if (!end) end = buf.length\n      if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n      var oldOffset = offset\n      var obj = {\n        keys: [],\n        children: []\n      }\n      while (true) {\n        if (end <= offset) {\n          decode.bytes = offset - oldOffset\n          return obj\n        }\n        var prefix = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        var tag = prefix >> 3\n        switch (tag) {\n          case 1:\n          var packedEnd = varint.decode(buf, offset)\n          offset += varint.decode.bytes\n          packedEnd += offset\n          while (offset < packedEnd) {\n            obj.keys.push(encodings.varint.decode(buf, offset))\n            offset += encodings.varint.decode.bytes\n          }\n          break\n          case 2:\n          var packedEnd = varint.decode(buf, offset)\n          offset += varint.decode.bytes\n          packedEnd += offset\n          while (offset < packedEnd) {\n            obj.children.push(encodings.varint.decode(buf, offset))\n            offset += encodings.varint.decode.bytes\n          }\n          break\n          default:\n          offset = skip(prefix & 7, buf, offset)\n        }\n      }\n    }\n  }\n\n  YoloIndex.encodingLength = encodingLength\n  YoloIndex.encode = encode\n  YoloIndex.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.levels)) {\n      for (var i = 0; i < obj.levels.length; i++) {\n        if (!defined(obj.levels[i])) continue\n        var len = Level.encodingLength(obj.levels[i])\n        length += varint.encodingLength(len)\n        length += 1 + len\n      }\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.levels)) {\n      for (var i = 0; i < obj.levels.length; i++) {\n        if (!defined(obj.levels[i])) continue\n        buf[offset++] = 10\n        varint.encode(Level.encodingLength(obj.levels[i]), buf, offset)\n        offset += varint.encode.bytes\n        Level.encode(obj.levels[i], buf, offset)\n        offset += Level.encode.bytes\n      }\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      levels: []\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        var len = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        obj.levels.push(Level.decode(buf, offset, offset + len))\n        offset += Level.decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineHeader () {\n  var Metadata = Header.Metadata = {\n    buffer: true,\n    encodingLength: null,\n    encode: null,\n    decode: null\n  }\n\n  defineMetadata()\n\n  function defineMetadata () {\n    Metadata.encodingLength = encodingLength\n    Metadata.encode = encode\n    Metadata.decode = decode\n\n    function encodingLength (obj) {\n      var length = 0\n      if (defined(obj.contentFeed)) {\n        var len = encodings.bytes.encodingLength(obj.contentFeed)\n        length += 1 + len\n      }\n      if (defined(obj.userData)) {\n        var len = encodings.bytes.encodingLength(obj.userData)\n        length += 1 + len\n      }\n      return length\n    }\n\n    function encode (obj, buf, offset) {\n      if (!offset) offset = 0\n      if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))\n      var oldOffset = offset\n      if (defined(obj.contentFeed)) {\n        buf[offset++] = 10\n        encodings.bytes.encode(obj.contentFeed, buf, offset)\n        offset += encodings.bytes.encode.bytes\n      }\n      if (defined(obj.userData)) {\n        buf[offset++] = 18\n        encodings.bytes.encode(obj.userData, buf, offset)\n        offset += encodings.bytes.encode.bytes\n      }\n      encode.bytes = offset - oldOffset\n      return buf\n    }\n\n    function decode (buf, offset, end) {\n      if (!offset) offset = 0\n      if (!end) end = buf.length\n      if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n      var oldOffset = offset\n      var obj = {\n        contentFeed: null,\n        userData: null\n      }\n      while (true) {\n        if (end <= offset) {\n          decode.bytes = offset - oldOffset\n          return obj\n        }\n        var prefix = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        var tag = prefix >> 3\n        switch (tag) {\n          case 1:\n          obj.contentFeed = encodings.bytes.decode(buf, offset)\n          offset += encodings.bytes.decode.bytes\n          break\n          case 2:\n          obj.userData = encodings.bytes.decode(buf, offset)\n          offset += encodings.bytes.decode.bytes\n          break\n          default:\n          offset = skip(prefix & 7, buf, offset)\n        }\n      }\n    }\n  }\n\n  Header.encodingLength = encodingLength\n  Header.encode = encode\n  Header.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.protocol)) throw new Error(\"protocol is required\")\n    var len = encodings.string.encodingLength(obj.protocol)\n    length += 1 + len\n    if (defined(obj.metadata)) {\n      var len = Metadata.encodingLength(obj.metadata)\n      length += varint.encodingLength(len)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.protocol)) throw new Error(\"protocol is required\")\n    buf[offset++] = 10\n    encodings.string.encode(obj.protocol, buf, offset)\n    offset += encodings.string.encode.bytes\n    if (defined(obj.metadata)) {\n      buf[offset++] = 18\n      varint.encode(Metadata.encodingLength(obj.metadata), buf, offset)\n      offset += varint.encode.bytes\n      Metadata.encode(obj.metadata, buf, offset)\n      offset += Metadata.encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      protocol: \"\",\n      metadata: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.protocol = encodings.string.decode(buf, offset)\n        offset += encodings.string.decode.bytes\n        found0 = true\n        break\n        case 2:\n        var len = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        obj.metadata = Metadata.decode(buf, offset, offset + len)\n        offset += Metadata.decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineNode () {\n  Node.encodingLength = encodingLength\n  Node.encode = encode\n  Node.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = encodings.bytes.encodingLength(obj.index)\n    length += 1 + len\n    if (!defined(obj.key)) throw new Error(\"key is required\")\n    var len = encodings.bytes.encodingLength(obj.key)\n    length += 1 + len\n    if (defined(obj.value)) {\n      var len = encodings.bytes.encodingLength(obj.value)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 10\n    encodings.bytes.encode(obj.index, buf, offset)\n    offset += encodings.bytes.encode.bytes\n    if (!defined(obj.key)) throw new Error(\"key is required\")\n    buf[offset++] = 18\n    encodings.bytes.encode(obj.key, buf, offset)\n    offset += encodings.bytes.encode.bytes\n    if (defined(obj.value)) {\n      buf[offset++] = 26\n      encodings.bytes.encode(obj.value, buf, offset)\n      offset += encodings.bytes.encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: null,\n      key: null,\n      value: null\n    }\n    var found0 = false\n    var found1 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0 || !found1) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = encodings.bytes.decode(buf, offset)\n        offset += encodings.bytes.decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.key = encodings.bytes.decode(buf, offset)\n        offset += encodings.bytes.decode.bytes\n        found1 = true\n        break\n        case 3:\n        obj.value = encodings.bytes.decode(buf, offset)\n        offset += encodings.bytes.decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineExtension () {\n  var Get = Extension.Get = {\n    buffer: true,\n    encodingLength: null,\n    encode: null,\n    decode: null\n  }\n\n  var Iterator = Extension.Iterator = {\n    buffer: true,\n    encodingLength: null,\n    encode: null,\n    decode: null\n  }\n\n  var Cache = Extension.Cache = {\n    buffer: true,\n    encodingLength: null,\n    encode: null,\n    decode: null\n  }\n\n  defineGet()\n  defineIterator()\n  defineCache()\n\n  function defineGet () {\n    Get.encodingLength = encodingLength\n    Get.encode = encode\n    Get.decode = decode\n\n    function encodingLength (obj) {\n      var length = 0\n      if (defined(obj.version)) {\n        var len = encodings.varint.encodingLength(obj.version)\n        length += 1 + len\n      }\n      if (defined(obj.key)) {\n        var len = encodings.bytes.encodingLength(obj.key)\n        length += 1 + len\n      }\n      return length\n    }\n\n    function encode (obj, buf, offset) {\n      if (!offset) offset = 0\n      if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))\n      var oldOffset = offset\n      if (defined(obj.version)) {\n        buf[offset++] = 8\n        encodings.varint.encode(obj.version, buf, offset)\n        offset += encodings.varint.encode.bytes\n      }\n      if (defined(obj.key)) {\n        buf[offset++] = 18\n        encodings.bytes.encode(obj.key, buf, offset)\n        offset += encodings.bytes.encode.bytes\n      }\n      encode.bytes = offset - oldOffset\n      return buf\n    }\n\n    function decode (buf, offset, end) {\n      if (!offset) offset = 0\n      if (!end) end = buf.length\n      if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n      var oldOffset = offset\n      var obj = {\n        version: 0,\n        key: null\n      }\n      while (true) {\n        if (end <= offset) {\n          decode.bytes = offset - oldOffset\n          return obj\n        }\n        var prefix = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        var tag = prefix >> 3\n        switch (tag) {\n          case 1:\n          obj.version = encodings.varint.decode(buf, offset)\n          offset += encodings.varint.decode.bytes\n          break\n          case 2:\n          obj.key = encodings.bytes.decode(buf, offset)\n          offset += encodings.bytes.decode.bytes\n          break\n          default:\n          offset = skip(prefix & 7, buf, offset)\n        }\n      }\n    }\n  }\n\n  function defineIterator () {\n    Iterator.encodingLength = encodingLength\n    Iterator.encode = encode\n    Iterator.decode = decode\n\n    function encodingLength (obj) {\n      var length = 0\n      if (defined(obj.version)) {\n        var len = encodings.varint.encodingLength(obj.version)\n        length += 1 + len\n      }\n      if (defined(obj.gte)) {\n        var len = encodings.bytes.encodingLength(obj.gte)\n        length += 1 + len\n      }\n      if (defined(obj.gt)) {\n        var len = encodings.bytes.encodingLength(obj.gt)\n        length += 1 + len\n      }\n      if (defined(obj.lte)) {\n        var len = encodings.bytes.encodingLength(obj.lte)\n        length += 1 + len\n      }\n      if (defined(obj.lt)) {\n        var len = encodings.bytes.encodingLength(obj.lt)\n        length += 1 + len\n      }\n      if (defined(obj.limit)) {\n        var len = encodings.varint.encodingLength(obj.limit)\n        length += 1 + len\n      }\n      if (defined(obj.reverse)) {\n        var len = encodings.bool.encodingLength(obj.reverse)\n        length += 1 + len\n      }\n      if (defined(obj.checkpoint)) {\n        var packedLen = 0\n        for (var i = 0; i < obj.checkpoint.length; i++) {\n          if (!defined(obj.checkpoint[i])) continue\n          var len = encodings.varint.encodingLength(obj.checkpoint[i])\n          packedLen += len\n        }\n        if (packedLen) {\n          length += 1 + packedLen + varint.encodingLength(packedLen)\n        }\n      }\n      return length\n    }\n\n    function encode (obj, buf, offset) {\n      if (!offset) offset = 0\n      if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))\n      var oldOffset = offset\n      if (defined(obj.version)) {\n        buf[offset++] = 8\n        encodings.varint.encode(obj.version, buf, offset)\n        offset += encodings.varint.encode.bytes\n      }\n      if (defined(obj.gte)) {\n        buf[offset++] = 18\n        encodings.bytes.encode(obj.gte, buf, offset)\n        offset += encodings.bytes.encode.bytes\n      }\n      if (defined(obj.gt)) {\n        buf[offset++] = 26\n        encodings.bytes.encode(obj.gt, buf, offset)\n        offset += encodings.bytes.encode.bytes\n      }\n      if (defined(obj.lte)) {\n        buf[offset++] = 34\n        encodings.bytes.encode(obj.lte, buf, offset)\n        offset += encodings.bytes.encode.bytes\n      }\n      if (defined(obj.lt)) {\n        buf[offset++] = 42\n        encodings.bytes.encode(obj.lt, buf, offset)\n        offset += encodings.bytes.encode.bytes\n      }\n      if (defined(obj.limit)) {\n        buf[offset++] = 48\n        encodings.varint.encode(obj.limit, buf, offset)\n        offset += encodings.varint.encode.bytes\n      }\n      if (defined(obj.reverse)) {\n        buf[offset++] = 56\n        encodings.bool.encode(obj.reverse, buf, offset)\n        offset += encodings.bool.encode.bytes\n      }\n      if (defined(obj.checkpoint)) {\n        var packedLen = 0\n        for (var i = 0; i < obj.checkpoint.length; i++) {\n          if (!defined(obj.checkpoint[i])) continue\n          packedLen += encodings.varint.encodingLength(obj.checkpoint[i])\n        }\n        if (packedLen) {\n          buf[offset++] = 66\n          varint.encode(packedLen, buf, offset)\n          offset += varint.encode.bytes\n        }\n        for (var i = 0; i < obj.checkpoint.length; i++) {\n          if (!defined(obj.checkpoint[i])) continue\n          encodings.varint.encode(obj.checkpoint[i], buf, offset)\n          offset += encodings.varint.encode.bytes\n        }\n      }\n      encode.bytes = offset - oldOffset\n      return buf\n    }\n\n    function decode (buf, offset, end) {\n      if (!offset) offset = 0\n      if (!end) end = buf.length\n      if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n      var oldOffset = offset\n      var obj = {\n        version: 0,\n        gte: null,\n        gt: null,\n        lte: null,\n        lt: null,\n        limit: 0,\n        reverse: false,\n        checkpoint: []\n      }\n      while (true) {\n        if (end <= offset) {\n          decode.bytes = offset - oldOffset\n          return obj\n        }\n        var prefix = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        var tag = prefix >> 3\n        switch (tag) {\n          case 1:\n          obj.version = encodings.varint.decode(buf, offset)\n          offset += encodings.varint.decode.bytes\n          break\n          case 2:\n          obj.gte = encodings.bytes.decode(buf, offset)\n          offset += encodings.bytes.decode.bytes\n          break\n          case 3:\n          obj.gt = encodings.bytes.decode(buf, offset)\n          offset += encodings.bytes.decode.bytes\n          break\n          case 4:\n          obj.lte = encodings.bytes.decode(buf, offset)\n          offset += encodings.bytes.decode.bytes\n          break\n          case 5:\n          obj.lt = encodings.bytes.decode(buf, offset)\n          offset += encodings.bytes.decode.bytes\n          break\n          case 6:\n          obj.limit = encodings.varint.decode(buf, offset)\n          offset += encodings.varint.decode.bytes\n          break\n          case 7:\n          obj.reverse = encodings.bool.decode(buf, offset)\n          offset += encodings.bool.decode.bytes\n          break\n          case 8:\n          var packedEnd = varint.decode(buf, offset)\n          offset += varint.decode.bytes\n          packedEnd += offset\n          while (offset < packedEnd) {\n            obj.checkpoint.push(encodings.varint.decode(buf, offset))\n            offset += encodings.varint.decode.bytes\n          }\n          break\n          default:\n          offset = skip(prefix & 7, buf, offset)\n        }\n      }\n    }\n  }\n\n  function defineCache () {\n    Cache.encodingLength = encodingLength\n    Cache.encode = encode\n    Cache.decode = decode\n\n    function encodingLength (obj) {\n      var length = 0\n      if (!defined(obj.start)) throw new Error(\"start is required\")\n      var len = encodings.varint.encodingLength(obj.start)\n      length += 1 + len\n      if (!defined(obj.end)) throw new Error(\"end is required\")\n      var len = encodings.varint.encodingLength(obj.end)\n      length += 1 + len\n      if (defined(obj.blocks)) {\n        var packedLen = 0\n        for (var i = 0; i < obj.blocks.length; i++) {\n          if (!defined(obj.blocks[i])) continue\n          var len = encodings.varint.encodingLength(obj.blocks[i])\n          packedLen += len\n        }\n        if (packedLen) {\n          length += 1 + packedLen + varint.encodingLength(packedLen)\n        }\n      }\n      return length\n    }\n\n    function encode (obj, buf, offset) {\n      if (!offset) offset = 0\n      if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))\n      var oldOffset = offset\n      if (!defined(obj.start)) throw new Error(\"start is required\")\n      buf[offset++] = 8\n      encodings.varint.encode(obj.start, buf, offset)\n      offset += encodings.varint.encode.bytes\n      if (!defined(obj.end)) throw new Error(\"end is required\")\n      buf[offset++] = 16\n      encodings.varint.encode(obj.end, buf, offset)\n      offset += encodings.varint.encode.bytes\n      if (defined(obj.blocks)) {\n        var packedLen = 0\n        for (var i = 0; i < obj.blocks.length; i++) {\n          if (!defined(obj.blocks[i])) continue\n          packedLen += encodings.varint.encodingLength(obj.blocks[i])\n        }\n        if (packedLen) {\n          buf[offset++] = 26\n          varint.encode(packedLen, buf, offset)\n          offset += varint.encode.bytes\n        }\n        for (var i = 0; i < obj.blocks.length; i++) {\n          if (!defined(obj.blocks[i])) continue\n          encodings.varint.encode(obj.blocks[i], buf, offset)\n          offset += encodings.varint.encode.bytes\n        }\n      }\n      encode.bytes = offset - oldOffset\n      return buf\n    }\n\n    function decode (buf, offset, end) {\n      if (!offset) offset = 0\n      if (!end) end = buf.length\n      if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n      var oldOffset = offset\n      var obj = {\n        start: 0,\n        end: 0,\n        blocks: []\n      }\n      var found0 = false\n      var found1 = false\n      while (true) {\n        if (end <= offset) {\n          if (!found0 || !found1) throw new Error(\"Decoded message is not valid\")\n          decode.bytes = offset - oldOffset\n          return obj\n        }\n        var prefix = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        var tag = prefix >> 3\n        switch (tag) {\n          case 1:\n          obj.start = encodings.varint.decode(buf, offset)\n          offset += encodings.varint.decode.bytes\n          found0 = true\n          break\n          case 2:\n          obj.end = encodings.varint.decode(buf, offset)\n          offset += encodings.varint.decode.bytes\n          found1 = true\n          break\n          case 3:\n          var packedEnd = varint.decode(buf, offset)\n          offset += varint.decode.bytes\n          packedEnd += offset\n          while (offset < packedEnd) {\n            obj.blocks.push(encodings.varint.decode(buf, offset))\n            offset += encodings.varint.decode.bytes\n          }\n          break\n          default:\n          offset = skip(prefix & 7, buf, offset)\n        }\n      }\n    }\n  }\n\n  Extension.encodingLength = encodingLength\n  Extension.encode = encode\n  Extension.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.cache)) {\n      var len = Cache.encodingLength(obj.cache)\n      length += varint.encodingLength(len)\n      length += 1 + len\n    }\n    if (defined(obj.get)) {\n      var len = Get.encodingLength(obj.get)\n      length += varint.encodingLength(len)\n      length += 1 + len\n    }\n    if (defined(obj.iterator)) {\n      var len = Iterator.encodingLength(obj.iterator)\n      length += varint.encodingLength(len)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.cache)) {\n      buf[offset++] = 10\n      varint.encode(Cache.encodingLength(obj.cache), buf, offset)\n      offset += varint.encode.bytes\n      Cache.encode(obj.cache, buf, offset)\n      offset += Cache.encode.bytes\n    }\n    if (defined(obj.get)) {\n      buf[offset++] = 18\n      varint.encode(Get.encodingLength(obj.get), buf, offset)\n      offset += varint.encode.bytes\n      Get.encode(obj.get, buf, offset)\n      offset += Get.encode.bytes\n    }\n    if (defined(obj.iterator)) {\n      buf[offset++] = 26\n      varint.encode(Iterator.encodingLength(obj.iterator), buf, offset)\n      offset += varint.encode.bytes\n      Iterator.encode(obj.iterator, buf, offset)\n      offset += Iterator.encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      cache: null,\n      get: null,\n      iterator: null\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        var len = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        obj.cache = Cache.decode(buf, offset, offset + len)\n        offset += Cache.decode.bytes\n        break\n        case 2:\n        var len = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        obj.get = Get.decode(buf, offset, offset + len)\n        offset += Get.decode.bytes\n        break\n        case 3:\n        var len = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        obj.iterator = Iterator.decode(buf, offset, offset + len)\n        offset += Iterator.decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defined (val) {\n  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))\n}\n{\n  \"name\": \"hyperbee\",\n  \"version\": \"2.20.7\",\n  \"description\": \"An append-only B-tree running on a Hypercore.\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib/**.js\",\n    \"iterators/**.js\"\n  ],\n  \"dependencies\": {\n    \"b4a\": \"^1.6.0\",\n    \"codecs\": \"^3.0.0\",\n    \"debounceify\": \"^1.0.0\",\n    \"hypercore-errors\": \"^1.0.0\",\n    \"mutexify\": \"^1.4.0\",\n    \"protocol-buffers-encodings\": \"^1.2.0\",\n    \"rache\": \"^1.0.0\",\n    \"ready-resource\": \"^1.0.0\",\n    \"safety-catch\": \"^1.0.2\",\n    \"streamx\": \"^2.12.4\",\n    \"unslab\": \"^1.2.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.0\",\n    \"hypercore\": \"^10.37.10\",\n    \"protocol-buffers\": \"^4.2.0\",\n    \"random-access-memory\": \"^6.0.0\",\n    \"standard\": \"^17.0.0\",\n    \"sub-encoder\": \"^1.0.6\",\n    \"test-tmp\": \"^1.2.1\",\n    \"tree-to-string\": \"^1.1.1\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\",\n    \"protobuf\": \"protocol-buffers schema.proto -o ./lib/messages.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/hyperbee.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hyperbee/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hyperbee\"\n}\nconst mutexify = require('mutexify')\nconst b4a = require('b4a')\n\nconst { BlobReadStream, BlobWriteStream } = require('./lib/streams')\nconst Monitor = require('./lib/monitor')\n\nconst DEFAULT_BLOCK_SIZE = 2 ** 16\n\nclass HyperBlobsBatch {\n  constructor (blobs) {\n    this.blobs = blobs\n    this.blocks = []\n    this.bytes = 0\n  }\n\n  ready () {\n    return this.blobs.ready()\n  }\n\n  async put (buffer) {\n    if (!this.blobs.core.opened) await this.blobs.core.ready()\n\n    const blockSize = this.blobs.blockSize\n    const result = {\n      blockOffset: this.blobs.core.length + this.blocks.length,\n      blockLength: 0,\n      byteOffset: this.blobs.core.byteLength + this.bytes,\n      byteLength: 0\n    }\n\n    let offset = 0\n    while (offset < buffer.byteLength) {\n      const blk = buffer.subarray(offset, offset + blockSize)\n      offset += blockSize\n\n      result.blockLength++\n      result.byteLength += blk.byteLength\n      this.bytes += blk.byteLength\n      this.blocks.push(blk)\n    }\n\n    return result\n  }\n\n  async get (id) {\n    if (id.blockOffset < this.blobs.core.length) {\n      return this.blobs.get(id)\n    }\n\n    const bufs = []\n\n    for (let i = id.blockOffset - this.blobs.core.length; i < id.blockOffset + id.blockLength; i++) {\n      if (i >= this.blocks.length) return null\n      bufs.push(this.blocks[i])\n    }\n\n    return bufs.length === 1 ? bufs[0] : b4a.concat(bufs)\n  }\n\n  async flush () {\n    await this.blobs.core.append(this.blocks)\n    this.blocks = []\n    this.bytes = 0\n  }\n\n  close () {\n    // noop, atm nothing to unlink\n  }\n}\n\nclass Hyperblobs {\n  constructor (core, opts = {}) {\n    this.core = core\n    this.blockSize = opts.blockSize || DEFAULT_BLOCK_SIZE\n\n    this._lock = mutexify()\n    this._monitors = new Set()\n\n    this._boundUpdatePeers = this._updatePeers.bind(this)\n    this._boundOnUpload = this._onUpload.bind(this)\n    this._boundOnDownload = this._onDownload.bind(this)\n  }\n\n  get key () {\n    return this.core.key\n  }\n\n  get discoveryKey () {\n    return this.core.discoveryKey\n  }\n\n  get feed () {\n    return this.core\n  }\n\n  get locked () {\n    return this._lock.locked\n  }\n\n  replicate (isInitiator, opts) {\n    return this.core.replicate(isInitiator, opts)\n  }\n\n  ready () {\n    return this.core.ready()\n  }\n\n  close () {\n    return this.core.close()\n  }\n\n  batch () {\n    return new HyperBlobsBatch(this)\n  }\n\n  snapshot () {\n    return new Hyperblobs(this.core.snapshot())\n  }\n\n  async put (blob, opts) {\n    if (!b4a.isBuffer(blob)) blob = b4a.from(blob)\n    const blockSize = (opts && opts.blockSize) || this.blockSize\n\n    const stream = this.createWriteStream(opts)\n    for (let i = 0; i < blob.length; i += blockSize) {\n      stream.write(blob.subarray(i, i + blockSize))\n    }\n    stream.end()\n\n    return new Promise((resolve, reject) => {\n      stream.once('error', reject)\n      stream.once('close', () => resolve(stream.id))\n    })\n  }\n\n  async _getAll (id, opts) {\n    if (id.blockLength === 1) return this.core.get(id.blockOffset, opts)\n\n    const promises = new Array(id.blockLength)\n    for (let i = 0; i < id.blockLength; i++) {\n      promises[i] = this.core.get(id.blockOffset + i, opts)\n    }\n\n    const blocks = await Promise.all(promises)\n    for (let i = 0; i < id.blockLength; i++) {\n      if (blocks[i] === null) return null\n    }\n    return b4a.concat(blocks)\n  }\n\n  async get (id, opts) {\n    const all = !opts || (!opts.start && opts.length === undefined && opts.end === undefined && !opts.core)\n    if (all) return this._getAll(id, opts)\n\n    const res = []\n    try {\n      for await (const block of this.createReadStream(id, opts)) {\n        res.push(block)\n      }\n    } catch (error) {\n      if (error.code === 'BLOCK_NOT_AVAILABLE') return null\n      throw error\n    }\n\n    if (res.length === 1) return res[0]\n    return b4a.concat(res)\n  }\n\n  async clear (id, opts) {\n    return this.core.clear(id.blockOffset, id.blockOffset + id.blockLength, opts)\n  }\n\n  createReadStream (id, opts) {\n    const core = (opts && opts.core) ? opts.core : this.core\n    return new BlobReadStream(core, id, opts)\n  }\n\n  createWriteStream (opts) {\n    const core = (opts && opts.core) ? opts.core : this.core\n    return new BlobWriteStream(core, this._lock, opts)\n  }\n\n  monitor (id) {\n    const monitor = new Monitor(this, id)\n    if (this._monitors.size === 0) this._startListening()\n    this._monitors.add(monitor)\n    return monitor\n  }\n\n  _removeMonitor (mon) {\n    this._monitors.delete(mon)\n    if (this._monitors.size === 0) this._stopListening()\n  }\n\n  _updatePeers () {\n    for (const m of this._monitors) m._updatePeers()\n  }\n\n  _onUpload (index, bytes, from) {\n    for (const m of this._monitors) m._onUpload(index, bytes, from)\n  }\n\n  _onDownload (index, bytes, from) {\n    for (const m of this._monitors) m._onDownload(index, bytes, from)\n  }\n\n  _startListening () {\n    this.core.on('peer-add', this._boundUpdatePeers)\n    this.core.on('peer-remove', this._boundUpdatePeers)\n    this.core.on('upload', this._boundOnUpload)\n    this.core.on('download', this._boundOnDownload)\n  }\n\n  _stopListening () {\n    this.core.off('peer-add', this._boundUpdatePeers)\n    this.core.off('peer-remove', this._boundUpdatePeers)\n    this.core.off('upload', this._boundOnUpload)\n    this.core.off('download', this._boundOnDownload)\n  }\n}\n\nmodule.exports = Hyperblobs\nconst EventEmitter = require('events')\nconst speedometer = require('speedometer')\n\nmodule.exports = class Monitor extends EventEmitter {\n  constructor (blobs, id) {\n    super()\n\n    if (!id) throw new Error('id is required')\n\n    this.blobs = blobs\n    this.id = id\n    this.peers = 0\n    this.uploadSpeedometer = null\n    this.downloadSpeedometer = null\n\n    const stats = {\n      startTime: 0,\n      percentage: 0,\n      peers: 0,\n      speed: 0,\n      blocks: 0,\n      totalBytes: 0, // local + bytes loaded during monitoring\n      monitoringBytes: 0, // bytes loaded during monitoring\n      targetBytes: 0,\n      targetBlocks: 0\n    }\n\n    this.uploadStats = { ...stats }\n    this.downloadStats = { ...stats }\n    this.uploadStats.targetBytes = this.downloadStats.targetBytes = this.id.byteLength\n    this.uploadStats.targetBlocks = this.downloadStats.targetBlocks = this.id.blockLength\n    this.uploadStats.peers = this.downloadStats.peers = this.peers = this.blobs.core.peers.length\n\n    this.uploadSpeedometer = speedometer()\n    this.downloadSpeedometer = speedometer()\n\n    // Handlers\n  }\n\n  // just an alias\n  destroy () {\n    return this.close()\n  }\n\n  close () {\n    this.blobs._removeMonitor(this)\n  }\n\n  _onUpload (index, bytes, from) {\n    this._updateStats(this.uploadSpeedometer, this.uploadStats, index, bytes, from)\n  }\n\n  _onDownload (index, bytes, from) {\n    this._updateStats(this.downloadSpeedometer, this.downloadStats, index, bytes, from)\n  }\n\n  _updatePeers () {\n    this.uploadStats.peers = this.downloadStats.peers = this.peers = this.blobs.core.peers.length\n    this.emit('update')\n  }\n\n  _updateStats (speed, stats, index, bytes) {\n    if (this.closing) return\n    if (!isWithinRange(index, this.id)) return\n\n    if (!stats.startTime) stats.startTime = Date.now()\n\n    stats.speed = speed(bytes)\n    stats.blocks++\n    stats.totalBytes += bytes\n    stats.monitoringBytes += bytes\n    stats.percentage = toFixed(stats.blocks / stats.targetBlocks * 100)\n\n    this.emit('update')\n  }\n\n  downloadSpeed () {\n    return this.downloadSpeedometer ? this.downloadSpeedometer() : 0\n  }\n\n  uploadSpeed () {\n    return this.uploadSpeedometer ? this.uploadSpeedometer() : 0\n  }\n}\n\nfunction isWithinRange (index, { blockOffset, blockLength }) {\n  return index >= blockOffset && index < blockOffset + blockLength\n}\n\nfunction toFixed (n) {\n  return Math.round(n * 100) / 100\n}\n// should move to hypercore itself\n\nconst MAX_READAHEAD_TARGET = 0.05 // aim to buffer 5% always\n\nmodule.exports = class Prefetcher {\n  constructor (core, { max = 64, start = 0, end = core.length, linear = true } = {}) {\n    this.core = core\n    this.max = max\n    this.range = null\n    this.startBound = start\n    this.endBound = end\n    this.maxReadAhead = Math.max(max * 2, Math.floor((end - start) * MAX_READAHEAD_TARGET))\n\n    this.start = start\n    this.end = start\n    this.linear = linear\n    this.missing = 0\n\n    this._ondownloadBound = this._ondownload.bind(this)\n    this.core.on('download', this._ondownloadBound)\n  }\n\n  _ondownload (index) {\n    if (this.range && index < this.end && this.start <= index) {\n      this.missing--\n      this._update()\n    }\n  }\n\n  destroy () {\n    this.core.off('download', this._ondownloadBound)\n    if (this.range) this.range.destroy()\n    this.range = null\n    this.max = 0\n  }\n\n  update (position) {\n    this.start = position\n    if (!this.range) this._update()\n  }\n\n  _update () {\n    if (this.missing >= this.max) return\n    if (this.range) this.range.destroy()\n\n    let end = this.end\n\n    while (end < this.endBound && this.missing < this.max) {\n      end = this.core.core.bitfield.firstUnset(end) + 1\n      if (end >= this.endBound) break\n      this.missing++\n    }\n\n    if (end > this.start + this.maxReadAhead) end = this.start + this.maxReadAhead\n    if (end >= this.endBound) end = this.endBound\n\n    this.end = end\n\n    if (this.start >= this.end) return\n\n    this.range = this.core.download({\n      start: this.start,\n      end: this.end,\n      linear: this.linear\n    })\n  }\n}\nconst { Readable, Writable } = require('streamx')\nconst { BLOCK_NOT_AVAILABLE } = require('hypercore-errors')\nconst Prefetcher = require('./prefetcher')\n\nclass BlobWriteStream extends Writable {\n  constructor (core, lock, opts) {\n    super(opts)\n    this.id = {}\n    this.core = core\n    this._lock = lock\n    this._release = null\n    this._batch = []\n  }\n\n  _open (cb) {\n    this.core.ready().then(() => {\n      this._lock(release => {\n        this._release = release\n        this.id.byteOffset = this.core.byteLength\n        this.id.blockOffset = this.core.length\n        return cb(null)\n      })\n    }, err => cb(err))\n  }\n\n  _final (cb) {\n    this._append(err => {\n      if (err) return cb(err)\n      this.id.blockLength = this.core.length - this.id.blockOffset\n      this.id.byteLength = this.core.byteLength - this.id.byteOffset\n      return cb(null)\n    })\n  }\n\n  _destroy (cb) {\n    if (this._release) this._release()\n    cb(null)\n  }\n\n  _append (cb) {\n    if (!this._batch.length) return cb(null)\n    return this.core.append(this._batch).then(() => {\n      this._batch = []\n      return cb(null)\n    }, err => {\n      this._batch = []\n      return cb(err)\n    })\n  }\n\n  _write (data, cb) {\n    this._batch.push(data)\n    if (this._batch.length >= 16) return this._append(cb)\n    return cb(null)\n  }\n}\n\nclass BlobReadStream extends Readable {\n  constructor (core, id, opts = {}) {\n    super(opts)\n    this.id = id\n    this.core = core.session({ wait: opts.wait, timeout: opts.timeout })\n\n    const start = id.blockOffset\n    const end = id.blockOffset + id.blockLength\n    const noPrefetch = opts.wait === false || opts.prefetch === false || !core.core\n\n    this._prefetch = noPrefetch ? null : new Prefetcher(this.core, { max: opts.prefetch, start, end })\n    this._lastPrefetch = null\n\n    this._pos = opts.start !== undefined ? id.byteOffset + opts.start : id.byteOffset\n\n    if (opts.length !== undefined) this._end = this._pos + opts.length\n    else if (opts.end !== undefined) this._end = id.byteOffset + opts.end + 1\n    else this._end = id.byteOffset + id.byteLength\n\n    this._index = 0\n    this._relativeOffset = 0\n    this._bytesRead = 0\n  }\n\n  _open (cb) {\n    if (this._pos === this.id.byteOffset) {\n      this._index = this.id.blockOffset\n      this._relativeOffset = 0\n      return cb(null)\n    }\n\n    this.core.seek(this._pos, {\n      start: this.id.blockOffset,\n      end: this.id.blockOffset + this.id.blockLength\n    }).then(result => {\n      if (!result) return cb(BLOCK_NOT_AVAILABLE())\n\n      this._index = result[0]\n      this._relativeOffset = result[1]\n      return cb(null)\n    }, err => cb(err))\n  }\n\n  _predestroy () {\n    if (this._prefetch) this._prefetch.destroy()\n    this.core.close().then(noop, noop)\n  }\n\n  _destroy (cb) {\n    if (this._prefetch) this._prefetch.destroy()\n    this.core.close().then(cb, cb)\n  }\n\n  _read (cb) {\n    if (this._pos >= this._end) {\n      this.push(null)\n      return cb(null)\n    }\n\n    if (this._prefetch) this._prefetch.update(this._index)\n\n    this.core.get(this._index).then(block => {\n      if (!block) return cb(BLOCK_NOT_AVAILABLE())\n\n      const remainder = this._end - this._pos\n      if (this._relativeOffset || (remainder < block.length)) {\n        block = block.subarray(this._relativeOffset, this._relativeOffset + remainder)\n      }\n\n      this._index++\n      this._relativeOffset = 0\n      this._pos += block.length\n      this._bytesRead += block.length\n\n      this.push(block)\n      return cb(null)\n    }, err => cb(err))\n  }\n}\n\nmodule.exports = {\n  BlobReadStream,\n  BlobWriteStream\n}\n\nfunction noop () {}\n{\n  \"name\": \"hyperblobs\",\n  \"version\": \"2.8.0\",\n  \"description\": \"A blob store for Hypercore\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/hyperblobs.git\"\n  },\n  \"keywords\": [\n    \"hypercore\",\n    \"blob\",\n    \"store\"\n  ],\n  \"author\": \"Andrew Osheroff <andrewosh@gmail.com>\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hyperblobs/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hyperblobs#readme\",\n  \"files\": [\n    \"index.js\",\n    \"lib/**.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.6.1\",\n    \"bare-events\": \"^2.5.0\",\n    \"hypercore-errors\": \"^1.1.1\",\n    \"mutexify\": \"^1.4.0\",\n    \"speedometer\": \"^1.1.0\",\n    \"streamx\": \"^2.13.2\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.0\",\n    \"hypercore\": \"^10.18.0\",\n    \"random-access-memory\": \"^6.0.0\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst sodium = require('sodium-universal')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\n\n// https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack\nconst LEAF_TYPE = b4a.from([0])\nconst PARENT_TYPE = b4a.from([1])\nconst ROOT_TYPE = b4a.from([2])\n\nconst HYPERCORE = b4a.from('hypercore')\n\nexports.keyPair = function (seed) {\n  // key pairs might stay around for a while, so better not to use a default slab to avoid retaining it completely\n  const slab = b4a.allocUnsafeSlow(sodium.crypto_sign_PUBLICKEYBYTES + sodium.crypto_sign_SECRETKEYBYTES)\n  const publicKey = slab.subarray(0, sodium.crypto_sign_PUBLICKEYBYTES)\n  const secretKey = slab.subarray(sodium.crypto_sign_PUBLICKEYBYTES)\n\n  if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)\n  else sodium.crypto_sign_keypair(publicKey, secretKey)\n\n  return {\n    publicKey,\n    secretKey\n  }\n}\n\nexports.validateKeyPair = function (keyPair) {\n  const pk = b4a.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES)\n  sodium.crypto_sign_ed25519_sk_to_pk(pk, keyPair.secretKey)\n  return b4a.equals(pk, keyPair.publicKey)\n}\n\nexports.sign = function (message, secretKey) {\n  // Dedicated slab for the signature, to avoid retaining unneeded mem and for security\n  const signature = b4a.allocUnsafeSlow(sodium.crypto_sign_BYTES)\n  sodium.crypto_sign_detached(signature, message, secretKey)\n  return signature\n}\n\nexports.verify = function (message, signature, publicKey) {\n  return sodium.crypto_sign_verify_detached(signature, message, publicKey)\n}\n\nexports.encrypt = function (message, publicKey) {\n  const ciphertext = b4a.alloc(message.byteLength + sodium.crypto_box_SEALBYTES)\n  sodium.crypto_box_seal(ciphertext, message, publicKey)\n  return ciphertext\n}\n\nexports.decrypt = function (ciphertext, keyPair) {\n  if (ciphertext.byteLength < sodium.crypto_box_SEALBYTES) return null\n\n  const plaintext = b4a.alloc(ciphertext.byteLength - sodium.crypto_box_SEALBYTES)\n\n  if (!sodium.crypto_box_seal_open(plaintext, ciphertext, keyPair.publicKey, keyPair.secretKey)) {\n    return null\n  }\n\n  return plaintext\n}\n\nexports.encryptionKeyPair = function (seed) {\n  const publicKey = b4a.alloc(sodium.crypto_box_PUBLICKEYBYTES)\n  const secretKey = b4a.alloc(sodium.crypto_box_SECRETKEYBYTES)\n\n  if (seed) {\n    sodium.crypto_box_seed_keypair(publicKey, secretKey, seed)\n  } else {\n    sodium.crypto_box_keypair(publicKey, secretKey)\n  }\n\n  return {\n    publicKey,\n    secretKey\n  }\n}\n\nexports.data = function (data) {\n  const out = b4a.allocUnsafe(32)\n\n  sodium.crypto_generichash_batch(out, [\n    LEAF_TYPE,\n    c.encode(c.uint64, data.byteLength),\n    data\n  ])\n\n  return out\n}\n\nexports.parent = function (a, b) {\n  if (a.index > b.index) {\n    const tmp = a\n    a = b\n    b = tmp\n  }\n\n  const out = b4a.allocUnsafe(32)\n\n  sodium.crypto_generichash_batch(out, [\n    PARENT_TYPE,\n    c.encode(c.uint64, a.size + b.size),\n    a.hash,\n    b.hash\n  ])\n\n  return out\n}\n\nexports.tree = function (roots, out) {\n  const buffers = new Array(3 * roots.length + 1)\n  let j = 0\n\n  buffers[j++] = ROOT_TYPE\n\n  for (let i = 0; i < roots.length; i++) {\n    const r = roots[i]\n    buffers[j++] = r.hash\n    buffers[j++] = c.encode(c.uint64, r.index)\n    buffers[j++] = c.encode(c.uint64, r.size)\n  }\n\n  if (!out) out = b4a.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, buffers)\n  return out\n}\n\nexports.hash = function (data, out) {\n  if (!out) out = b4a.allocUnsafe(32)\n  if (!Array.isArray(data)) data = [data]\n\n  sodium.crypto_generichash_batch(out, data)\n\n  return out\n}\n\nexports.randomBytes = function (n) {\n  const buf = b4a.allocUnsafe(n)\n  sodium.randombytes_buf(buf)\n  return buf\n}\n\nexports.discoveryKey = function (publicKey) {\n  // Discovery keys might stay around for a while, so better not to use slab memory (for better gc)\n  const digest = b4a.allocUnsafeSlow(32)\n  sodium.crypto_generichash(digest, HYPERCORE, publicKey)\n  return digest\n}\n\nif (sodium.sodium_free) {\n  exports.free = function (secureBuf) {\n    if (secureBuf.secure) sodium.sodium_free(secureBuf)\n  }\n} else {\n  exports.free = function () {}\n}\n\nexports.namespace = function (name, count) {\n  const ids = typeof count === 'number' ? range(count) : count\n\n  // Namespaces are long-lived, so better to use a dedicated slab\n  const buf = b4a.allocUnsafeSlow(32 * ids.length)\n\n  const list = new Array(ids.length)\n\n  // ns is emhemeral, so default slab\n  const ns = b4a.allocUnsafe(33)\n  sodium.crypto_generichash(ns.subarray(0, 32), typeof name === 'string' ? b4a.from(name) : name)\n\n  for (let i = 0; i < list.length; i++) {\n    list[i] = buf.subarray(32 * i, 32 * i + 32)\n    ns[32] = ids[i]\n    sodium.crypto_generichash(list[i], ns)\n  }\n\n  return list\n}\n\nfunction range (count) {\n  const arr = new Array(count)\n  for (let i = 0; i < count; i++) arr[i] = i\n  return arr\n}\n{\n  \"name\": \"hypercore-crypto\",\n  \"version\": \"3.5.0\",\n  \"description\": \"The crypto primitives used in hypercore, extracted into a separate module\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {\n    \"b4a\": \"^1.6.6\",\n    \"compact-encoding\": \"^2.15.0\",\n    \"sodium-universal\": \"^4.0.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.0\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/hypercore-crypto.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/hypercore-crypto/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/hypercore-crypto\"\n}\nmodule.exports = class HypercoreError extends Error {\n  constructor (msg, code, fn = HypercoreError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name () {\n    return 'HypercoreError'\n  }\n\n  static ASSERTION (msg) { // ERR_ASSERTION is picked up by safety-catch also\n    return new HypercoreError(msg, 'ERR_ASSERTION', HypercoreError.ASSERT)\n  }\n\n  static BAD_ARGUMENT (msg) {\n    return new HypercoreError(msg, 'BAD_ARGUMENT', HypercoreError.BAD_ARGUMENT)\n  }\n\n  static STORAGE_EMPTY (msg) {\n    return new HypercoreError(msg, 'STORAGE_EMPTY', HypercoreError.STORAGE_EMPTY)\n  }\n\n  static STORAGE_CONFLICT (msg) {\n    return new HypercoreError(msg, 'STORAGE_CONFLICT', HypercoreError.STORAGE_CONFLICT)\n  }\n\n  static INVALID_SIGNATURE (msg) {\n    return new HypercoreError(msg, 'INVALID_SIGNATURE', HypercoreError.INVALID_SIGNATURE)\n  }\n\n  static INVALID_CAPABILITY (msg) {\n    return new HypercoreError(msg, 'INVALID_CAPABILITY', HypercoreError.INVALID_CAPABILITY)\n  }\n\n  static INVALID_CHECKSUM (msg = 'Invalid checksum') {\n    return new HypercoreError(msg, 'INVALID_CHECKSUM', HypercoreError.INVALID_CHECKSUM)\n  }\n\n  static INVALID_OPERATION (msg) {\n    return new HypercoreError(msg, 'INVALID_OPERATION', HypercoreError.INVALID_OPERATION)\n  }\n\n  static INVALID_PROOF (msg = 'Proof not verifiable') {\n    return new HypercoreError(msg, 'INVALID_PROOF', HypercoreError.INVALID_PROOF)\n  }\n\n  static BLOCK_NOT_AVAILABLE (msg = 'Block is not available') {\n    return new HypercoreError(msg, 'BLOCK_NOT_AVAILABLE', HypercoreError.BLOCK_NOT_AVAILABLE)\n  }\n\n  static SNAPSHOT_NOT_AVAILABLE (msg = 'Snapshot is not available') {\n    return new HypercoreError(msg, 'SNAPSHOT_NOT_AVAILABLE', HypercoreError.SNAPSHOT_NOT_AVAILABLE)\n  }\n\n  static REQUEST_CANCELLED (msg = 'Request was cancelled') {\n    return new HypercoreError(msg, 'REQUEST_CANCELLED', HypercoreError.REQUEST_CANCELLED)\n  }\n\n  static REQUEST_TIMEOUT (msg = 'Request timed out') {\n    return new HypercoreError(msg, 'REQUEST_TIMEOUT', HypercoreError.REQUEST_TIMEOUT)\n  }\n\n  static SESSION_NOT_WRITABLE (msg = 'Session is not writable') {\n    return new HypercoreError(msg, 'SESSION_NOT_WRITABLE', HypercoreError.SESSION_NOT_WRITABLE)\n  }\n\n  static SESSION_CLOSED (msg = 'Session is closed') {\n    return new HypercoreError(msg, 'SESSION_CLOSED', HypercoreError.SESSION_CLOSED)\n  }\n\n  static BATCH_UNFLUSHED (msg = 'Batch not yet flushed') {\n    return new HypercoreError(msg, 'BATCH_UNFLUSHED', HypercoreError.BATCH_UNFLUSHED)\n  }\n\n  static BATCH_ALREADY_EXISTS (msg = 'Batch already exists') {\n    return new HypercoreError(msg, 'BATCH_ALREADY_EXISTS', HypercoreError.BATCH_ALREADY_EXISTS)\n  }\n\n  static BATCH_ALREADY_FLUSHED (msg = 'Batch has already been flushed') {\n    return new HypercoreError(msg, 'BATCH_ALREADY_FLUSHED', HypercoreError.BATCH_ALREADY_FLUSHED)\n  }\n\n  static OPLOG_CORRUPT (msg = 'Oplog file appears corrupt or out of date') {\n    return new HypercoreError(msg, 'OPLOG_CORRUPT', HypercoreError.OPLOG_CORRUPT)\n  }\n\n  static OPLOG_HEADER_OVERFLOW (msg = 'Oplog header exceeds page size') {\n    return new HypercoreError(msg, 'OPLOG_HEADER_OVERFLOW', HypercoreError.OPLOG_HEADER_OVERFLOW)\n  }\n\n  static INVALID_OPLOG_VERSION (msg = 'Invalid header version') {\n    return new HypercoreError(msg, 'INVALID_OPLOG_VERSION', HypercoreError.INVALID_OPLOG_VERSION)\n  }\n\n  static WRITE_FAILED (msg = 'Write to storage failed') {\n    return new HypercoreError(msg, 'WRITE_FAILED', HypercoreError.WRITE_FAILED)\n  }\n\n  static DECODING_ERROR (msg = 'Decoding error') {\n    return new HypercoreError(msg, 'DECODING_ERROR', HypercoreError.DECODING_ERROR)\n  }\n\n  static SESSION_MOVED (msg = 'Session moved') {\n    return new HypercoreError(msg, 'SESSION_MOVED', HypercoreError.SESSION_MOVED)\n  }\n}\n{\n  \"name\": \"hypercore-errors\",\n  \"version\": \"1.4.0\",\n  \"description\": \"Hypercore errors\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/hypercore-errors.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hypercore-errors/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hypercore-errors#readme\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.3\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst z32 = require('z32')\nconst b4a = require('b4a')\n\nmodule.exports = {\n  encode,\n  decode,\n  normalize,\n  isValid\n}\n\nfunction encode (key) {\n  if (!b4a.isBuffer(key)) throw new Error('Key must be a Buffer')\n  if (key.byteLength !== 32) throw new Error('Key must be 32-bytes long')\n  return z32.encode(key)\n}\n\nfunction decode (id) {\n  if (b4a.isBuffer(id)) {\n    if (id.byteLength !== 32) throw new Error('ID must be 32-bytes long')\n    return id\n  }\n  if (typeof id === 'string') {\n    if (id.startsWith('pear://')) id = id.slice(7).split('/')[0]\n    if (id.length === 52) return z32.decode(id)\n    if (id.length === 64) {\n      const buf = b4a.from(id, 'hex')\n      if (buf.byteLength === 32) return buf\n    }\n  }\n  throw new Error('Invalid Hypercore key')\n}\n\nfunction normalize (any) {\n  return encode(decode(any))\n}\n\nfunction isValid (any) {\n  try {\n    decode(any)\n    return true\n  } catch {\n    return false\n  }\n}\n{\n  \"name\": \"hypercore-id-encoding\",\n  \"version\": \"1.3.0\",\n  \"description\": \"Convert Hypercore keys to/from z-base32 or hex\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {\n    \"b4a\": \"^1.5.3\",\n    \"z32\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.1\",\n    \"hypercore\": \"^10.0.0\",\n    \"random-access-memory\": \"^6.0.0\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/hypercore-id-encoding.git\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hypercore-id-encoding/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hypercore-id-encoding#readme\"\n}\n// explicitly exposed as hypercore/errors\nmodule.exports = require('hypercore-errors')\nconst { EventEmitter } = require('events')\nconst RAF = require('random-access-file')\nconst isOptions = require('is-options')\nconst hypercoreCrypto = require('hypercore-crypto')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst Xache = require('xache')\nconst NoiseSecretStream = require('@hyperswarm/secret-stream')\nconst Protomux = require('protomux')\nconst z32 = require('z32')\nconst id = require('hypercore-id-encoding')\nconst safetyCatch = require('safety-catch')\nconst unslab = require('unslab')\n\nconst Replicator = require('./lib/replicator')\nconst Core = require('./lib/core')\nconst BlockEncryption = require('./lib/block-encryption')\nconst Info = require('./lib/info')\nconst Download = require('./lib/download')\nconst Batch = require('./lib/batch')\nconst { manifestHash, createManifest } = require('./lib/verifier')\nconst { ReadStream, WriteStream, ByteStream } = require('./lib/streams')\nconst {\n  ASSERTION,\n  BAD_ARGUMENT,\n  SESSION_CLOSED,\n  SESSION_NOT_WRITABLE,\n  SNAPSHOT_NOT_AVAILABLE,\n  DECODING_ERROR\n} = require('hypercore-errors')\n\nconst promises = Symbol.for('hypercore.promises')\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\n\n// Hypercore actually does not have any notion of max/min block sizes\n// but we enforce 15mb to ensure smooth replication (each block is transmitted atomically)\nconst MAX_SUGGESTED_BLOCK_SIZE = 15 * 1024 * 1024\n\nmodule.exports = class Hypercore extends EventEmitter {\n  constructor (storage, key, opts) {\n    super()\n\n    if (isOptions(storage)) {\n      opts = storage\n      storage = null\n      key = opts.key || null\n    } else if (isOptions(key)) {\n      opts = key\n      key = opts.key || null\n    }\n\n    if (key && typeof key === 'string') key = id.decode(key)\n    if (!opts) opts = {}\n\n    if (!storage) storage = opts.storage\n\n    this[promises] = true\n\n    this.storage = null\n    this.crypto = opts.crypto || hypercoreCrypto\n    this.core = null\n    this.replicator = null\n    this.encryption = null\n    this.extensions = new Map()\n    this.cache = createCache(opts.cache)\n\n    this.valueEncoding = null\n    this.encodeBatch = null\n    this.activeRequests = []\n\n    this.id = null\n    this.key = key || null\n    this.keyPair = opts.keyPair || null\n    this.readable = true\n    this.writable = false\n    this.opened = false\n    this.closed = false\n    this.snapshotted = !!opts.snapshot\n    this.sparse = opts.sparse !== false\n    this.sessions = opts._sessions || [this]\n    this.autoClose = !!opts.autoClose\n    this.onwait = opts.onwait || null\n    this.wait = opts.wait !== false\n    this.timeout = opts.timeout || 0\n    this.closing = null\n    this.opening = null\n\n    this._readonly = opts.writable === false\n    this._preappend = preappend.bind(this)\n    this._snapshot = null\n    this._findingPeers = 0\n    this._active = opts.active !== false\n\n    this.opening = this._openSession(key, storage, opts)\n    this.opening.catch(safetyCatch)\n  }\n\n  [inspect] (depth, opts) {\n    let indent = ''\n    if (typeof opts.indentationLvl === 'number') {\n      while (indent.length < opts.indentationLvl) indent += ' '\n    }\n\n    let peers = ''\n    const min = Math.min(this.peers.length, 5)\n\n    for (let i = 0; i < min; i++) {\n      const peer = this.peers[i]\n\n      peers += indent + '    Peer(\\n'\n      peers += indent + '      remotePublicKey: ' + opts.stylize(toHex(peer.remotePublicKey), 'string') + '\\n'\n      peers += indent + '      remoteLength: ' + opts.stylize(peer.remoteLength, 'number') + '\\n'\n      peers += indent + '      remoteFork: ' + opts.stylize(peer.remoteFork, 'number') + '\\n'\n      peers += indent + '      remoteCanUpgrade: ' + opts.stylize(peer.remoteCanUpgrade, 'boolean') + '\\n'\n      peers += indent + '    )' + '\\n'\n    }\n\n    if (this.peers.length > 5) {\n      peers += indent + '  ... and ' + (this.peers.length - 5) + ' more\\n'\n    }\n\n    if (peers) peers = '[\\n' + peers + indent + '  ]'\n    else peers = '[ ' + opts.stylize(0, 'number') + ' ]'\n\n    return this.constructor.name + '(\\n' +\n      indent + '  id: ' + opts.stylize(this.id, 'string') + '\\n' +\n      indent + '  key: ' + opts.stylize(toHex(this.key), 'string') + '\\n' +\n      indent + '  discoveryKey: ' + opts.stylize(toHex(this.discoveryKey), 'string') + '\\n' +\n      indent + '  opened: ' + opts.stylize(this.opened, 'boolean') + '\\n' +\n      indent + '  closed: ' + opts.stylize(this.closed, 'boolean') + '\\n' +\n      indent + '  snapshotted: ' + opts.stylize(this.snapshotted, 'boolean') + '\\n' +\n      indent + '  sparse: ' + opts.stylize(this.sparse, 'boolean') + '\\n' +\n      indent + '  writable: ' + opts.stylize(this.writable, 'boolean') + '\\n' +\n      indent + '  length: ' + opts.stylize(this.length, 'number') + '\\n' +\n      indent + '  fork: ' + opts.stylize(this.fork, 'number') + '\\n' +\n      indent + '  sessions: [ ' + opts.stylize(this.sessions.length, 'number') + ' ]\\n' +\n      indent + '  activeRequests: [ ' + opts.stylize(this.activeRequests.length, 'number') + ' ]\\n' +\n      indent + '  peers: ' + peers + '\\n' +\n      indent + ')'\n  }\n\n  static MAX_SUGGESTED_BLOCK_SIZE = MAX_SUGGESTED_BLOCK_SIZE\n\n  static key (manifest, { compat, version, namespace } = {}) {\n    if (b4a.isBuffer(manifest)) manifest = { version, signers: [{ publicKey: manifest, namespace }] }\n    return compat ? manifest.signers[0].publicKey : manifestHash(createManifest(manifest))\n  }\n\n  static discoveryKey (key) {\n    return hypercoreCrypto.discoveryKey(key)\n  }\n\n  static getProtocolMuxer (stream) {\n    return stream.noiseStream.userData\n  }\n\n  static createProtocolStream (isInitiator, opts = {}) {\n    let outerStream = Protomux.isProtomux(isInitiator)\n      ? isInitiator.stream\n      : isStream(isInitiator)\n        ? isInitiator\n        : opts.stream\n\n    let noiseStream = null\n\n    if (outerStream) {\n      noiseStream = outerStream.noiseStream\n    } else {\n      noiseStream = new NoiseSecretStream(isInitiator, null, opts)\n      outerStream = noiseStream.rawStream\n    }\n    if (!noiseStream) throw BAD_ARGUMENT('Invalid stream')\n\n    if (!noiseStream.userData) {\n      const protocol = Protomux.from(noiseStream)\n\n      if (opts.keepAlive !== false) {\n        noiseStream.setKeepAlive(5000)\n      }\n      noiseStream.userData = protocol\n    }\n\n    if (opts.ondiscoverykey) {\n      noiseStream.userData.pair({ protocol: 'hypercore/alpha' }, opts.ondiscoverykey)\n    }\n\n    return outerStream\n  }\n\n  static defaultStorage (storage, opts = {}) {\n    if (typeof storage !== 'string') {\n      if (!isRandomAccessClass(storage)) return storage\n      const Cls = storage // just to satisfy standard...\n      return name => new Cls(name)\n    }\n\n    const directory = storage\n    const toLock = opts.unlocked ? null : (opts.lock || 'oplog')\n    const pool = opts.pool || (opts.poolSize ? RAF.createPool(opts.poolSize) : null)\n    const rmdir = !!opts.rmdir\n    const writable = opts.writable !== false\n\n    return createFile\n\n    function createFile (name) {\n      const lock = toLock === null ? false : isFile(name, toLock)\n      const sparse = isFile(name, 'data') || isFile(name, 'bitfield') || isFile(name, 'tree')\n      return new RAF(name, { directory, lock, sparse, pool: lock ? null : pool, rmdir, writable })\n    }\n\n    function isFile (name, n) {\n      return name === n || name.endsWith('/' + n)\n    }\n  }\n\n  snapshot (opts) {\n    return this.session({ ...opts, snapshot: true })\n  }\n\n  session (opts = {}) {\n    if (this.closing) {\n      // This makes the closing logic a lot easier. If this turns out to be a problem\n      // in practice, open an issue and we'll try to make a solution for it.\n      throw SESSION_CLOSED('Cannot make sessions on a closing core')\n    }\n\n    const sparse = opts.sparse === false ? false : this.sparse\n    const wait = opts.wait === false ? false : this.wait\n    const writable = opts.writable === false ? false : !this._readonly\n    const onwait = opts.onwait === undefined ? this.onwait : opts.onwait\n    const timeout = opts.timeout === undefined ? this.timeout : opts.timeout\n    const Clz = opts.class || Hypercore\n    const s = new Clz(this.storage, this.key, {\n      ...opts,\n      sparse,\n      wait,\n      onwait,\n      timeout,\n      writable,\n      _opening: this.opening,\n      _sessions: this.sessions\n    })\n\n    s._passCapabilities(this)\n\n    // Configure the cache unless explicitly disabled.\n    if (opts.cache !== false) {\n      s.cache = opts.cache === true || !opts.cache ? this.cache : opts.cache\n    }\n\n    if (this.opened) ensureEncryption(s, opts)\n    this._addSession(s)\n\n    return s\n  }\n\n  _addSession (s) {\n    this.sessions.push(s)\n    if (this.core) this.core.active++\n  }\n\n  async setEncryptionKey (encryptionKey, opts) {\n    if (!this.opened) await this.opening\n    this.encryption = encryptionKey ? new BlockEncryption(encryptionKey, this.key, { compat: this.core.compat, ...opts }) : null\n  }\n\n  setKeyPair (keyPair) {\n    this.keyPair = keyPair\n    this.writable = this._isWritable()\n  }\n\n  setActive (bool) {\n    const active = !!bool\n    if (active === this._active || this.closing) return\n    this._active = active\n    if (!this.opened) return\n    this.replicator.updateActivity(this._active ? 1 : -1)\n  }\n\n  _passCapabilities (o) {\n    if (!this.keyPair) this.keyPair = o.keyPair\n    this.crypto = o.crypto\n    this.id = o.id\n    this.key = o.key\n    this.core = o.core\n    this.replicator = o.replicator\n    this.encryption = o.encryption\n    this.writable = this._isWritable()\n    this.autoClose = o.autoClose\n\n    if (this.snapshotted && this.core && !this._snapshot) this._updateSnapshot()\n  }\n\n  async _openFromExisting (from, opts) {\n    if (!from.opened) await from.opening\n\n    // includes ourself as well, so the loop below also updates us\n    const sessions = this.sessions\n\n    for (const s of sessions) {\n      s.sessions = from.sessions\n      s._passCapabilities(from)\n      s._addSession(s)\n    }\n\n    this.storage = from.storage\n    this.replicator.findingPeers += this._findingPeers\n\n    ensureEncryption(this, opts)\n\n    // we need to manually fwd the encryption cap as the above removes it potentially\n    if (this.encryption && !from.encryption) {\n      for (const s of sessions) s.encryption = this.encryption\n    }\n  }\n\n  async _openSession (key, storage, opts) {\n    const isFirst = !opts._opening\n\n    if (!isFirst) {\n      await opts._opening\n    }\n    if (opts.preload) opts = { ...opts, ...(await this._retryPreload(opts.preload)) }\n    if (this.cache === null && opts.cache) this.cache = createCache(opts.cache)\n\n    if (isFirst) {\n      await this._openCapabilities(key, storage, opts)\n\n      // check we are the actual root and not a opts.from session\n      if (!opts.from) {\n        // Only the root session should pass capabilities to other sessions.\n        for (let i = 0; i < this.sessions.length; i++) {\n          const s = this.sessions[i]\n          if (s !== this) s._passCapabilities(this)\n        }\n      }\n    } else {\n      ensureEncryption(this, opts)\n    }\n\n    if (opts.manifest && !this.core.header.manifest) {\n      await this.core.setManifest(opts.manifest)\n    }\n\n    this.writable = this._isWritable()\n\n    if (opts.valueEncoding) {\n      this.valueEncoding = c.from(opts.valueEncoding)\n    }\n    if (opts.encodeBatch) {\n      this.encodeBatch = opts.encodeBatch\n    }\n\n    // Start continous replication if not in sparse mode.\n    if (!this.sparse) this.download({ start: 0, end: -1 })\n\n    // This is a hidden option that's only used by Corestore.\n    // It's required so that corestore can load a name from userData before 'ready' is emitted.\n    if (opts._preready) await opts._preready(this)\n\n    this.replicator.updateActivity(this._active ? 1 : 0)\n\n    this.opened = true\n    this.emit('ready')\n  }\n\n  async _retryPreload (preload) {\n    while (true) { // TODO: better long term fix is allowing lib/core.js creation from the outside...\n      const result = await preload()\n      const from = result && result.from\n      if (from) {\n        if (!from.opened) await from.ready()\n        if (from.closing) continue\n      }\n      return result\n    }\n  }\n\n  async _openCapabilities (key, storage, opts) {\n    if (opts.from) return this._openFromExisting(opts.from, opts)\n\n    const unlocked = !!opts.unlocked\n    this.storage = Hypercore.defaultStorage(opts.storage || storage, { unlocked, writable: !unlocked })\n\n    this.core = await Core.open(this.storage, {\n      compat: opts.compat,\n      force: opts.force,\n      sessions: this.sessions,\n      createIfMissing: opts.createIfMissing,\n      readonly: unlocked,\n      overwrite: opts.overwrite,\n      key,\n      keyPair: opts.keyPair,\n      crypto: this.crypto,\n      legacy: opts.legacy,\n      manifest: opts.manifest,\n      globalCache: opts.globalCache || null, // This is a temp option, not to be relied on unless you know what you are doing (no semver guarantees)\n      onupdate: this._oncoreupdate.bind(this),\n      onconflict: this._oncoreconflict.bind(this)\n    })\n\n    if (opts.userData) {\n      for (const [key, value] of Object.entries(opts.userData)) {\n        await this.core.userData(key, value)\n      }\n    }\n\n    this.key = this.core.header.key\n    this.keyPair = this.core.header.keyPair\n    this.id = z32.encode(this.key)\n\n    this.replicator = new Replicator(this.core, this.key, {\n      eagerUpgrade: true,\n      notDownloadingLinger: opts.notDownloadingLinger,\n      allowFork: opts.allowFork !== false,\n      inflightRange: opts.inflightRange,\n      onpeerupdate: this._onpeerupdate.bind(this),\n      onupload: this._onupload.bind(this),\n      oninvalid: this._oninvalid.bind(this)\n    })\n\n    this.replicator.findingPeers += this._findingPeers\n\n    if (!this.encryption && opts.encryptionKey) {\n      this.encryption = new BlockEncryption(opts.encryptionKey, this.key, { compat: this.core.compat, isBlockKey: opts.isBlockKey })\n    }\n  }\n\n  _getSnapshot () {\n    if (this.sparse) {\n      return {\n        length: this.core.tree.length,\n        byteLength: this.core.tree.byteLength,\n        fork: this.core.tree.fork,\n        compatLength: this.core.tree.length\n      }\n    }\n\n    return {\n      length: this.core.header.hints.contiguousLength,\n      byteLength: 0,\n      fork: this.core.tree.fork,\n      compatLength: this.core.header.hints.contiguousLength\n    }\n  }\n\n  _updateSnapshot () {\n    const prev = this._snapshot\n    const next = this._snapshot = this._getSnapshot()\n\n    if (!prev) return true\n    return prev.length !== next.length || prev.fork !== next.fork\n  }\n\n  _isWritable () {\n    return !this._readonly && !!(this.keyPair && this.keyPair.secretKey)\n  }\n\n  close (err) {\n    if (this.closing) return this.closing\n    this.closing = this._close(err || null)\n    return this.closing\n  }\n\n  async _close (err) {\n    if (this.opened === false) await this.opening\n\n    const i = this.sessions.indexOf(this)\n    if (i === -1) return\n\n    this.sessions.splice(i, 1)\n    this.core.active--\n    this.readable = false\n    this.writable = false\n    this.closed = true\n    this.opened = false\n\n    const gc = []\n    for (const ext of this.extensions.values()) {\n      if (ext.session === this) gc.push(ext)\n    }\n    for (const ext of gc) ext.destroy()\n\n    if (this.replicator !== null) {\n      this.replicator.findingPeers -= this._findingPeers\n      this.replicator.clearRequests(this.activeRequests, err)\n      this.replicator.updateActivity(this._active ? -1 : 0)\n    }\n\n    this._findingPeers = 0\n\n    if (this.sessions.length || this.core.active > 0) {\n      // if this is the last session and we are auto closing, trigger that first to enforce error handling\n      if (this.sessions.length === 1 && this.core.active === 1 && this.autoClose) await this.sessions[0].close(err)\n      // emit \"fake\" close as this is a session\n      this.emit('close', false)\n      return\n    }\n\n    if (this.replicator !== null) {\n      await this.replicator.destroy()\n    }\n\n    await this.core.close()\n\n    this.emit('close', true)\n  }\n\n  replicate (isInitiator, opts = {}) {\n    // Only limitation here is that ondiscoverykey doesn't work atm when passing a muxer directly,\n    // because it doesn't really make a lot of sense.\n    if (Protomux.isProtomux(isInitiator)) return this._attachToMuxer(isInitiator, opts)\n\n    // if same stream is passed twice, ignore the 2nd one before we make sessions etc\n    if (isStream(isInitiator) && this._isAttached(isInitiator)) return isInitiator\n\n    const protocolStream = Hypercore.createProtocolStream(isInitiator, opts)\n    const noiseStream = protocolStream.noiseStream\n    const protocol = noiseStream.userData\n    const useSession = !!opts.session\n\n    this._attachToMuxer(protocol, useSession)\n\n    return protocolStream\n  }\n\n  _isAttached (stream) {\n    return stream.userData && this.replicator && this.replicator.attached(stream.userData)\n  }\n\n  _attachToMuxer (mux, useSession) {\n    if (this.opened) {\n      this._attachToMuxerOpened(mux, useSession)\n    } else {\n      this.opening.then(this._attachToMuxerOpened.bind(this, mux, useSession), mux.destroy.bind(mux))\n    }\n\n    return mux\n  }\n\n  _attachToMuxerOpened (mux, useSession) {\n    // If the user wants to, we can make this replication run in a session\n    // that way the core wont close \"under them\" during replication\n    this.replicator.attachTo(mux, useSession)\n  }\n\n  get discoveryKey () {\n    return this.replicator === null ? null : this.replicator.discoveryKey\n  }\n\n  get manifest () {\n    return this.core === null ? null : this.core.header.manifest\n  }\n\n  get length () {\n    if (this._snapshot) return this._snapshot.length\n    if (this.core === null) return 0\n    if (!this.sparse) return this.contiguousLength\n    return this.core.tree.length\n  }\n\n  get signedLength () {\n    return this.length\n  }\n\n  get indexedLength () {\n    return this.length\n  }\n\n  /**\n   * Deprecated. Use `const { byteLength } = await core.info()`.\n   */\n  get byteLength () {\n    if (this._snapshot) return this._snapshot.byteLength\n    if (this.core === null) return 0\n    if (!this.sparse) return this.contiguousByteLength\n    return this.core.tree.byteLength - (this.core.tree.length * this.padding)\n  }\n\n  get contiguousLength () {\n    return this.core === null ? 0 : Math.min(this.core.tree.length, this.core.header.hints.contiguousLength)\n  }\n\n  get contiguousByteLength () {\n    return 0\n  }\n\n  get fork () {\n    return this.core === null ? 0 : this.core.tree.fork\n  }\n\n  get peers () {\n    return this.replicator === null ? [] : this.replicator.peers\n  }\n\n  get encryptionKey () {\n    return this.encryption && this.encryption.key\n  }\n\n  get padding () {\n    return this.encryption === null ? 0 : this.encryption.padding\n  }\n\n  get globalCache () {\n    return this.core && this.core.globalCache\n  }\n\n  ready () {\n    return this.opening\n  }\n\n  _onupload (index, value, from) {\n    const byteLength = value.byteLength - this.padding\n\n    for (let i = 0; i < this.sessions.length; i++) {\n      this.sessions[i].emit('upload', index, byteLength, from)\n    }\n  }\n\n  _oninvalid (err, req, res, from) {\n    for (let i = 0; i < this.sessions.length; i++) {\n      this.sessions[i].emit('verification-error', err, req, res, from)\n    }\n  }\n\n  async _oncoreconflict (proof, from) {\n    await this.replicator.onconflict(from)\n\n    for (const s of this.sessions) s.emit('conflict', proof.upgrade.length, proof.fork, proof)\n\n    const err = new Error('Two conflicting signatures exist for length ' + proof.upgrade.length)\n    await this._closeAllSessions(err)\n  }\n\n  async _closeAllSessions (err) {\n    // this.sessions modifies itself when a session closes\n    // This way we ensure we indeed iterate over all sessions\n    const sessions = [...this.sessions]\n\n    const all = []\n    for (const s of sessions) all.push(s.close(err))\n    await Promise.allSettled(all)\n  }\n\n  _oncoreupdate (status, bitfield, value, from) {\n    if (status !== 0) {\n      const truncatedNonSparse = (status & 0b1000) !== 0\n      const appendedNonSparse = (status & 0b0100) !== 0\n      const truncated = (status & 0b0010) !== 0\n      const appended = (status & 0b0001) !== 0\n\n      if (truncated) {\n        this.replicator.ontruncate(bitfield.start, bitfield.length)\n      }\n\n      if ((status & 0b10011) !== 0) {\n        this.replicator.onupgrade()\n      }\n\n      if (status & 0b10000) {\n        for (let i = 0; i < this.sessions.length; i++) {\n          const s = this.sessions[i]\n\n          if (s.encryption && s.encryption.compat !== this.core.compat) {\n            s.encryption = new BlockEncryption(s.encryption.key, this.key, { compat: this.core.compat, isBlockKey: s.encryption.isBlockKey })\n          }\n        }\n\n        for (let i = 0; i < this.sessions.length; i++) {\n          this.sessions[i].emit('manifest')\n        }\n      }\n\n      for (let i = 0; i < this.sessions.length; i++) {\n        const s = this.sessions[i]\n\n        if (truncated) {\n          if (s.cache) s.cache.clear()\n\n          // If snapshotted, make sure to update our compat so we can fail gets\n          if (s._snapshot && bitfield.start < s._snapshot.compatLength) s._snapshot.compatLength = bitfield.start\n        }\n\n        if (s.sparse ? truncated : truncatedNonSparse) {\n          s.emit('truncate', bitfield.start, this.core.tree.fork)\n        }\n\n        // For sparse sessions, immediately emit appends. If non-sparse, emit if contig length has updated\n        if (s.sparse ? appended : appendedNonSparse) {\n          s.emit('append')\n        }\n      }\n\n      const contig = this.core.header.hints.contiguousLength\n\n      // When the contig length catches up, broadcast the non-sparse length to peers\n      if (appendedNonSparse && contig === this.core.tree.length) {\n        for (const peer of this.peers) {\n          if (peer.broadcastedNonSparse) continue\n\n          peer.broadcastRange(0, contig)\n          peer.broadcastedNonSparse = true\n        }\n      }\n    }\n\n    if (bitfield) {\n      this.replicator.onhave(bitfield.start, bitfield.length, bitfield.drop)\n    }\n\n    if (value) {\n      const byteLength = value.byteLength - this.padding\n\n      for (let i = 0; i < this.sessions.length; i++) {\n        this.sessions[i].emit('download', bitfield.start, byteLength, from)\n      }\n    }\n  }\n\n  _onpeerupdate (added, peer) {\n    const name = added ? 'peer-add' : 'peer-remove'\n\n    for (let i = 0; i < this.sessions.length; i++) {\n      this.sessions[i].emit(name, peer)\n\n      if (added) {\n        for (const ext of this.sessions[i].extensions.values()) {\n          peer.extensions.set(ext.name, ext)\n        }\n      }\n    }\n  }\n\n  async setUserData (key, value, { flush = false } = {}) {\n    if (this.opened === false) await this.opening\n    return this.core.userData(key, value, flush)\n  }\n\n  async getUserData (key) {\n    if (this.opened === false) await this.opening\n    for (const { key: savedKey, value } of this.core.header.userData) {\n      if (key === savedKey) return value\n    }\n    return null\n  }\n\n  createTreeBatch () {\n    return this.core.tree.batch()\n  }\n\n  findingPeers () {\n    this._findingPeers++\n    if (this.replicator !== null && !this.closing) this.replicator.findingPeers++\n\n    let once = true\n\n    return () => {\n      if (this.closing || !once) return\n      once = false\n      this._findingPeers--\n      if (this.replicator !== null && --this.replicator.findingPeers === 0) {\n        this.replicator.updateAll()\n      }\n    }\n  }\n\n  async info (opts) {\n    if (this.opened === false) await this.opening\n\n    return Info.from(this, opts)\n  }\n\n  async update (opts) {\n    if (this.opened === false) await this.opening\n    if (this.closing !== null) return false\n\n    if (this.writable && (!opts || opts.force !== true)) {\n      if (!this.snapshotted) return false\n      return this._updateSnapshot()\n    }\n\n    const remoteWait = this._shouldWait(opts, this.replicator.findingPeers > 0)\n\n    let upgraded = false\n\n    if (await this.replicator.applyPendingReorg()) {\n      upgraded = true\n    }\n\n    if (!upgraded && remoteWait) {\n      const activeRequests = (opts && opts.activeRequests) || this.activeRequests\n      const req = this.replicator.addUpgrade(activeRequests)\n\n      upgraded = await req.promise\n    }\n\n    if (!upgraded) return false\n    if (this.snapshotted) return this._updateSnapshot()\n    return true\n  }\n\n  batch ({ checkout = -1, autoClose = true, session = true, restore = false, clear = false } = {}) {\n    return new Batch(session ? this.session() : this, checkout, autoClose, restore, clear)\n  }\n\n  async seek (bytes, opts) {\n    if (this.opened === false) await this.opening\n    if (!isValidIndex(bytes)) throw ASSERTION('seek is invalid')\n\n    const tree = (opts && opts.tree) || this.core.tree\n    const s = tree.seek(bytes, this.padding)\n\n    const offset = await s.update()\n    if (offset) return offset\n\n    if (this.closing !== null) throw SESSION_CLOSED()\n\n    if (!this._shouldWait(opts, this.wait)) return null\n\n    const activeRequests = (opts && opts.activeRequests) || this.activeRequests\n    const req = this.replicator.addSeek(activeRequests, s)\n\n    const timeout = opts && opts.timeout !== undefined ? opts.timeout : this.timeout\n    if (timeout) req.context.setTimeout(req, timeout)\n\n    return req.promise\n  }\n\n  async has (start, end = start + 1) {\n    if (this.opened === false) await this.opening\n    if (!isValidIndex(start) || !isValidIndex(end)) throw ASSERTION('has range is invalid')\n\n    if (end === start + 1) return this.core.bitfield.get(start)\n\n    const i = this.core.bitfield.firstUnset(start)\n    return i === -1 || i >= end\n  }\n\n  async get (index, opts) {\n    if (this.opened === false) await this.opening\n    if (!isValidIndex(index)) throw ASSERTION('block index is invalid')\n\n    if (this.closing !== null) throw SESSION_CLOSED()\n    if (this._snapshot !== null && index >= this._snapshot.compatLength) throw SNAPSHOT_NOT_AVAILABLE()\n\n    const encoding = (opts && opts.valueEncoding && c.from(opts.valueEncoding)) || this.valueEncoding\n\n    let req = this.cache && this.cache.get(index)\n    if (!req) req = this._get(index, opts)\n\n    let block = await req\n    if (!block) return null\n\n    if (opts && opts.raw) return block\n\n    if (this.encryption && (!opts || opts.decrypt !== false)) {\n      // Copy the block as it might be shared with other sessions.\n      block = b4a.from(block)\n\n      this.encryption.decrypt(index, block)\n    }\n\n    return this._decode(encoding, block)\n  }\n\n  async clear (start, end = start + 1, opts) {\n    if (this.opened === false) await this.opening\n    if (this.closing !== null) throw SESSION_CLOSED()\n\n    if (typeof end === 'object') {\n      opts = end\n      end = start + 1\n    }\n\n    if (!isValidIndex(start) || !isValidIndex(end)) throw ASSERTION('clear range is invalid')\n\n    const cleared = (opts && opts.diff) ? { blocks: 0 } : null\n\n    if (start >= end) return cleared\n    if (start >= this.length) return cleared\n\n    await this.core.clear(start, end, cleared)\n\n    return cleared\n  }\n\n  async purge () {\n    await this._closeAllSessions(null)\n    await this.core.purge()\n  }\n\n  async _get (index, opts) {\n    let block\n\n    if (this.core.bitfield.get(index)) {\n      const tree = (opts && opts.tree) || this.core.tree\n      block = this.core.blocks.get(index, tree)\n\n      if (this.cache) this.cache.set(index, block)\n    } else {\n      if (!this._shouldWait(opts, this.wait)) return null\n\n      if (opts && opts.onwait) opts.onwait(index, this)\n      if (this.onwait) this.onwait(index, this)\n\n      const activeRequests = (opts && opts.activeRequests) || this.activeRequests\n\n      const req = this.replicator.addBlock(activeRequests, index)\n      req.snapshot = index < this.length\n\n      const timeout = opts && opts.timeout !== undefined ? opts.timeout : this.timeout\n      if (timeout) req.context.setTimeout(req, timeout)\n\n      block = this._cacheOnResolve(index, req.promise, this.core.tree.fork)\n    }\n\n    return block\n  }\n\n  async _cacheOnResolve (index, req, fork) {\n    const resolved = await req\n\n    // Unslab only when it takes up less then half the slab\n    const block = resolved !== null && 2 * resolved.byteLength < resolved.buffer.byteLength\n      ? unslab(resolved)\n      : resolved\n\n    if (this.cache && fork === this.core.tree.fork) {\n      this.cache.set(index, Promise.resolve(block))\n    }\n\n    return block\n  }\n\n  _shouldWait (opts, defaultValue) {\n    if (opts) {\n      if (opts.wait === false) return false\n      if (opts.wait === true) return true\n    }\n    return defaultValue\n  }\n\n  createReadStream (opts) {\n    return new ReadStream(this, opts)\n  }\n\n  createWriteStream (opts) {\n    return new WriteStream(this, opts)\n  }\n\n  createByteStream (opts) {\n    return new ByteStream(this, opts)\n  }\n\n  download (range) {\n    const req = this._download(range)\n\n    // do not crash in the background...\n    req.catch(safetyCatch)\n\n    return new Download(req)\n  }\n\n  async _download (range) {\n    if (this.opened === false) await this.opening\n\n    const activeRequests = (range && range.activeRequests) || this.activeRequests\n    return this.replicator.addRange(activeRequests, range)\n  }\n\n  // TODO: get rid of this / deprecate it?\n  undownload (range) {\n    range.destroy(null)\n  }\n\n  // TODO: get rid of this / deprecate it?\n  cancel (request) {\n    // Do nothing for now\n  }\n\n  async truncate (newLength = 0, opts = {}) {\n    if (this.opened === false) await this.opening\n\n    const {\n      fork = this.core.tree.fork + 1,\n      keyPair = this.keyPair,\n      signature = null\n    } = typeof opts === 'number' ? { fork: opts } : opts\n\n    const writable = !this._readonly && !!(signature || (keyPair && keyPair.secretKey))\n    if (writable === false && (newLength > 0 || fork !== this.core.tree.fork)) throw SESSION_NOT_WRITABLE()\n\n    await this.core.truncate(newLength, fork, { keyPair, signature })\n\n    // TODO: Should propagate from an event triggered by the oplog\n    this.replicator.updateAll()\n  }\n\n  async append (blocks, opts = {}) {\n    if (this.opened === false) await this.opening\n\n    const { keyPair = this.keyPair, signature = null } = opts\n    const writable = !this._readonly && !!(signature || (keyPair && keyPair.secretKey))\n\n    if (writable === false) throw SESSION_NOT_WRITABLE()\n\n    blocks = Array.isArray(blocks) ? blocks : [blocks]\n\n    const preappend = this.encryption && this._preappend\n\n    const buffers = this.encodeBatch !== null ? this.encodeBatch(blocks) : new Array(blocks.length)\n\n    if (this.encodeBatch === null) {\n      for (let i = 0; i < blocks.length; i++) {\n        buffers[i] = this._encode(this.valueEncoding, blocks[i])\n      }\n    }\n    for (const b of buffers) {\n      if (b.byteLength > MAX_SUGGESTED_BLOCK_SIZE) {\n        throw BAD_ARGUMENT('Appended block exceeds the maximum suggested block size')\n      }\n    }\n\n    return this.core.append(buffers, { keyPair, signature, preappend })\n  }\n\n  async treeHash (length) {\n    if (length === undefined) {\n      await this.ready()\n      length = this.core.tree.length\n    }\n\n    const roots = await this.core.tree.getRoots(length)\n    return this.crypto.tree(roots)\n  }\n\n  registerExtension (name, handlers = {}) {\n    if (this.extensions.has(name)) {\n      const ext = this.extensions.get(name)\n      ext.handlers = handlers\n      ext.encoding = c.from(handlers.encoding || c.buffer)\n      ext.session = this\n      return ext\n    }\n\n    const ext = {\n      name,\n      handlers,\n      encoding: c.from(handlers.encoding || c.buffer),\n      session: this,\n      send (message, peer) {\n        const buffer = c.encode(this.encoding, message)\n        peer.extension(name, buffer)\n      },\n      broadcast (message) {\n        const buffer = c.encode(this.encoding, message)\n        for (const peer of this.session.peers) {\n          peer.extension(name, buffer)\n        }\n      },\n      destroy () {\n        for (const peer of this.session.peers) {\n          if (peer.extensions.get(name) === ext) peer.extensions.delete(name)\n        }\n        this.session.extensions.delete(name)\n      },\n      _onmessage (state, peer) {\n        const m = this.encoding.decode(state)\n        if (this.handlers.onmessage) this.handlers.onmessage(m, peer)\n      }\n    }\n\n    this.extensions.set(name, ext)\n    for (const peer of this.peers) {\n      peer.extensions.set(name, ext)\n    }\n\n    return ext\n  }\n\n  _encode (enc, val) {\n    const state = { start: this.padding, end: this.padding, buffer: null }\n\n    if (b4a.isBuffer(val)) {\n      if (state.start === 0) return val\n      state.end += val.byteLength\n    } else if (enc) {\n      enc.preencode(state, val)\n    } else {\n      val = b4a.from(val)\n      if (state.start === 0) return val\n      state.end += val.byteLength\n    }\n\n    state.buffer = b4a.allocUnsafe(state.end)\n\n    if (enc) enc.encode(state, val)\n    else state.buffer.set(val, state.start)\n\n    return state.buffer\n  }\n\n  _decode (enc, block) {\n    if (this.padding) block = block.subarray(this.padding)\n    try {\n      if (enc) return c.decode(enc, block)\n    } catch {\n      throw DECODING_ERROR()\n    }\n    return block\n  }\n}\n\nfunction isStream (s) {\n  return typeof s === 'object' && s && typeof s.pipe === 'function'\n}\n\nfunction isRandomAccessClass (fn) {\n  return !!(typeof fn === 'function' && fn.prototype && typeof fn.prototype.open === 'function')\n}\n\nfunction toHex (buf) {\n  return buf && b4a.toString(buf, 'hex')\n}\n\nfunction preappend (blocks) {\n  const offset = this.core.tree.length\n  const fork = this.core.tree.fork\n\n  for (let i = 0; i < blocks.length; i++) {\n    this.encryption.encrypt(offset + i, blocks[i], fork)\n  }\n}\n\nfunction ensureEncryption (core, opts) {\n  if (!opts.encryptionKey) return\n  // Only override the block encryption if it's either not already set or if\n  // the caller provided a different key.\n  if (core.encryption && b4a.equals(core.encryption.key, opts.encryptionKey) && core.encryption.compat === core.core.compat) return\n  core.encryption = new BlockEncryption(opts.encryptionKey, core.key, { compat: core.core ? core.core.compat : true, isBlockKey: opts.isBlockKey })\n}\n\nfunction createCache (cache) {\n  return cache === true ? new Xache({ maxSize: 65536, maxAge: 0 }) : (cache || null)\n}\n\nfunction isValidIndex (index) {\n  return index === 0 || index > 0\n}\nconst hypercoreCrypto = require('hypercore-crypto')\nconst flat = require('flat-tree')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\n\nconst empty = b4a.alloc(32)\n\n// this is optimised for speed over mem atm\n// can be tweaked in the future\n\nmodule.exports = async function auditCore (core) {\n  const corrections = {\n    tree: 0,\n    blocks: 0\n  }\n\n  const length = core.header.tree.length\n\n  const data = await readFullStorage(core.blocks.storage)\n  const tree = await readFullStorage(core.tree.storage)\n\n  const valid = new Uint8Array(Math.ceil(tree.byteLength / 40))\n  const stack = []\n\n  for (const r of core.tree.roots) {\n    valid[r.index] = 1\n    stack.push(r)\n  }\n\n  while (stack.length > 0) {\n    const node = stack.pop()\n    if ((node.index & 1) === 0) continue\n\n    const [left, right] = flat.children(node.index)\n    const leftNode = getNode(left)\n    const rightNode = getNode(right)\n\n    if (!rightNode && !leftNode) continue\n\n    stack.push(leftNode, rightNode)\n\n    if (valid[node.index]) {\n      const hash = hypercoreCrypto.parent(leftNode, rightNode)\n      if (b4a.equals(hash, node.hash) && node.size === (leftNode.size + rightNode.size)) {\n        valid[leftNode.index] = 1\n        valid[rightNode.index] = 1\n        continue\n      }\n    }\n\n    if (leftNode.size) clearNode(leftNode)\n    if (rightNode.size) clearNode(rightNode)\n  }\n\n  if (corrections.tree) {\n    core.tree.cache.clear()\n  }\n\n  let i = 0\n  let nextOffset = -1\n  while (i < length) {\n    const has = core.bitfield.get(i)\n\n    if (!has) {\n      if (i + 1 === length) break\n      i = core.bitfield.findFirst(true, i + 1)\n      if (i < 0) break\n      nextOffset = -1\n      continue\n    }\n\n    if (nextOffset === -1) {\n      try {\n        nextOffset = await core.tree.byteOffset(i * 2)\n      } catch {\n        core._setBitfield(i, false)\n        corrections.blocks++\n        i++\n        continue\n      }\n    }\n\n    const node = getNode(i * 2)\n    const blk = data.subarray(nextOffset, nextOffset + node.size)\n    const hash = hypercoreCrypto.data(blk)\n\n    nextOffset += blk.byteLength\n\n    if (!b4a.equals(hash, node.hash)) {\n      core._setBitfield(i, false)\n      corrections.blocks++\n    }\n\n    i++\n  }\n\n  return corrections\n\n  function getNode (index) {\n    if (index * 40 + 40 > tree.byteLength) return null\n    const state = { start: index * 40, end: index * 40 + 40, buffer: tree }\n    const size = c.uint64.decode(state)\n    const hash = c.fixed32.decode(state)\n    if (size === 0 && hash.equals(empty)) return null\n    return { index, size, hash }\n  }\n\n  function clearNode (node) {\n    valid[node.index] = 0\n\n    if (node.size) {\n      b4a.fill(tree, 0, node.index * 40, node.index * 40 + 40)\n      core.tree.unflushed.set(node.index, core.tree.blankNode(node.index))\n      corrections.tree++\n    }\n  }\n}\n\nfunction readFullStorage (storage) {\n  return new Promise((resolve, reject) => {\n    storage.stat((_, st) => {\n      if (!st) return resolve(b4a.alloc(0))\n      storage.read(0, st.size, (err, data) => {\n        if (err) reject(err)\n        else resolve(data)\n      })\n    })\n  })\n}\nconst { BLOCK_NOT_AVAILABLE, SESSION_CLOSED } = require('hypercore-errors')\nconst EventEmitter = require('events')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst safetyCatch = require('safety-catch')\n\nmodule.exports = class HypercoreBatch extends EventEmitter {\n  constructor (session, checkoutLength, autoClose, restore, clear) {\n    super()\n\n    this.session = session\n    this.opened = false\n    this.closed = false\n    this.opening = null\n    this.closing = null\n    this.writable = true // always writable...\n    this.autoClose = autoClose\n    this.restore = restore\n    this.fork = 0\n\n    this._appends = []\n    this._appendsActual = null\n    this._checkoutLength = checkoutLength\n    this._byteLength = 0\n    this._sessionLength = 0\n    this._sessionByteLength = 0\n    this._sessionBatch = null\n    this._cachedBatch = null\n    this._flushing = null\n    this._clear = clear\n\n    this.opening = this._open()\n    this.opening.catch(safetyCatch)\n  }\n\n  get id () {\n    return this.session.id\n  }\n\n  get key () {\n    return this.session.key\n  }\n\n  get discoveryKey () {\n    return this.session.discoveryKey\n  }\n\n  get indexedLength () {\n    return Math.min(this._sessionLength, this.session.core === null ? 0 : this.session.core.tree.length)\n  }\n\n  get flushedLength () {\n    return this._sessionLength\n  }\n\n  get indexedByteLength () {\n    return this._sessionByteLength\n  }\n\n  get length () {\n    return this._sessionLength + this._appends.length\n  }\n\n  get byteLength () {\n    return this._sessionByteLength + this._byteLength\n  }\n\n  get core () {\n    return this.session.core\n  }\n\n  get manifest () {\n    return this.session.manifest\n  }\n\n  ready () {\n    return this.opening\n  }\n\n  async _open () {\n    await this.session.ready()\n\n    if (this._clear) this._checkoutLength = this.core.tree.length\n\n    if (this._checkoutLength !== -1) {\n      const batch = await this.session.core.tree.restoreBatch(this._checkoutLength)\n      batch.treeLength = this._checkoutLength\n      this._sessionLength = batch.length\n      this._sessionByteLength = batch.byteLength\n      this._sessionBatch = batch\n      if (this._clear) await this.core.clearBatch()\n    } else {\n      const last = this.restore ? this.session.core.bitfield.findFirst(false, this.session.length) : 0\n\n      if (last > this.session.length) {\n        const batch = await this.session.core.tree.restoreBatch(last)\n        this._sessionLength = batch.length\n        this._sessionByteLength = batch.byteLength - this.session.padding * batch.length\n        this._sessionBatch = batch\n      } else {\n        this._sessionLength = this.session.length\n        this._sessionByteLength = this.session.byteLength\n        this._sessionBatch = this.session.createTreeBatch()\n      }\n    }\n\n    this._appendsActual = this.session.encryption ? [] : this._appends\n    this.fork = this.session.fork\n    this.opened = true\n    this.emit('ready')\n  }\n\n  async has (index) {\n    if (this.opened === false) await this.ready()\n    if (index >= this._sessionLength) return index < this.length\n    return this.session.has(index)\n  }\n\n  async update (opts) {\n    if (this.opened === false) await this.ready()\n    await this.session.update(opts)\n  }\n\n  treeHash () {\n    return this._sessionBatch.hash()\n  }\n\n  setUserData (key, value, opts) {\n    return this.session.setUserData(key, value, opts)\n  }\n\n  getUserData (key, opts) {\n    return this.session.getUserData(key, opts)\n  }\n\n  async info (opts) {\n    const session = this.session\n    const info = await session.info(opts)\n\n    info.length = this._sessionLength\n\n    if (info.contiguousLength >= info.length) {\n      info.contiguousLength = info.length += this._appends.length\n    } else {\n      info.length += this._appends.length\n    }\n\n    info.byteLength = this._sessionByteLength + this._byteLength\n\n    return info\n  }\n\n  async seek (bytes, opts = {}) {\n    if (this.opened === false) await this.opening\n    if (this.closing) throw SESSION_CLOSED()\n\n    if (bytes < this._sessionByteLength) return await this.session.seek(bytes, { ...opts, tree: this._sessionBatch })\n\n    bytes -= this._sessionByteLength\n\n    let i = 0\n\n    for (const blk of this._appends) {\n      if (bytes < blk.byteLength) return [this._sessionLength + i, bytes]\n      i++\n      bytes -= blk.byteLength\n    }\n\n    if (bytes === 0) return [this._sessionLength + i, 0]\n\n    throw BLOCK_NOT_AVAILABLE()\n  }\n\n  async get (index, opts = {}) {\n    if (this.opened === false) await this.opening\n    if (this.closing) throw SESSION_CLOSED()\n\n    const length = this._sessionLength\n\n    if (index < length) {\n      return this.session.get(index, { ...opts, tree: this._sessionBatch })\n    }\n\n    if (opts && opts.raw) {\n      return this._appendsActual[index - length] || null\n    }\n\n    const buffer = this._appends[index - length] || null\n    if (!buffer) throw BLOCK_NOT_AVAILABLE()\n\n    const encoding = (opts && opts.valueEncoding && c.from(opts.valueEncoding)) || this.session.valueEncoding\n    if (!encoding) return buffer\n\n    return c.decode(encoding, buffer)\n  }\n\n  async _waitForFlush () {\n    // wait for any pending flush...\n    while (this._flushing) {\n      await this._flushing\n      await Promise.resolve() // yield in case a new flush is queued\n    }\n  }\n\n  async restoreBatch (length, blocks) {\n    if (this.opened === false) await this.opening\n    if (length >= this._sessionLength) return this.createTreeBatch(length, blocks)\n    return this.session.core.tree.restoreBatch(length)\n  }\n\n  _catchupBatch (clone) {\n    if (this._cachedBatch === null) this._cachedBatch = this._sessionBatch.clone()\n\n    if (this.length > this._cachedBatch.length) {\n      const offset = this._cachedBatch.length - this._sessionBatch.length\n\n      for (let i = offset; i < this._appendsActual.length; i++) {\n        this._cachedBatch.append(this._appendsActual[i])\n      }\n    }\n\n    return clone ? this._cachedBatch.clone() : this._cachedBatch\n  }\n\n  createTreeBatch (length, opts = {}) {\n    if (Array.isArray(opts)) opts = { blocks: opts }\n\n    const { blocks = [], clone = true } = opts\n    if (!length && length !== 0) length = this.length + blocks.length\n\n    const maxLength = this.length + blocks.length\n    const b = this._catchupBatch(clone || (blocks.length > 0 || length !== this.length))\n    const len = Math.min(length, this.length)\n\n    if (len < this._sessionLength || length > maxLength) return null\n    if (len < b.length) b.checkout(len, this._sessionBatch.roots)\n\n    for (let i = 0; i < length - len; i++) {\n      b.append(this._appendsActual === this._appends ? blocks[i] : this._encrypt(b.length, blocks[i]))\n    }\n\n    return b\n  }\n\n  async truncate (newLength = 0, opts = {}) {\n    if (this.opened === false) await this.opening\n    if (this.closing) throw SESSION_CLOSED()\n\n    // wait for any pending flush... (prop needs a lock)\n    await this._waitForFlush()\n\n    if (typeof opts === 'number') opts = { fork: opts }\n    const { fork = this.fork + 1, force = false } = opts\n\n    this._cachedBatch = null\n\n    const length = this._sessionLength\n    if (newLength < length) {\n      if (!force) throw new Error('Cannot truncate committed blocks')\n      this._appends.length = 0\n      this._byteLength = 0\n      await this.session.truncate(newLength, { fork, force: true, ...opts })\n      this._sessionLength = this.session.length\n      this._sessionByteLength = this.session.byteLength\n      this._sessionBatch = this.session.createTreeBatch()\n    } else {\n      for (let i = newLength - length; i < this._appends.length; i++) this._byteLength -= this._appends[i].byteLength\n      this._appends.length = newLength - length\n    }\n\n    this.fork = fork\n\n    this.emit('truncate', newLength, this.fork)\n  }\n\n  async append (blocks) {\n    const session = this.session\n\n    if (this.opened === false) await this.opening\n    if (this.closing) throw SESSION_CLOSED()\n\n    // wait for any pending flush... (prop needs a lock)\n    await this._waitForFlush()\n\n    blocks = Array.isArray(blocks) ? blocks : [blocks]\n\n    const buffers = session.encodeBatch !== null\n      ? session.encodeBatch(blocks)\n      : new Array(blocks.length)\n\n    if (session.encodeBatch === null) {\n      for (let i = 0; i < blocks.length; i++) {\n        const buffer = this._encode(session.valueEncoding, blocks[i])\n        buffers[i] = buffer\n        this._byteLength += buffer.byteLength\n      }\n    }\n    if (this._appends !== this._appendsActual) {\n      for (let i = 0; i < buffers.length; i++) {\n        this._appendsActual.push(this._encrypt(this._sessionLength + this._appendsActual.length, buffers[i]))\n      }\n    }\n\n    for (const b of buffers) this._appends.push(b)\n\n    const info = { length: this.length, byteLength: this.byteLength }\n    this.emit('append')\n\n    return info\n  }\n\n  _encode (enc, val) {\n    const state = { start: 0, end: 0, buffer: null }\n\n    if (b4a.isBuffer(val)) {\n      if (state.start === 0) return val\n      state.end += val.byteLength\n    } else if (enc) {\n      enc.preencode(state, val)\n    } else {\n      val = b4a.from(val)\n      if (state.start === 0) return val\n      state.end += val.byteLength\n    }\n\n    state.buffer = b4a.allocUnsafe(state.end)\n\n    if (enc) enc.encode(state, val)\n    else state.buffer.set(val, state.start)\n\n    return state.buffer\n  }\n\n  _encrypt (index, buffer) {\n    const block = b4a.allocUnsafe(buffer.byteLength + 8)\n    block.set(buffer, 8)\n    this.session.encryption.encrypt(index, block, this.fork)\n    return block\n  }\n\n  async flush (opts = {}) {\n    if (this.opened === false) await this.opening\n    if (this.closing) throw SESSION_CLOSED()\n\n    const { length = this.length, keyPair = this.session.keyPair, signature = null, pending = !signature && !keyPair } = opts\n\n    while (this._flushing) await this._flushing\n    this._flushing = this._flush(length, keyPair, signature, pending)\n\n    let flushed = false\n\n    try {\n      flushed = await this._flushing\n    } finally {\n      this._flushing = null\n    }\n\n    if (this.autoClose) await this.close()\n\n    return flushed\n  }\n\n  async _flush (length, keyPair, signature, pending) { // TODO: make this safe to interact with a parallel truncate...\n    if (this._sessionBatch.fork !== this.session.fork) return false // no truncs supported atm\n\n    if (this.session.replicator._upgrade) {\n      for (const req of this.session.replicator._upgrade.inflight) {\n        // yield to the remote inflight upgrade, TODO: if the remote upgrade fails, retry flushing...\n        if (req.upgrade && (req.upgrade.start + req.upgrade.length) > length) {\n          return false\n        }\n      }\n    }\n\n    const flushingLength = Math.min(length - this._sessionLength, this._appends.length)\n    if (flushingLength <= 0) {\n      if (this._sessionLength > this.core.tree.length && length > this.core.tree.length && !pending) {\n        const batch = await this.restoreBatch(length)\n        const info = await this.core.insertBatch(batch, [], { keyPair, signature, pending, treeLength: length })\n        return info !== null\n      }\n      return true\n    }\n\n    const batch = this.createTreeBatch(this._sessionLength + flushingLength)\n    if (batch === null) return false\n\n    const info = await this.core.insertBatch(batch, this._appendsActual, { keyPair, signature, pending, treeLength: this._sessionLength })\n    if (info === null) return false\n\n    const delta = info.byteLength - this._sessionByteLength\n    const newBatch = info.length !== this.session.length ? await this.session.core.tree.restoreBatch(info.length) : this.session.createTreeBatch()\n\n    this._sessionLength = info.length\n    this._sessionByteLength = info.byteLength\n    this._sessionBatch = newBatch\n\n    if (this._cachedBatch !== null) this._cachedBatch.prune(info.length)\n\n    const same = this._appends === this._appendsActual\n\n    this._appends = this._appends.slice(flushingLength)\n    this._appendsActual = same ? this._appends : this._appendsActual.slice(flushingLength)\n    this._byteLength -= delta\n\n    this.emit('flush')\n\n    return true\n  }\n\n  close () {\n    if (!this.closing) this.closing = this._close()\n    return this.closing\n  }\n\n  async _close () {\n    this._clearAppends()\n\n    await this.session.close()\n\n    this.closed = true\n    this.emit('close')\n  }\n\n  _clearAppends () {\n    this._appends = []\n    this._appendsActual = []\n    this._byteLength = 0\n    this.fork = 0\n  }\n}\nconst c = require('compact-encoding')\nconst { oplog } = require('./messages')\n\nmodule.exports = class BigHeader {\n  constructor (storage) {\n    this.storage = storage\n  }\n\n  async load (external) {\n    const buf = await new Promise((resolve, reject) => {\n      this.storage.read(external.start, external.length, (err, buf) => {\n        if (err) return reject(err)\n        resolve(buf)\n      })\n    })\n\n    const header = c.decode(oplog.header, buf)\n    header.external = external\n    return header\n  }\n\n  async flush (header) {\n    const external = header.external || { start: 0, length: 0 }\n    header.external = null\n\n    const buf = c.encode(oplog.header, header)\n\n    let start = 0\n    if (buf.byteLength > external.start) {\n      start = external.start + external.length\n      const rem = start & 4095\n      if (rem > 0) start += (4096 - rem)\n    }\n\n    header.external = { start, length: buf.byteLength }\n\n    await new Promise((resolve, reject) => {\n      this.storage.write(start, buf, (err) => {\n        if (err) return reject(err)\n        resolve()\n      })\n    })\n\n    return header\n  }\n\n  close () {\n    return new Promise((resolve, reject) => {\n      this.storage.close((err) => {\n        if (err) return reject(err)\n        resolve()\n      })\n    })\n  }\n}\nconst BigSparseArray = require('big-sparse-array')\nconst b4a = require('b4a')\nconst quickbit = require('./compat').quickbit\n\nconst BITS_PER_PAGE = 32768\nconst BYTES_PER_PAGE = BITS_PER_PAGE / 8\nconst WORDS_PER_PAGE = BYTES_PER_PAGE / 4\nconst BITS_PER_SEGMENT = 2097152\nconst BYTES_PER_SEGMENT = BITS_PER_SEGMENT / 8\nconst WORDS_PER_SEGMENT = BYTES_PER_SEGMENT / 4\nconst INITIAL_WORDS_PER_SEGMENT = 1024\nconst PAGES_PER_SEGMENT = BITS_PER_SEGMENT / BITS_PER_PAGE\nconst SEGMENT_GROWTH_FACTOR = 4\n\nclass BitfieldPage {\n  constructor (index, segment) {\n    this.dirty = false\n    this.index = index\n    this.offset = index * BYTES_PER_PAGE - segment.offset\n    this.bitfield = null\n    this.segment = segment\n\n    segment.add(this)\n  }\n\n  get tree () {\n    return this.segment.tree\n  }\n\n  get (index) {\n    return quickbit.get(this.bitfield, index)\n  }\n\n  set (index, val) {\n    if (quickbit.set(this.bitfield, index, val)) {\n      this.tree.update(this.offset * 8 + index)\n    }\n  }\n\n  setRange (start, length, val) {\n    quickbit.fill(this.bitfield, val, start, start + length)\n\n    let i = Math.floor(start / 128)\n    const n = i + Math.ceil(length / 128)\n\n    while (i <= n) this.tree.update(this.offset * 8 + i++ * 128)\n  }\n\n  findFirst (val, position) {\n    return quickbit.findFirst(this.bitfield, val, position)\n  }\n\n  findLast (val, position) {\n    return quickbit.findLast(this.bitfield, val, position)\n  }\n\n  count (start, length, val) {\n    const end = start + length\n\n    let i = start\n    let c = 0\n\n    while (length > 0) {\n      const l = this.findFirst(val, i)\n      if (l === -1 || l >= end) return c\n\n      const h = this.findFirst(!val, l + 1)\n      if (h === -1 || h >= end) return c + end - l\n\n      c += h - l\n      length -= h - i\n      i = h\n    }\n\n    return c\n  }\n}\n\nclass BitfieldSegment {\n  constructor (index, bitfield) {\n    this.index = index\n    this.offset = index * BYTES_PER_SEGMENT\n    this.tree = quickbit.Index.from(bitfield, BYTES_PER_SEGMENT)\n    this.pages = new Array(PAGES_PER_SEGMENT)\n  }\n\n  get bitfield () {\n    return this.tree.field\n  }\n\n  add (page) {\n    const i = page.index - this.index * PAGES_PER_SEGMENT\n    this.pages[i] = page\n\n    const start = i * WORDS_PER_PAGE\n    const end = start + WORDS_PER_PAGE\n\n    if (end >= this.bitfield.length) this.reallocate(end)\n\n    page.bitfield = this.bitfield.subarray(start, end)\n  }\n\n  reallocate (length) {\n    let target = this.bitfield.length\n    while (target < length) target *= SEGMENT_GROWTH_FACTOR\n\n    const bitfield = new Uint32Array(target)\n    bitfield.set(this.bitfield)\n\n    this.tree = quickbit.Index.from(bitfield, BYTES_PER_SEGMENT)\n\n    for (let i = 0; i < this.pages.length; i++) {\n      const page = this.pages[i]\n      if (!page) continue\n\n      const start = i * WORDS_PER_PAGE\n      const end = start + WORDS_PER_PAGE\n\n      page.bitfield = bitfield.subarray(start, end)\n    }\n  }\n\n  findFirst (val, position) {\n    position = this.tree.skipFirst(!val, position)\n\n    let j = position & (BITS_PER_PAGE - 1)\n    let i = (position - j) / BITS_PER_PAGE\n\n    if (i >= PAGES_PER_SEGMENT) return -1\n\n    while (i < this.pages.length) {\n      const p = this.pages[i]\n\n      let index = -1\n\n      if (p) index = p.findFirst(val, j)\n      else if (!val) index = j\n\n      if (index !== -1) return i * BITS_PER_PAGE + index\n\n      j = 0\n      i++\n    }\n\n    return -1\n  }\n\n  findLast (val, position) {\n    position = this.tree.skipLast(!val, position)\n\n    let j = position & (BITS_PER_PAGE - 1)\n    let i = (position - j) / BITS_PER_PAGE\n\n    if (i >= PAGES_PER_SEGMENT) return -1\n\n    while (i >= 0) {\n      const p = this.pages[i]\n\n      let index = -1\n\n      if (p) index = p.findLast(val, j)\n      else if (!val) index = j\n\n      if (index !== -1) return i * BITS_PER_PAGE + index\n\n      j = BITS_PER_PAGE - 1\n      i--\n    }\n\n    return -1\n  }\n}\n\nmodule.exports = class Bitfield {\n  constructor (storage, buffer) {\n    this.unflushed = []\n    this.storage = storage\n    this.resumed = !!(buffer && buffer.byteLength >= 4)\n\n    this._pages = new BigSparseArray()\n    this._segments = new BigSparseArray()\n\n    const view = this.resumed\n      ? new Uint32Array(\n        buffer.buffer,\n        buffer.byteOffset,\n        Math.floor(buffer.byteLength / 4)\n      )\n      : new Uint32Array(INITIAL_WORDS_PER_SEGMENT)\n\n    for (let i = 0; i < view.length; i += WORDS_PER_SEGMENT) {\n      let bitfield = view.subarray(i, i + (WORDS_PER_SEGMENT))\n      let length = WORDS_PER_SEGMENT\n\n      if (i === 0) {\n        length = INITIAL_WORDS_PER_SEGMENT\n        while (length < bitfield.length) length *= SEGMENT_GROWTH_FACTOR\n      }\n\n      if (bitfield.length !== length) {\n        const copy = new Uint32Array(length)\n        copy.set(bitfield, 0)\n        bitfield = copy\n      }\n\n      const segment = new BitfieldSegment(i / (WORDS_PER_SEGMENT), bitfield)\n      this._segments.set(segment.index, segment)\n\n      for (let j = 0; j < bitfield.length; j += WORDS_PER_PAGE) {\n        const page = new BitfieldPage((i + j) / WORDS_PER_PAGE, segment)\n        this._pages.set(page.index, page)\n      }\n    }\n  }\n\n  toBuffer (length) {\n    const pages = Math.ceil(length / BITS_PER_PAGE)\n    const buffer = b4a.allocUnsafe(pages * BYTES_PER_PAGE)\n\n    for (let i = 0; i < pages; i++) {\n      const page = this._pages.get(i)\n      const offset = i * BYTES_PER_PAGE\n\n      if (page) {\n        const buf = b4a.from(\n          page.bitfield.buffer,\n          page.bitfield.byteOffset,\n          page.bitfield.byteLength\n        )\n\n        buffer.set(buf, offset)\n      } else {\n        buffer.fill(0, offset, offset + BYTES_PER_PAGE)\n      }\n    }\n\n    return buffer\n  }\n\n  getBitfield (index) {\n    const j = index & (BITS_PER_PAGE - 1)\n    const i = (index - j) / BITS_PER_PAGE\n\n    const p = this._pages.get(i)\n    return p || null\n  }\n\n  get (index) {\n    const j = index & (BITS_PER_PAGE - 1)\n    const i = (index - j) / BITS_PER_PAGE\n\n    const p = this._pages.get(i)\n\n    return p ? p.get(j) : false\n  }\n\n  set (index, val) {\n    const j = index & (BITS_PER_PAGE - 1)\n    const i = (index - j) / BITS_PER_PAGE\n\n    let p = this._pages.get(i)\n\n    if (!p && val) {\n      const k = Math.floor(i / PAGES_PER_SEGMENT)\n      const s = this._segments.get(k) || this._segments.set(k, new BitfieldSegment(k, new Uint32Array(k === 0 ? INITIAL_WORDS_PER_SEGMENT : WORDS_PER_SEGMENT)))\n\n      p = this._pages.set(i, new BitfieldPage(i, s))\n    }\n\n    if (p) {\n      p.set(j, val)\n\n      if (!p.dirty) {\n        p.dirty = true\n        this.unflushed.push(p)\n      }\n    }\n  }\n\n  setRange (start, length, val) {\n    let j = start & (BITS_PER_PAGE - 1)\n    let i = (start - j) / BITS_PER_PAGE\n\n    while (length > 0) {\n      let p = this._pages.get(i)\n\n      if (!p && val) {\n        const k = Math.floor(i / PAGES_PER_SEGMENT)\n        const s = this._segments.get(k) || this._segments.set(k, new BitfieldSegment(k, new Uint32Array(k === 0 ? INITIAL_WORDS_PER_SEGMENT : WORDS_PER_SEGMENT)))\n\n        p = this._pages.set(i, new BitfieldPage(i, s))\n      }\n\n      const end = Math.min(j + length, BITS_PER_PAGE)\n      const range = end - j\n\n      if (p) {\n        p.setRange(j, range, val)\n\n        if (!p.dirty) {\n          p.dirty = true\n          this.unflushed.push(p)\n        }\n      }\n\n      j = 0\n      i++\n      length -= range\n    }\n  }\n\n  findFirst (val, position) {\n    let j = position & (BITS_PER_SEGMENT - 1)\n    let i = (position - j) / BITS_PER_SEGMENT\n\n    while (i < this._segments.maxLength) {\n      const s = this._segments.get(i)\n\n      let index = -1\n\n      if (s) index = s.findFirst(val, j)\n      else if (!val) index = j\n\n      if (index !== -1) return i * BITS_PER_SEGMENT + index\n\n      j = 0\n      i++\n    }\n\n    return val ? -1 : this._segments.maxLength * BITS_PER_SEGMENT\n  }\n\n  firstSet (position) {\n    return this.findFirst(true, position)\n  }\n\n  firstUnset (position) {\n    return this.findFirst(false, position)\n  }\n\n  findLast (val, position) {\n    let j = position & (BITS_PER_SEGMENT - 1)\n    let i = (position - j) / BITS_PER_SEGMENT\n\n    while (i >= 0) {\n      const s = this._segments.get(i)\n\n      let index = -1\n\n      if (s) index = s.findLast(val, j)\n      else if (!val) index = j\n\n      if (index !== -1) return i * BITS_PER_SEGMENT + index\n\n      j = BITS_PER_SEGMENT - 1\n      i--\n    }\n\n    return -1\n  }\n\n  lastSet (position) {\n    return this.findLast(true, position)\n  }\n\n  lastUnset (position) {\n    return this.findLast(false, position)\n  }\n\n  count (start, length, val) {\n    let j = start & (BITS_PER_PAGE - 1)\n    let i = (start - j) / BITS_PER_PAGE\n    let c = 0\n\n    while (length > 0) {\n      const p = this._pages.get(i)\n\n      const end = Math.min(j + length, BITS_PER_PAGE)\n      const range = end - j\n\n      if (p) c += p.count(j, range, val)\n      else if (!val) c += range\n\n      j = 0\n      i++\n      length -= range\n    }\n\n    return c\n  }\n\n  countSet (start, length) {\n    return this.count(start, length, true)\n  }\n\n  countUnset (start, length) {\n    return this.count(start, length, false)\n  }\n\n  * want (start, length) {\n    const j = start & (BITS_PER_SEGMENT - 1)\n    let i = (start - j) / BITS_PER_SEGMENT\n\n    while (length > 0) {\n      const s = this._segments.get(i)\n\n      if (s) {\n        // We always send at least 4 KiB worth of bitfield in a want, rounding\n        // to the nearest 4 KiB.\n        const end = ceilTo(clamp(length / 8, 4096, BYTES_PER_SEGMENT), 4096)\n\n        yield {\n          start: i * BITS_PER_SEGMENT,\n          bitfield: s.bitfield.subarray(0, end / 4)\n        }\n      }\n\n      i++\n      length -= BITS_PER_SEGMENT\n    }\n  }\n\n  clear () {\n    return new Promise((resolve, reject) => {\n      this.storage.truncate(0, (err) => {\n        if (err) return reject(err)\n        this._pages = new BigSparseArray()\n        this.unflushed = []\n        resolve()\n      })\n    })\n  }\n\n  close () {\n    return new Promise((resolve, reject) => {\n      this.storage.close((err) => {\n        if (err) reject(err)\n        else resolve()\n      })\n    })\n  }\n\n  flush () {\n    return new Promise((resolve, reject) => {\n      if (!this.unflushed.length) return resolve()\n\n      const self = this\n      let missing = this.unflushed.length\n      let error = null\n\n      for (const page of this.unflushed) {\n        const buf = b4a.from(\n          page.bitfield.buffer,\n          page.bitfield.byteOffset,\n          page.bitfield.byteLength\n        )\n\n        page.dirty = false\n        this.storage.write(page.index * BYTES_PER_PAGE, buf, done)\n      }\n\n      function done (err) {\n        if (err) error = err\n        if (--missing) return\n        if (error) return reject(error)\n        self.unflushed = []\n        resolve()\n      }\n    })\n  }\n\n  static open (storage, tree = null) {\n    return new Promise((resolve, reject) => {\n      storage.stat((err, st) => {\n        if (err) return resolve(new Bitfield(storage, null))\n        let size = st.size - (st.size & 3)\n        if (!size) return resolve(new Bitfield(storage, null))\n        if (tree) size = Math.min(size, ceilTo(tree.length / 8, 4096))\n        storage.read(0, size, (err, data) => {\n          if (err) return reject(err)\n          resolve(new Bitfield(storage, data))\n        })\n      })\n    })\n  }\n}\n\nfunction clamp (n, min, max) {\n  return Math.min(Math.max(n, min), max)\n}\n\nfunction ceilTo (n, multiple = 1) {\n  const remainder = n % multiple\n  if (remainder === 0) return n\n  return n + multiple - remainder\n}\nconst sodium = require('sodium-universal')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst { BLOCK_ENCRYPTION } = require('./caps')\n\nconst nonce = b4a.alloc(sodium.crypto_stream_NONCEBYTES)\n\nmodule.exports = class BlockEncryption {\n  constructor (encryptionKey, hypercoreKey, { isBlockKey = false, compat = true } = {}) {\n    const subKeys = b4a.alloc(2 * sodium.crypto_stream_KEYBYTES)\n\n    this.key = encryptionKey\n    this.blockKey = isBlockKey ? encryptionKey : subKeys.subarray(0, sodium.crypto_stream_KEYBYTES)\n    this.blindingKey = subKeys.subarray(sodium.crypto_stream_KEYBYTES)\n    this.padding = 8\n    this.compat = compat\n    this.isBlockKey = isBlockKey\n\n    if (!isBlockKey) {\n      if (compat) sodium.crypto_generichash_batch(this.blockKey, [encryptionKey], hypercoreKey)\n      else sodium.crypto_generichash_batch(this.blockKey, [BLOCK_ENCRYPTION, hypercoreKey, encryptionKey])\n    }\n\n    sodium.crypto_generichash(this.blindingKey, this.blockKey)\n  }\n\n  encrypt (index, block, fork) {\n    const padding = block.subarray(0, this.padding)\n    block = block.subarray(this.padding)\n\n    c.uint64.encode({ start: 0, end: 8, buffer: padding }, fork)\n    c.uint64.encode({ start: 0, end: 8, buffer: nonce }, index)\n\n    // Zero out any previous padding.\n    nonce.fill(0, 8, 8 + padding.byteLength)\n\n    // Blind the fork ID, possibly risking reusing the nonce on a reorg of the\n    // Hypercore. This is fine as the blinding is best-effort and the latest\n    // fork ID shared on replication anyway.\n    sodium.crypto_stream_xor(\n      padding,\n      padding,\n      nonce,\n      this.blindingKey\n    )\n\n    nonce.set(padding, 8)\n\n    // The combination of a (blinded) fork ID and a block index is unique for a\n    // given Hypercore and is therefore a valid nonce for encrypting the block.\n    sodium.crypto_stream_xor(\n      block,\n      block,\n      nonce,\n      this.blockKey\n    )\n  }\n\n  decrypt (index, block) {\n    const padding = block.subarray(0, this.padding)\n    block = block.subarray(this.padding)\n\n    c.uint64.encode({ start: 0, end: 8, buffer: nonce }, index)\n\n    nonce.set(padding, 8)\n\n    // Decrypt the block using the blinded fork ID.\n    sodium.crypto_stream_xor(\n      block,\n      block,\n      nonce,\n      this.blockKey\n    )\n  }\n}\nconst b4a = require('b4a')\nconst { WRITE_FAILED } = require('hypercore-errors')\n\nmodule.exports = class BlockStore {\n  constructor (storage, tree) {\n    this.storage = storage\n    this.tree = tree\n  }\n\n  async get (i, tree) {\n    if (!tree) tree = this.tree\n    const [offset, size] = await tree.byteRange(2 * i)\n    return this._read(offset, size)\n  }\n\n  async put (i, data, offset) {\n    return this._write(offset, data)\n  }\n\n  putBatch (i, batch, offset) {\n    if (batch.length === 0) return Promise.resolve()\n    return this.put(i, batch.length === 1 ? batch[0] : b4a.concat(batch), offset)\n  }\n\n  clear (offset = 0, length = -1) {\n    return new Promise((resolve, reject) => {\n      if (length === -1) this.storage.truncate(offset, done)\n      else this.storage.del(offset, length, done)\n\n      function done (err) {\n        if (err) reject(err)\n        else resolve()\n      }\n    })\n  }\n\n  close () {\n    return new Promise((resolve, reject) => {\n      this.storage.close((err) => {\n        if (err) reject(err)\n        else resolve()\n      })\n    })\n  }\n\n  _read (offset, size) {\n    return new Promise((resolve, reject) => {\n      this.storage.read(offset, size, (err, data) => {\n        if (err) reject(err)\n        else resolve(data)\n      })\n    })\n  }\n\n  _write (offset, data) {\n    return new Promise((resolve, reject) => {\n      this.storage.write(offset, data, (err) => {\n        if (err) reject(WRITE_FAILED(err.message))\n        else resolve(offset + data.byteLength)\n      })\n    })\n  }\n}\nconst crypto = require('hypercore-crypto')\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\n\n// TODO: rename this to \"crypto\" and move everything hashing related etc in here\n// Also lets move the tree stuff from hypercore-crypto here\n\nconst [\n  TREE,\n  REPLICATE_INITIATOR,\n  REPLICATE_RESPONDER,\n  MANIFEST,\n  DEFAULT_NAMESPACE,\n  BLOCK_ENCRYPTION\n] = crypto.namespace('hypercore', 6)\n\nexports.MANIFEST = MANIFEST\nexports.DEFAULT_NAMESPACE = DEFAULT_NAMESPACE\nexports.BLOCK_ENCRYPTION = BLOCK_ENCRYPTION\n\nexports.replicate = function (isInitiator, key, handshakeHash) {\n  const out = b4a.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, [isInitiator ? REPLICATE_INITIATOR : REPLICATE_RESPONDER, key], handshakeHash)\n  return out\n}\n\nexports.treeSignable = function (manifestHash, treeHash, length, fork) {\n  const state = { start: 0, end: 112, buffer: b4a.allocUnsafe(112) }\n  c.fixed32.encode(state, TREE)\n  c.fixed32.encode(state, manifestHash)\n  c.fixed32.encode(state, treeHash)\n  c.uint64.encode(state, length)\n  c.uint64.encode(state, fork)\n  return state.buffer\n}\n\nexports.treeSignableCompat = function (hash, length, fork, noHeader) {\n  const end = noHeader ? 48 : 80\n  const state = { start: 0, end, buffer: b4a.allocUnsafe(end) }\n  if (!noHeader) c.fixed32.encode(state, TREE) // ultra legacy mode, kill in future major\n  c.fixed32.encode(state, hash)\n  c.uint64.encode(state, length)\n  c.uint64.encode(state, fork)\n  return state.buffer\n}\n// Export the appropriate version of `quickbit-universal` as the plain import\n// may resolve to an older version in some environments\nlet quickbit = require('quickbit-universal')\nif (\n  typeof quickbit.findFirst !== 'function' ||\n  typeof quickbit.findLast !== 'function' ||\n  typeof quickbit.clear !== 'function'\n) {\n  // This should always load the fallback from the locally installed version\n  quickbit = require('quickbit-universal/fallback')\n}\nexports.quickbit = quickbit\nconst hypercoreCrypto = require('hypercore-crypto')\nconst b4a = require('b4a')\nconst unslab = require('unslab')\nconst Oplog = require('./oplog')\nconst BigHeader = require('./big-header')\nconst Mutex = require('./mutex')\nconst MerkleTree = require('./merkle-tree')\nconst BlockStore = require('./block-store')\nconst Bitfield = require('./bitfield')\nconst RemoteBitfield = require('./remote-bitfield')\nconst Info = require('./info')\nconst { BAD_ARGUMENT, STORAGE_EMPTY, STORAGE_CONFLICT, INVALID_OPERATION, INVALID_SIGNATURE, INVALID_CHECKSUM } = require('hypercore-errors')\nconst m = require('./messages')\nconst Verifier = require('./verifier')\nconst audit = require('./audit')\n\nmodule.exports = class Core {\n  constructor (header, compat, crypto, oplog, bigHeader, tree, blocks, bitfield, verifier, sessions, legacy, globalCache, onupdate, onconflict) {\n    this.onupdate = onupdate\n    this.onconflict = onconflict\n    this.preupdate = null\n    this.header = header\n    this.compat = compat\n    this.crypto = crypto\n    this.oplog = oplog\n    this.bigHeader = bigHeader\n    this.tree = tree\n    this.blocks = blocks\n    this.bitfield = bitfield\n    this.verifier = verifier\n    this.truncating = 0\n    this.updating = false\n    this.closed = false\n    this.skipBitfield = null\n    this.active = sessions.length\n    this.sessions = sessions\n    this.globalCache = globalCache\n\n    this._manifestFlushed = !!header.manifest\n    this._maxOplogSize = 65536\n    this._autoFlush = 1\n    this._verifies = null\n    this._verifiesFlushed = null\n    this._mutex = new Mutex()\n    this._legacy = legacy\n  }\n\n  static async open (storage, opts = {}) {\n    const oplogFile = storage('oplog')\n    const treeFile = storage('tree')\n    const bitfieldFile = storage('bitfield')\n    const dataFile = storage('data')\n    const headerFile = storage('header')\n\n    try {\n      return await this.resume(oplogFile, treeFile, bitfieldFile, dataFile, headerFile, opts)\n    } catch (err) {\n      await closeAll(oplogFile, treeFile, bitfieldFile, dataFile, headerFile)\n      throw err\n    }\n  }\n\n  static async resume (oplogFile, treeFile, bitfieldFile, dataFile, headerFile, opts) {\n    let overwrite = opts.overwrite === true\n\n    const force = opts.force === true\n    const createIfMissing = opts.createIfMissing !== false\n    const crypto = opts.crypto || hypercoreCrypto\n    // kill this flag soon\n    const legacy = !!opts.legacy\n\n    const oplog = new Oplog(oplogFile, {\n      headerEncoding: m.oplog.header,\n      entryEncoding: m.oplog.entry,\n      readonly: opts.readonly\n    })\n\n    // default to true for now if no manifest is provided\n    let compat = opts.compat === true || (opts.compat !== false && !opts.manifest)\n\n    let { header, entries } = await oplog.open()\n\n    if (force && opts.key && header && !b4a.equals(header.key, opts.key)) {\n      overwrite = true\n    }\n\n    const bigHeader = new BigHeader(headerFile)\n\n    if (!header || overwrite) {\n      if (!createIfMissing) {\n        throw STORAGE_EMPTY('No Hypercore is stored here')\n      }\n\n      if (compat) {\n        if (opts.key && opts.keyPair && !b4a.equals(opts.key, opts.keyPair.publicKey)) {\n          throw BAD_ARGUMENT('Key must match publicKey when in compat mode')\n        }\n      }\n\n      const keyPair = opts.keyPair || (opts.key ? null : crypto.keyPair())\n      const defaultManifest = !opts.manifest && (!!opts.compat || !opts.key || !!(keyPair && b4a.equals(opts.key, keyPair.publicKey)))\n      const manifest = defaultManifest ? Verifier.defaultSignerManifest(opts.key || keyPair.publicKey) : Verifier.createManifest(opts.manifest)\n\n      header = {\n        external: null,\n        key: opts.key || (compat ? manifest.signers[0].publicKey : Verifier.manifestHash(manifest)),\n        manifest,\n        keyPair: keyPair ? { publicKey: keyPair.publicKey, secretKey: keyPair.secretKey || null } : null,\n        userData: [],\n        tree: {\n          fork: 0,\n          length: 0,\n          rootHash: null,\n          signature: null\n        },\n        hints: {\n          reorgs: [],\n          contiguousLength: 0\n        }\n      }\n\n      await flushHeader(oplog, bigHeader, header)\n    } else if (header.external) {\n      header = await bigHeader.load(header.external)\n    }\n\n    // unslab the long lived buffers to avoid keeping the slab alive\n    header.key = unslab(header.key)\n    header.tree.rootHash = unslab(header.tree.rootHash)\n    header.tree.signature = unslab(header.tree.signature)\n\n    if (header.keyPair) {\n      header.keyPair.publicKey = unslab(header.keyPair.publicKey)\n      header.keyPair.secretKey = unslab(header.keyPair.secretKey)\n    }\n\n    if (opts.manifest) {\n      // if we provide a manifest and no key, verify that the stored key is the same\n      if (!opts.key && !Verifier.isValidManifest(header.key, Verifier.createManifest(opts.manifest))) {\n        throw STORAGE_CONFLICT('Manifest does not hash to provided key')\n      }\n\n      if (!header.manifest) header.manifest = opts.manifest\n    }\n\n    if (opts.key && !b4a.equals(header.key, opts.key)) {\n      throw STORAGE_CONFLICT('Another Hypercore is stored here')\n    }\n\n    // if we signalled compat, but already now this core isn't disable it\n    if (compat && header.manifest && !Verifier.isCompat(header.key, header.manifest)) {\n      compat = false\n    } else if (!compat && header.manifest && Verifier.isCompat(header.key, header.manifest)) {\n      compat = true\n    }\n\n    const prologue = header.manifest ? header.manifest.prologue : null\n\n    const tree = await MerkleTree.open(treeFile, { crypto, prologue, ...header.tree })\n    const bitfield = await Bitfield.open(bitfieldFile)\n    const blocks = new BlockStore(dataFile, tree)\n\n    if (overwrite) {\n      await tree.clear()\n      await blocks.clear()\n      await bitfield.clear()\n      entries = []\n    }\n\n    // compat from earlier version that do not store contig length\n    if (header.hints.contiguousLength === 0) {\n      while (bitfield.get(header.hints.contiguousLength)) header.hints.contiguousLength++\n    }\n\n    // to unslab\n    if (header.manifest) header.manifest = Verifier.createManifest(header.manifest)\n\n    const verifier = header.manifest ? new Verifier(header.key, header.manifest, { crypto, legacy }) : null\n\n    for (const e of entries) {\n      if (e.userData) {\n        updateUserData(header.userData, e.userData.key, e.userData.value)\n      }\n\n      if (e.treeNodes) {\n        for (const node of e.treeNodes) {\n          tree.addNode(node)\n        }\n      }\n\n      if (e.bitfield) {\n        bitfield.setRange(e.bitfield.start, e.bitfield.length, !e.bitfield.drop)\n        updateContig(header, e.bitfield, bitfield)\n      }\n\n      if (e.treeUpgrade) {\n        const batch = await tree.truncate(e.treeUpgrade.length, e.treeUpgrade.fork)\n        batch.ancestors = e.treeUpgrade.ancestors\n        batch.signature = unslab(e.treeUpgrade.signature)\n        addReorgHint(header.hints.reorgs, tree, batch)\n        batch.commit()\n\n        header.tree.length = tree.length\n        header.tree.fork = tree.fork\n        header.tree.rootHash = tree.hash()\n        header.tree.signature = tree.signature\n      }\n    }\n\n    for (const entry of header.userData) {\n      entry.value = unslab(entry.value)\n    }\n\n    return new this(header, compat, crypto, oplog, bigHeader, tree, blocks, bitfield, verifier, opts.sessions || [], legacy, opts.globalCache || null, opts.onupdate || noop, opts.onconflict || noop)\n  }\n\n  async audit () {\n    await this._mutex.lock()\n\n    try {\n      await this._flushOplog()\n      const corrections = await audit(this)\n      if (corrections.blocks || corrections.tree) await this._flushOplog()\n      return corrections\n    } finally {\n      await this._mutex.unlock()\n    }\n  }\n\n  async setManifest (manifest) {\n    await this._mutex.lock()\n\n    try {\n      if (manifest && this.header.manifest === null) {\n        if (!Verifier.isValidManifest(this.header.key, manifest)) throw INVALID_CHECKSUM('Manifest hash does not match')\n        this._setManifest(Verifier.createManifest(manifest), null)\n        await this._flushOplog()\n      }\n    } finally {\n      this._mutex.unlock()\n    }\n  }\n\n  _setManifest (manifest, keyPair) {\n    if (!manifest && b4a.equals(keyPair.publicKey, this.header.key)) manifest = Verifier.defaultSignerManifest(this.header.key)\n    if (!manifest) return\n\n    const verifier = new Verifier(this.header.key, manifest, { crypto: this.crypto, legacy: this._legacy })\n\n    if (verifier.prologue) this.tree.setPrologue(verifier.prologue)\n\n    this.header.manifest = manifest\n    this.compat = verifier.compat\n    this.verifier = verifier\n    this._manifestFlushed = false\n\n    this.onupdate(0b10000, null, null, null)\n  }\n\n  _shouldFlush () {\n    // TODO: make something more fancy for auto flush mode (like fibonacci etc)\n    if (--this._autoFlush <= 0 || this.oplog.byteLength >= this._maxOplogSize) {\n      this._autoFlush = 4\n      return true\n    }\n\n    if (!this._manifestFlushed && this.header.manifest) {\n      this._manifestFlushed = true\n      return true\n    }\n\n    return false\n  }\n\n  async copyPrologue (src, { additional = [] } = {}) {\n    await this._mutex.lock()\n\n    try {\n      await src._mutex.lock()\n    } catch (err) {\n      this._mutex.unlock()\n      throw err\n    }\n\n    try {\n      const prologue = this.header.manifest && this.header.manifest.prologue\n      if (!prologue) throw INVALID_OPERATION('No prologue present')\n\n      const srcLength = prologue.length - additional.length\n      const srcBatch = srcLength !== src.tree.length ? await src.tree.truncate(srcLength) : src.tree.batch()\n      const srcRoots = srcBatch.roots.slice(0)\n      const srcByteLength = srcBatch.byteLength\n\n      for (const blk of additional) srcBatch.append(blk)\n\n      if (!b4a.equals(srcBatch.hash(), prologue.hash)) throw INVALID_OPERATION('Source tree is conflicting')\n\n      // all hashes are correct, lets copy\n\n      const entry = {\n        userData: null,\n        treeNodes: srcRoots,\n        treeUpgrade: null,\n        bitfield: null\n      }\n\n      if (additional.length) {\n        await this.blocks.putBatch(srcLength, additional, srcByteLength)\n        entry.treeNodes = entry.treeNodes.concat(srcBatch.nodes)\n        entry.bitfield = {\n          drop: false,\n          start: srcLength,\n          length: additional.length\n        }\n      }\n\n      await this.oplog.append([entry], false)\n      this.tree.addNodes(entry.treeNodes)\n\n      if (this.header.tree.length < srcBatch.length) {\n        this.header.tree.length = srcBatch.length\n        this.header.tree.rootHash = srcBatch.hash()\n\n        this.tree.length = srcBatch.length\n        this.tree.byteLength = srcBatch.byteLength\n        this.tree.roots = srcBatch.roots\n        this.onupdate(0b0001, null, null, null)\n      }\n\n      if (entry.bitfield) {\n        this._setBitfieldRange(entry.bitfield.start, entry.bitfield.length, true)\n        this.onupdate(0, entry.bitfield, null, null)\n      }\n\n      await this._flushOplog()\n\n      // no more additional blocks now and we should be consistant on disk\n      // copy over all existing segments...\n\n      let segmentEnd = 0\n\n      while (segmentEnd < srcLength) {\n        const segmentStart = maximumSegmentStart(segmentEnd, src.bitfield, this.bitfield)\n        if (segmentStart >= srcLength || segmentStart < 0) break\n\n        // max segment is 65536 to avoid running out of memory\n        segmentEnd = Math.min(segmentStart + 65536, srcLength, minimumSegmentEnd(segmentStart, src.bitfield, this.bitfield))\n\n        const treeNodes = await src.tree.getNeededNodes(srcLength, segmentStart, segmentEnd)\n        const bitfield = {\n          drop: false,\n          start: segmentStart,\n          length: segmentEnd - segmentStart\n        }\n\n        const segment = []\n        for (let i = segmentStart; i < segmentEnd; i++) {\n          const blk = await src.blocks.get(i)\n          segment.push(blk)\n        }\n\n        const offset = await src.tree.byteOffset(2 * segmentStart)\n        await this.blocks.putBatch(segmentStart, segment, offset)\n\n        const entry = {\n          userData: null,\n          treeNodes,\n          treeUpgrade: null,\n          bitfield\n        }\n\n        await this.oplog.append([entry], false)\n        this.tree.addNodes(treeNodes)\n        this._setBitfieldRange(bitfield.start, bitfield.length, true)\n        this.onupdate(0, bitfield, null, null)\n        await this._flushOplog()\n      }\n\n      this.header.userData = src.header.userData.slice(0)\n      const contig = Math.min(src.header.hints.contiguousLength, srcBatch.length)\n      if (this.header.hints.contiguousLength < contig) this.header.hints.contiguousLength = contig\n\n      await this._flushOplog()\n    } finally {\n      src._mutex.unlock()\n      this._mutex.unlock()\n    }\n  }\n\n  async flush () {\n    await this._mutex.lock()\n    try {\n      this._manifestFlushed = true\n      this._autoFlush = 4\n      await this._flushOplog()\n    } finally {\n      this._mutex.unlock()\n    }\n  }\n\n  async _flushOplog () {\n    // TODO: the apis using this, actually do not need to wait for the bitfields, tree etc to flush\n    // as their mutations are already stored in the oplog. We could potentially just run this in the\n    // background. Might be easier to impl that where it is called instead and keep this one simple.\n    await this.bitfield.flush()\n    await this.tree.flush()\n\n    return flushHeader(this.oplog, this.bigHeader, this.header)\n  }\n\n  _appendBlocks (values) {\n    return this.blocks.putBatch(this.tree.length, values, this.tree.byteLength)\n  }\n\n  async _writeBlock (batch, index, value) {\n    const byteOffset = await batch.byteOffset(index * 2)\n    await this.blocks.put(index, value, byteOffset)\n  }\n\n  async userData (key, value, flush) {\n    // TODO: each oplog append can set user data, so we should have a way\n    // to just hitch a ride on one of the other ongoing appends?\n    await this._mutex.lock()\n\n    try {\n      let empty = true\n\n      for (const u of this.header.userData) {\n        if (u.key !== key) continue\n        if (value && b4a.equals(u.value, value)) return\n        empty = false\n        break\n      }\n\n      if (empty && !value) return\n\n      const entry = {\n        userData: { key, value },\n        treeNodes: null,\n        treeUpgrade: null,\n        bitfield: null\n      }\n\n      await this.oplog.append([entry], false)\n\n      updateUserData(this.header.userData, key, value)\n\n      if (this._shouldFlush() || flush) await this._flushOplog()\n    } finally {\n      this._mutex.unlock()\n    }\n  }\n\n  async truncate (length, fork, { signature, keyPair = this.header.keyPair } = {}) {\n    if (this.tree.prologue && length < this.tree.prologue.length) {\n      throw INVALID_OPERATION('Truncation breaks prologue')\n    }\n\n    this.truncating++\n    await this._mutex.lock()\n\n    // upsert compat manifest\n    if (this.verifier === null && keyPair) this._setManifest(null, keyPair)\n\n    try {\n      const batch = await this.tree.truncate(length, fork)\n      if (length > 0) batch.signature = signature || this.verifier.sign(batch, keyPair)\n      await this._truncate(batch, null)\n    } finally {\n      this.truncating--\n      this._mutex.unlock()\n    }\n  }\n\n  async clearBatch () {\n    await this._mutex.lock()\n\n    try {\n      const len = this.bitfield.findFirst(false, this.tree.length)\n      if (len <= this.tree.length) return\n\n      const batch = await this.tree.truncate(this.tree.length, this.tree.fork)\n\n      batch.signature = this.tree.signature // same sig\n\n      const entry = {\n        userData: null,\n        treeNodes: batch.nodes,\n        treeUpgrade: batch,\n        bitfield: {\n          drop: true,\n          start: batch.ancestors,\n          length: len - batch.ancestors\n        }\n      }\n\n      await this.oplog.append([entry], false)\n\n      this._setBitfieldRange(batch.ancestors, len - batch.ancestors, false)\n      batch.commit()\n\n      // TODO: (see below todo)\n      await this._flushOplog()\n    } finally {\n      this._mutex.unlock()\n    }\n  }\n\n  async clear (start, end, cleared) {\n    await this._mutex.lock()\n\n    try {\n      const entry = {\n        userData: null,\n        treeNodes: null,\n        treeUpgrade: null,\n        bitfield: {\n          start,\n          length: end - start,\n          drop: true\n        }\n      }\n\n      await this.oplog.append([entry], false)\n\n      this._setBitfieldRange(start, end - start, false)\n\n      if (start < this.header.hints.contiguousLength) {\n        this.header.hints.contiguousLength = start\n      }\n\n      start = this.bitfield.lastSet(start) + 1\n      end = this.bitfield.firstSet(end)\n\n      if (end === -1) end = this.tree.length\n      if (start >= end || start >= this.tree.length) return\n\n      const offset = await this.tree.byteOffset(start * 2)\n      const endOffset = await this.tree.byteOffset(end * 2)\n      const length = endOffset - offset\n\n      const before = cleared ? await Info.bytesUsed(this.blocks.storage) : null\n\n      await this.blocks.clear(offset, length)\n\n      const after = cleared ? await Info.bytesUsed(this.blocks.storage) : null\n\n      if (cleared) cleared.blocks = Math.max(before - after, 0)\n\n      this.onupdate(0, entry.bitfield, null, null)\n\n      if (this._shouldFlush()) await this._flushOplog()\n    } finally {\n      this._mutex.unlock()\n    }\n  }\n\n  async purge () {\n    return new Promise((resolve, reject) => {\n      let missing = 4\n      let error = null\n\n      this.oplog.storage.unlink(done)\n      this.tree.storage.unlink(done)\n      this.bitfield.storage.unlink(done)\n      this.blocks.storage.unlink(done)\n\n      function done (err) {\n        if (err) error = err\n        if (--missing) return\n        if (error) reject(error)\n        else resolve()\n      }\n    })\n  }\n\n  async insertBatch (batch, values, { signature, keyPair = this.header.keyPair, pending = false, treeLength = batch.treeLength } = {}) {\n    await this._mutex.lock()\n\n    try {\n      // upsert compat manifest\n      if (this.verifier === null && keyPair) this._setManifest(null, keyPair)\n\n      if (this.tree.fork !== batch.fork) return null\n\n      if (this.tree.length > batch.treeLength) {\n        if (this.tree.length > batch.length) return null // TODO: partial commit in the future if possible\n\n        for (const root of this.tree.roots) {\n          const batchRoot = await batch.get(root.index)\n          if (batchRoot.size !== root.size || !b4a.equals(batchRoot.hash, root.hash)) {\n            return null\n          }\n        }\n      }\n\n      const adding = batch.length - treeLength\n\n      batch.upgraded = !pending && batch.length > this.tree.length\n      batch.treeLength = this.tree.length\n      batch.ancestors = this.tree.length\n      if (batch.upgraded && !pending) batch.signature = signature || this.verifier.sign(batch, keyPair)\n\n      let byteOffset = batch.byteLength\n      for (let i = 0; i < adding; i++) byteOffset -= values[i].byteLength\n\n      if (pending === true) batch.upgraded = false\n\n      const entry = {\n        userData: null,\n        treeNodes: batch.nodes,\n        treeUpgrade: batch.upgraded ? batch : null,\n        bitfield: {\n          drop: false,\n          start: treeLength,\n          length: adding\n        }\n      }\n\n      await this.blocks.putBatch(treeLength, adding < values.length ? values.slice(0, adding) : values, byteOffset)\n      await this.oplog.append([entry], false)\n\n      this._setBitfieldRange(entry.bitfield.start, entry.bitfield.length, true)\n      batch.commit()\n\n      if (batch.upgraded) {\n        this.header.tree.length = batch.length\n        this.header.tree.rootHash = batch.hash()\n        this.header.tree.signature = batch.signature\n      }\n\n      const status = (batch.upgraded ? 0b0001 : 0) | updateContig(this.header, entry.bitfield, this.bitfield)\n      if (!pending) {\n        // we already commit this, and now we signed it, so tell others\n        if (entry.treeUpgrade && treeLength > batch.treeLength) {\n          entry.bitfield.start = batch.treeLength\n          entry.bitfield.length = treeLength - batch.treeLength\n        }\n\n        this.onupdate(status, entry.bitfield, null, null)\n      }\n\n      if (this._shouldFlush()) await this._flushOplog()\n    } finally {\n      this._mutex.unlock()\n    }\n\n    return { length: batch.length, byteLength: batch.byteLength }\n  }\n\n  async append (values, { signature, keyPair = this.header.keyPair, preappend } = {}) {\n    await this._mutex.lock()\n\n    try {\n      // upsert compat manifest\n      if (this.verifier === null && keyPair) this._setManifest(null, keyPair)\n\n      if (preappend) await preappend(values)\n\n      if (!values.length) {\n        return { length: this.tree.length, byteLength: this.tree.byteLength }\n      }\n\n      const batch = this.tree.batch()\n      for (const val of values) batch.append(val)\n\n      // only multisig can have prologue so signature is always present\n      if (this.tree.prologue && batch.length < this.tree.prologue.length) {\n        throw INVALID_OPERATION('Append is not consistent with prologue')\n      }\n\n      batch.signature = signature || this.verifier.sign(batch, keyPair)\n\n      const entry = {\n        userData: null,\n        treeNodes: batch.nodes,\n        treeUpgrade: batch,\n        bitfield: {\n          drop: false,\n          start: batch.ancestors,\n          length: values.length\n        }\n      }\n\n      const byteLength = await this._appendBlocks(values)\n\n      await this.oplog.append([entry], false)\n\n      this._setBitfieldRange(batch.ancestors, batch.length - batch.ancestors, true)\n      batch.commit()\n\n      this.header.tree.length = batch.length\n      this.header.tree.rootHash = batch.hash()\n      this.header.tree.signature = batch.signature\n\n      const status = 0b0001 | updateContig(this.header, entry.bitfield, this.bitfield)\n      this.onupdate(status, entry.bitfield, null, null)\n\n      if (this._shouldFlush()) await this._flushOplog()\n\n      return { length: batch.length, byteLength }\n    } finally {\n      this._mutex.unlock()\n    }\n  }\n\n  _verifyBatchUpgrade (batch, manifest) {\n    if (!this.header.manifest) {\n      if (!manifest && this.compat) manifest = Verifier.defaultSignerManifest(this.header.key)\n\n      if (!manifest || !(Verifier.isValidManifest(this.header.key, manifest) || (this.compat && Verifier.isCompat(this.header.key, manifest)))) {\n        throw INVALID_SIGNATURE('Proof contains an invalid manifest') // TODO: proper error type\n      }\n    }\n\n    manifest = Verifier.createManifest(manifest) // To unslab\n\n    const verifier = this.verifier || new Verifier(this.header.key, manifest, { crypto: this.crypto, legacy: this._legacy })\n\n    if (!verifier.verify(batch, batch.signature)) {\n      throw INVALID_SIGNATURE('Proof contains an invalid signature')\n    }\n\n    if (!this.header.manifest) {\n      this.header.manifest = manifest\n      this.compat = verifier.compat\n      this.verifier = verifier\n      this.onupdate(0b10000, null, null, null)\n    }\n  }\n\n  async _verifyExclusive ({ batch, bitfield, value, manifest, from }) {\n    this._verifyBatchUpgrade(batch, manifest)\n\n    await this._mutex.lock()\n\n    try {\n      if (!batch.commitable()) return false\n      this.updating = true\n\n      const entry = {\n        userData: null,\n        treeNodes: batch.nodes,\n        treeUpgrade: batch,\n        bitfield\n      }\n\n      if (this.preupdate !== null) await this.preupdate(batch, this.header.key)\n      if (bitfield) await this._writeBlock(batch, bitfield.start, value)\n\n      await this.oplog.append([entry], false)\n\n      let status = 0b0001\n\n      if (bitfield) {\n        this._setBitfield(bitfield.start, true)\n        status |= updateContig(this.header, bitfield, this.bitfield)\n      }\n\n      batch.commit()\n\n      this.header.tree.fork = batch.fork\n      this.header.tree.length = batch.length\n      this.header.tree.rootHash = batch.hash()\n      this.header.tree.signature = batch.signature\n\n      this.onupdate(status, bitfield, value, from)\n\n      if (this._shouldFlush()) await this._flushOplog()\n    } finally {\n      this.updating = false\n      this._mutex.unlock()\n    }\n\n    return true\n  }\n\n  async _verifyShared () {\n    if (!this._verifies.length) return false\n\n    await this._mutex.lock()\n\n    const verifies = this._verifies\n    this._verifies = null\n    this._verified = null\n\n    try {\n      const entries = []\n\n      for (const { batch, bitfield, value } of verifies) {\n        if (!batch.commitable()) continue\n\n        if (bitfield) {\n          await this._writeBlock(batch, bitfield.start, value)\n        }\n\n        entries.push({\n          userData: null,\n          treeNodes: batch.nodes,\n          treeUpgrade: null,\n          bitfield\n        })\n      }\n\n      await this.oplog.append(entries, false)\n\n      for (let i = 0; i < verifies.length; i++) {\n        const { batch, bitfield, value, manifest, from } = verifies[i]\n\n        if (!batch.commitable()) {\n          verifies[i] = null // signal that we cannot commit this one\n          continue\n        }\n\n        let status = 0\n\n        if (bitfield) {\n          this._setBitfield(bitfield.start, true)\n          status = updateContig(this.header, bitfield, this.bitfield)\n        }\n\n        // if we got a manifest AND its strictly a non compat one, lets store it\n        if (manifest && this.header.manifest === null) {\n          if (!Verifier.isValidManifest(this.header.key, manifest)) throw INVALID_CHECKSUM('Manifest hash does not match')\n          this._setManifest(manifest, null)\n        }\n\n        batch.commit()\n\n        this.onupdate(status, bitfield, value, from)\n      }\n\n      if (this._shouldFlush()) await this._flushOplog()\n    } finally {\n      this._mutex.unlock()\n    }\n\n    return verifies[0] !== null\n  }\n\n  async checkConflict (proof, from) {\n    if (this.tree.length < proof.upgrade.length || proof.fork !== this.tree.fork) {\n      // out of date this proof - ignore for now\n      return false\n    }\n\n    const batch = this.tree.verifyFullyRemote(proof)\n\n    try {\n      this._verifyBatchUpgrade(batch, proof.manifest)\n    } catch {\n      return true\n    }\n\n    const remoteTreeHash = this.crypto.tree(proof.upgrade.nodes)\n    const localTreeHash = this.crypto.tree(await this.tree.getRoots(proof.upgrade.length))\n\n    if (b4a.equals(localTreeHash, remoteTreeHash)) return false\n\n    await this.onconflict(proof)\n    return true\n  }\n\n  async verifyReorg (proof) {\n    const batch = await this.tree.reorg(proof)\n\n    this._verifyBatchUpgrade(batch, proof.manifest)\n\n    return batch\n  }\n\n  async verify (proof, from) {\n    // We cannot apply \"other forks\" atm.\n    // We should probably still try and they are likely super similar for non upgrades\n    // but this is easy atm (and the above layer will just retry)\n    if (proof.fork !== this.tree.fork) return false\n\n    const batch = await this.tree.verify(proof)\n    if (!batch.commitable()) return false\n\n    const value = (proof.block && proof.block.value) || null\n    const op = {\n      batch,\n      bitfield: value && { drop: false, start: proof.block.index, length: 1 },\n      value,\n      manifest: proof.manifest,\n      from\n    }\n\n    if (batch.upgraded) return this._verifyExclusive(op)\n\n    if (this._verifies !== null) {\n      const verifies = this._verifies\n      const i = verifies.push(op)\n      await this._verified\n      return verifies[i] !== null\n    }\n\n    this._verifies = [op]\n    this._verified = this._verifyShared()\n    return this._verified\n  }\n\n  async reorg (batch, from) {\n    if (!batch.commitable()) return false\n\n    this.truncating++\n    await this._mutex.lock()\n\n    try {\n      if (!batch.commitable()) return false\n      await this._truncate(batch, from)\n    } finally {\n      this.truncating--\n      this._mutex.unlock()\n    }\n\n    return true\n  }\n\n  async _truncate (batch, from) {\n    const entry = {\n      userData: null,\n      treeNodes: batch.nodes,\n      treeUpgrade: batch,\n      bitfield: {\n        drop: true,\n        start: batch.ancestors,\n        length: this.tree.length - batch.ancestors\n      }\n    }\n\n    await this.oplog.append([entry], false)\n\n    this._setBitfieldRange(batch.ancestors, this.tree.length - batch.ancestors, false)\n    addReorgHint(this.header.hints.reorgs, this.tree, batch)\n    batch.commit()\n\n    const contigStatus = updateContig(this.header, entry.bitfield, this.bitfield)\n    const status = ((batch.length > batch.ancestors) ? 0b0011 : 0b0010) | contigStatus\n\n    this.header.tree.fork = batch.fork\n    this.header.tree.length = batch.length\n    this.header.tree.rootHash = batch.hash()\n    this.header.tree.signature = batch.signature\n\n    this.onupdate(status, entry.bitfield, null, from)\n\n    // TODO: there is a bug in the merkle tree atm where it cannot handle unflushed\n    // truncates if we append or download anything after the truncation point later on\n    // This is because tree.get checks the truncated flag. We should fix this so we can do\n    // the later flush here as well\n    // if (this._shouldFlush()) await this._flushOplog()\n    await this._flushOplog()\n  }\n\n  openSkipBitfield () {\n    if (this.skipBitfield !== null) return this.skipBitfield\n    this.skipBitfield = new RemoteBitfield()\n    const buf = this.bitfield.toBuffer(this.tree.length)\n    const bitfield = new Uint32Array(buf.buffer, buf.byteOffset, buf.byteLength / 4)\n    this.skipBitfield.insert(0, bitfield)\n    return this.skipBitfield\n  }\n\n  _setBitfield (index, value) {\n    this.bitfield.set(index, value)\n    if (this.skipBitfield !== null) this.skipBitfield.set(index, value)\n  }\n\n  _setBitfieldRange (start, length, value) {\n    this.bitfield.setRange(start, length, value)\n    if (this.skipBitfield !== null) this.skipBitfield.setRange(start, length, value)\n  }\n\n  async close () {\n    this.closed = true\n    await this._mutex.destroy()\n    await Promise.allSettled([\n      this.oplog.close(),\n      this.bitfield.close(),\n      this.tree.close(),\n      this.blocks.close(),\n      this.bigHeader.close()\n    ])\n  }\n}\n\nfunction updateContig (header, upd, bitfield) {\n  const end = upd.start + upd.length\n\n  let c = header.hints.contiguousLength\n\n  if (upd.drop) {\n    // If we dropped a block in the current contig range, \"downgrade\" it\n    if (c <= end && c > upd.start) {\n      c = upd.start\n    }\n  } else {\n    if (c <= end && c >= upd.start) {\n      c = end\n      while (bitfield.get(c)) c++\n    }\n  }\n\n  if (c === header.hints.contiguousLength) {\n    return 0b0000\n  }\n\n  if (c > header.hints.contiguousLength) {\n    header.hints.contiguousLength = c\n    return 0b0100\n  }\n\n  header.hints.contiguousLength = c\n  return 0b1000\n}\n\nfunction addReorgHint (list, tree, batch) {\n  if (tree.length === 0 || tree.fork === batch.fork) return\n\n  while (list.length >= 4) list.shift() // 4 here is arbitrary, just want it to be small (hints only)\n  while (list.length > 0) {\n    if (list[list.length - 1].ancestors > batch.ancestors) list.pop()\n    else break\n  }\n\n  list.push({ from: tree.fork, to: batch.fork, ancestors: batch.ancestors })\n}\n\nfunction updateUserData (list, key, value) {\n  value = unslab(value)\n\n  for (let i = 0; i < list.length; i++) {\n    if (list[i].key === key) {\n      if (value) list[i].value = value\n      else list.splice(i, 1)\n      return\n    }\n  }\n  if (value) list.push({ key, value })\n}\n\nfunction closeAll (...storages) {\n  let missing = 1\n  let error = null\n\n  return new Promise((resolve, reject) => {\n    for (const s of storages) {\n      missing++\n      s.close(done)\n    }\n\n    done(null)\n\n    function done (err) {\n      if (err) error = err\n      if (--missing) return\n      if (error) reject(error)\n      else resolve()\n    }\n  })\n}\n\nasync function flushHeader (oplog, bigHeader, header) {\n  if (header.external) {\n    await bigHeader.flush(header)\n  }\n\n  try {\n    await oplog.flush(header)\n  } catch (err) {\n    if (err.code !== 'OPLOG_HEADER_OVERFLOW') throw err\n    await bigHeader.flush(header)\n    await oplog.flush(header)\n  }\n}\n\nfunction noop () {}\n\nfunction maximumSegmentStart (start, src, dst) {\n  while (true) {\n    const a = src.firstSet(start)\n    const b = dst.firstUnset(start)\n\n    if (a === -1) return -1\n    if (b === -1) return a\n\n    // if dst has the segment, restart\n    if (a < b) {\n      start = b\n      continue\n    }\n\n    return a\n  }\n}\n\nfunction minimumSegmentEnd (start, src, dst) {\n  const a = src.firstUnset(start)\n  const b = dst.firstSet(start)\n\n  if (a === -1) return -1\n  if (b === -1) return a\n  return a < b ? a : b\n}\nmodule.exports = class Download {\n  constructor (req) {\n    this.req = req\n  }\n\n  async done () {\n    return (await this.req).promise\n  }\n\n  /**\n   * Deprecated. Use `range.done()`.\n   */\n  downloaded () {\n    return this.done()\n  }\n\n  destroy () {\n    this.req.then(req => req.context && req.context.detach(req), noop)\n  }\n}\n\nfunction noop () {}\nconst TICKS = 16\n\nmodule.exports = class HotswapQueue {\n  constructor () {\n    this.priorities = [[], [], []]\n  }\n\n  * pick (peer) {\n    for (let i = 0; i < this.priorities.length; i++) {\n      // try first one more than second one etc etc\n      let ticks = (this.priorities.length - i) * TICKS\n      const queue = this.priorities[i]\n\n      for (let j = 0; j < queue.length; j++) {\n        const r = j + Math.floor(Math.random() * queue.length - j)\n        const a = queue[j]\n        const b = queue[r]\n\n        if (r !== j) {\n          queue[(b.hotswap.index = j)] = b\n          queue[(a.hotswap.index = r)] = a\n        }\n\n        if (hasInflight(b, peer)) continue\n\n        yield b\n\n        if (--ticks <= 0) break\n      }\n    }\n  }\n\n  add (block) {\n    if (block.hotswap !== null) this.remove(block)\n    if (block.inflight.length === 0 || block.inflight.length >= 3) return\n\n    // TODO: also use other stuff to determine queue prio\n    const queue = this.priorities[block.inflight.length - 1]\n\n    const index = queue.push(block) - 1\n    block.hotswap = { ref: this, queue, index }\n  }\n\n  remove (block) {\n    const hotswap = block.hotswap\n    if (hotswap === null) return\n\n    block.hotswap = null\n    const head = hotswap.queue.pop()\n    if (head === block) return\n    hotswap.queue[(head.hotswap.index = hotswap.index)] = head\n  }\n}\n\nfunction hasInflight (block, peer) {\n  for (let j = 0; j < block.inflight.length; j++) {\n    if (block.inflight[j].peer === peer) return true\n  }\n  return false\n}\nmodule.exports = class Info {\n  constructor (opts = {}) {\n    this.key = opts.key\n    this.discoveryKey = opts.discoveryKey\n    this.length = opts.length || 0\n    this.contiguousLength = opts.contiguousLength || 0\n    this.byteLength = opts.byteLength || 0\n    this.fork = opts.fork || 0\n    this.padding = opts.padding || 0\n    this.storage = opts.storage || null\n  }\n\n  static async from (session, opts = {}) {\n    return new Info({\n      key: session.key,\n      discoveryKey: session.discoveryKey,\n      length: session.length,\n      contiguousLength: session.contiguousLength,\n      byteLength: session.byteLength,\n      fork: session.fork,\n      padding: session.padding,\n      storage: opts.storage ? await this.storage(session) : null\n    })\n  }\n\n  static async storage (session) {\n    const { oplog, tree, blocks, bitfield } = session.core\n    try {\n      return {\n        oplog: await Info.bytesUsed(oplog.storage),\n        tree: await Info.bytesUsed(tree.storage),\n        blocks: await Info.bytesUsed(blocks.storage),\n        bitfield: await Info.bytesUsed(bitfield.storage)\n      }\n    } catch {\n      return null\n    }\n  }\n\n  static bytesUsed (file) {\n    return new Promise((resolve, reject) => {\n      file.stat((err, st) => {\n        if (err) {\n          resolve(0) // prob just file not found (TODO, improve)\n        } else if (typeof st.blocks !== 'number') {\n          reject(new Error('cannot determine bytes used'))\n        } else {\n          resolve(st.blocks * 512)\n        }\n      })\n    })\n  }\n}\nconst flat = require('flat-tree')\nconst crypto = require('hypercore-crypto')\nconst c = require('compact-encoding')\nconst Xache = require('xache')\nconst b4a = require('b4a')\nconst unslab = require('unslab')\nconst caps = require('./caps')\nconst { INVALID_PROOF, INVALID_CHECKSUM, INVALID_OPERATION, BAD_ARGUMENT, ASSERTION } = require('hypercore-errors')\n\nconst BLANK_HASH = b4a.alloc(32)\nconst OLD_TREE = b4a.from([5, 2, 87, 2, 0, 0, 40, 7, 66, 76, 65, 75, 69, 50, 98])\nconst TREE_CACHE = 128 // speeds up linear scans by A LOT\n\nclass NodeQueue {\n  constructor (nodes, extra = null) {\n    this.i = 0\n    this.nodes = nodes\n    this.extra = extra\n    this.length = nodes.length + (this.extra === null ? 0 : 1)\n  }\n\n  shift (index) {\n    if (this.extra !== null && this.extra.index === index) {\n      const node = this.extra\n      this.extra = null\n      this.length--\n      return node\n    }\n\n    if (this.i >= this.nodes.length) {\n      throw INVALID_OPERATION('Expected node ' + index + ', got (nil)')\n    }\n\n    const node = this.nodes[this.i++]\n    if (node.index !== index) {\n      throw INVALID_OPERATION('Expected node ' + index + ', got node ' + node.index)\n    }\n\n    this.length--\n    return node\n  }\n}\n\nclass MerkleTreeBatch {\n  constructor (tree) {\n    this.fork = tree.fork\n    this.roots = [...tree.roots]\n    this.length = tree.length\n    this.ancestors = tree.length\n    this.byteLength = tree.byteLength\n    this.signature = null\n    this.hashCached = null\n\n    this.treeLength = tree.length\n    this.treeFork = tree.fork\n    this.tree = tree\n    this.nodes = []\n    this.upgraded = false\n  }\n\n  checkout (length, additionalRoots) {\n    const roots = []\n    let r = 0\n\n    const head = 2 * length - 2\n    const gaps = new Set()\n    const all = new Map()\n\n    // additional roots is so the original roots can be passed (we mutate the array in appendRoot)\n    if (additionalRoots) {\n      for (const node of additionalRoots) all.set(node.index, node)\n    }\n\n    for (const node of this.nodes) all.set(node.index, node)\n\n    for (const index of flat.fullRoots(head + 2)) {\n      const left = flat.leftSpan(index)\n      if (left !== 0) gaps.add(left - 1)\n\n      if (r < this.roots.length && this.roots[r].index === index) {\n        roots.push(this.roots[r++])\n        continue\n      }\n      const node = all.get(index)\n      if (!node) throw new BAD_ARGUMENT('root missing for given length')\n      roots.push(node)\n    }\n\n    this.roots = roots\n    this.length = length\n    this.byteLength = totalSize(roots)\n    this.hashCached = null\n    this.signature = null\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      const index = this.nodes[i].index\n      if (index <= head && !gaps.has(index)) continue\n      const last = this.nodes.pop()\n      if (i < this.nodes.length) this.nodes[i--] = last\n    }\n  }\n\n  prune (length) {\n    if (length === 0) return\n\n    const head = 2 * length - 2\n    const gaps = new Set()\n\n    // TODO: make a function for this in flat-tree\n    for (const index of flat.fullRoots(head + 2)) {\n      const left = flat.leftSpan(index)\n      if (left !== 0) gaps.add(left - 1)\n    }\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      const index = this.nodes[i].index\n      if (index > head || gaps.has(index)) continue\n      const last = this.nodes.pop()\n      if (i < this.nodes.length) this.nodes[i--] = last\n    }\n  }\n\n  clone () {\n    const b = new MerkleTreeBatch(this.tree)\n\n    b.fork = this.fork\n    b.roots = [...this.roots]\n    b.length = this.length\n    b.byteLength = this.byteLength\n    b.signature = this.signature\n    b.treeLength = this.treeLength\n    b.treeFork = this.treeFork\n    b.tree = this.tree\n    b.nodes = [...this.nodes]\n    b.upgraded = this.upgraded\n\n    return b\n  }\n\n  hash () {\n    if (this.hashCached === null) this.hashCached = unslab(this.tree.crypto.tree(this.roots))\n    return this.hashCached\n  }\n\n  signable (manifestHash) {\n    return caps.treeSignable(manifestHash, this.hash(), this.length, this.fork)\n  }\n\n  signableCompat (noHeader) {\n    return caps.treeSignableCompat(this.hash(), this.length, this.fork, noHeader)\n  }\n\n  get (index, error) {\n    if (index >= this.length * 2) {\n      return null\n    }\n\n    for (const n of this.nodes) {\n      if (n.index === index) return n\n    }\n\n    return this.tree.get(index, error)\n  }\n\n  proof ({ block, hash, seek, upgrade }) {\n    return generateProof(this, block, hash, seek, upgrade)\n  }\n\n  verifyUpgrade (proof) {\n    const unverified = verifyTree(proof, this.tree.crypto, this.nodes)\n\n    if (!proof.upgrade) throw INVALID_OPERATION('Expected upgrade proof')\n\n    return verifyUpgrade(proof, unverified, this)\n  }\n\n  append (buf) {\n    const head = this.length * 2\n    const ite = flat.iterator(head)\n    const node = blockNode(this.tree.crypto, head, buf)\n\n    this.appendRoot(node, ite)\n  }\n\n  appendRoot (node, ite) {\n    node = unslabNode(node)\n    this.hashCached = null\n    this.upgraded = true\n    this.length += ite.factor / 2\n    this.byteLength += node.size\n    this.roots.push(node)\n    this.nodes.push(node)\n\n    while (this.roots.length > 1) {\n      const a = this.roots[this.roots.length - 1]\n      const b = this.roots[this.roots.length - 2]\n\n      // TODO: just have a peek sibling instead? (pretty sure it's always the left sib as well)\n      if (ite.sibling() !== b.index) {\n        ite.sibling() // unset so it always points to last root\n        break\n      }\n\n      const node = unslabNode(parentNode(this.tree.crypto, ite.parent(), a, b))\n      this.nodes.push(node)\n      this.roots.pop()\n      this.roots.pop()\n      this.roots.push(node)\n    }\n  }\n\n  commitable () {\n    return this.treeFork === this.tree.fork && (\n      this.upgraded\n        ? this.treeLength === this.tree.length\n        : this.treeLength <= this.tree.length\n    )\n  }\n\n  commit () {\n    if (!this.commitable()) throw INVALID_OPERATION('Tree was modified during batch, refusing to commit')\n\n    if (this.upgraded) this._commitUpgrade()\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      const node = this.nodes[i]\n      this.tree.unflushed.set(node.index, node)\n    }\n  }\n\n  _commitUpgrade () {\n    // TODO: If easy to detect, we should refuse an trunc+append here without a fork id\n    // change. Will only happen on user error so mostly to prevent that.\n\n    if (this.ancestors < this.treeLength) {\n      if (this.ancestors > 0) {\n        const head = 2 * this.ancestors\n        const ite = flat.iterator(head - 2)\n\n        while (true) {\n          if (ite.contains(head) && ite.index < head) {\n            this.tree.unflushed.set(ite.index, blankNode(ite.index))\n          }\n          if (ite.offset === 0) break\n          ite.parent()\n        }\n      }\n\n      this.tree.truncateTo = this.tree.truncated\n        ? Math.min(this.tree.truncateTo, this.ancestors)\n        : this.ancestors\n\n      this.tree.truncated = true\n      this.tree.cache = new Xache({ maxSize: this.tree.cache.maxSize })\n      truncateMap(this.tree.unflushed, this.ancestors)\n      if (this.tree.flushing !== null) truncateMap(this.tree.flushing, this.ancestors)\n    }\n\n    this.tree.roots = this.roots\n    this.tree.length = this.length\n    this.tree.byteLength = this.byteLength\n    this.tree.fork = this.fork\n    this.tree.signature = this.signature\n  }\n\n  seek (bytes, padding) {\n    return new ByteSeeker(this, bytes, padding)\n  }\n\n  byteRange (index) {\n    return getByteRange(this, index)\n  }\n\n  byteOffset (index) {\n    if (index === 2 * this.tree.length) return this.tree.byteLength\n    return getByteOffset(this, index)\n  }\n}\n\nclass ReorgBatch extends MerkleTreeBatch {\n  constructor (tree) {\n    super(tree)\n    this.roots = []\n    this.length = 0\n    this.byteLength = 0\n    this.diff = null\n    this.ancestors = 0\n    // We set upgraded because reorgs are signed so hit will\n    // hit the same code paths (like the treeLength check in commit)\n    this.upgraded = true\n    this.want = {\n      nodes: 0,\n      start: 0,\n      end: 0\n    }\n  }\n\n  get finished () {\n    return this.want === null\n  }\n\n  update (proof) {\n    if (this.want === null) return true\n\n    const nodes = []\n    const root = verifyTree(proof, this.tree.crypto, nodes)\n\n    if (root === null || !b4a.equals(root.hash, this.diff.hash)) return false\n\n    this.nodes.push(...nodes)\n    return this._update(nodes)\n  }\n\n  async _update (nodes) {\n    const n = new Map()\n    for (const node of nodes) n.set(node.index, node)\n\n    let diff = null\n    const ite = flat.iterator(this.diff.index)\n    const startingDiff = this.diff\n\n    while ((ite.index & 1) !== 0) {\n      const left = n.get(ite.leftChild())\n      if (!left) break\n\n      const existing = await this.tree.get(left.index, false)\n      if (!existing || !b4a.equals(existing.hash, left.hash)) {\n        diff = left\n      } else {\n        diff = n.get(ite.sibling())\n      }\n    }\n\n    if ((this.diff.index & 1) === 0) return true\n    if (diff === null) return false\n    if (startingDiff !== this.diff) return false\n\n    return this._updateDiffRoot(diff)\n  }\n\n  _updateDiffRoot (diff) {\n    if (this.want === null) return true\n\n    const spans = flat.spans(diff.index)\n    const start = spans[0] / 2\n    const end = Math.min(this.treeLength, spans[1] / 2 + 1)\n    const len = end - start\n\n    this.ancestors = start\n    this.diff = diff\n\n    if ((diff.index & 1) === 0 || this.want.start >= this.treeLength || len <= 0) {\n      this.want = null\n      return true\n    }\n\n    this.want.start = start\n    this.want.end = end\n    this.want.nodes = log2(spans[1] - spans[0] + 2) - 1\n\n    return false\n  }\n}\n\nclass ByteSeeker {\n  constructor (tree, bytes, padding = 0) {\n    this.tree = tree\n    this.bytes = bytes\n    this.padding = padding\n\n    const size = tree.byteLength - (tree.length * padding)\n\n    this.start = bytes >= size ? tree.length : 0\n    this.end = bytes < size ? tree.length : 0\n  }\n\n  async _seek (bytes) {\n    if (!bytes) return [0, 0]\n\n    for (const node of this.tree.roots) { // all async ticks happen once we find the root so safe\n      const size = getUnpaddedSize(node, this.padding, null)\n\n      if (bytes === size) return [flat.rightSpan(node.index) + 2, 0]\n      if (bytes > size) {\n        bytes -= size\n        continue\n      }\n\n      const ite = flat.iterator(node.index)\n\n      while ((ite.index & 1) !== 0) {\n        const l = await this.tree.get(ite.leftChild(), false)\n\n        if (l) {\n          const size = getUnpaddedSize(l, this.padding, ite)\n\n          if (size === bytes) return [ite.rightSpan() + 2, 0]\n          if (size > bytes) continue\n          bytes -= size\n          ite.sibling()\n        } else {\n          ite.parent()\n          return [ite.index, bytes]\n        }\n      }\n\n      return [ite.index, bytes]\n    }\n\n    return null\n  }\n\n  async update () { // TODO: combine _seek and this, much simpler\n    const res = await this._seek(this.bytes)\n    if (!res) return null\n    if ((res[0] & 1) === 0) return [res[0] / 2, res[1]]\n\n    const span = flat.spans(res[0])\n    this.start = span[0] / 2\n    this.end = span[1] / 2 + 1\n\n    return null\n  }\n}\n\nmodule.exports = class MerkleTree {\n  constructor (storage, roots, fork, signature, prologue) {\n    this.crypto = crypto\n    this.fork = fork\n    this.roots = roots\n    this.length = roots.length ? totalSpan(roots) / 2 : 0\n    this.byteLength = totalSize(roots)\n    this.signature = signature\n    this.prologue = prologue\n\n    this.storage = storage\n    this.unflushed = new Map()\n    this.cache = new Xache({ maxSize: TREE_CACHE })\n    this.flushing = null\n    this.truncated = false\n    this.truncateTo = 0\n  }\n\n  addNode (node) {\n    if (node.size === 0 && b4a.equals(node.hash, BLANK_HASH)) node = blankNode(node.index)\n    this.unflushed.set(node.index, node)\n  }\n\n  batch () {\n    return new MerkleTreeBatch(this)\n  }\n\n  async restoreBatch (length) {\n    const batch = new MerkleTreeBatch(this)\n    if (length === this.length) return batch\n\n    const roots = unslabNodes(await this.getRoots(length))\n\n    batch.roots = roots\n    batch.length = length\n    batch.byteLength = 0\n    batch.ancestors = length\n\n    for (const node of roots) batch.byteLength += node.size\n\n    return batch\n  }\n\n  seek (bytes, padding) {\n    return new ByteSeeker(this, bytes, padding)\n  }\n\n  hash () {\n    return unslab(this.crypto.tree(this.roots))\n  }\n\n  signable (namespace) {\n    return caps.treeSignable(namespace, this.hash(), this.length, this.fork)\n  }\n\n  getRoots (length) {\n    const indexes = flat.fullRoots(2 * length)\n    const roots = new Array(indexes.length)\n\n    for (let i = 0; i < indexes.length; i++) {\n      roots[i] = this.get(indexes[i], true)\n    }\n\n    return Promise.all(roots)\n  }\n\n  setPrologue ({ hash, length }) {\n    this.prologue = { hash, length }\n  }\n\n  addNodes (nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i]\n      this.unflushed.set(node.index, node)\n    }\n  }\n\n  getNeededNodes (length, start, end) {\n    const nodes = new Map()\n    const head = length * 2\n\n    for (let i = start; i < end; i++) {\n      const ite = flat.iterator(i * 2)\n\n      while (true) {\n        if (nodes.has(ite.index)) break\n        nodes.set(ite.index, this.get(ite.index, true))\n\n        const sibling = ite.sibling()\n\n        ite.parent()\n        if (ite.contains(head)) break\n\n        if (nodes.has(sibling)) break\n        nodes.set(sibling, this.get(sibling, true))\n      }\n    }\n\n    return Promise.all([...nodes.values()])\n  }\n\n  async upgradeable (length) {\n    const indexes = flat.fullRoots(2 * length)\n    const roots = new Array(indexes.length)\n\n    for (let i = 0; i < indexes.length; i++) {\n      roots[i] = this.get(indexes[i], false)\n    }\n\n    for (const node of await Promise.all(roots)) {\n      if (node === null) return false\n    }\n\n    return true\n  }\n\n  blankNode (index) {\n    return blankNode(index)\n  }\n\n  get (index, error = true) {\n    const c = this.cache.get(index)\n    if (c) return c\n\n    let node = this.unflushed.get(index)\n\n    if (this.flushing !== null && node === undefined) {\n      node = this.flushing.get(index)\n    }\n\n    // TODO: test this\n    if (this.truncated && node !== undefined && node.index >= 2 * this.truncateTo) {\n      node = blankNode(index)\n    }\n\n    if (node !== undefined) {\n      if (node.hash === BLANK_HASH) {\n        if (error) throw INVALID_OPERATION('Could not load node: ' + index)\n        return Promise.resolve(null)\n      }\n      return Promise.resolve(node)\n    }\n\n    return getStoredNode(this.storage, index, this.cache, error)\n  }\n\n  async flush () {\n    this.flushing = this.unflushed\n    this.unflushed = new Map()\n\n    try {\n      if (this.truncated) await this._flushTruncation()\n      await this._flushNodes()\n    } catch (err) {\n      for (const node of this.flushing.values()) {\n        if (!this.unflushed.has(node.index)) this.unflushed.set(node.index, node)\n      }\n      throw err\n    } finally {\n      this.flushing = null\n    }\n  }\n\n  _flushTruncation () {\n    return new Promise((resolve, reject) => {\n      const t = this.truncateTo\n      const offset = t === 0 ? 0 : (t - 1) * 80 + 40\n\n      this.storage.truncate(offset, (err) => {\n        if (err) return reject(err)\n\n        if (this.truncateTo === t) {\n          this.truncateTo = 0\n          this.truncated = false\n        }\n\n        resolve()\n      })\n    })\n  }\n\n  _flushNodes () {\n    // TODO: write neighbors together etc etc\n    // TODO: bench loading a full disk page and copy to that instead\n    return new Promise((resolve, reject) => {\n      const slab = b4a.allocUnsafe(40 * this.flushing.size)\n\n      let error = null\n      let missing = this.flushing.size + 1\n      let offset = 0\n\n      for (const node of this.flushing.values()) {\n        const state = {\n          start: 0,\n          end: 40,\n          buffer: slab.subarray(offset, offset += 40)\n        }\n\n        c.uint64.encode(state, node.size)\n        c.raw.encode(state, node.hash)\n\n        this.storage.write(node.index * 40, state.buffer, done)\n      }\n\n      done(null)\n\n      function done (err) {\n        if (err) error = err\n        if (--missing > 0) return\n        if (error) reject(error)\n        else resolve()\n      }\n    })\n  }\n\n  clear () {\n    this.cache = new Xache({ maxSize: this.cache.maxSize })\n    this.truncated = true\n    this.truncateTo = 0\n    this.roots = []\n    this.length = 0\n    this.byteLength = 0\n    this.fork = 0\n    this.signature = null\n    if (this.flushing !== null) this.flushing.clear()\n    this.unflushed.clear()\n    return this.flush()\n  }\n\n  close () {\n    return new Promise((resolve, reject) => {\n      this.storage.close(err => {\n        if (err) reject(err)\n        else resolve()\n      })\n    })\n  }\n\n  async truncate (length, fork = this.fork) {\n    const head = length * 2\n    const batch = new MerkleTreeBatch(this)\n    const fullRoots = flat.fullRoots(head)\n\n    for (let i = 0; i < fullRoots.length; i++) {\n      const root = fullRoots[i]\n      if (i < batch.roots.length && batch.roots[i].index === root) continue\n\n      while (batch.roots.length > i) batch.roots.pop()\n      batch.roots.push(unslabNode(await this.get(root)))\n    }\n\n    while (batch.roots.length > fullRoots.length) {\n      batch.roots.pop()\n    }\n\n    batch.fork = fork\n    batch.length = length\n    batch.ancestors = length\n    batch.byteLength = totalSize(batch.roots)\n    batch.upgraded = true\n\n    return batch\n  }\n\n  async reorg (proof) {\n    const batch = new ReorgBatch(this)\n\n    let unverified = null\n\n    if (proof.block || proof.hash || proof.seek) {\n      unverified = verifyTree(proof, this.crypto, batch.nodes)\n    }\n\n    if (!verifyUpgrade(proof, unverified, batch)) {\n      throw INVALID_PROOF('Fork proof not verifiable')\n    }\n\n    for (const root of batch.roots) {\n      const existing = await this.get(root.index, false)\n      if (existing && b4a.equals(existing.hash, root.hash)) continue\n      batch._updateDiffRoot(root)\n      break\n    }\n\n    if (batch.diff !== null) {\n      await batch._update(batch.nodes)\n    } else {\n      batch.want = null\n      batch.ancestors = batch.length\n    }\n\n    return batch\n  }\n\n  verifyFullyRemote (proof) {\n    // TODO: impl this less hackishly\n    const batch = new MerkleTreeBatch(this)\n\n    batch.fork = proof.fork\n    batch.roots = []\n    batch.length = 0\n    batch.ancestors = 0\n    batch.byteLength = 0\n\n    let unverified = verifyTree(proof, this.crypto, batch.nodes)\n\n    if (proof.upgrade) {\n      if (verifyUpgrade(proof, unverified, batch)) {\n        unverified = null\n      }\n    }\n\n    return batch\n  }\n\n  async verify (proof) {\n    const batch = new MerkleTreeBatch(this)\n\n    let unverified = verifyTree(proof, this.crypto, batch.nodes)\n\n    if (proof.upgrade) {\n      if (verifyUpgrade(proof, unverified, batch)) {\n        unverified = null\n      }\n    }\n\n    if (unverified) {\n      const verified = await this.get(unverified.index)\n      if (!b4a.equals(verified.hash, unverified.hash)) {\n        throw INVALID_CHECKSUM('Invalid checksum at node ' + unverified.index)\n      }\n    }\n\n    return batch\n  }\n\n  proof ({ block, hash, seek, upgrade }) {\n    return generateProof(this, block, hash, seek, upgrade)\n  }\n\n  // Successor to .nodes()\n  async missingNodes (index) {\n    const head = 2 * this.length\n    const ite = flat.iterator(index)\n\n    // See iterator.rightSpan()\n    const iteRightSpan = ite.index + ite.factor / 2 - 1\n    // If the index is not in the current tree, we do not know how many missing nodes there are...\n    if (iteRightSpan >= head) return 0\n\n    let cnt = 0\n    while (!ite.contains(head) && (await this.get(ite.index, false)) === null) {\n      cnt++\n      ite.parent()\n    }\n\n    return cnt\n  }\n\n  // Deprecated\n  async nodes (index) {\n    const head = 2 * this.length\n    const ite = flat.iterator(index)\n\n    let cnt = 0\n    while (!ite.contains(head) && (await this.get(ite.index, false)) === null) {\n      cnt++\n      ite.parent()\n    }\n\n    return cnt\n  }\n\n  byteRange (index) {\n    return getByteRange(this, index)\n  }\n\n  byteOffset (index) {\n    return getByteOffset(this, index)\n  }\n\n  static async open (storage, opts = {}) {\n    await new Promise((resolve, reject) => {\n      storage.read(0, OLD_TREE.length, (err, buf) => {\n        if (err) return resolve()\n        if (b4a.equals(buf, OLD_TREE)) return reject(new Error('Storage contains an incompatible merkle tree'))\n        resolve()\n      })\n    })\n\n    const length = typeof opts.length === 'number'\n      ? opts.length\n      : await autoLength(storage)\n\n    const roots = []\n    for (const index of flat.fullRoots(2 * length)) {\n      roots.push(unslabNode(await getStoredNode(storage, index, null, true)))\n    }\n\n    return new MerkleTree(storage, roots, opts.fork || 0, opts.signature || null, opts.prologue || null)\n  }\n}\n\nasync function getByteRange (tree, index) {\n  const head = 2 * tree.length\n  if (((index & 1) === 0 ? index : flat.rightSpan(index)) >= head) {\n    throw BAD_ARGUMENT('Index is out of bounds')\n  }\n  return [await tree.byteOffset(index), (await tree.get(index)).size]\n}\n\nasync function getByteOffset (tree, index) {\n  if (index === 2 * tree.length) return tree.byteLength\n  if ((index & 1) === 1) index = flat.leftSpan(index)\n\n  let head = 0\n  let offset = 0\n\n  for (const node of tree.roots) { // all async ticks happen once we find the root so safe\n    head += 2 * ((node.index - head) + 1)\n\n    if (index >= head) {\n      offset += node.size\n      continue\n    }\n\n    const ite = flat.iterator(node.index)\n\n    while (ite.index !== index) {\n      if (index < ite.index) {\n        ite.leftChild()\n      } else {\n        offset += (await tree.get(ite.leftChild())).size\n        ite.sibling()\n      }\n    }\n\n    return offset\n  }\n\n  throw ASSERTION('Failed to find offset')\n}\n\n// All the methods needed for proof verification\n\nfunction verifyTree ({ block, hash, seek }, crypto, nodes) {\n  const untrustedNode = block\n    ? { index: 2 * block.index, value: block.value, nodes: block.nodes }\n    : hash\n      ? { index: hash.index, value: null, nodes: hash.nodes }\n      : null\n\n  if (untrustedNode === null && (!seek || !seek.nodes.length)) return null\n\n  let root = null\n\n  if (seek && seek.nodes.length) {\n    const ite = flat.iterator(seek.nodes[0].index)\n    const q = new NodeQueue(seek.nodes)\n\n    root = q.shift(ite.index)\n    nodes.push(root)\n\n    while (q.length > 0) {\n      const node = q.shift(ite.sibling())\n\n      root = parentNode(crypto, ite.parent(), root, node)\n      nodes.push(node)\n      nodes.push(root)\n    }\n  }\n\n  if (untrustedNode === null) return root\n\n  const ite = flat.iterator(untrustedNode.index)\n  const blockHash = untrustedNode.value && blockNode(crypto, ite.index, untrustedNode.value)\n\n  const q = new NodeQueue(untrustedNode.nodes, root)\n\n  root = blockHash || q.shift(ite.index)\n  nodes.push(root)\n\n  while (q.length > 0) {\n    const node = q.shift(ite.sibling())\n\n    root = parentNode(crypto, ite.parent(), root, node)\n    nodes.push(node)\n    nodes.push(root)\n  }\n\n  return root\n}\n\nfunction verifyUpgrade ({ fork, upgrade }, blockRoot, batch) {\n  const prologue = batch.tree.prologue\n\n  if (prologue) {\n    const { start, length } = upgrade\n    if (start < prologue.length && (start !== 0 || length < prologue.length)) {\n      throw INVALID_PROOF('Upgrade does not satisfy prologue')\n    }\n  }\n\n  const q = new NodeQueue(upgrade.nodes, blockRoot)\n\n  let grow = batch.roots.length > 0\n  let i = 0\n\n  const to = 2 * (upgrade.start + upgrade.length)\n  const ite = flat.iterator(0)\n\n  for (; ite.fullRoot(to); ite.nextTree()) {\n    if (i < batch.roots.length && batch.roots[i].index === ite.index) {\n      i++\n      continue\n    }\n\n    if (grow) {\n      grow = false\n      const root = ite.index\n      if (i < batch.roots.length) {\n        ite.seek(batch.roots[batch.roots.length - 1].index)\n        while (ite.index !== root) {\n          batch.appendRoot(q.shift(ite.sibling()), ite)\n        }\n        continue\n      }\n    }\n\n    batch.appendRoot(q.shift(ite.index), ite)\n  }\n\n  if (prologue && batch.length === prologue.length) {\n    if (!b4a.equals(prologue.hash, batch.hash())) {\n      throw INVALID_PROOF('Invalid hash')\n    }\n  }\n\n  const extra = upgrade.additionalNodes\n\n  ite.seek(batch.roots[batch.roots.length - 1].index)\n  i = 0\n\n  while (i < extra.length && extra[i].index === ite.sibling()) {\n    batch.appendRoot(extra[i++], ite)\n  }\n\n  while (i < extra.length) {\n    const node = extra[i++]\n\n    while (node.index !== ite.index) {\n      if (ite.factor === 2) throw INVALID_OPERATION('Unexpected node: ' + node.index)\n      ite.leftChild()\n    }\n\n    batch.appendRoot(node, ite)\n    ite.sibling()\n  }\n\n  batch.signature = unslab(upgrade.signature)\n  batch.fork = fork\n\n  return q.extra === null\n}\n\nasync function seekFromHead (tree, head, bytes, padding) {\n  const roots = flat.fullRoots(head)\n\n  for (let i = 0; i < roots.length; i++) {\n    const root = roots[i]\n    const node = await tree.get(root)\n    const size = getUnpaddedSize(node, padding, null)\n\n    if (bytes === size) return root\n    if (bytes > size) {\n      bytes -= size\n      continue\n    }\n\n    return seekTrustedTree(tree, root, bytes, padding)\n  }\n\n  return head\n}\n\n// trust that bytes are within the root tree and find the block at bytes\n\nasync function seekTrustedTree (tree, root, bytes, padding) {\n  if (!bytes) return root\n\n  const ite = flat.iterator(root)\n\n  while ((ite.index & 1) !== 0) {\n    const l = await tree.get(ite.leftChild(), false)\n    if (l) {\n      const size = getUnpaddedSize(l, padding, ite)\n      if (size === bytes) return ite.index\n      if (size > bytes) continue\n      bytes -= size\n      ite.sibling()\n    } else {\n      ite.parent()\n      return ite.index\n    }\n  }\n\n  return ite.index\n}\n\n// try to find the block at bytes without trusting that is *is* within the root passed\n\nasync function seekUntrustedTree (tree, root, bytes, padding) {\n  const offset = await tree.byteOffset(root) - (padding ? padding * flat.leftSpan(root) / 2 : 0)\n\n  if (offset > bytes) throw INVALID_OPERATION('Invalid seek')\n  if (offset === bytes) return root\n\n  bytes -= offset\n\n  const node = await tree.get(root)\n\n  if (getUnpaddedSize(node, padding, null) <= bytes) throw INVALID_OPERATION('Invalid seek')\n\n  return seekTrustedTree(tree, root, bytes, padding)\n}\n\n// Below is proof production, ie, construct proofs to verify a request\n// Note, that all these methods are sync as we can statically infer which nodes\n// are needed for the remote to verify given they arguments they passed us\n\nfunction seekProof (tree, seekRoot, root, p) {\n  const ite = flat.iterator(seekRoot)\n\n  p.seek = []\n  p.seek.push(tree.get(ite.index))\n\n  while (ite.index !== root) {\n    ite.sibling()\n    p.seek.push(tree.get(ite.index))\n    ite.parent()\n  }\n}\n\nfunction blockAndSeekProof (tree, node, seek, seekRoot, root, p) {\n  if (!node) return seekProof(tree, seekRoot, root, p)\n\n  const ite = flat.iterator(node.index)\n\n  p.node = []\n  if (!node.value) p.node.push(tree.get(ite.index))\n\n  while (ite.index !== root) {\n    ite.sibling()\n\n    if (seek && ite.contains(seekRoot) && ite.index !== seekRoot) {\n      seekProof(tree, seekRoot, ite.index, p)\n    } else {\n      p.node.push(tree.get(ite.index))\n    }\n\n    ite.parent()\n  }\n}\n\nfunction upgradeProof (tree, node, seek, from, to, subTree, p) {\n  if (from === 0) p.upgrade = []\n\n  for (const ite = flat.iterator(0); ite.fullRoot(to); ite.nextTree()) {\n    // check if they already have the node\n    if (ite.index + ite.factor / 2 < from) continue\n\n    // connect existing tree\n    if (p.upgrade === null && ite.contains(from - 2)) {\n      p.upgrade = []\n\n      const root = ite.index\n      const target = from - 2\n\n      ite.seek(target)\n\n      while (ite.index !== root) {\n        ite.sibling()\n        if (ite.index > target) {\n          if (p.node === null && p.seek === null && ite.contains(subTree)) {\n            blockAndSeekProof(tree, node, seek, subTree, ite.index, p)\n          } else {\n            p.upgrade.push(tree.get(ite.index))\n          }\n        }\n        ite.parent()\n      }\n\n      continue\n    }\n\n    if (p.upgrade === null) {\n      p.upgrade = []\n    }\n\n    // if the subtree included is a child of this tree, include that one\n    // instead of a dup node\n    if (p.node === null && p.seek === null && ite.contains(subTree)) {\n      blockAndSeekProof(tree, node, seek, subTree, ite.index, p)\n      continue\n    }\n\n    // add root (can be optimised since the root might be in tree.roots)\n    p.upgrade.push(tree.get(ite.index))\n  }\n}\n\nfunction additionalUpgradeProof (tree, from, to, p) {\n  if (from === 0) p.additionalUpgrade = []\n\n  for (const ite = flat.iterator(0); ite.fullRoot(to); ite.nextTree()) {\n    // check if they already have the node\n    if (ite.index + ite.factor / 2 < from) continue\n\n    // connect existing tree\n    if (p.additionalUpgrade === null && ite.contains(from - 2)) {\n      p.additionalUpgrade = []\n\n      const root = ite.index\n      const target = from - 2\n\n      ite.seek(target)\n\n      while (ite.index !== root) {\n        ite.sibling()\n        if (ite.index > target) {\n          p.additionalUpgrade.push(tree.get(ite.index))\n        }\n        ite.parent()\n      }\n\n      continue\n    }\n\n    if (p.additionalUpgrade === null) {\n      p.additionalUpgrade = []\n    }\n\n    // add root (can be optimised since the root is in tree.roots)\n    p.additionalUpgrade.push(tree.get(ite.index))\n  }\n}\n\nfunction nodesToRoot (index, nodes, head) {\n  const ite = flat.iterator(index)\n\n  for (let i = 0; i < nodes; i++) {\n    ite.parent()\n    if (ite.contains(head)) throw BAD_ARGUMENT('Nodes is out of bounds')\n  }\n\n  return ite.index\n}\n\nfunction totalSize (nodes) {\n  let s = 0\n  for (const node of nodes) s += node.size\n  return s\n}\n\nfunction totalSpan (nodes) {\n  let s = 0\n  for (const node of nodes) s += 2 * ((node.index - s) + 1)\n  return s\n}\n\nfunction blockNode (crypto, index, value) {\n  return { index, size: value.byteLength, hash: crypto.data(value) }\n}\n\nfunction parentNode (crypto, index, a, b) {\n  return { index, size: a.size + b.size, hash: crypto.parent(a, b) }\n}\n\nfunction blankNode (index) {\n  return { index, size: 0, hash: BLANK_HASH }\n}\n\n// Storage methods\n\nfunction getStoredNode (storage, index, cache, error) {\n  return new Promise((resolve, reject) => {\n    storage.read(40 * index, 40, (err, data) => {\n      if (err) {\n        if (error) return reject(err)\n        else resolve(null)\n        return\n      }\n\n      const hash = data.subarray(8)\n      const size = c.decode(c.uint64, data)\n\n      if (size === 0 && b4a.compare(hash, BLANK_HASH) === 0) {\n        if (error) reject(new Error('Could not load node: ' + index))\n        else resolve(null)\n        return\n      }\n\n      const node = { index, size, hash }\n\n      if (cache !== null) {\n        // Copy hash to a new buffer to avoid blocking gc of its original slab\n        node.hash = unslab(hash)\n        cache.set(index, node)\n      }\n\n      resolve(node)\n    })\n  })\n}\n\nfunction storedNodes (storage) {\n  return new Promise((resolve) => {\n    storage.stat((_, st) => {\n      if (!st) return resolve(0)\n      resolve((st.size - (st.size % 40)) / 40)\n    })\n  })\n}\n\nasync function autoLength (storage) {\n  const nodes = await storedNodes(storage)\n  if (!nodes) return 0\n  const ite = flat.iterator(nodes - 1)\n  let index = nodes - 1\n  while (await getStoredNode(storage, ite.parent(), null, false)) index = ite.index\n  return flat.rightSpan(index) / 2 + 1\n}\n\nfunction truncateMap (map, len) {\n  for (const node of map.values()) {\n    if (node.index >= 2 * len) map.delete(node.index)\n  }\n}\n\nfunction log2 (n) {\n  let res = 1\n\n  while (n > 2) {\n    n /= 2\n    res++\n  }\n\n  return res\n}\n\nfunction normalizeIndexed (block, hash) {\n  if (block) return { value: true, index: block.index * 2, nodes: block.nodes, lastIndex: block.index }\n  if (hash) return { value: false, index: hash.index, nodes: hash.nodes, lastIndex: flat.rightSpan(hash.index) / 2 }\n  return null\n}\n\nasync function settleProof (p) {\n  const result = [\n    p.node && Promise.all(p.node),\n    p.seek && Promise.all(p.seek),\n    p.upgrade && Promise.all(p.upgrade),\n    p.additionalUpgrade && Promise.all(p.additionalUpgrade)\n  ]\n\n  try {\n    return await Promise.all(result)\n  } catch (err) {\n    if (p.node) await Promise.allSettled(p.node)\n    if (p.seek) await Promise.allSettled(p.seek)\n    if (p.upgrade) await Promise.allSettled(p.upgrade)\n    if (p.additionalUpgrade) await Promise.allSettled(p.additionalUpgrade)\n    throw err\n  }\n}\n\n// tree can be either the merkle tree or a merkle tree batch\nasync function generateProof (tree, block, hash, seek, upgrade) {\n  // Important that this does not throw inbetween making the promise arrays\n  // and finalise being called, otherwise there will be lingering promises in the background\n\n  if (tree.prologue && upgrade) {\n    upgrade.start = upgrade.start < tree.prologue.length ? 0 : upgrade.start\n    upgrade.length = upgrade.start < tree.prologue.length ? tree.prologue.length : upgrade.length\n  }\n\n  const fork = tree.fork\n  const signature = tree.signature\n  const head = 2 * tree.length\n  const from = upgrade ? upgrade.start * 2 : 0\n  const to = upgrade ? from + upgrade.length * 2 : head\n  const node = normalizeIndexed(block, hash)\n\n  const result = { fork, block: null, hash: null, seek: null, upgrade: null, manifest: null }\n\n  // can't do anything as we have no data...\n  if (head === 0) return result\n\n  if (from >= to || to > head) {\n    throw INVALID_OPERATION('Invalid upgrade')\n  }\n  if (seek && upgrade && node !== null && node.index >= from) {\n    throw INVALID_OPERATION('Cannot both do a seek and block/hash request when upgrading')\n  }\n\n  let subTree = head\n\n  const p = {\n    node: null,\n    seek: null,\n    upgrade: null,\n    additionalUpgrade: null\n  }\n\n  if (node !== null && (!upgrade || node.lastIndex < upgrade.start)) {\n    subTree = nodesToRoot(node.index, node.nodes, to)\n    const seekRoot = seek ? await seekUntrustedTree(tree, subTree, seek.bytes, seek.padding) : head\n    blockAndSeekProof(tree, node, seek, seekRoot, subTree, p)\n  } else if ((node || seek) && upgrade) {\n    subTree = seek ? await seekFromHead(tree, to, seek.bytes, seek.padding) : node.index\n  }\n\n  if (upgrade) {\n    upgradeProof(tree, node, seek, from, to, subTree, p)\n    if (head > to) additionalUpgradeProof(tree, to, head, p)\n  }\n\n  const [pNode, pSeek, pUpgrade, pAdditional] = await settleProof(p)\n\n  if (block) {\n    if (pNode === null) throw INVALID_OPERATION('Invalid block request')\n    result.block = {\n      index: block.index,\n      value: null, // populated upstream, alloc it here for simplicity\n      nodes: pNode\n    }\n  } else if (hash) {\n    if (pNode === null) throw INVALID_OPERATION('Invalid hash request')\n    result.hash = {\n      index: hash.index,\n      nodes: pNode\n    }\n  }\n\n  if (seek && pSeek !== null) {\n    result.seek = {\n      bytes: seek.bytes,\n      nodes: pSeek\n    }\n  }\n\n  if (upgrade) {\n    result.upgrade = {\n      start: upgrade.start,\n      length: upgrade.length,\n      nodes: pUpgrade,\n      additionalNodes: pAdditional || [],\n      signature\n    }\n  }\n\n  return result\n}\n\nfunction getUnpaddedSize (node, padding, ite) {\n  return padding === 0 ? node.size : node.size - padding * (ite ? ite.countLeaves() : flat.countLeaves(node.index))\n}\n\nfunction unslabNodes (nodes) {\n  for (const node of nodes) unslabNode(node)\n  return nodes\n}\n\nfunction unslabNode (node) {\n  if (node === null) return node\n  node.hash = unslab(node.hash)\n  return node\n}\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst { DEFAULT_NAMESPACE } = require('./caps')\nconst { INVALID_OPLOG_VERSION } = require('hypercore-errors')\nconst unslab = require('unslab')\n\nconst EMPTY = b4a.alloc(0)\n\nconst hashes = {\n  preencode (state, m) {\n    state.end++ // small uint\n  },\n  encode (state, m) {\n    if (m === 'blake2b') {\n      c.uint.encode(state, 0)\n      return\n    }\n\n    throw new Error('Unknown hash: ' + m)\n  },\n  decode (state) {\n    const n = c.uint.decode(state)\n    if (n === 0) return 'blake2b'\n    throw new Error('Unknown hash id: ' + n)\n  }\n}\n\nconst signatures = {\n  preencode (state, m) {\n    state.end++ // small uint\n  },\n  encode (state, m) {\n    if (m === 'ed25519') {\n      c.uint.encode(state, 0)\n      return\n    }\n\n    throw new Error('Unknown signature: ' + m)\n  },\n  decode (state) {\n    const n = c.uint.decode(state)\n    if (n === 0) return 'ed25519'\n    throw new Error('Unknown signature id: ' + n)\n  }\n}\n\nconst signer = {\n  preencode (state, m) {\n    signatures.preencode(state, m.signature)\n    c.fixed32.preencode(state, m.namespace)\n    c.fixed32.preencode(state, m.publicKey)\n  },\n  encode (state, m) {\n    signatures.encode(state, m.signature)\n    c.fixed32.encode(state, m.namespace)\n    c.fixed32.encode(state, m.publicKey)\n  },\n  decode (state) {\n    return {\n      signature: signatures.decode(state),\n      namespace: c.fixed32.decode(state),\n      publicKey: c.fixed32.decode(state)\n    }\n  }\n}\n\nconst signerArray = c.array(signer)\n\nconst prologue = {\n  preencode (state, p) {\n    c.fixed32.preencode(state, p.hash)\n    c.uint.preencode(state, p.length)\n  },\n  encode (state, p) {\n    c.fixed32.encode(state, p.hash)\n    c.uint.encode(state, p.length)\n  },\n  decode (state) {\n    return {\n      hash: c.fixed32.decode(state),\n      length: c.uint.decode(state)\n    }\n  }\n}\n\nconst manifestv0 = {\n  preencode (state, m) {\n    hashes.preencode(state, m.hash)\n    state.end++ // type\n\n    if (m.prologue && m.signers.length === 0) {\n      c.fixed32.preencode(state, m.prologue.hash)\n      return\n    }\n\n    if (m.quorum === 1 && m.signers.length === 1 && !m.allowPatch) {\n      signer.preencode(state, m.signers[0])\n    } else {\n      state.end++ // flags\n      c.uint.preencode(state, m.quorum)\n      signerArray.preencode(state, m.signers)\n    }\n  },\n  encode (state, m) {\n    hashes.encode(state, m.hash)\n\n    if (m.prologue && m.signers.length === 0) {\n      c.uint.encode(state, 0)\n      c.fixed32.encode(state, m.prologue.hash)\n      return\n    }\n\n    if (m.quorum === 1 && m.signers.length === 1 && !m.allowPatch) {\n      c.uint.encode(state, 1)\n      signer.encode(state, m.signers[0])\n    } else {\n      c.uint.encode(state, 2)\n      c.uint.encode(state, m.allowPatch ? 1 : 0)\n      c.uint.encode(state, m.quorum)\n      signerArray.encode(state, m.signers)\n    }\n  },\n  decode (state) {\n    const hash = hashes.decode(state)\n    const type = c.uint.decode(state)\n\n    if (type > 2) throw new Error('Unknown type: ' + type)\n\n    if (type === 0) {\n      return {\n        version: 0,\n        hash,\n        allowPatch: false,\n        quorum: 0,\n        signers: [],\n        prologue: {\n          hash: c.fixed32.decode(state),\n          length: 0\n        }\n      }\n    }\n\n    if (type === 1) {\n      return {\n        version: 0,\n        hash,\n        allowPatch: false,\n        quorum: 1,\n        signers: [signer.decode(state)],\n        prologue: null\n      }\n    }\n\n    const flags = c.uint.decode(state)\n\n    return {\n      version: 0,\n      hash,\n      allowPatch: (flags & 1) !== 0,\n      quorum: c.uint.decode(state),\n      signers: signerArray.decode(state),\n      prologue: null\n    }\n  }\n}\n\nconst manifest = exports.manifest = {\n  preencode (state, m) {\n    state.end++ // version\n    if (m.version === 0) return manifestv0.preencode(state, m)\n\n    state.end++ // flags\n    hashes.preencode(state, m.hash)\n\n    c.uint.preencode(state, m.quorum)\n    signerArray.preencode(state, m.signers)\n    if (m.prologue) prologue.preencode(state, m.prologue)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.version)\n    if (m.version === 0) return manifestv0.encode(state, m)\n\n    c.uint.encode(state, (m.allowPatch ? 1 : 0) | (m.prologue ? 2 : 0))\n    hashes.encode(state, m.hash)\n\n    c.uint.encode(state, m.quorum)\n    signerArray.encode(state, m.signers)\n    if (m.prologue) prologue.encode(state, m.prologue)\n  },\n  decode (state) {\n    const v = c.uint.decode(state)\n    if (v === 0) return manifestv0.decode(state)\n    if (v !== 1) throw new Error('Unknown version: ' + v)\n\n    const flags = c.uint.decode(state)\n    const hash = hashes.decode(state)\n    const quorum = c.uint.decode(state)\n    const signers = signerArray.decode(state)\n\n    return {\n      version: 1,\n      hash,\n      allowPatch: (flags & 1) !== 0,\n      quorum,\n      signers,\n      prologue: (flags & 2) === 0 ? null : prologue.decode(state)\n    }\n  }\n}\n\nconst node = {\n  preencode (state, n) {\n    c.uint.preencode(state, n.index)\n    c.uint.preencode(state, n.size)\n    c.fixed32.preencode(state, n.hash)\n  },\n  encode (state, n) {\n    c.uint.encode(state, n.index)\n    c.uint.encode(state, n.size)\n    c.fixed32.encode(state, n.hash)\n  },\n  decode (state) {\n    return {\n      index: c.uint.decode(state),\n      size: c.uint.decode(state),\n      hash: c.fixed32.decode(state)\n    }\n  }\n}\n\nconst nodeArray = c.array(node)\n\nconst wire = exports.wire = {}\n\nwire.handshake = {\n  preencode (state, m) {\n    c.uint.preencode(state, 1)\n    c.fixed32.preencode(state, m.capability)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.seeks ? 1 : 0)\n    c.fixed32.encode(state, m.capability)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      seeks: (flags & 1) !== 0,\n      capability: unslab(c.fixed32.decode(state))\n    }\n  }\n}\n\nconst requestBlock = {\n  preencode (state, b) {\n    c.uint.preencode(state, b.index)\n    c.uint.preencode(state, b.nodes)\n  },\n  encode (state, b) {\n    c.uint.encode(state, b.index)\n    c.uint.encode(state, b.nodes)\n  },\n  decode (state) {\n    return {\n      index: c.uint.decode(state),\n      nodes: c.uint.decode(state)\n    }\n  }\n}\n\nconst requestSeek = {\n  preencode (state, s) {\n    c.uint.preencode(state, s.bytes)\n    c.uint.preencode(state, s.padding)\n  },\n  encode (state, s) {\n    c.uint.encode(state, s.bytes)\n    c.uint.encode(state, s.padding)\n  },\n  decode (state) {\n    return {\n      bytes: c.uint.decode(state),\n      padding: c.uint.decode(state)\n    }\n  }\n}\n\nconst requestUpgrade = {\n  preencode (state, u) {\n    c.uint.preencode(state, u.start)\n    c.uint.preencode(state, u.length)\n  },\n  encode (state, u) {\n    c.uint.encode(state, u.start)\n    c.uint.encode(state, u.length)\n  },\n  decode (state) {\n    return {\n      start: c.uint.decode(state),\n      length: c.uint.decode(state)\n    }\n  }\n}\n\nwire.request = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.uint.preencode(state, m.id)\n    c.uint.preencode(state, m.fork)\n\n    if (m.block) requestBlock.preencode(state, m.block)\n    if (m.hash) requestBlock.preencode(state, m.hash)\n    if (m.seek) requestSeek.preencode(state, m.seek)\n    if (m.upgrade) requestUpgrade.preencode(state, m.upgrade)\n    if (m.priority) c.uint.preencode(state, m.priority)\n  },\n  encode (state, m) {\n    const flags = (m.block ? 1 : 0) | (m.hash ? 2 : 0) | (m.seek ? 4 : 0) | (m.upgrade ? 8 : 0) | (m.manifest ? 16 : 0) | (m.priority ? 32 : 0)\n\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.id)\n    c.uint.encode(state, m.fork)\n\n    if (m.block) requestBlock.encode(state, m.block)\n    if (m.hash) requestBlock.encode(state, m.hash)\n    if (m.seek) requestSeek.encode(state, m.seek)\n    if (m.upgrade) requestUpgrade.encode(state, m.upgrade)\n    if (m.priority) c.uint.encode(state, m.priority)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n\n    return {\n      id: c.uint.decode(state),\n      fork: c.uint.decode(state),\n      block: flags & 1 ? requestBlock.decode(state) : null,\n      hash: flags & 2 ? requestBlock.decode(state) : null,\n      seek: flags & 4 ? requestSeek.decode(state) : null,\n      upgrade: flags & 8 ? requestUpgrade.decode(state) : null,\n      manifest: (flags & 16) !== 0,\n      priority: flags & 32 ? c.uint.decode(state) : 0\n    }\n  }\n}\n\nwire.cancel = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.request)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.request)\n  },\n  decode (state, m) {\n    return {\n      request: c.uint.decode(state)\n    }\n  }\n}\n\nconst dataUpgrade = {\n  preencode (state, u) {\n    c.uint.preencode(state, u.start)\n    c.uint.preencode(state, u.length)\n    nodeArray.preencode(state, u.nodes)\n    nodeArray.preencode(state, u.additionalNodes)\n    c.buffer.preencode(state, u.signature)\n  },\n  encode (state, u) {\n    c.uint.encode(state, u.start)\n    c.uint.encode(state, u.length)\n    nodeArray.encode(state, u.nodes)\n    nodeArray.encode(state, u.additionalNodes)\n    c.buffer.encode(state, u.signature)\n  },\n  decode (state) {\n    return {\n      start: c.uint.decode(state),\n      length: c.uint.decode(state),\n      nodes: nodeArray.decode(state),\n      additionalNodes: nodeArray.decode(state),\n      signature: c.buffer.decode(state)\n    }\n  }\n}\n\nconst dataSeek = {\n  preencode (state, s) {\n    c.uint.preencode(state, s.bytes)\n    nodeArray.preencode(state, s.nodes)\n  },\n  encode (state, s) {\n    c.uint.encode(state, s.bytes)\n    nodeArray.encode(state, s.nodes)\n  },\n  decode (state) {\n    return {\n      bytes: c.uint.decode(state),\n      nodes: nodeArray.decode(state)\n    }\n  }\n}\n\nconst dataBlock = {\n  preencode (state, b) {\n    c.uint.preencode(state, b.index)\n    c.buffer.preencode(state, b.value)\n    nodeArray.preencode(state, b.nodes)\n  },\n  encode (state, b) {\n    c.uint.encode(state, b.index)\n    c.buffer.encode(state, b.value)\n    nodeArray.encode(state, b.nodes)\n  },\n  decode (state) {\n    return {\n      index: c.uint.decode(state),\n      value: c.buffer.decode(state) || EMPTY,\n      nodes: nodeArray.decode(state)\n    }\n  }\n}\n\nconst dataHash = {\n  preencode (state, b) {\n    c.uint.preencode(state, b.index)\n    nodeArray.preencode(state, b.nodes)\n  },\n  encode (state, b) {\n    c.uint.encode(state, b.index)\n    nodeArray.encode(state, b.nodes)\n  },\n  decode (state) {\n    return {\n      index: c.uint.decode(state),\n      nodes: nodeArray.decode(state)\n    }\n  }\n}\n\nwire.data = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.uint.preencode(state, m.request)\n    c.uint.preencode(state, m.fork)\n\n    if (m.block) dataBlock.preencode(state, m.block)\n    if (m.hash) dataHash.preencode(state, m.hash)\n    if (m.seek) dataSeek.preencode(state, m.seek)\n    if (m.upgrade) dataUpgrade.preencode(state, m.upgrade)\n    if (m.manifest) manifest.preencode(state, m.manifest)\n  },\n  encode (state, m) {\n    const flags = (m.block ? 1 : 0) | (m.hash ? 2 : 0) | (m.seek ? 4 : 0) | (m.upgrade ? 8 : 0) | (m.manifest ? 16 : 0)\n\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.request)\n    c.uint.encode(state, m.fork)\n\n    if (m.block) dataBlock.encode(state, m.block)\n    if (m.hash) dataHash.encode(state, m.hash)\n    if (m.seek) dataSeek.encode(state, m.seek)\n    if (m.upgrade) dataUpgrade.encode(state, m.upgrade)\n    if (m.manifest) manifest.encode(state, m.manifest)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n\n    return {\n      request: c.uint.decode(state),\n      fork: c.uint.decode(state),\n      block: flags & 1 ? dataBlock.decode(state) : null,\n      hash: flags & 2 ? dataHash.decode(state) : null,\n      seek: flags & 4 ? dataSeek.decode(state) : null,\n      upgrade: flags & 8 ? dataUpgrade.decode(state) : null,\n      manifest: flags & 16 ? manifest.decode(state) : null\n    }\n  }\n}\n\nwire.noData = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.request)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.request)\n  },\n  decode (state, m) {\n    return {\n      request: c.uint.decode(state)\n    }\n  }\n}\n\nwire.want = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.start)\n    c.uint.preencode(state, m.length)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.start)\n    c.uint.encode(state, m.length)\n  },\n  decode (state) {\n    return {\n      start: c.uint.decode(state),\n      length: c.uint.decode(state)\n    }\n  }\n}\n\nwire.unwant = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.start)\n    c.uint.preencode(state, m.length)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.start)\n    c.uint.encode(state, m.length)\n  },\n  decode (state, m) {\n    return {\n      start: c.uint.decode(state),\n      length: c.uint.decode(state)\n    }\n  }\n}\n\nwire.range = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.uint.preencode(state, m.start)\n    if (m.length !== 1) c.uint.preencode(state, m.length)\n  },\n  encode (state, m) {\n    c.uint.encode(state, (m.drop ? 1 : 0) | (m.length === 1 ? 2 : 0))\n    c.uint.encode(state, m.start)\n    if (m.length !== 1) c.uint.encode(state, m.length)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n\n    return {\n      drop: (flags & 1) !== 0,\n      start: c.uint.decode(state),\n      length: (flags & 2) !== 0 ? 1 : c.uint.decode(state)\n    }\n  }\n}\n\nwire.bitfield = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.start)\n    c.uint32array.preencode(state, m.bitfield)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.start)\n    c.uint32array.encode(state, m.bitfield)\n  },\n  decode (state, m) {\n    return {\n      start: c.uint.decode(state),\n      bitfield: c.uint32array.decode(state)\n    }\n  }\n}\n\nwire.sync = {\n  preencode (state, m) {\n    state.end++ // flags\n    c.uint.preencode(state, m.fork)\n    c.uint.preencode(state, m.length)\n    c.uint.preencode(state, m.remoteLength)\n  },\n  encode (state, m) {\n    c.uint.encode(state, (m.canUpgrade ? 1 : 0) | (m.uploading ? 2 : 0) | (m.downloading ? 4 : 0) | (m.hasManifest ? 8 : 0))\n    c.uint.encode(state, m.fork)\n    c.uint.encode(state, m.length)\n    c.uint.encode(state, m.remoteLength)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n\n    return {\n      fork: c.uint.decode(state),\n      length: c.uint.decode(state),\n      remoteLength: c.uint.decode(state),\n      canUpgrade: (flags & 1) !== 0,\n      uploading: (flags & 2) !== 0,\n      downloading: (flags & 4) !== 0,\n      hasManifest: (flags & 8) !== 0\n    }\n  }\n}\n\nwire.reorgHint = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.from)\n    c.uint.preencode(state, m.to)\n    c.uint.preencode(state, m.ancestors)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.from)\n    c.uint.encode(state, m.to)\n    c.uint.encode(state, m.ancestors)\n  },\n  decode (state) {\n    return {\n      from: c.uint.encode(state),\n      to: c.uint.encode(state),\n      ancestors: c.uint.encode(state)\n    }\n  }\n}\n\nwire.extension = {\n  preencode (state, m) {\n    c.string.preencode(state, m.name)\n    c.raw.preencode(state, m.message)\n  },\n  encode (state, m) {\n    c.string.encode(state, m.name)\n    c.raw.encode(state, m.message)\n  },\n  decode (state) {\n    return {\n      name: c.string.decode(state),\n      message: c.raw.decode(state)\n    }\n  }\n}\n\nconst keyValue = {\n  preencode (state, p) {\n    c.string.preencode(state, p.key)\n    c.buffer.preencode(state, p.value)\n  },\n  encode (state, p) {\n    c.string.encode(state, p.key)\n    c.buffer.encode(state, p.value)\n  },\n  decode (state) {\n    return {\n      key: c.string.decode(state),\n      value: c.buffer.decode(state)\n    }\n  }\n}\n\nconst treeUpgrade = {\n  preencode (state, u) {\n    c.uint.preencode(state, u.fork)\n    c.uint.preencode(state, u.ancestors)\n    c.uint.preencode(state, u.length)\n    c.buffer.preencode(state, u.signature)\n  },\n  encode (state, u) {\n    c.uint.encode(state, u.fork)\n    c.uint.encode(state, u.ancestors)\n    c.uint.encode(state, u.length)\n    c.buffer.encode(state, u.signature)\n  },\n  decode (state) {\n    return {\n      fork: c.uint.decode(state),\n      ancestors: c.uint.decode(state),\n      length: c.uint.decode(state),\n      signature: c.buffer.decode(state)\n    }\n  }\n}\n\nconst bitfieldUpdate = { // TODO: can maybe be folded into a HAVE later on with the most recent spec\n  preencode (state, b) {\n    state.end++ // flags\n    c.uint.preencode(state, b.start)\n    c.uint.preencode(state, b.length)\n  },\n  encode (state, b) {\n    state.buffer[state.start++] = b.drop ? 1 : 0\n    c.uint.encode(state, b.start)\n    c.uint.encode(state, b.length)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      drop: (flags & 1) !== 0,\n      start: c.uint.decode(state),\n      length: c.uint.decode(state)\n    }\n  }\n}\n\nconst oplog = exports.oplog = {}\n\noplog.entry = {\n  preencode (state, m) {\n    state.end++ // flags\n    if (m.userData) keyValue.preencode(state, m.userData)\n    if (m.treeNodes) nodeArray.preencode(state, m.treeNodes)\n    if (m.treeUpgrade) treeUpgrade.preencode(state, m.treeUpgrade)\n    if (m.bitfield) bitfieldUpdate.preencode(state, m.bitfield)\n  },\n  encode (state, m) {\n    const s = state.start++\n    let flags = 0\n\n    if (m.userData) {\n      flags |= 1\n      keyValue.encode(state, m.userData)\n    }\n    if (m.treeNodes) {\n      flags |= 2\n      nodeArray.encode(state, m.treeNodes)\n    }\n    if (m.treeUpgrade) {\n      flags |= 4\n      treeUpgrade.encode(state, m.treeUpgrade)\n    }\n    if (m.bitfield) {\n      flags |= 8\n      bitfieldUpdate.encode(state, m.bitfield)\n    }\n\n    state.buffer[s] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      userData: (flags & 1) !== 0 ? keyValue.decode(state) : null,\n      treeNodes: (flags & 2) !== 0 ? nodeArray.decode(state) : null,\n      treeUpgrade: (flags & 4) !== 0 ? treeUpgrade.decode(state) : null,\n      bitfield: (flags & 8) !== 0 ? bitfieldUpdate.decode(state) : null\n    }\n  }\n}\n\nconst keyPair = {\n  preencode (state, kp) {\n    c.buffer.preencode(state, kp.publicKey)\n    c.buffer.preencode(state, kp.secretKey)\n  },\n  encode (state, kp) {\n    c.buffer.encode(state, kp.publicKey)\n    c.buffer.encode(state, kp.secretKey)\n  },\n  decode (state) {\n    return {\n      publicKey: c.buffer.decode(state),\n      secretKey: c.buffer.decode(state)\n    }\n  }\n}\n\nconst reorgHint = {\n  preencode (state, r) {\n    c.uint.preencode(state, r.from)\n    c.uint.preencode(state, r.to)\n    c.uint.preencode(state, r.ancestors)\n  },\n  encode (state, r) {\n    c.uint.encode(state, r.from)\n    c.uint.encode(state, r.to)\n    c.uint.encode(state, r.ancestors)\n  },\n  decode (state) {\n    return {\n      from: c.uint.decode(state),\n      to: c.uint.decode(state),\n      ancestors: c.uint.decode(state)\n    }\n  }\n}\n\nconst reorgHintArray = c.array(reorgHint)\n\nconst hints = {\n  preencode (state, h) {\n    reorgHintArray.preencode(state, h.reorgs)\n    c.uint.preencode(state, h.contiguousLength)\n  },\n  encode (state, h) {\n    reorgHintArray.encode(state, h.reorgs)\n    c.uint.encode(state, h.contiguousLength)\n  },\n  decode (state) {\n    return {\n      reorgs: reorgHintArray.decode(state),\n      contiguousLength: state.start < state.end ? c.uint.decode(state) : 0\n    }\n  }\n}\n\nconst treeHeader = {\n  preencode (state, t) {\n    c.uint.preencode(state, t.fork)\n    c.uint.preencode(state, t.length)\n    c.buffer.preencode(state, t.rootHash)\n    c.buffer.preencode(state, t.signature)\n  },\n  encode (state, t) {\n    c.uint.encode(state, t.fork)\n    c.uint.encode(state, t.length)\n    c.buffer.encode(state, t.rootHash)\n    c.buffer.encode(state, t.signature)\n  },\n  decode (state) {\n    return {\n      fork: c.uint.decode(state),\n      length: c.uint.decode(state),\n      rootHash: c.buffer.decode(state),\n      signature: c.buffer.decode(state)\n    }\n  }\n}\n\nconst types = {\n  preencode (state, t) {\n    c.string.preencode(state, t.tree)\n    c.string.preencode(state, t.bitfield)\n    c.string.preencode(state, t.signer)\n  },\n  encode (state, t) {\n    c.string.encode(state, t.tree)\n    c.string.encode(state, t.bitfield)\n    c.string.encode(state, t.signer)\n  },\n  decode (state) {\n    return {\n      tree: c.string.decode(state),\n      bitfield: c.string.decode(state),\n      signer: c.string.decode(state)\n    }\n  }\n}\n\nconst externalHeader = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.start)\n    c.uint.preencode(state, m.length)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.start)\n    c.uint.encode(state, m.length)\n  },\n  decode (state) {\n    return {\n      start: c.uint.decode(state),\n      length: c.uint.decode(state)\n    }\n  }\n}\n\nconst keyValueArray = c.array(keyValue)\n\noplog.header = {\n  preencode (state, h) {\n    state.end += 2 // version + flags\n    if (h.external) {\n      externalHeader.preencode(state, h.external)\n      return\n    }\n    c.fixed32.preencode(state, h.key)\n    if (h.manifest) manifest.preencode(state, h.manifest)\n    if (h.keyPair) keyPair.preencode(state, h.keyPair)\n    keyValueArray.preencode(state, h.userData)\n    treeHeader.preencode(state, h.tree)\n    hints.preencode(state, h.hints)\n  },\n  encode (state, h) {\n    c.uint.encode(state, 1)\n    if (h.external) {\n      c.uint.encode(state, 1) // ONLY set the first big for clarity\n      externalHeader.encode(state, h.external)\n      return\n    }\n    c.uint.encode(state, (h.manifest ? 2 : 0) | (h.keyPair ? 4 : 0))\n    c.fixed32.encode(state, h.key)\n    if (h.manifest) manifest.encode(state, h.manifest)\n    if (h.keyPair) keyPair.encode(state, h.keyPair)\n    keyValueArray.encode(state, h.userData)\n    treeHeader.encode(state, h.tree)\n    hints.encode(state, h.hints)\n  },\n  decode (state) {\n    const version = c.uint.decode(state)\n\n    if (version > 1) {\n      throw INVALID_OPLOG_VERSION('Invalid header version. Expected <= 1, got ' + version)\n    }\n\n    if (version === 0) {\n      const old = {\n        types: types.decode(state),\n        userData: keyValueArray.decode(state),\n        tree: treeHeader.decode(state),\n        signer: keyPair.decode(state),\n        hints: hints.decode(state)\n      }\n\n      return {\n        external: null,\n        key: old.signer.publicKey,\n        manifest: {\n          version: 0,\n          hash: old.types.tree,\n          allowPatch: false,\n          quorum: 1,\n          signers: [{\n            signature: old.types.signer,\n            namespace: DEFAULT_NAMESPACE,\n            publicKey: old.signer.publicKey\n          }],\n          prologue: null\n        },\n        keyPair: old.signer.secretKey ? old.signer : null,\n        userData: old.userData,\n        tree: old.tree,\n        hints: old.hints\n      }\n    }\n\n    const flags = c.uint.decode(state)\n\n    if (flags & 1) {\n      return {\n        external: externalHeader.decode(state),\n        key: null,\n        manifest: null,\n        keyPair: null,\n        userData: null,\n        tree: null,\n        hints: null\n      }\n    }\n\n    return {\n      external: null,\n      key: c.fixed32.decode(state),\n      manifest: (flags & 2) !== 0 ? manifest.decode(state) : null,\n      keyPair: (flags & 4) !== 0 ? keyPair.decode(state) : null,\n      userData: keyValueArray.decode(state),\n      tree: treeHeader.decode(state),\n      hints: hints.decode(state)\n    }\n  }\n}\n\nconst uintArray = c.array(c.uint)\n\nconst multisigInput = {\n  preencode (state, inp) {\n    c.uint.preencode(state, inp.signer)\n    c.fixed64.preencode(state, inp.signature)\n    c.uint.preencode(state, inp.patch)\n  },\n  encode (state, inp) {\n    c.uint.encode(state, inp.signer)\n    c.fixed64.encode(state, inp.signature)\n    c.uint.encode(state, inp.patch)\n  },\n  decode (state) {\n    return {\n      signer: c.uint.decode(state),\n      signature: c.fixed64.decode(state),\n      patch: c.uint.decode(state)\n    }\n  }\n}\n\nconst patchEncodingv0 = {\n  preencode (state, n) {\n    c.uint.preencode(state, n.start)\n    c.uint.preencode(state, n.length)\n    uintArray.preencode(state, n.nodes)\n  },\n  encode (state, n) {\n    c.uint.encode(state, n.start)\n    c.uint.encode(state, n.length)\n    uintArray.encode(state, n.nodes)\n  },\n  decode (state) {\n    return {\n      start: c.uint.decode(state),\n      length: c.uint.decode(state),\n      nodes: uintArray.decode(state)\n    }\n  }\n}\n\nconst multisigInputv0 = {\n  preencode (state, n) {\n    state.end++\n    c.uint.preencode(state, n.signer)\n    c.fixed64.preencode(state, n.signature)\n    if (n.patch) patchEncodingv0.preencode(state, n.patch)\n  },\n  encode (state, n) {\n    c.uint.encode(state, n.patch ? 1 : 0)\n    c.uint.encode(state, n.signer)\n    c.fixed64.encode(state, n.signature)\n    if (n.patch) patchEncodingv0.encode(state, n.patch)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      signer: c.uint.decode(state),\n      signature: c.fixed64.decode(state),\n      patch: (flags & 1) ? patchEncodingv0.decode(state) : null\n    }\n  }\n}\n\nconst multisigInputArrayv0 = c.array(multisigInputv0)\nconst multisigInputArray = c.array(multisigInput)\n\nconst compactNode = {\n  preencode (state, n) {\n    c.uint.preencode(state, n.index)\n    c.uint.preencode(state, n.size)\n    c.fixed32.preencode(state, n.hash)\n  },\n  encode (state, n) {\n    c.uint.encode(state, n.index)\n    c.uint.encode(state, n.size)\n    c.fixed32.encode(state, n.hash)\n  },\n  decode (state) {\n    return {\n      index: c.uint.decode(state),\n      size: c.uint.decode(state),\n      hash: c.fixed32.decode(state)\n    }\n  }\n}\n\nconst compactNodeArray = c.array(compactNode)\n\nexports.multiSignaturev0 = {\n  preencode (state, s) {\n    multisigInputArrayv0.preencode(state, s.proofs)\n    compactNodeArray.preencode(state, s.patch)\n  },\n  encode (state, s) {\n    multisigInputArrayv0.encode(state, s.proofs)\n    compactNodeArray.encode(state, s.patch)\n  },\n  decode (state) {\n    return {\n      proofs: multisigInputArrayv0.decode(state),\n      patch: compactNodeArray.decode(state)\n    }\n  }\n}\n\nexports.multiSignature = {\n  preencode (state, s) {\n    multisigInputArray.preencode(state, s.proofs)\n    compactNodeArray.preencode(state, s.patch)\n  },\n  encode (state, s) {\n    multisigInputArray.encode(state, s.proofs)\n    compactNodeArray.encode(state, s.patch)\n  },\n  decode (state) {\n    return {\n      proofs: multisigInputArray.decode(state),\n      patch: compactNodeArray.decode(state)\n    }\n  }\n}\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst flat = require('flat-tree')\nconst { multiSignature, multiSignaturev0 } = require('./messages')\n\nmodule.exports = {\n  assemblev0,\n  assemble,\n  inflatev0,\n  inflate,\n  partialSignature,\n  signableLength\n}\n\nfunction inflatev0 (data) {\n  return c.decode(multiSignaturev0, data)\n}\n\nfunction inflate (data) {\n  return c.decode(multiSignature, data)\n}\n\nasync function partialSignature (tree, signer, from, to = tree.length, signature = tree.signature) {\n  if (from > tree.length) return null\n  const nodes = to <= from ? null : await upgradeNodes(tree, from, to)\n\n  if (signature.byteLength !== 64) signature = c.decode(multiSignature, signature).proofs[0].signature\n\n  return {\n    signer,\n    signature,\n    patch: nodes ? to - from : 0,\n    nodes\n  }\n}\n\nasync function upgradeNodes (tree, from, to) {\n  const p = await tree.proof({ upgrade: { start: from, length: to - from } })\n  return p.upgrade.nodes\n}\n\nfunction signableLength (lengths, quorum) {\n  if (quorum <= 0) quorum = 1\n  if (quorum > lengths.length) return 0\n\n  return lengths.sort(cmp)[quorum - 1]\n}\n\nfunction cmp (a, b) {\n  return b - a\n}\n\nfunction assemblev0 (inputs) {\n  const proofs = []\n  const patch = []\n\n  for (const u of inputs) {\n    proofs.push(compressProof(u, patch))\n  }\n\n  return c.encode(multiSignaturev0, { proofs, patch })\n}\n\nfunction assemble (inputs) {\n  const proofs = []\n  const patch = []\n  const seen = new Set()\n\n  for (const u of inputs) {\n    if (u.nodes) {\n      for (const node of u.nodes) {\n        if (seen.has(node.index)) continue\n        seen.add(node.index)\n        patch.push(node)\n      }\n    }\n\n    proofs.push({\n      signer: u.signer,\n      signature: u.signature,\n      patch: u.patch\n    })\n  }\n\n  return c.encode(multiSignature, { proofs, patch })\n}\n\nfunction compareNode (a, b) {\n  if (a.index !== b.index) return false\n  if (a.size !== b.size) return false\n  return b4a.equals(a.hash, b.hash)\n}\n\nfunction compressProof (proof, nodes) {\n  return {\n    signer: proof.signer,\n    signature: proof.signature,\n    patch: proof.patch ? compressUpgrade(proof, nodes) : null\n  }\n}\n\nfunction compressUpgrade (p, nodes) {\n  const u = {\n    start: flat.rightSpan(p.nodes[p.nodes.length - 1].index) / 2 + 1,\n    length: p.patch,\n    nodes: []\n  }\n\n  for (const node of p.nodes) {\n    let present = false\n    for (let i = 0; i < nodes.length; i++) {\n      if (!compareNode(nodes[i], node)) continue\n\n      u.nodes.push(i)\n      present = true\n      break\n    }\n\n    if (present) continue\n    u.nodes.push(nodes.push(node) - 1)\n  }\n\n  return u\n}\nmodule.exports = class Mutex {\n  constructor () {\n    this.locked = false\n    this.destroyed = false\n\n    this._destroying = null\n    this._destroyError = null\n    this._queue = []\n    this._enqueue = (resolve, reject) => this._queue.push([resolve, reject])\n  }\n\n  lock () {\n    if (this.destroyed) return Promise.reject(this._destroyError || new Error('Mutex has been destroyed'))\n    if (this.locked) return new Promise(this._enqueue)\n    this.locked = true\n    return Promise.resolve()\n  }\n\n  unlock () {\n    if (!this._queue.length) {\n      this.locked = false\n      return\n    }\n    this._queue.shift()[0]()\n  }\n\n  destroy (err) {\n    if (!this._destroying) this._destroying = this.locked ? this.lock().catch(() => {}) : Promise.resolve()\n\n    this.destroyed = true\n    if (err) this._destroyError = err\n\n    if (err) {\n      while (this._queue.length) this._queue.shift()[1](err)\n    }\n\n    return this._destroying\n  }\n}\nconst cenc = require('compact-encoding')\nconst b4a = require('b4a')\nconst { crc32 } = require('crc-universal')\nconst { OPLOG_CORRUPT, OPLOG_HEADER_OVERFLOW, WRITE_FAILED } = require('hypercore-errors')\n\nmodule.exports = class Oplog {\n  constructor (storage, { pageSize = 4096, headerEncoding = cenc.raw, entryEncoding = cenc.raw, readonly = false } = {}) {\n    this.storage = storage\n    this.headerEncoding = headerEncoding\n    this.entryEncoding = entryEncoding\n    this.readonly = readonly\n    this.flushed = false\n    this.byteLength = 0\n    this.length = 0\n\n    this._headers = [1, 0]\n    this._pageSize = pageSize\n    this._entryOffset = pageSize * 2\n  }\n\n  _addHeader (state, len, headerBit, partialBit) {\n    // add the uint header (frame length and flush info)\n    state.start = state.start - len - 4\n    cenc.uint32.encode(state, (len << 2) | headerBit | partialBit)\n\n    // crc32 the length + header-bit + content and prefix it\n    state.start -= 8\n    cenc.uint32.encode(state, crc32(state.buffer.subarray(state.start + 4, state.start + 8 + len)))\n    state.start += len + 4\n  }\n\n  _decodeEntry (state, enc) {\n    if (state.end - state.start < 8) return null\n    const cksum = cenc.uint32.decode(state)\n    const l = cenc.uint32.decode(state)\n    const length = l >>> 2\n    const headerBit = l & 1\n    const partialBit = l & 2\n\n    if (state.end - state.start < length) return null\n\n    const end = state.start + length\n\n    if (crc32(state.buffer.subarray(state.start - 4, end)) !== cksum) {\n      return null\n    }\n\n    const result = { header: headerBit, partial: partialBit !== 0, byteLength: length + 8, message: null }\n\n    try {\n      result.message = enc.decode({ start: state.start, end, buffer: state.buffer })\n    } catch {\n      return null\n    }\n\n    state.start = end\n\n    return result\n  }\n\n  async open () {\n    const buffer = await this._readAll() // TODO: stream the oplog in on load maybe?\n    const state = { start: 0, end: buffer.byteLength, buffer }\n    const result = { header: null, entries: [] }\n\n    this.byteLength = 0\n    this.length = 0\n\n    const h1 = this._decodeEntry(state, this.headerEncoding)\n    state.start = this._pageSize\n\n    const h2 = this._decodeEntry(state, this.headerEncoding)\n    state.start = this._entryOffset\n\n    if (!h1 && !h2) {\n      // reset state...\n      this.flushed = false\n      this._headers[0] = 1\n      this._headers[1] = 0\n\n      if (buffer.byteLength >= this._entryOffset) {\n        throw OPLOG_CORRUPT()\n      }\n      return result\n    }\n\n    this.flushed = true\n\n    if (h1 && !h2) {\n      this._headers[0] = h1.header\n      this._headers[1] = h1.header\n    } else if (!h1 && h2) {\n      this._headers[0] = (h2.header + 1) & 1\n      this._headers[1] = h2.header\n    } else {\n      this._headers[0] = h1.header\n      this._headers[1] = h2.header\n    }\n\n    const header = (this._headers[0] + this._headers[1]) & 1\n    const decoded = []\n\n    result.header = header ? h2.message : h1.message\n\n    while (true) {\n      const entry = this._decodeEntry(state, this.entryEncoding)\n      if (!entry) break\n      if (entry.header !== header) break\n\n      decoded.push(entry)\n    }\n\n    while (decoded.length > 0 && decoded[decoded.length - 1].partial) decoded.pop()\n\n    for (const e of decoded) {\n      result.entries.push(e.message)\n      this.byteLength += e.byteLength\n      this.length++\n    }\n\n    const size = this.byteLength + this._entryOffset\n\n    if (size === buffer.byteLength) return result\n\n    await new Promise((resolve, reject) => {\n      if (this.readonly) return resolve()\n      this.storage.truncate(size, err => {\n        if (err) return reject(err)\n        resolve()\n      })\n    })\n\n    return result\n  }\n\n  _readAll () {\n    return new Promise((resolve, reject) => {\n      this.storage.open(err => {\n        if (err && err.code !== 'ENOENT') return reject(err)\n        if (err) return resolve(b4a.alloc(0))\n        this.storage.stat((err, stat) => {\n          if (err && err.code !== 'ENOENT') return reject(err)\n          this.storage.read(0, stat.size, (err, buf) => {\n            if (err) return reject(err)\n            resolve(buf)\n          })\n        })\n      })\n    })\n  }\n\n  flush (header) {\n    const state = { start: 8, end: 8, buffer: null }\n    const i = this._headers[0] === this._headers[1] ? 1 : 0\n    const bit = (this._headers[i] + 1) & 1\n\n    this.headerEncoding.preencode(state, header)\n    if (state.end > this._pageSize) throw OPLOG_HEADER_OVERFLOW()\n    state.buffer = b4a.allocUnsafe(state.end)\n    this.headerEncoding.encode(state, header)\n    this._addHeader(state, state.end - 8, bit, 0)\n\n    return this._writeHeaderAndTruncate(i, bit, state.buffer)\n  }\n\n  _writeHeaderAndTruncate (i, bit, buf) {\n    return new Promise((resolve, reject) => {\n      this.storage.write(i === 0 ? 0 : this._pageSize, buf, err => {\n        if (err) return reject(err)\n\n        this.storage.truncate(this._entryOffset, err => {\n          if (err) return reject(err)\n\n          this._headers[i] = bit\n          this.byteLength = 0\n          this.length = 0\n          this.flushed = true\n\n          resolve()\n        })\n      })\n    })\n  }\n\n  append (batch, atomic = true) {\n    if (!Array.isArray(batch)) batch = [batch]\n\n    const state = { start: 0, end: batch.length * 8, buffer: null }\n    const bit = (this._headers[0] + this._headers[1]) & 1\n\n    for (let i = 0; i < batch.length; i++) {\n      this.entryEncoding.preencode(state, batch[i])\n    }\n\n    state.buffer = b4a.allocUnsafe(state.end)\n\n    for (let i = 0; i < batch.length; i++) {\n      const start = state.start += 8 // space for header\n      const partial = (atomic && i < batch.length - 1) ? 2 : 0\n      this.entryEncoding.encode(state, batch[i])\n      this._addHeader(state, state.start - start, bit, partial)\n    }\n\n    return this._append(state.buffer, batch.length)\n  }\n\n  close () {\n    return new Promise((resolve, reject) => {\n      this.storage.close(err => {\n        if (err) return reject(err)\n        resolve()\n      })\n    })\n  }\n\n  _append (buf, count) {\n    return new Promise((resolve, reject) => {\n      this.storage.write(this._entryOffset + this.byteLength, buf, err => {\n        if (err) return reject(WRITE_FAILED(err.message))\n\n        this.byteLength += buf.byteLength\n        this.length += count\n\n        resolve()\n      })\n    })\n  }\n}\nconst FIFO = require('fast-fifo')\n\nmodule.exports = class ReceiverQueue {\n  constructor () {\n    this.queue = new FIFO()\n    this.priority = []\n    this.requests = new Map()\n    this.length = 0\n  }\n\n  push (req) {\n    // TODO: use a heap at some point if we wanna support multiple prios\n    if (req.priority > 0) this.priority.push(req)\n    else this.queue.push(req)\n\n    this.requests.set(req.id, req)\n    this.length++\n  }\n\n  shift () {\n    while (this.priority.length > 0) {\n      const msg = this.priority.pop()\n      const req = this._processRequest(msg)\n      if (req !== null) return req\n    }\n\n    while (this.queue.length > 0) {\n      const msg = this.queue.shift()\n      const req = this._processRequest(msg)\n      if (req !== null) return req\n    }\n\n    return null\n  }\n\n  _processRequest (req) {\n    if (req.block || req.hash || req.seek || req.upgrade || req.manifest) {\n      this.requests.delete(req.id)\n      this.length--\n      return req\n    }\n\n    return null\n  }\n\n  clear () {\n    this.queue.clear()\n    this.priority = []\n    this.length = 0\n    this.requests.clear()\n  }\n\n  delete (id) {\n    const req = this.requests.get(id)\n    if (!req) return\n\n    req.block = null\n    req.hash = null\n    req.seek = null\n    req.upgrade = null\n    req.manifest = false\n\n    this.requests.delete(id)\n    this.length--\n\n    if (this.length === 0) {\n      this.queue.clear()\n      this.priority = []\n    }\n  }\n}\nconst BigSparseArray = require('big-sparse-array')\nconst quickbit = require('./compat').quickbit\n\nconst BITS_PER_PAGE = 32768\nconst BYTES_PER_PAGE = BITS_PER_PAGE / 8\nconst WORDS_PER_PAGE = BYTES_PER_PAGE / 4\nconst BITS_PER_SEGMENT = 2097152\nconst BYTES_PER_SEGMENT = BITS_PER_SEGMENT / 8\nconst PAGES_PER_SEGMENT = BITS_PER_SEGMENT / BITS_PER_PAGE\n\nclass RemoteBitfieldPage {\n  constructor (index, bitfield, segment) {\n    this.index = index\n    this.offset = index * BYTES_PER_PAGE - segment.offset\n    this.bitfield = bitfield\n    this.segment = segment\n\n    segment.add(this)\n  }\n\n  get tree () {\n    return this.segment.tree\n  }\n\n  get (index) {\n    return quickbit.get(this.bitfield, index)\n  }\n\n  set (index, val) {\n    if (quickbit.set(this.bitfield, index, val)) {\n      this.tree.update(this.offset * 8 + index)\n    }\n  }\n\n  setRange (start, length, val) {\n    quickbit.fill(this.bitfield, val, start, start + length)\n\n    let i = Math.floor(start / 128)\n    const n = i + Math.ceil(length / 128)\n\n    while (i <= n) this.tree.update(this.offset * 8 + i++ * 128)\n  }\n\n  findFirst (val, position) {\n    return quickbit.findFirst(this.bitfield, val, position)\n  }\n\n  findLast (val, position) {\n    return quickbit.findLast(this.bitfield, val, position)\n  }\n\n  insert (start, bitfield) {\n    this.bitfield.set(bitfield, start / 32)\n    this.segment.refresh()\n  }\n\n  clear (start, bitfield) {\n    quickbit.clear(this.bitfield, { field: bitfield, offset: start })\n  }\n}\n\nclass RemoteBitfieldSegment {\n  constructor (index) {\n    this.index = index\n    this.offset = index * BYTES_PER_SEGMENT\n    this.tree = quickbit.Index.from([], BYTES_PER_SEGMENT)\n    this.pages = new Array(PAGES_PER_SEGMENT)\n    this.pagesLength = 0\n  }\n\n  get chunks () {\n    return this.tree.chunks\n  }\n\n  refresh () {\n    this.tree = quickbit.Index.from(this.tree.chunks, BYTES_PER_SEGMENT)\n  }\n\n  add (page) {\n    const pageIndex = page.index - this.index * PAGES_PER_SEGMENT\n    if (pageIndex >= this.pagesLength) this.pagesLength = pageIndex + 1\n\n    this.pages[pageIndex] = page\n\n    const chunk = { field: page.bitfield, offset: page.offset }\n\n    this.chunks.push(chunk)\n\n    for (let i = this.chunks.length - 2; i >= 0; i--) {\n      const prev = this.chunks[i]\n      if (prev.offset <= chunk.offset) break\n      this.chunks[i] = chunk\n      this.chunks[i + 1] = prev\n    }\n  }\n\n  findFirst (val, position) {\n    position = this.tree.skipFirst(!val, position)\n\n    let j = position & (BITS_PER_PAGE - 1)\n    let i = (position - j) / BITS_PER_PAGE\n\n    if (i >= PAGES_PER_SEGMENT) return -1\n\n    while (i < this.pagesLength) {\n      const p = this.pages[i]\n\n      let index = -1\n\n      if (p) index = p.findFirst(val, j)\n      else if (!val) index = j\n\n      if (index !== -1) return i * BITS_PER_PAGE + index\n\n      j = 0\n      i++\n    }\n\n    return (val || this.pagesLength === PAGES_PER_SEGMENT) ? -1 : this.pagesLength * BITS_PER_PAGE\n  }\n\n  findLast (val, position) {\n    position = this.tree.skipLast(!val, position)\n\n    let j = position & (BITS_PER_PAGE - 1)\n    let i = (position - j) / BITS_PER_PAGE\n\n    if (i >= PAGES_PER_SEGMENT) return -1\n\n    while (i >= 0) {\n      const p = this.pages[i]\n\n      let index = -1\n\n      if (p) index = p.findLast(val, j)\n      else if (!val) index = j\n\n      if (index !== -1) return i * BITS_PER_PAGE + index\n\n      j = BITS_PER_PAGE - 1\n      i--\n    }\n\n    return -1\n  }\n}\n\nmodule.exports = class RemoteBitfield {\n  static BITS_PER_PAGE = BITS_PER_PAGE\n\n  constructor () {\n    this._pages = new BigSparseArray()\n    this._segments = new BigSparseArray()\n    this._maxSegments = 0\n  }\n\n  getBitfield (index) {\n    const j = index & (BITS_PER_PAGE - 1)\n    const i = (index - j) / BITS_PER_PAGE\n\n    const p = this._pages.get(i)\n    return p || null\n  }\n\n  get (index) {\n    const j = index & (BITS_PER_PAGE - 1)\n    const i = (index - j) / BITS_PER_PAGE\n\n    const p = this._pages.get(i)\n\n    return p ? p.get(j) : false\n  }\n\n  set (index, val) {\n    const j = index & (BITS_PER_PAGE - 1)\n    const i = (index - j) / BITS_PER_PAGE\n\n    let p = this._pages.get(i)\n\n    if (!p && val) {\n      const k = Math.floor(i / PAGES_PER_SEGMENT)\n      const s = this._segments.get(k) || this._segments.set(k, new RemoteBitfieldSegment(k))\n      if (this._maxSegments <= k) this._maxSegments = k + 1\n\n      p = this._pages.set(i, new RemoteBitfieldPage(i, new Uint32Array(WORDS_PER_PAGE), s))\n    }\n\n    if (p) p.set(j, val)\n  }\n\n  setRange (start, length, val) {\n    let j = start & (BITS_PER_PAGE - 1)\n    let i = (start - j) / BITS_PER_PAGE\n\n    while (length > 0) {\n      let p = this._pages.get(i)\n\n      if (!p && val) {\n        const k = Math.floor(i / PAGES_PER_SEGMENT)\n        const s = this._segments.get(k) || this._segments.set(k, new RemoteBitfieldSegment(k))\n        if (this._maxSegments <= k) this._maxSegments = k + 1\n\n        p = this._pages.set(i, new RemoteBitfieldPage(i, new Uint32Array(WORDS_PER_PAGE), s))\n      }\n\n      const end = Math.min(j + length, BITS_PER_PAGE)\n      const range = end - j\n\n      if (p) p.setRange(j, range, val)\n\n      j = 0\n      i++\n      length -= range\n    }\n  }\n\n  findFirst (val, position) {\n    let j = position & (BITS_PER_SEGMENT - 1)\n    let i = (position - j) / BITS_PER_SEGMENT\n\n    while (i < this._maxSegments) {\n      const s = this._segments.get(i)\n\n      let index = -1\n\n      if (s) index = s.findFirst(val, j)\n      else if (!val) index = j\n\n      if (index !== -1) return i * BITS_PER_SEGMENT + index\n\n      j = 0\n      i++\n    }\n\n    // For the val === false case, we always return at least\n    // the 'position', also if nothing was found\n    return val\n      ? -1\n      : Math.max(position, this._maxSegments * BITS_PER_SEGMENT)\n  }\n\n  firstSet (position) {\n    return this.findFirst(true, position)\n  }\n\n  firstUnset (position) {\n    return this.findFirst(false, position)\n  }\n\n  findLast (val, position) {\n    let j = position & (BITS_PER_SEGMENT - 1)\n    let i = (position - j) / BITS_PER_SEGMENT\n\n    while (i >= 0) {\n      const s = this._segments.get(i)\n\n      let index = -1\n\n      if (s) index = s.findLast(val, j)\n      else if (!val) index = j\n\n      if (index !== -1) return i * BITS_PER_SEGMENT + index\n\n      j = BITS_PER_SEGMENT - 1\n      i--\n    }\n\n    return -1\n  }\n\n  lastSet (position) {\n    return this.findLast(true, position)\n  }\n\n  lastUnset (position) {\n    return this.findLast(false, position)\n  }\n\n  insert (start, bitfield) {\n    if (start % 32 !== 0) return false\n\n    let length = bitfield.byteLength * 8\n\n    let j = start & (BITS_PER_PAGE - 1)\n    let i = (start - j) / BITS_PER_PAGE\n\n    while (length > 0) {\n      let p = this._pages.get(i)\n\n      if (!p) {\n        const k = Math.floor(i / PAGES_PER_SEGMENT)\n        const s = this._segments.get(k) || this._segments.set(k, new RemoteBitfieldSegment(k))\n        if (this._maxSegments <= k) this._maxSegments = k + 1\n\n        p = this._pages.set(i, new RemoteBitfieldPage(i, new Uint32Array(WORDS_PER_PAGE), s))\n      }\n\n      const end = Math.min(j + length, BITS_PER_PAGE)\n      const range = end - j\n\n      p.insert(j, bitfield.subarray(0, range / 32))\n\n      bitfield = bitfield.subarray(range / 32)\n\n      j = 0\n      i++\n      length -= range\n    }\n\n    return true\n  }\n\n  clear (start, bitfield) {\n    if (start % 32 !== 0) return false\n\n    let length = bitfield.byteLength * 8\n\n    let j = start & (BITS_PER_PAGE - 1)\n    let i = (start - j) / BITS_PER_PAGE\n\n    while (length > 0) {\n      let p = this._pages.get(i)\n\n      if (!p) {\n        const k = Math.floor(i / PAGES_PER_SEGMENT)\n        const s = this._segments.get(k) || this._segments.set(k, new RemoteBitfieldSegment(k))\n        if (this._maxSegments <= k) this._maxSegments = k + 1\n\n        p = this._pages.set(i, new RemoteBitfieldPage(i, new Uint32Array(WORDS_PER_PAGE), s))\n      }\n\n      const end = Math.min(j + length, BITS_PER_PAGE)\n      const range = end - j\n\n      p.clear(j, bitfield.subarray(0, range / 32))\n\n      bitfield = bitfield.subarray(range / 32)\n\n      j = 0\n      i++\n      length -= range\n    }\n\n    return true\n  }\n}\n/* DEV DOCS\n  Every hypercore has one Replicator object managing its connections to other peers.\n  There is one Peer object per peer connected to the Hypercore.\n  Hypercores do not know about other hypercores, so when a peer is connected to multiple cores, there exists one Peer object per core.\n\n  Hypercore indicates block should be downloaded through methods like Replicator.addRange or Replicator.addBlock\n  Hypercore calls Replicator.updateActivity every time a hypercore session opens/closes\n  Replicator.updateActivity ensures the Hypercore is downloading blocks as expected\n  Replicator keeps track of:\n    - Which blocks need to be downloaded (Replicator._blocks)\n    - Which blocks currently have inflight requests (Replicator._inflight)\n\n  Blocks are requested from remote peers by Peer objects. The flow is:\n    - The replicator's updatePeer method gets called\n    - The replicator detects whether the Peer can accept more requests (for example by checking if it's maxed out on inflight blocks)\n    - The replicator then tells the Peer what to request (e.g. Peer_requestRange or Peer._requestBlock methods)\n\n  The Peer object is responsible for tracking\n    - Which blocks does the Peer have available (tracked in remoteBitfield)\n    - Which blocks are you actively looking for from this peer (tracked in missingBlocks)\n    - How many blocks are currently inflight (tracked in inflight)\n  The Peer uses this information to decide which blocks to request form the peer in response to _requestRange requests and the like.\n*/\n\nconst b4a = require('b4a')\nconst safetyCatch = require('safety-catch')\nconst RandomIterator = require('random-array-iterator')\nconst flatTree = require('flat-tree')\nconst ReceiverQueue = require('./receiver-queue')\nconst HotswapQueue = require('./hotswap-queue')\nconst RemoteBitfield = require('./remote-bitfield')\nconst { REQUEST_CANCELLED, REQUEST_TIMEOUT, INVALID_CAPABILITY, SNAPSHOT_NOT_AVAILABLE } = require('hypercore-errors')\nconst m = require('./messages')\nconst caps = require('./caps')\n\nconst DEFAULT_MAX_INFLIGHT = [16, 512]\nconst SCALE_LATENCY = 50\nconst DEFAULT_SEGMENT_SIZE = 256 * 1024 * 8 // 256 KiB in bits\nconst NOT_DOWNLOADING_SLACK = 20000 + (Math.random() * 20000) | 0\nconst MAX_PEERS_UPGRADE = 3\n\nconst MAX_RANGES = 64\n\nconst PRIORITY = {\n  NORMAL: 0,\n  HIGH: 1,\n  VERY_HIGH: 2,\n  CANCELLED: 255 // reserved to mark cancellation\n}\n\nclass Attachable {\n  constructor () {\n    this.resolved = false\n    this.refs = []\n  }\n\n  attach (session) {\n    const r = {\n      context: this,\n      session,\n      sindex: 0,\n      rindex: 0,\n      snapshot: true,\n      resolve: null,\n      reject: null,\n      promise: null,\n      timeout: null\n    }\n\n    r.sindex = session.push(r) - 1\n    r.rindex = this.refs.push(r) - 1\n    r.promise = new Promise((resolve, reject) => {\n      r.resolve = resolve\n      r.reject = reject\n    })\n\n    return r\n  }\n\n  detach (r, err = null) {\n    if (r.context !== this) return false\n\n    this._detach(r)\n    this._cancel(r, err)\n    this.gc()\n\n    return true\n  }\n\n  _detach (r) {\n    const rh = this.refs.pop()\n    const sh = r.session.pop()\n\n    if (r.rindex < this.refs.length) this.refs[rh.rindex = r.rindex] = rh\n    if (r.sindex < r.session.length) r.session[sh.sindex = r.sindex] = sh\n\n    destroyRequestTimeout(r)\n    r.context = null\n\n    return r\n  }\n\n  gc () {\n    if (this.refs.length === 0) this._unref()\n  }\n\n  _cancel (r, err) {\n    r.reject(err || REQUEST_CANCELLED())\n  }\n\n  _unref () {\n    // overwrite me\n  }\n\n  resolve (val) {\n    this.resolved = true\n    while (this.refs.length > 0) {\n      this._detach(this.refs[this.refs.length - 1]).resolve(val)\n    }\n  }\n\n  reject (err) {\n    this.resolved = true\n    while (this.refs.length > 0) {\n      this._detach(this.refs[this.refs.length - 1]).reject(err)\n    }\n  }\n\n  setTimeout (r, ms) {\n    destroyRequestTimeout(r)\n    r.timeout = setTimeout(onrequesttimeout, ms, r)\n  }\n}\n\nclass BlockRequest extends Attachable {\n  constructor (tracker, index, priority) {\n    super()\n\n    this.index = index\n    this.priority = priority\n    this.inflight = []\n    this.queued = false\n    this.hotswap = null\n    this.tracker = tracker\n  }\n\n  _unref () {\n    this.queued = false\n\n    for (const req of this.inflight) {\n      req.peer._cancelRequest(req)\n    }\n\n    this.tracker.remove(this.index)\n    removeHotswap(this)\n  }\n}\n\nclass RangeRequest extends Attachable {\n  constructor (ranges, start, end, linear, ifAvailable, blocks) {\n    super()\n\n    this.start = start\n    this.end = end\n    this.linear = linear\n    this.ifAvailable = ifAvailable\n    this.blocks = blocks\n    this.ranges = ranges\n\n    // As passed by the user, immut\n    this.userStart = start\n    this.userEnd = end\n  }\n\n  _unref () {\n    const i = this.ranges.indexOf(this)\n    if (i === -1) return\n    const h = this.ranges.pop()\n    if (i < this.ranges.length) this.ranges[i] = h\n  }\n\n  _cancel (r) {\n    r.resolve(false)\n  }\n}\n\nclass UpgradeRequest extends Attachable {\n  constructor (replicator, fork, length) {\n    super()\n\n    this.fork = fork\n    this.length = length\n    this.inflight = []\n    this.replicator = replicator\n  }\n\n  _unref () {\n    if (this.replicator.eagerUpgrade === true || this.inflight.length > 0) return\n    this.replicator._upgrade = null\n  }\n\n  _cancel (r) {\n    r.resolve(false)\n  }\n}\n\nclass SeekRequest extends Attachable {\n  constructor (seeks, seeker) {\n    super()\n\n    this.seeker = seeker\n    this.inflight = []\n    this.seeks = seeks\n  }\n\n  _unref () {\n    if (this.inflight.length > 0) return\n    const i = this.seeks.indexOf(this)\n    if (i === -1) return\n    const h = this.seeks.pop()\n    if (i < this.seeks.length) this.seeks[i] = h\n  }\n}\n\nclass InflightTracker {\n  constructor () {\n    this._requests = []\n    this._free = []\n  }\n\n  get idle () {\n    return this._requests.length === this._free.length\n  }\n\n  * [Symbol.iterator] () {\n    for (const req of this._requests) {\n      if (req !== null) yield req\n    }\n  }\n\n  add (req) {\n    const id = this._free.length ? this._free.pop() : this._requests.push(null)\n    req.id = id\n    this._requests[id - 1] = req\n    return req\n  }\n\n  get (id) {\n    return id <= this._requests.length ? this._requests[id - 1] : null\n  }\n\n  remove (id, roundtrip) {\n    if (id > this._requests.length) return\n    this._requests[id - 1] = null\n    if (roundtrip === true) this._free.push(id)\n  }\n\n  reusable (id) {\n    this._free.push(id)\n  }\n}\n\nclass BlockTracker {\n  constructor () {\n    this._map = new Map()\n  }\n\n  [Symbol.iterator] () {\n    return this._map.values()\n  }\n\n  isEmpty () {\n    return this._map.size === 0\n  }\n\n  has (index) {\n    return this._map.has(index)\n  }\n\n  get (index) {\n    return this._map.get(index) || null\n  }\n\n  add (index, priority) {\n    let b = this._map.get(index)\n    if (b) return b\n\n    b = new BlockRequest(this, index, priority)\n    this._map.set(index, b)\n\n    return b\n  }\n\n  remove (index) {\n    const b = this.get(index)\n    this._map.delete(index)\n    return b\n  }\n}\n\nclass RoundtripQueue {\n  constructor () {\n    this.queue = []\n    this.tick = 0\n  }\n\n  clear () {\n    const ids = new Array(this.queue.length)\n    for (let i = 0; i < ids.length; i++) {\n      ids[i] = this.queue[i][1]\n    }\n\n    this.queue = []\n\n    return ids\n  }\n\n  add (id) {\n    this.queue.push([++this.tick, id])\n  }\n\n  flush (tick) {\n    let flushed = null\n\n    for (let i = 0; i < this.queue.length; i++) {\n      if (this.queue[i][0] > tick) break\n      if (flushed === null) flushed = []\n      flushed.push(this.queue[i][1])\n    }\n\n    if (flushed !== null) this.queue.splice(0, flushed.length)\n    return flushed\n  }\n}\n\nclass Peer {\n  constructor (replicator, protomux, channel, useSession, inflightRange) {\n    this.core = replicator.core\n    this.replicator = replicator\n    this.stream = protomux.stream\n    this.protomux = protomux\n    this.remotePublicKey = this.stream.remotePublicKey\n    this.remoteSupportsSeeks = false\n    this.inflightRange = inflightRange\n\n    this.paused = false\n    this.removed = false\n\n    this.useSession = useSession\n\n    this.channel = channel\n    this.channel.userData = this\n\n    this.wireSync = this.channel.messages[0]\n    this.wireRequest = this.channel.messages[1]\n    this.wireCancel = this.channel.messages[2]\n    this.wireData = this.channel.messages[3]\n    this.wireNoData = this.channel.messages[4]\n    this.wireWant = this.channel.messages[5]\n    this.wireUnwant = this.channel.messages[6]\n    this.wireBitfield = this.channel.messages[7]\n    this.wireRange = this.channel.messages[8]\n    this.wireExtension = this.channel.messages[9]\n\n    // Same stats as replicator, but for this specific peer\n    this.stats = {\n      wireSync: { tx: 0, rx: 0 },\n      wireRequest: { tx: 0, rx: 0 },\n      wireCancel: { tx: 0, rx: 0 },\n      wireData: { tx: 0, rx: 0 },\n      wireWant: { tx: 0, rx: 0 },\n      wireBitfield: { tx: 0, rx: 0 },\n      wireRange: { tx: 0, rx: 0 },\n      wireExtension: { tx: 0, rx: 0 },\n      hotswaps: 0\n    }\n\n    this.receiverQueue = new ReceiverQueue()\n    this.receiverBusy = false\n\n    // most often not used, so made on demand\n    this.roundtripQueue = null\n\n    this.inflight = 0\n    this.dataProcessing = 0\n\n    this.canUpgrade = true\n\n    this.needsSync = false\n    this.syncsProcessing = 0\n\n    this._remoteContiguousLength = 0\n\n    // TODO: tweak pipelining so that data sent BEFORE remoteOpened is not cap verified!\n    // we might wanna tweak that with some crypto, ie use the cap to encrypt it...\n    // or just be aware of that, to only push non leaky data\n\n    this.remoteOpened = false\n    this.remoteBitfield = new RemoteBitfield()\n    this.missingBlocks = new RemoteBitfield()\n\n    this.remoteFork = 0\n    this.remoteLength = 0\n    this.remoteCanUpgrade = false\n    this.remoteUploading = true\n    this.remoteDownloading = true\n    this.remoteSynced = false\n    this.remoteHasManifest = false\n    this.remoteRequests = new Map()\n\n    this.segmentsWanted = new Set()\n    this.broadcastedNonSparse = false\n\n    this.lengthAcked = 0\n\n    this.extensions = new Map()\n    this.lastExtensionSent = ''\n    this.lastExtensionRecv = ''\n\n    replicator._ifAvailable++\n  }\n\n  get remoteContiguousLength () {\n    return this.remoteBitfield.findFirst(false, this._remoteContiguousLength)\n  }\n\n  getMaxInflight () {\n    const stream = this.stream.rawStream\n    if (!stream.udx) return Math.min(this.inflightRange[1], this.inflightRange[0] * 3)\n\n    const scale = stream.rtt <= SCALE_LATENCY ? 1 : stream.rtt / SCALE_LATENCY * Math.min(1, 2 / this.replicator.peers.length)\n    return Math.max(this.inflightRange[0], Math.round(Math.min(this.inflightRange[1], this.inflightRange[0] * scale)))\n  }\n\n  getMaxHotswapInflight () {\n    const inf = this.getMaxInflight()\n    return Math.max(16, inf / 2)\n  }\n\n  signalUpgrade () {\n    if (this._shouldUpdateCanUpgrade() === true) this._updateCanUpgradeAndSync()\n    else this.sendSync()\n  }\n\n  _markInflight (index) {\n    this.missingBlocks.set(index, false)\n  }\n\n  broadcastRange (start, length, drop) {\n    if (drop) this._unclearLocalRange(start, length)\n    else this._clearLocalRange(start, length)\n\n    // TODO: consider also adding early-returns on the drop===true case\n    if (!drop) {\n      // No need to broadcast if the remote already has this range\n\n      if (this._remoteContiguousLength >= start + length) return\n\n      if (length === 1) {\n        if (this.remoteBitfield.get(start)) return\n      } else {\n        if (this.remoteBitfield.firstUnset(start) >= start + length) return\n      }\n    }\n\n    this.wireRange.send({\n      drop,\n      start,\n      length\n    })\n    incrementTx(this.stats.wireRange, this.replicator.stats.wireRange)\n  }\n\n  extension (name, message) {\n    this.wireExtension.send({ name: name === this.lastExtensionSent ? '' : name, message })\n    incrementTx(this.stats.wireExtension, this.replicator.stats.wireExtension)\n    this.lastExtensionSent = name\n  }\n\n  onextension (message) {\n    const name = message.name || this.lastExtensionRecv\n    this.lastExtensionRecv = name\n    const ext = this.extensions.get(name)\n    if (ext) ext._onmessage({ start: 0, end: message.message.byteLength, buffer: message.message }, this)\n  }\n\n  sendSync () {\n    if (this.syncsProcessing !== 0) {\n      this.needsSync = true\n      return\n    }\n\n    if (this.core.tree.fork !== this.remoteFork) {\n      this.canUpgrade = false\n    }\n\n    this.needsSync = false\n\n    this.wireSync.send({\n      fork: this.core.tree.fork,\n      length: this.core.tree.length,\n      remoteLength: this.core.tree.fork === this.remoteFork ? this.remoteLength : 0,\n      canUpgrade: this.canUpgrade,\n      uploading: true,\n      downloading: this.replicator.isDownloading(),\n      hasManifest: !!this.core.header.manifest && this.core.compat === false\n    })\n    incrementTx(this.stats.wireSync, this.replicator.stats.wireSync)\n  }\n\n  onopen ({ seeks, capability }) {\n    const expected = caps.replicate(this.stream.isInitiator === false, this.replicator.key, this.stream.handshakeHash)\n\n    if (b4a.equals(capability, expected) !== true) { // TODO: change this to a rejection instead, less leakage\n      throw INVALID_CAPABILITY('Remote sent an invalid replication capability')\n    }\n\n    if (this.remoteOpened === true) return\n    this.remoteOpened = true\n    this.remoteSupportsSeeks = seeks\n\n    this.protomux.cork()\n\n    this.sendSync()\n\n    const contig = Math.min(this.core.tree.length, this.core.header.hints.contiguousLength)\n    if (contig > 0) {\n      this.broadcastRange(0, contig, false)\n\n      if (contig === this.core.tree.length) {\n        this.broadcastedNonSparse = true\n      }\n    }\n\n    this.replicator._ifAvailable--\n    this.replicator._addPeer(this)\n\n    this.protomux.uncork()\n  }\n\n  onclose (isRemote) {\n    // we might have signalled to the remote that we are done (ie not downloading) and the remote might agree on that\n    // if that happens, the channel might be closed by the remote. if so just renegotiate it.\n    // TODO: add a CLOSE_REASON to mux to we can make this cleaner...\n    const reopen = isRemote === true && this.remoteOpened === true && this.remoteDownloading === false &&\n       this.remoteUploading === true && this.replicator.downloading === true\n\n    if (this.remoteOpened === false) {\n      if (this.useSession) {\n        this.replicator._peerSessions--\n        this.replicator._closeSessionMaybe()\n      }\n      this.replicator._ifAvailable--\n      this.replicator.updateAll()\n      return\n    }\n\n    this.remoteOpened = false\n    this.removed = true\n    this.remoteRequests.clear() // cancel all\n    this.receiverQueue.clear()\n\n    if (this.roundtripQueue !== null) {\n      for (const id of this.roundtripQueue.clear()) this.replicator._inflight.reusable(id)\n    }\n\n    this.replicator._removePeer(this)\n\n    if (reopen) {\n      this.replicator._makePeer(this.protomux, this.useSession)\n    }\n\n    if (this.useSession) {\n      this.replicator._peerSessions--\n      this.replicator._closeSessionMaybe()\n    }\n  }\n\n  closeIfIdle () {\n    if (this.remoteDownloading === false && this.replicator.isDownloading() === false) {\n      // idling, shut it down...\n      this.channel.close()\n      return true\n    }\n\n    return false\n  }\n\n  async onsync ({ fork, length, remoteLength, canUpgrade, uploading, downloading, hasManifest }) {\n    const lengthChanged = length !== this.remoteLength\n    const sameFork = fork === this.core.tree.fork\n\n    this.remoteSynced = true\n    this.remoteFork = fork\n    this.remoteLength = length\n    this.remoteCanUpgrade = canUpgrade\n    this.remoteUploading = uploading\n    this.remoteDownloading = downloading\n    this.remoteHasManifest = hasManifest\n\n    if (this.closeIfIdle()) return\n\n    this.lengthAcked = sameFork ? remoteLength : 0\n    this.syncsProcessing++\n\n    this.replicator._updateFork(this)\n\n    if (this.remoteLength > this.core.tree.length && this.lengthAcked === this.core.tree.length) {\n      if (this.replicator._addUpgradeMaybe() !== null) this._update()\n    }\n\n    const upgrade = (lengthChanged === false || sameFork === false)\n      ? this.canUpgrade && sameFork\n      : await this._canUpgrade(length, fork)\n\n    if (length === this.remoteLength && fork === this.core.tree.fork) {\n      this.canUpgrade = upgrade\n    }\n\n    if (--this.syncsProcessing !== 0) return // ie not latest\n\n    if (this.needsSync === true || (this.core.tree.fork === this.remoteFork && this.core.tree.length > this.remoteLength)) {\n      this.signalUpgrade()\n    }\n\n    this._update()\n  }\n\n  _shouldUpdateCanUpgrade () {\n    return this.core.tree.fork === this.remoteFork &&\n      this.core.tree.length > this.remoteLength &&\n      this.canUpgrade === false &&\n      this.syncsProcessing === 0\n  }\n\n  async _updateCanUpgradeAndSync () {\n    const { length, fork } = this.core.tree\n\n    const canUpgrade = await this._canUpgrade(this.remoteLength, this.remoteFork)\n\n    if (this.syncsProcessing > 0 || length !== this.core.tree.length || fork !== this.core.tree.fork) {\n      return\n    }\n    if (canUpgrade === this.canUpgrade) {\n      return\n    }\n\n    this.canUpgrade = canUpgrade\n    this.sendSync()\n  }\n\n  // Safe to call in the background - never fails\n  async _canUpgrade (remoteLength, remoteFork) {\n    if (remoteFork !== this.core.tree.fork) return false\n\n    if (remoteLength === 0) return true\n    if (remoteLength >= this.core.tree.length) return false\n\n    try {\n      // Rely on caching to make sure this is cheap...\n      const canUpgrade = await this.core.tree.upgradeable(remoteLength)\n\n      if (remoteFork !== this.core.tree.fork) return false\n\n      return canUpgrade\n    } catch {\n      return false\n    }\n  }\n\n  async _getProof (msg) {\n    const proof = await this.core.tree.proof(msg)\n\n    if (proof.block) {\n      const index = msg.block.index\n\n      if (msg.fork !== this.core.tree.fork || !this.core.bitfield.get(index)) {\n        return null\n      }\n\n      proof.block.value = await this.core.blocks.get(index)\n    }\n\n    if (msg.manifest && !this.core.compat) {\n      proof.manifest = this.core.header.manifest\n    }\n\n    return proof\n  }\n\n  async onrequest (msg) {\n    const size = this.remoteRequests.size\n    this.remoteRequests.set(msg.id, msg)\n\n    // if size didnt change -> id overwrite -> old one is deleted, cancel current and re-add\n    if (size === this.remoteRequests.size) {\n      this._cancel(msg.id)\n      this.remoteRequests.set(msg.id, msg)\n    }\n\n    if (!this.protomux.drained || this.receiverQueue.length) {\n      this.receiverQueue.push(msg)\n      return\n    }\n\n    await this._handleRequest(msg)\n  }\n\n  oncancel (msg) {\n    this._cancel(msg.request)\n  }\n\n  _cancel (id) {\n    this.remoteRequests.delete(id)\n    this.receiverQueue.delete(id)\n  }\n\n  ondrain () {\n    return this._handleRequests()\n  }\n\n  async _handleRequests () {\n    if (this.receiverBusy) return\n    this.receiverBusy = true\n    this.protomux.cork()\n\n    while (this.remoteOpened && this.protomux.drained && this.receiverQueue.length > 0 && !this.removed) {\n      const msg = this.receiverQueue.shift()\n      await this._handleRequest(msg)\n    }\n\n    this.protomux.uncork()\n    this.receiverBusy = false\n  }\n\n  async _handleRequest (msg) {\n    let proof = null\n\n    // TODO: could still be answerable if (index, fork) is an ancestor of the current fork\n    if (msg.fork === this.core.tree.fork) {\n      try {\n        proof = await this._getProof(msg)\n      } catch (err) {\n        safetyCatch(err)\n        if (msg.fork === this.core.tree.fork && isCriticalError(err)) throw err\n      }\n    }\n\n    // if cancelled do not reply\n    if (this.remoteRequests.get(msg.id) !== msg) {\n      return\n    }\n\n    // sync from now on, so safe to delete from the map\n    this.remoteRequests.delete(msg.id)\n\n    if (proof === null) {\n      if (msg.manifest && this.core.header.manifest) {\n        const manifest = this.core.header.manifest\n        this.wireData.send({ request: msg.id, fork: this.core.tree.fork, block: null, hash: null, seek: null, upgrade: null, manifest })\n        incrementTx(this.stats.wireData, this.replicator.stats.wireData)\n        return\n      }\n\n      this.wireNoData.send({ request: msg.id })\n      return\n    }\n\n    if (proof.block !== null) {\n      this.replicator.onupload(proof.block.index, proof.block.value, this)\n    }\n\n    this.wireData.send({\n      request: msg.id,\n      fork: msg.fork,\n      block: proof.block,\n      hash: proof.hash,\n      seek: proof.seek,\n      upgrade: proof.upgrade,\n      manifest: proof.manifest\n    })\n    incrementTx(this.stats.wireData, this.replicator.stats.wireData)\n  }\n\n  _cancelRequest (req) {\n    if (req.priority === PRIORITY.CANCELLED) return\n    // mark as cancelled also and avoid re-entry\n    req.priority = PRIORITY.CANCELLED\n\n    this.inflight--\n    this.replicator._requestDone(req.id, false)\n\n    // clear inflight state\n    if (isBlockRequest(req)) this.replicator._unmarkInflight(req.block.index)\n    if (isUpgradeRequest(req)) this.replicator._clearInflightUpgrade(req)\n\n    if (this.roundtripQueue === null) this.roundtripQueue = new RoundtripQueue()\n    this.roundtripQueue.add(req.id)\n    this.wireCancel.send({ request: req.id })\n    incrementTx(this.stats.wireCancel, this.replicator.stats.wireCancel)\n  }\n\n  _checkIfConflict () {\n    this.paused = true\n\n    const length = Math.min(this.core.tree.length, this.remoteLength)\n    if (length === 0) return // pause and ignore\n\n    this.wireRequest.send({\n      id: 0, // TODO: use an more explicit id for this eventually...\n      fork: this.remoteFork,\n      block: null,\n      hash: null,\n      seek: null,\n      upgrade: {\n        start: 0,\n        length\n      }\n    })\n\n    incrementTx(this.stats.wireRequest, this.replicator.stats.wireRequest)\n  }\n\n  async ondata (data) {\n    // always allow a fork conflict proof to be sent\n    if (data.request === 0 && data.upgrade && data.upgrade.start === 0) {\n      if (await this.core.checkConflict(data, this)) return\n      this.paused = false\n    }\n\n    const req = data.request > 0 ? this.replicator._inflight.get(data.request) : null\n    const reorg = data.fork > this.core.tree.fork\n\n    // no push atm, TODO: check if this satisfies another pending request\n    // allow reorg pushes tho as those are not written to storage so we'll take all the help we can get\n    if (req === null && reorg === false) return\n\n    if (req !== null) {\n      if (req.peer !== this) return\n      this._onrequestroundtrip(req)\n    }\n\n    try {\n      if (reorg === true) return await this.replicator._onreorgdata(this, req, data)\n    } catch (err) {\n      safetyCatch(err)\n      if (isBlockRequest(req)) this.replicator._unmarkInflight(req.block.index)\n\n      this.paused = true\n      this.replicator.oninvalid(err, req, data, this)\n      return\n    }\n\n    this.dataProcessing++\n\n    try {\n      if (!matchingRequest(req, data) || !(await this.core.verify(data, this))) {\n        this.replicator._onnodata(this, req)\n        return\n      }\n    } catch (err) {\n      safetyCatch(err)\n      if (isBlockRequest(req)) this.replicator._unmarkInflight(req.block.index)\n\n      if (err.code === 'WRITE_FAILED') {\n        // For example, we don't want to keep pulling data when storage is full\n        // TODO: notify the user somehow\n        this.paused = true\n        return\n      }\n\n      if (this.core.closed && !isCriticalError(err)) return\n\n      if (err.code !== 'INVALID_OPERATION') {\n        // might be a fork, verify\n        this._checkIfConflict()\n      }\n\n      this.replicator._onnodata(this, req)\n      this.replicator.oninvalid(err, req, data, this)\n      return\n    } finally {\n      this.dataProcessing--\n    }\n\n    this.replicator._ondata(this, req, data)\n\n    if (this._shouldUpdateCanUpgrade() === true) {\n      this._updateCanUpgradeAndSync()\n    }\n  }\n\n  onnodata ({ request }) {\n    const req = request > 0 ? this.replicator._inflight.get(request) : null\n\n    if (req === null || req.peer !== this) return\n\n    this._onrequestroundtrip(req)\n    this.replicator._onnodata(this, req)\n  }\n\n  _onrequestroundtrip (req) {\n    if (req.priority === PRIORITY.CANCELLED) return\n    // to avoid re-entry we also just mark it as cancelled\n    req.priority = PRIORITY.CANCELLED\n\n    this.inflight--\n    this.replicator._requestDone(req.id, true)\n    if (this.roundtripQueue === null) return\n    const flushed = this.roundtripQueue.flush(req.rt)\n    if (flushed === null) return\n    for (const id of flushed) this.replicator._inflight.reusable(id)\n  }\n\n  onwant ({ start, length }) {\n    this.replicator._onwant(this, start, length)\n  }\n\n  onunwant () {\n    // TODO\n  }\n\n  onbitfield ({ start, bitfield }) {\n    if (start < this._remoteContiguousLength) this._remoteContiguousLength = start // bitfield is always the truth\n    this.remoteBitfield.insert(start, bitfield)\n    this.missingBlocks.insert(start, bitfield)\n    this._clearLocalRange(start, bitfield.byteLength * 8)\n    this._update()\n  }\n\n  _clearLocalRange (start, length) {\n    const bitfield = this.core.skipBitfield === null ? this.core.bitfield : this.core.skipBitfield\n\n    if (length === 1) {\n      this.missingBlocks.set(start, this._remoteHasBlock(start) && !bitfield.get(start))\n      return\n    }\n\n    const contig = Math.min(this.core.tree.length, this.core.header.hints.contiguousLength)\n\n    if (start + length < contig) {\n      const delta = contig - start\n      this.missingBlocks.setRange(start, delta, false)\n      return\n    }\n\n    const rem = start & 32767\n    if (rem > 0) {\n      start -= rem\n      length += rem\n    }\n\n    const end = start + Math.min(length, this.core.tree.length)\n    while (start < end) {\n      const local = bitfield.getBitfield(start)\n\n      if (local && local.bitfield) {\n        this.missingBlocks.clear(start, local.bitfield)\n      }\n\n      start += 32768\n    }\n  }\n\n  _resetMissingBlock (index) {\n    const bitfield = this.core.skipBitfield === null ? this.core.bitfield : this.core.skipBitfield\n    this.missingBlocks.set(index, this._remoteHasBlock(index) && !bitfield.get(index))\n  }\n\n  _unclearLocalRange (start, length) {\n    if (length === 1) {\n      this._resetMissingBlock(start)\n      return\n    }\n\n    const rem = start & 2097151\n    if (rem > 0) {\n      start -= rem\n      length += rem\n    }\n\n    const fixedStart = start\n\n    const end = start + Math.min(length, this.remoteLength)\n    while (start < end) {\n      const remote = this.remoteBitfield.getBitfield(start)\n      if (remote && remote.bitfield) {\n        this.missingBlocks.insert(start, remote.bitfield)\n      }\n\n      start += 2097152\n    }\n\n    this._clearLocalRange(fixedStart, length)\n  }\n\n  onrange ({ drop, start, length }) {\n    const has = drop === false\n\n    if (drop === true && start < this._remoteContiguousLength) {\n      this._remoteContiguousLength = start\n    }\n\n    if (start === 0 && drop === false) {\n      if (length > this._remoteContiguousLength) this._remoteContiguousLength = length\n    } else if (length === 1) {\n      const bitfield = this.core.skipBitfield === null ? this.core.bitfield : this.core.skipBitfield\n      this.remoteBitfield.set(start, has)\n      this.missingBlocks.set(start, has && !bitfield.get(start))\n    } else {\n      const rangeStart = this.remoteBitfield.findFirst(!has, start)\n      const rangeLength = length - (rangeStart - start)\n\n      if (rangeLength > 0) {\n        this.remoteBitfield.setRange(rangeStart, rangeLength, has)\n        this.missingBlocks.setRange(rangeStart, rangeLength, has)\n        if (has) this._clearLocalRange(rangeStart, rangeLength)\n      }\n    }\n\n    if (drop === false) this._update()\n  }\n\n  onreorghint () {\n    // TODO\n  }\n\n  _update () {\n    // TODO: if this is in a batch or similar it would be better to defer it\n    // we could do that with nextTick/microtick mb? (combined with a property on the session to signal read buffer mb)\n    this.replicator.updatePeer(this)\n  }\n\n  async _onconflict () {\n    this.protomux.cork()\n    if (this.remoteLength > 0 && this.core.tree.fork === this.remoteFork) {\n      await this.onrequest({\n        id: 0,\n        fork: this.core.tree.fork,\n        block: null,\n        hash: null,\n        seek: null,\n        upgrade: {\n          start: 0,\n          length: Math.min(this.core.tree.length, this.remoteLength)\n        }\n      })\n    }\n    this.channel.close()\n    this.protomux.uncork()\n  }\n\n  _makeRequest (needsUpgrade, priority, minLength) {\n    if (needsUpgrade === true && this.replicator._shouldUpgrade(this) === false) {\n      return null\n    }\n\n    // ensure that the remote has signalled they have the length we request\n    if (this.remoteLength < minLength) {\n      return null\n    }\n\n    if (needsUpgrade === false && this.replicator._autoUpgrade(this) === true) {\n      needsUpgrade = true\n    }\n\n    return {\n      peer: this,\n      rt: this.roundtripQueue === null ? 0 : this.roundtripQueue.tick,\n      id: 0,\n      fork: this.remoteFork,\n      block: null,\n      hash: null,\n      seek: null,\n      upgrade: needsUpgrade === false\n        ? null\n        : { start: this.core.tree.length, length: this.remoteLength - this.core.tree.length },\n      // remote manifest check can be removed eventually...\n      manifest: this.core.header.manifest === null && this.remoteHasManifest === true,\n      priority\n    }\n  }\n\n  _requestManifest () {\n    const req = this._makeRequest(false, 0, 0)\n    this._send(req)\n  }\n\n  _requestUpgrade (u) {\n    const req = this._makeRequest(true, 0, 0)\n    if (req === null) return false\n\n    this._send(req)\n\n    return true\n  }\n\n  _requestSeek (s) {\n    // if replicator is updating the seeks etc, bail and wait for it to drain\n    if (this.replicator._updatesPending > 0) return false\n\n    const { length, fork } = this.core.tree\n\n    if (fork !== this.remoteFork) return false\n\n    if (s.seeker.start >= length) {\n      const req = this._makeRequest(true, 0, 0)\n\n      // We need an upgrade for the seek, if non can be provided, skip\n      if (req === null) return false\n\n      req.seek = this.remoteSupportsSeeks ? { bytes: s.seeker.bytes, padding: s.seeker.padding } : null\n\n      s.inflight.push(req)\n      this._send(req)\n\n      return true\n    }\n\n    const len = s.seeker.end - s.seeker.start\n    const off = s.seeker.start + Math.floor(Math.random() * len)\n\n    for (let i = 0; i < len; i++) {\n      let index = off + i\n      if (index > s.seeker.end) index -= len\n\n      if (this._remoteHasBlock(index) === false) continue\n      if (this.core.bitfield.get(index) === true) continue\n      if (!this._hasTreeParent(index)) continue\n\n      // Check if this block is currently inflight - if so pick another\n      const b = this.replicator._blocks.get(index)\n      if (b !== null && b.inflight.length > 0) continue\n\n      // Block is not inflight, but we only want the hash, check if that is inflight\n      const h = this.replicator._hashes.add(index, PRIORITY.NORMAL)\n      if (h.inflight.length > 0) continue\n\n      const req = this._makeRequest(false, h.priority, index + 1)\n      if (req === null) continue\n\n      const nodes = flatTree.depth(s.seeker.start + s.seeker.end - 1)\n\n      req.hash = { index: 2 * index, nodes }\n      req.seek = this.remoteSupportsSeeks ? { bytes: s.seeker.bytes, padding: s.seeker.padding } : null\n\n      s.inflight.push(req)\n      h.inflight.push(req)\n      this._send(req)\n\n      return true\n    }\n\n    this._maybeWant(s.seeker.start, len)\n    return false\n  }\n\n  _hasTreeParent (index) {\n    if (this.remoteLength >= this.core.tree.length) return true\n\n    const ite = flatTree.iterator(index * 2)\n\n    let span = 2\n    let length = 0\n\n    while (true) {\n      ite.parent()\n\n      const left = (ite.index - ite.factor / 2 + 1) / 2\n      length = left + span\n\n      // if larger than local AND larger than remote - they share the root so its ok\n      if (length > this.core.tree.length) {\n        if (length > this.remoteLength) return true\n        break\n      }\n\n      // its less than local but larger than remote so skip it\n      if (length > this.remoteLength) break\n\n      span *= 2\n      const first = this.core.bitfield.findFirst(true, left)\n      if (first > -1 && first < length) return true\n    }\n\n    // TODO: push to async queue and check against our local merkle tree if we actually can request this block\n    return false\n  }\n\n  _remoteHasBlock (index) {\n    return index < this._remoteContiguousLength || this.remoteBitfield.get(index) === true\n  }\n\n  _sendBlockRequest (req, b) {\n    req.block = { index: b.index, nodes: 0 }\n    this.replicator._markInflight(b.index)\n\n    b.inflight.push(req)\n    this.replicator.hotswaps.add(b)\n    this._send(req)\n  }\n\n  _requestBlock (b) {\n    const { length, fork } = this.core.tree\n\n    if (this._remoteHasBlock(b.index) === false || fork !== this.remoteFork) {\n      this._maybeWant(b.index)\n      return false\n    }\n\n    if (!this._hasTreeParent(b.index)) {\n      return false\n    }\n\n    const req = this._makeRequest(b.index >= length, b.priority, b.index + 1)\n    if (req === null) return false\n\n    this._sendBlockRequest(req, b)\n\n    return true\n  }\n\n  _requestRangeBlock (index, length) {\n    if (this.core.bitfield.get(index) === true || !this._hasTreeParent(index)) return false\n\n    const b = this.replicator._blocks.add(index, PRIORITY.NORMAL)\n    if (b.inflight.length > 0) {\n      this.missingBlocks.set(index, false) // in case we missed some states just set them ondemand, nbd\n      return false\n    }\n\n    const req = this._makeRequest(index >= length, b.priority, index + 1)\n\n    // If the request cannot be satisfied, dealloc the block request if no one is subscribed to it\n    if (req === null) {\n      b.gc()\n      return false\n    }\n\n    this._sendBlockRequest(req, b)\n\n    // Don't think this will ever happen, as the pending queue is drained before the range queue\n    // but doesn't hurt to check this explicitly here also.\n    if (b.queued) b.queued = false\n    return true\n  }\n\n  _findNext (i) {\n    if (i < this._remoteContiguousLength) {\n      if (this.core.skipBitfield === null) this.replicator._openSkipBitfield()\n      i = this.core.skipBitfield.findFirst(false, i)\n      if (i < this._remoteContiguousLength && i > -1) return i\n      i = this._remoteContiguousLength\n    }\n\n    return this.missingBlocks.findFirst(true, i)\n  }\n\n  _requestRange (r) {\n    const { length, fork } = this.core.tree\n\n    if (r.blocks) {\n      let min = -1\n      let max = -1\n\n      for (let i = r.start; i < r.end; i++) {\n        const index = r.blocks[i]\n        if (min === -1 || index < min) min = index\n        if (max === -1 || index > max) max = index\n        const has = index < this._remoteContiguousLength || this.missingBlocks.get(index) === true\n        if (has === true && this._requestRangeBlock(index, length)) return true\n      }\n\n      if (min > -1) this._maybeWant(min, max - min)\n      return false\n    }\n\n    const end = Math.min(this.core.tree.length, Math.min(r.end === -1 ? this.remoteLength : r.end, this.remoteLength))\n    if (end <= r.start || fork !== this.remoteFork) return false\n\n    const len = end - r.start\n    const off = r.start + (r.linear ? 0 : Math.floor(Math.random() * len))\n\n    let i = off\n\n    while (true) {\n      i = this._findNext(i)\n      if (i === -1 || i >= end) break\n\n      if (this._requestRangeBlock(i, length)) return true\n      i++\n    }\n\n    i = r.start\n\n    while (true) {\n      i = this._findNext(i)\n      if (i === -1 || i >= off) break\n\n      if (this._requestRangeBlock(i, length)) return true\n      i++\n    }\n\n    this._maybeWant(r.start, len)\n    return false\n  }\n\n  _requestForkProof (f) {\n    const req = this._makeRequest(false, 0, 0)\n\n    req.upgrade = { start: 0, length: this.remoteLength }\n    req.manifest = !this.core.header.manifest\n\n    f.inflight.push(req)\n    this._send(req)\n  }\n\n  _requestForkRange (f) {\n    if (f.fork !== this.remoteFork || f.batch.want === null) return false\n\n    const end = Math.min(f.batch.want.end, this.remoteLength)\n    if (end < f.batch.want.start) return false\n\n    const len = end - f.batch.want.start\n    const off = f.batch.want.start + Math.floor(Math.random() * len)\n\n    for (let i = 0; i < len; i++) {\n      let index = off + i\n      if (index >= end) index -= len\n\n      if (this._remoteHasBlock(index) === false) continue\n\n      const req = this._makeRequest(false, 0, 0)\n\n      req.hash = { index: 2 * index, nodes: f.batch.want.nodes }\n\n      f.inflight.push(req)\n      this._send(req)\n\n      return true\n    }\n\n    this._maybeWant(f.batch.want.start, len)\n    return false\n  }\n\n  _maybeWant (start, length = 1) {\n    if (start + length <= this.remoteContiguousLength) return\n\n    let i = Math.floor(start / DEFAULT_SEGMENT_SIZE)\n    const n = Math.ceil((start + length) / DEFAULT_SEGMENT_SIZE)\n\n    for (; i < n; i++) {\n      if (this.segmentsWanted.has(i)) continue\n      this.segmentsWanted.add(i)\n\n      this.wireWant.send({\n        start: i * DEFAULT_SEGMENT_SIZE,\n        length: DEFAULT_SEGMENT_SIZE\n      })\n      incrementTx(this.stats.wireWant, this.replicator.stats.wireWant)\n    }\n  }\n\n  isActive () {\n    if (this.paused || this.removed) return false\n    return true\n  }\n\n  async _send (req) {\n    const fork = this.core.tree.fork\n\n    this.inflight++\n    this.replicator._inflight.add(req)\n\n    if (req.upgrade !== null && req.fork === fork) {\n      const u = this.replicator._addUpgrade()\n      u.inflight.push(req)\n    }\n\n    try {\n      if (req.block !== null && req.fork === fork) {\n        req.block.nodes = await this.core.tree.missingNodes(2 * req.block.index)\n        if (req.priority === PRIORITY.CANCELLED) return\n      }\n      if (req.hash !== null && req.fork === fork && req.hash.nodes === 0) {\n        req.hash.nodes = await this.core.tree.missingNodes(req.hash.index)\n        if (req.priority === PRIORITY.CANCELLED) return\n\n        // nodes === 0, we already have it, bail\n        if (req.hash.nodes === 0 && (req.hash.index & 1) === 0) {\n          this.inflight--\n          this.replicator._resolveHashLocally(this, req)\n          return\n        }\n      }\n    } catch (err) {\n      this.stream.destroy(err)\n      return\n    }\n\n    this.wireRequest.send(req)\n    incrementTx(this.stats.wireRequest, this.replicator.stats.wireRequest)\n  }\n}\n\nmodule.exports = class Replicator {\n  static Peer = Peer // hack to be able to access Peer from outside this module\n\n  constructor (core, key, {\n    notDownloadingLinger = NOT_DOWNLOADING_SLACK,\n    eagerUpgrade = true,\n    allowFork = true,\n    inflightRange = null,\n    onpeerupdate = noop,\n    onupload = noop,\n    oninvalid = noop\n  } = {}) {\n    this.key = key\n    this.discoveryKey = core.crypto.discoveryKey(key)\n    this.core = core\n    this.eagerUpgrade = eagerUpgrade\n    this.allowFork = allowFork\n    this.onpeerupdate = onpeerupdate\n    this.onupload = onupload\n    this.oninvalid = oninvalid\n    this.ondownloading = null // optional external hook for monitoring downloading status\n    this.peers = []\n    this.findingPeers = 0 // updateable from the outside\n    this.destroyed = false\n    this.downloading = false\n    this.activeSessions = 0\n\n    this.hotswaps = new HotswapQueue()\n    this.inflightRange = inflightRange || DEFAULT_MAX_INFLIGHT\n\n    // Note: nodata and unwant not currently tracked\n    // tx = transmitted, rx = received\n    this.stats = {\n      wireSync: { tx: 0, rx: 0 },\n      wireRequest: { tx: 0, rx: 0 },\n      wireCancel: { tx: 0, rx: 0 },\n      wireData: { tx: 0, rx: 0 },\n      wireWant: { tx: 0, rx: 0 },\n      wireBitfield: { tx: 0, rx: 0 },\n      wireRange: { tx: 0, rx: 0 },\n      wireExtension: { tx: 0, rx: 0 },\n      hotswaps: 0\n    }\n\n    this._attached = new Set()\n    this._inflight = new InflightTracker()\n    this._blocks = new BlockTracker()\n    this._hashes = new BlockTracker()\n\n    this._queued = []\n\n    this._seeks = []\n    this._upgrade = null\n    this._reorgs = []\n    this._ranges = []\n\n    this._hadPeers = false\n    this._ifAvailable = 0\n    this._updatesPending = 0\n    this._applyingReorg = null\n    this._manifestPeer = null\n    this._hasSession = false\n    this._peerSessions = 0\n    this._notDownloadingLinger = notDownloadingLinger\n    this._downloadingTimer = null\n\n    const self = this\n    this._onstreamclose = onstreamclose\n\n    function onstreamclose () {\n      self.detachFrom(this.userData)\n    }\n  }\n\n  updateActivity (inc, session) {\n    this.activeSessions += inc\n    this.setDownloading(this.activeSessions !== 0, session)\n  }\n\n  isDownloading () {\n    return this.downloading || !this._inflight.idle\n  }\n\n  setDownloading (downloading) {\n    clearTimeout(this._downloadingTimer)\n\n    if (this.destroyed) return\n    if (downloading || this._notDownloadingLinger === 0) {\n      this.setDownloadingNow(downloading)\n      return\n    }\n\n    this._downloadingTimer = setTimeout(setDownloadingLater, this._notDownloadingLinger, this, downloading)\n  }\n\n  setDownloadingNow (downloading) {\n    this._downloadingTimer = null\n    if (this.downloading === downloading) return\n    this.downloading = downloading\n    if (!downloading && this.isDownloading()) return\n\n    for (const peer of this.peers) peer.signalUpgrade()\n\n    if (downloading) { // restart channel if needed...\n      for (const protomux of this._attached) {\n        if (!protomux.stream.handshakeHash) continue\n        if (protomux.opened({ protocol: 'hypercore/alpha', id: this.discoveryKey })) continue\n        this._makePeer(protomux, true)\n      }\n    } else {\n      for (const peer of this.peers) peer.closeIfIdle()\n    }\n\n    if (this.ondownloading !== null && downloading) this.ondownloading()\n  }\n\n  cork () {\n    for (const peer of this.peers) peer.protomux.cork()\n  }\n\n  uncork () {\n    for (const peer of this.peers) peer.protomux.uncork()\n  }\n\n  // Called externally when a range of new blocks has been processed/removed\n  onhave (start, length, drop = false) {\n    for (const peer of this.peers) peer.broadcastRange(start, length, drop)\n  }\n\n  // Called externally when a truncation upgrade has been processed\n  ontruncate (newLength, truncated) {\n    const notify = []\n\n    for (const blk of this._blocks) {\n      if (blk.index < newLength) continue\n      notify.push(blk)\n    }\n\n    for (const blk of notify) {\n      for (const r of blk.refs) {\n        if (r.snapshot === false) continue\n        blk.detach(r, SNAPSHOT_NOT_AVAILABLE())\n      }\n    }\n\n    for (const peer of this.peers) peer._unclearLocalRange(newLength, truncated)\n  }\n\n  // Called externally when a upgrade has been processed\n  onupgrade () {\n    for (const peer of this.peers) peer.signalUpgrade()\n    if (this._blocks.isEmpty() === false) this._resolveBlocksLocally()\n    if (this._upgrade !== null) this._resolveUpgradeRequest(null)\n    if (this._ranges.length !== 0 || this._seeks.length !== 0) this._updateNonPrimary(true)\n  }\n\n  // Called externally when a conflict has been detected and verified\n  async onconflict (from) {\n    const all = []\n    for (const peer of this.peers) {\n      all.push(peer._onconflict())\n    }\n    await Promise.allSettled(all)\n  }\n\n  async applyPendingReorg () {\n    if (this._applyingReorg !== null) {\n      await this._applyingReorg\n      return true\n    }\n\n    for (let i = this._reorgs.length - 1; i >= 0; i--) {\n      const f = this._reorgs[i]\n      if (f.batch !== null && f.batch.finished) {\n        await this._applyReorg(f)\n        return true\n      }\n    }\n\n    return false\n  }\n\n  addUpgrade (session) {\n    if (this._upgrade !== null) {\n      const ref = this._upgrade.attach(session)\n      this._checkUpgradeIfAvailable()\n      return ref\n    }\n\n    const ref = this._addUpgrade().attach(session)\n\n    this.updateAll()\n\n    return ref\n  }\n\n  addBlock (session, index) {\n    const b = this._blocks.add(index, PRIORITY.HIGH)\n    const ref = b.attach(session)\n\n    this._queueBlock(b)\n    this.updateAll()\n\n    return ref\n  }\n\n  addSeek (session, seeker) {\n    const s = new SeekRequest(this._seeks, seeker)\n    const ref = s.attach(session)\n\n    this._seeks.push(s)\n    this.updateAll()\n\n    return ref\n  }\n\n  addRange (session, { start = 0, end = -1, length = toLength(start, end), blocks = null, linear = false, ifAvailable = false } = {}) {\n    if (blocks !== null) { // if using blocks, start, end just acts as frames around the blocks array\n      start = 0\n      end = length = blocks.length\n    }\n\n    const r = new RangeRequest(\n      this._ranges,\n      start,\n      length === -1 ? -1 : start + length,\n      linear,\n      ifAvailable,\n      blocks\n    )\n\n    const ref = r.attach(session)\n\n    // Trigger this to see if this is already resolved...\n    // Also auto compresses the range based on local bitfield\n    clampRange(this.core, r)\n\n    this._ranges.push(r)\n\n    if (r.end !== -1 && r.start >= r.end) {\n      this._resolveRangeRequest(r, this._ranges.length - 1)\n      return ref\n    }\n\n    this.updateAll()\n\n    return ref\n  }\n\n  cancel (ref) {\n    ref.context.detach(ref, null)\n  }\n\n  clearRequests (session, err = null) {\n    let cleared = false\n    while (session.length > 0) {\n      const ref = session[session.length - 1]\n      ref.context.detach(ref, err)\n      cleared = true\n    }\n\n    if (cleared) this.updateAll()\n  }\n\n  _addUpgradeMaybe () {\n    return this.eagerUpgrade === true ? this._addUpgrade() : this._upgrade\n  }\n\n  // TODO: this function is OVER called atm, at each updatePeer/updateAll\n  // instead its more efficient to only call it when the conditions in here change - ie on sync/add/remove peer\n  // Do this when we have more tests.\n  _checkUpgradeIfAvailable () {\n    if (this._ifAvailable > 0 && this.peers.length < MAX_PEERS_UPGRADE) return\n    if (this._upgrade === null || this._upgrade.refs.length === 0) return\n    if (this._hadPeers === false && this.findingPeers > 0) return\n\n    const maxPeers = Math.min(this.peers.length, MAX_PEERS_UPGRADE)\n\n    // check if a peer can upgrade us\n\n    for (let i = 0; i < maxPeers; i++) {\n      const peer = this.peers[i]\n\n      if (peer.remoteSynced === false) return\n\n      if (this.core.tree.length === 0 && peer.remoteLength > 0) return\n\n      if (peer.remoteLength <= this._upgrade.length || peer.remoteFork !== this._upgrade.fork) continue\n\n      if (peer.syncsProcessing > 0) return\n\n      if (peer.lengthAcked !== this.core.tree.length && peer.remoteFork === this.core.tree.fork) return\n      if (peer.remoteCanUpgrade === true) return\n    }\n\n    // check if reorgs in progress...\n\n    if (this._applyingReorg !== null) return\n\n    // TODO: we prob should NOT wait for inflight reorgs here, seems better to just resolve the upgrade\n    // and then apply the reorg on the next call in case it's slow - needs some testing in practice\n\n    for (let i = 0; i < this._reorgs.length; i++) {\n      const r = this._reorgs[i]\n      if (r.inflight.length > 0) return\n    }\n\n    // if something is inflight, wait for that first\n    if (this._upgrade.inflight.length > 0) return\n\n    // nothing to do, indicate no update avail\n\n    const u = this._upgrade\n    this._upgrade = null\n    u.resolve(false)\n  }\n\n  _addUpgrade () {\n    if (this._upgrade !== null) return this._upgrade\n\n    // TODO: needs a reorg: true/false flag to indicate if the user requested a reorg\n    this._upgrade = new UpgradeRequest(this, this.core.tree.fork, this.core.tree.length)\n\n    return this._upgrade\n  }\n\n  _addReorg (fork, peer) {\n    if (this.allowFork === false) return null\n\n    // TODO: eager gc old reorgs from the same peer\n    // not super important because they'll get gc'ed when the request finishes\n    // but just spam the remote can do ...\n\n    for (const f of this._reorgs) {\n      if (f.fork > fork && f.batch !== null) return null\n      if (f.fork === fork) return f\n    }\n\n    const f = {\n      fork,\n      inflight: [],\n      batch: null\n    }\n\n    this._reorgs.push(f)\n\n    // maintain sorted by fork\n    let i = this._reorgs.length - 1\n    while (i > 0 && this._reorgs[i - 1].fork > fork) {\n      this._reorgs[i] = this._reorgs[i - 1]\n      this._reorgs[--i] = f\n    }\n\n    return f\n  }\n\n  _shouldUpgrade (peer) {\n    if (this._upgrade !== null && this._upgrade.inflight.length > 0) return false\n    return peer.remoteCanUpgrade === true &&\n      peer.remoteLength > this.core.tree.length &&\n      peer.lengthAcked === this.core.tree.length\n  }\n\n  _autoUpgrade (peer) {\n    return this._upgrade !== null && peer.remoteFork === this.core.tree.fork && this._shouldUpgrade(peer)\n  }\n\n  _addPeer (peer) {\n    this._hadPeers = true\n    this.peers.push(peer)\n    this.updatePeer(peer)\n    this.onpeerupdate(true, peer)\n  }\n\n  _requestDone (id, roundtrip) {\n    this._inflight.remove(id, roundtrip)\n    if (this.isDownloading() === true) return\n    for (const peer of this.peers) peer.signalUpgrade()\n  }\n\n  _removePeer (peer) {\n    this.peers.splice(this.peers.indexOf(peer), 1)\n\n    if (this._manifestPeer === peer) this._manifestPeer = null\n\n    for (const req of this._inflight) {\n      if (req.peer !== peer) continue\n      this._inflight.remove(req.id, true)\n      this._clearRequest(peer, req)\n    }\n\n    if (peer.useSession) this._closeSessionMaybe()\n\n    this.onpeerupdate(false, peer)\n    this.updateAll()\n  }\n\n  _queueBlock (b) {\n    if (b.inflight.length > 0 || b.queued === true) return\n    b.queued = true\n    this._queued.push(b)\n  }\n\n  _resolveHashLocally (peer, req) {\n    this._requestDone(req.id, false)\n    this._resolveBlockRequest(this._hashes, req.hash.index / 2, null, req)\n    this.updatePeer(peer)\n  }\n\n  // Runs in the background - not allowed to throw\n  async _resolveBlocksLocally () {\n    // TODO: check if fork compat etc. Requires that we pass down truncation info\n\n    let clear = null\n\n    for (const b of this._blocks) {\n      if (this.core.bitfield.get(b.index) === false) continue\n\n      try {\n        b.resolve(await this.core.blocks.get(b.index))\n      } catch (err) {\n        b.reject(err)\n      }\n\n      if (clear === null) clear = []\n      clear.push(b)\n    }\n\n    if (clear === null) return\n\n    // Currently the block tracker does not support deletes during iteration, so we make\n    // sure to clear them afterwards.\n    for (const b of clear) {\n      this._blocks.remove(b.index)\n      removeHotswap(b)\n    }\n  }\n\n  _resolveBlockRequest (tracker, index, value, req) {\n    const b = tracker.remove(index)\n    if (b === null) return false\n\n    removeInflight(b.inflight, req)\n    removeHotswap(b)\n    b.queued = false\n\n    b.resolve(value)\n\n    if (b.inflight.length > 0) { // if anything is still inflight, cancel it\n      for (let i = b.inflight.length - 1; i >= 0; i--) {\n        const req = b.inflight[i]\n        req.peer._cancelRequest(req)\n      }\n    }\n\n    return true\n  }\n\n  _resolveUpgradeRequest (req) {\n    if (req !== null) removeInflight(this._upgrade.inflight, req)\n\n    if (this.core.tree.length === this._upgrade.length && this.core.tree.fork === this._upgrade.fork) return false\n\n    const u = this._upgrade\n    this._upgrade = null\n    u.resolve(true)\n\n    return true\n  }\n\n  _resolveRangeRequest (req, index) {\n    const head = this._ranges.pop()\n\n    if (index < this._ranges.length) this._ranges[index] = head\n\n    req.resolve(true)\n  }\n\n  _clearInflightBlock (tracker, req) {\n    const isBlock = tracker === this._blocks\n    const index = isBlock === true ? req.block.index : req.hash.index / 2\n    const b = tracker.get(index)\n\n    if (b === null || removeInflight(b.inflight, req) === false) return\n\n    if (removeHotswap(b) === true && b.inflight.length > 0) {\n      this.hotswaps.add(b)\n    }\n\n    if (b.refs.length > 0 && isBlock === true) {\n      this._queueBlock(b)\n      return\n    }\n\n    b.gc()\n  }\n\n  _clearInflightUpgrade (req) {\n    if (removeInflight(this._upgrade.inflight, req) === false) return\n    this._upgrade.gc()\n  }\n\n  _clearInflightSeeks (req) {\n    for (const s of this._seeks) {\n      if (removeInflight(s.inflight, req) === false) continue\n      s.gc()\n    }\n  }\n\n  _clearInflightReorgs (req) {\n    for (const r of this._reorgs) {\n      removeInflight(r.inflight, req)\n    }\n  }\n\n  _clearOldReorgs (fork) {\n    for (let i = 0; i < this._reorgs.length; i++) {\n      const f = this._reorgs[i]\n      if (f.fork >= fork) continue\n      if (i === this._reorgs.length - 1) this._reorgs.pop()\n      else this._reorgs[i] = this._reorgs.pop()\n      i--\n    }\n  }\n\n  // \"slow\" updates here - async but not allowed to ever throw\n  async _updateNonPrimary (updateAll) {\n    // Check if running, if so skip it and the running one will issue another update for us (debounce)\n    while (++this._updatesPending === 1) {\n      let len = Math.min(MAX_RANGES, this._ranges.length)\n\n      for (let i = 0; i < len; i++) {\n        const r = this._ranges[i]\n\n        clampRange(this.core, r)\n\n        if (r.end !== -1 && r.start >= r.end) {\n          this._resolveRangeRequest(r, i--)\n          if (len > this._ranges.length) len--\n          if (this._ranges.length === MAX_RANGES) updateAll = true\n        }\n      }\n\n      for (let i = 0; i < this._seeks.length; i++) {\n        const s = this._seeks[i]\n\n        let err = null\n        let res = null\n\n        try {\n          res = await s.seeker.update()\n        } catch (error) {\n          err = error\n        }\n\n        if (!res && !err) continue\n\n        if (i < this._seeks.length - 1) this._seeks[i] = this._seeks.pop()\n        else this._seeks.pop()\n\n        i--\n\n        if (err) s.reject(err)\n        else s.resolve(res)\n      }\n\n      // No additional updates scheduled - break\n      if (--this._updatesPending === 0) break\n      // Debounce the additional updates - continue\n      this._updatesPending = 0\n    }\n\n    if (this._inflight.idle || updateAll) this.updateAll()\n  }\n\n  _maybeResolveIfAvailableRanges () {\n    if (this._ifAvailable > 0 || !this._inflight.idle || !this._ranges.length) return\n\n    for (let i = 0; i < this.peers.length; i++) {\n      if (this.peers[i].dataProcessing > 0) return\n    }\n\n    for (let i = 0; i < this._ranges.length; i++) {\n      const r = this._ranges[i]\n\n      if (r.ifAvailable) {\n        this._resolveRangeRequest(r, i--)\n      }\n    }\n  }\n\n  _clearRequest (peer, req) {\n    if (req.block !== null) {\n      this._clearInflightBlock(this._blocks, req)\n      this._unmarkInflight(req.block.index)\n    }\n\n    if (req.hash !== null) {\n      this._clearInflightBlock(this._hashes, req)\n    }\n\n    if (req.upgrade !== null && this._upgrade !== null) {\n      this._clearInflightUpgrade(req)\n    }\n\n    if (this._seeks.length > 0) {\n      this._clearInflightSeeks(req)\n    }\n\n    if (this._reorgs.length > 0) {\n      this._clearInflightReorgs(req)\n    }\n  }\n\n  _onnodata (peer, req) {\n    this._clearRequest(peer, req)\n    this.updateAll()\n  }\n\n  _openSkipBitfield () {\n    // technically the skip bitfield gets bits cleared if .clear() is called\n    // also which might be in inflight also, but that just results in that section being overcalled shortly\n    // worst case, so ok for now\n\n    const bitfield = this.core.openSkipBitfield()\n\n    for (const req of this._inflight) {\n      if (req.block) bitfield.set(req.block.index, true) // skip\n    }\n  }\n\n  _markInflight (index) {\n    if (this.core.skipBitfield !== null) this.core.skipBitfield.set(index, true)\n    for (const peer of this.peers) peer._markInflight(index)\n  }\n\n  _unmarkInflight (index) {\n    if (this.core.skipBitfield !== null) this.core.skipBitfield.set(index, this.core.bitfield.get(index))\n    for (const peer of this.peers) peer._resetMissingBlock(index)\n  }\n\n  _ondata (peer, req, data) {\n    if (data.block !== null) {\n      this._resolveBlockRequest(this._blocks, data.block.index, data.block.value, req)\n    }\n\n    if (data.hash !== null && (data.hash.index & 1) === 0) {\n      this._resolveBlockRequest(this._hashes, data.hash.index / 2, null, req)\n    }\n\n    if (this._upgrade !== null) {\n      this._resolveUpgradeRequest(req)\n    }\n\n    if (this._seeks.length > 0) {\n      this._clearInflightSeeks(req)\n    }\n\n    if (this._reorgs.length > 0) {\n      this._clearInflightReorgs(req)\n    }\n\n    if (this._manifestPeer === peer && this.core.header.manifest !== null) {\n      this._manifestPeer = null\n    }\n\n    if (this._seeks.length > 0 || this._ranges.length > 0) this._updateNonPrimary(this._seeks.length > 0)\n    this.updatePeer(peer)\n  }\n\n  _onwant (peer, start, length) {\n    const contig = Math.min(this.core.tree.length, this.core.header.hints.contiguousLength)\n\n    if (start + length < contig || (this.core.tree.length === contig)) {\n      peer.wireRange.send({\n        drop: false,\n        start: 0,\n        length: contig\n      })\n      incrementTx(peer.stats.wireRange, this.stats.wireRange)\n      return\n    }\n\n    length = Math.min(length, this.core.tree.length - start)\n\n    peer.protomux.cork()\n\n    for (const msg of this.core.bitfield.want(start, length)) {\n      peer.wireBitfield.send(msg)\n      incrementTx(peer.stats.wireBitfield, this.stats.wireBitfield)\n    }\n\n    peer.protomux.uncork()\n  }\n\n  async _onreorgdata (peer, req, data) {\n    const newBatch = data.upgrade && await this.core.verifyReorg(data)\n    const f = this._addReorg(data.fork, peer)\n\n    if (f === null) {\n      this.updateAll()\n      return\n    }\n\n    removeInflight(f.inflight, req)\n\n    if (f.batch) {\n      await f.batch.update(data)\n    } else if (data.upgrade) {\n      f.batch = newBatch\n\n      // Remove \"older\" reorgs in progress as we just verified this one.\n      this._clearOldReorgs(f.fork)\n    }\n\n    if (f.batch && f.batch.finished) {\n      if (this._addUpgradeMaybe() !== null) {\n        await this._applyReorg(f)\n      }\n    }\n\n    this.updateAll()\n  }\n\n  // Never throws, allowed to run in the background\n  async _applyReorg (f) {\n    // TODO: more optimal here to check if potentially a better reorg\n    // is available, ie higher fork, and request that one first.\n    // This will request that one after this finishes, which is fine, but we\n    // should investigate the complexity in going the other way\n\n    const u = this._upgrade\n\n    this._reorgs = [] // clear all as the nodes are against the old tree - easier\n    this._applyingReorg = this.core.reorg(f.batch, null) // TODO: null should be the first/last peer?\n\n    try {\n      await this._applyingReorg\n    } catch (err) {\n      this._upgrade = null\n      u.reject(err)\n    }\n\n    this._applyingReorg = null\n\n    if (this._upgrade !== null) {\n      this._resolveUpgradeRequest(null)\n    }\n\n    for (const peer of this.peers) this._updateFork(peer)\n\n    // TODO: all the remaining is a tmp workaround until we have a flag/way for ANY_FORK\n    for (const r of this._ranges) {\n      r.start = r.userStart\n      r.end = r.userEnd\n    }\n\n    this.updateAll()\n  }\n\n  _maybeUpdate () {\n    return this._upgrade !== null && this._upgrade.inflight.length === 0\n  }\n\n  _maybeRequestManifest () {\n    return this.core.header.manifest === null && this._manifestPeer === null\n  }\n\n  _updateFork (peer) {\n    if (this._applyingReorg !== null || this.allowFork === false || peer.remoteFork <= this.core.tree.fork) {\n      return false\n    }\n\n    const f = this._addReorg(peer.remoteFork, peer)\n\n    // TODO: one per peer is better\n    if (f !== null && f.batch === null && f.inflight.length === 0) {\n      return peer._requestForkProof(f)\n    }\n\n    return false\n  }\n\n  _updateHotswap (peer) {\n    const maxHotswaps = peer.getMaxHotswapInflight()\n    if (!peer.isActive() || peer.inflight >= maxHotswaps) return\n\n    for (const b of this.hotswaps.pick(peer)) {\n      if (peer._requestBlock(b) === false) continue\n      peer.stats.hotswaps++\n      peer.replicator.stats.hotswaps++\n      if (peer.inflight >= maxHotswaps) break\n    }\n  }\n\n  _updatePeer (peer) {\n    if (!peer.isActive() || peer.inflight >= peer.getMaxInflight()) {\n      return false\n    }\n\n    // Eagerly request the manifest even if the remote length is 0. If not 0 we'll get as part of the upgrade request...\n    if (this._maybeRequestManifest() === true && peer.remoteLength === 0 && peer.remoteHasManifest === true) {\n      this._manifestPeer = peer\n      peer._requestManifest()\n    }\n\n    for (const s of this._seeks) {\n      if (s.inflight.length > 0) continue // TODO: one per peer is better\n      if (peer._requestSeek(s) === true) {\n        return true\n      }\n    }\n\n    // Implied that any block in the queue should be requested, no matter how many inflights\n    const blks = new RandomIterator(this._queued)\n\n    for (const b of blks) {\n      if (b.queued === false || peer._requestBlock(b) === true) {\n        b.queued = false\n        blks.dequeue()\n        return true\n      }\n    }\n\n    return false\n  }\n\n  _updatePeerNonPrimary (peer) {\n    if (!peer.isActive() || peer.inflight >= peer.getMaxInflight()) {\n      return false\n    }\n\n    const ranges = new RandomIterator(this._ranges)\n    let tried = 0\n\n    for (const r of ranges) {\n      if (peer._requestRange(r) === true) {\n        return true\n      }\n      if (++tried >= MAX_RANGES) break\n    }\n\n    // Iterate from newest fork to oldest fork...\n    for (let i = this._reorgs.length - 1; i >= 0; i--) {\n      const f = this._reorgs[i]\n      if (f.batch !== null && f.inflight.length === 0 && peer._requestForkRange(f) === true) {\n        return true\n      }\n    }\n\n    if (this._maybeUpdate() === true && peer._requestUpgrade(this._upgrade) === true) {\n      return true\n    }\n\n    return false\n  }\n\n  updatePeer (peer) {\n    // Quick shortcut to wait for flushing reorgs - not needed but less waisted requests\n    if (this._applyingReorg !== null) return\n\n    while (this._updatePeer(peer) === true);\n    while (this._updatePeerNonPrimary(peer) === true);\n\n    if (this.peers.length > 1 && this._blocks.isEmpty() === false) {\n      this._updateHotswap(peer)\n    }\n\n    this._checkUpgradeIfAvailable()\n    this._maybeResolveIfAvailableRanges()\n  }\n\n  updateAll () {\n    // Quick shortcut to wait for flushing reorgs - not needed but less waisted requests\n    if (this._applyingReorg !== null) return\n\n    const peers = new RandomIterator(this.peers)\n\n    for (const peer of peers) {\n      if (this._updatePeer(peer) === true) {\n        peers.requeue()\n      }\n    }\n\n    // Check if we can skip the non primary check fully\n    if (this._maybeUpdate() === false && this._ranges.length === 0 && this._reorgs.length === 0) {\n      this._checkUpgradeIfAvailable()\n      return\n    }\n\n    for (const peer of peers.restart()) {\n      if (this._updatePeerNonPrimary(peer) === true) {\n        peers.requeue()\n      }\n    }\n\n    this._checkUpgradeIfAvailable()\n    this._maybeResolveIfAvailableRanges()\n  }\n\n  _closeSessionMaybe () {\n    if (this._hasSession && this._peerSessions === 0) {\n      this._hasSession = false\n      this.core.active--\n    }\n\n    // we were the last active ref, so lets shut things down\n    if (this.core.active === 0 && this.core.sessions.length === 0) {\n      this.destroy()\n      this.core.close().catch(safetyCatch)\n      return\n    }\n\n    // in case one session is still alive but its been marked for auto close also kill it\n    if (this.core.sessions.length === 1 && this.core.active === 1 && this.core.sessions[0].autoClose) {\n      this.core.sessions[0].close().catch(safetyCatch)\n    }\n  }\n\n  attached (protomux) {\n    return this._attached.has(protomux)\n  }\n\n  ensureSession () {\n    if (this._hasSession) return\n    this._hasSession = true\n    this.core.active++\n  }\n\n  attachTo (protomux, useSession) {\n    if (this.core.closed) return\n    if (useSession) this.ensureSession()\n\n    const makePeer = this._makePeer.bind(this, protomux, useSession)\n\n    this._attached.add(protomux)\n    protomux.pair({ protocol: 'hypercore/alpha', id: this.discoveryKey }, makePeer)\n    protomux.stream.setMaxListeners(0)\n    protomux.stream.on('close', this._onstreamclose)\n\n    if (useSession) this._peerSessions++\n    this._ifAvailable++\n\n    protomux.stream.opened.then((opened) => {\n      if (useSession) this._peerSessions--\n      this._ifAvailable--\n\n      if (opened && !this.destroyed) makePeer()\n      else if (useSession) this._closeSessionMaybe()\n      this._checkUpgradeIfAvailable()\n    })\n  }\n\n  detachFrom (protomux) {\n    if (this._attached.delete(protomux)) {\n      protomux.stream.removeListener('close', this._onstreamclose)\n      protomux.unpair({ protocol: 'hypercore/alpha', id: this.discoveryKey })\n    }\n  }\n\n  destroy () {\n    this.destroyed = true\n\n    if (this._downloadingTimer) {\n      clearTimeout(this._downloadingTimer)\n      this._downloadingTimer = null\n    }\n\n    const waiting = []\n\n    while (this.peers.length) {\n      const peer = this.peers[this.peers.length - 1]\n      this.detachFrom(peer.protomux)\n      peer.channel.close() // peer is removed from array in onclose\n      waiting.push(peer.channel.fullyClosed())\n    }\n\n    for (const protomux of this._attached) {\n      this.detachFrom(protomux)\n    }\n\n    return Promise.all(waiting)\n  }\n\n  _makePeer (protomux, useSession) {\n    const replicator = this\n    if (protomux.opened({ protocol: 'hypercore/alpha', id: this.discoveryKey })) return onnochannel()\n\n    const channel = protomux.createChannel({\n      userData: null,\n      protocol: 'hypercore/alpha',\n      aliases: ['hypercore'],\n      id: this.discoveryKey,\n      handshake: m.wire.handshake,\n      messages: [\n        { encoding: m.wire.sync, onmessage: onwiresync },\n        { encoding: m.wire.request, onmessage: onwirerequest },\n        { encoding: m.wire.cancel, onmessage: onwirecancel },\n        { encoding: m.wire.data, onmessage: onwiredata },\n        { encoding: m.wire.noData, onmessage: onwirenodata },\n        { encoding: m.wire.want, onmessage: onwirewant },\n        { encoding: m.wire.unwant, onmessage: onwireunwant },\n        { encoding: m.wire.bitfield, onmessage: onwirebitfield },\n        { encoding: m.wire.range, onmessage: onwirerange },\n        { encoding: m.wire.extension, onmessage: onwireextension }\n      ],\n      onopen: onwireopen,\n      onclose: onwireclose,\n      ondrain: onwiredrain\n    })\n\n    if (channel === null) return onnochannel()\n\n    const peer = new Peer(replicator, protomux, channel, useSession, this.inflightRange)\n    const stream = protomux.stream\n\n    if (useSession) {\n      // session may have been unref'd underneath us\n      replicator.ensureSession()\n      replicator._peerSessions++\n    }\n\n    peer.channel.open({\n      seeks: true,\n      capability: caps.replicate(stream.isInitiator, this.key, stream.handshakeHash)\n    })\n\n    return true\n\n    function onnochannel () {\n      if (useSession) replicator._closeSessionMaybe()\n      return false\n    }\n  }\n}\n\nfunction matchingRequest (req, data) {\n  if (data.block !== null && (req.block === null || req.block.index !== data.block.index)) return false\n  if (data.hash !== null && (req.hash === null || req.hash.index !== data.hash.index)) return false\n  if (data.seek !== null && (req.seek === null || req.seek.bytes !== data.seek.bytes)) return false\n  if (data.upgrade !== null && req.upgrade === null) return false\n  return req.fork === data.fork\n}\n\nfunction removeHotswap (block) {\n  if (block.hotswap === null) return false\n  block.hotswap.ref.remove(block)\n  return true\n}\n\nfunction removeInflight (inf, req) {\n  const i = inf.indexOf(req)\n  if (i === -1) return false\n  if (i < inf.length - 1) inf[i] = inf.pop()\n  else inf.pop()\n  return true\n}\n\nfunction noop () {}\n\nfunction toLength (start, end) {\n  return end === -1 ? -1 : (end < start ? 0 : end - start)\n}\n\nfunction clampRange (core, r) {\n  if (r.blocks === null) {\n    const start = core.bitfield.firstUnset(r.start)\n\n    if (r.end === -1) r.start = start === -1 ? core.tree.length : start\n    else if (start === -1 || start >= r.end) r.start = r.end\n    else {\n      r.start = start\n\n      const end = core.bitfield.lastUnset(r.end - 1)\n\n      if (end === -1 || start >= end + 1) r.end = r.start\n      else r.end = end + 1\n    }\n  } else {\n    while (r.start < r.end && core.bitfield.get(r.blocks[r.start])) r.start++\n    while (r.start < r.end && core.bitfield.get(r.blocks[r.end - 1])) r.end--\n  }\n}\n\nfunction onrequesttimeout (req) {\n  if (req.context) req.context.detach(req, REQUEST_TIMEOUT())\n}\n\nfunction destroyRequestTimeout (req) {\n  if (req.timeout !== null) {\n    clearTimeout(req.timeout)\n    req.timeout = null\n  }\n}\n\nfunction isCriticalError (err) {\n  // TODO: expose .critical or similar on the hypercore errors that are critical (if all not are)\n  return err.name === 'HypercoreError'\n}\n\nfunction onwireopen (m, c) {\n  return c.userData.onopen(m)\n}\n\nfunction onwireclose (isRemote, c) {\n  return c.userData.onclose(isRemote)\n}\n\nfunction onwiredrain (c) {\n  return c.userData.ondrain()\n}\n\nfunction onwiresync (m, c) {\n  incrementRx(c.userData.stats.wireSync, c.userData.replicator.stats.wireSync)\n  return c.userData.onsync(m)\n}\n\nfunction onwirerequest (m, c) {\n  incrementRx(c.userData.stats.wireRequest, c.userData.replicator.stats.wireRequest)\n  return c.userData.onrequest(m)\n}\n\nfunction onwirecancel (m, c) {\n  incrementRx(c.userData.stats.wireCancel, c.userData.replicator.stats.wireCancel)\n  return c.userData.oncancel(m)\n}\n\nfunction onwiredata (m, c) {\n  incrementRx(c.userData.stats.wireData, c.userData.replicator.stats.wireData)\n  return c.userData.ondata(m)\n}\n\nfunction onwirenodata (m, c) {\n  return c.userData.onnodata(m)\n}\n\nfunction onwirewant (m, c) {\n  incrementRx(c.userData.stats.wireWant, c.userData.replicator.stats.wireWant)\n  return c.userData.onwant(m)\n}\n\nfunction onwireunwant (m, c) {\n  return c.userData.onunwant(m)\n}\n\nfunction onwirebitfield (m, c) {\n  incrementRx(c.userData.stats.wireBitfield, c.userData.replicator.stats.wireBitfield)\n  return c.userData.onbitfield(m)\n}\n\nfunction onwirerange (m, c) {\n  incrementRx(c.userData.stats.wireRange, c.userData.replicator.stats.wireRange)\n  return c.userData.onrange(m)\n}\n\nfunction onwireextension (m, c) {\n  incrementRx(c.userData.stats.wireExtension, c.userData.replicator.stats.wireExtension)\n  return c.userData.onextension(m)\n}\n\nfunction setDownloadingLater (repl, downloading, session) {\n  repl.setDownloadingNow(downloading, session)\n}\n\nfunction isBlockRequest (req) {\n  return req !== null && req.block !== null\n}\n\nfunction isUpgradeRequest (req) {\n  return req !== null && req.upgrade !== null\n}\n\nfunction incrementTx (stats1, stats2) {\n  stats1.tx++\n  stats2.tx++\n}\n\nfunction incrementRx (stats1, stats2) {\n  stats1.rx++\n  stats2.rx++\n}\nconst { Writable, Readable } = require('streamx')\n\nclass ReadStream extends Readable {\n  constructor (core, opts = {}) {\n    super()\n\n    this.core = core\n    this.start = opts.start || 0\n    this.end = typeof opts.end === 'number' ? opts.end : -1\n    this.snapshot = !opts.live && opts.snapshot !== false\n    this.live = !!opts.live\n  }\n\n  _open (cb) {\n    this._openP().then(cb, cb)\n  }\n\n  _read (cb) {\n    this._readP().then(cb, cb)\n  }\n\n  async _openP () {\n    if (this.end === -1) await this.core.update()\n    else await this.core.ready()\n    if (this.snapshot && this.end === -1) this.end = this.core.length\n  }\n\n  async _readP () {\n    const end = this.live ? -1 : (this.end === -1 ? this.core.length : this.end)\n    if (end >= 0 && this.start >= end) {\n      this.push(null)\n      return\n    }\n\n    this.push(await this.core.get(this.start++))\n  }\n}\n\nexports.ReadStream = ReadStream\n\nclass WriteStream extends Writable {\n  constructor (core) {\n    super()\n    this.core = core\n  }\n\n  _writev (batch, cb) {\n    this._writevP(batch).then(cb, cb)\n  }\n\n  async _writevP (batch) {\n    await this.core.append(batch)\n  }\n}\n\nexports.WriteStream = WriteStream\n\nclass ByteStream extends Readable {\n  constructor (core, opts = {}) {\n    super()\n\n    this._core = core\n    this._index = 0\n    this._range = null\n\n    this._byteOffset = opts.byteOffset || 0\n    this._byteLength = typeof opts.byteLength === 'number' ? opts.byteLength : -1\n    this._prefetch = typeof opts.prefetch === 'number' ? opts.prefetch : 32\n\n    this._applyOffset = this._byteOffset > 0\n  }\n\n  _open (cb) {\n    this._openp().then(cb, cb)\n  }\n\n  _read (cb) {\n    this._readp().then(cb, cb)\n  }\n\n  async _openp () {\n    if (this._byteLength === -1) {\n      await this._core.update()\n      this._byteLength = Math.max(this._core.byteLength - this._byteOffset, 0)\n    }\n  }\n\n  async _readp () {\n    let data = null\n\n    if (this._byteLength === 0) {\n      this.push(null)\n      return\n    }\n\n    let relativeOffset = 0\n\n    if (this._applyOffset) {\n      this._applyOffset = false\n\n      const [block, byteOffset] = await this._core.seek(this._byteOffset)\n\n      this._index = block\n      relativeOffset = byteOffset\n    }\n\n    this._predownload(this._index + 1)\n    data = await this._core.get(this._index++, { valueEncoding: 'binary' })\n\n    if (relativeOffset > 0) data = data.subarray(relativeOffset)\n\n    if (data.byteLength > this._byteLength) data = data.subarray(0, this._byteLength)\n    this._byteLength -= data.byteLength\n\n    this.push(data)\n    if (this._byteLength === 0) this.push(null)\n  }\n\n  _predownload (index) {\n    if (this._range) this._range.destroy()\n    this._range = this._core.download({ start: index, end: index + this._prefetch, linear: true })\n  }\n\n  _destroy (cb) {\n    if (this._range) this._range.destroy()\n    cb(null)\n  }\n}\n\nexports.ByteStream = ByteStream\nconst defaultCrypto = require('hypercore-crypto')\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\nconst flat = require('flat-tree')\nconst { BAD_ARGUMENT } = require('hypercore-errors')\nconst unslab = require('unslab')\n\nconst m = require('./messages')\nconst multisig = require('./multisig')\nconst caps = require('./caps')\n\nclass Signer {\n  constructor (crypto, manifestHash, version, index, { signature = 'ed25519', publicKey, namespace = caps.DEFAULT_NAMESPACE } = {}) {\n    if (!publicKey) throw BAD_ARGUMENT('public key is required for a signer')\n    if (signature !== 'ed25519') throw BAD_ARGUMENT('Only Ed25519 signatures are supported')\n\n    this.crypto = crypto\n    this.manifestHash = manifestHash\n    this.version = version\n    this.signer = index\n    this.signature = signature\n    this.publicKey = publicKey\n    this.namespace = namespace\n  }\n\n  _ctx () {\n    return this.version === 0 ? this.namespace : this.manifestHash\n  }\n\n  verify (batch, signature) {\n    return this.crypto.verify(batch.signable(this._ctx()), signature, this.publicKey)\n  }\n\n  sign (batch, keyPair) {\n    return this.crypto.sign(batch.signable(this._ctx()), keyPair.secretKey)\n  }\n}\n\nclass CompatSigner extends Signer {\n  constructor (crypto, index, signer, legacy) {\n    super(crypto, null, 0, index, signer)\n    this.legacy = legacy\n  }\n\n  verify (batch, signature) {\n    return this.crypto.verify(batch.signableCompat(this.legacy), signature, this.publicKey)\n  }\n\n  sign (batch, keyPair) {\n    return this.crypto.sign(batch.signableCompat(this.legacy), keyPair.secretKey)\n  }\n}\n\nmodule.exports = class Verifier {\n  constructor (manifestHash, manifest, { compat = isCompat(manifestHash, manifest), crypto = defaultCrypto, legacy = false } = {}) {\n    const self = this\n\n    this.manifestHash = manifestHash\n    this.compat = compat || manifest === null\n    this.version = this.compat ? 0 : typeof manifest.version === 'number' ? manifest.version : 1\n    this.hash = manifest.hash || 'blake2b'\n    this.allowPatch = !this.compat && !!manifest.allowPatch\n    this.quorum = this.compat ? 1 : defaultQuorum(manifest)\n\n    this.signers = manifest.signers ? manifest.signers.map(createSigner) : []\n    this.prologue = this.compat ? null : (manifest.prologue || null)\n\n    function createSigner (signer, index) {\n      return self.compat\n        ? new CompatSigner(crypto, index, signer, legacy)\n        : new Signer(crypto, manifestHash, self.version, index, signer)\n    }\n  }\n\n  _verifyCompat (batch, signature) {\n    if (!signature) return false\n\n    if (this.compat || (!this.allowPatch && this.signers.length === 1)) {\n      return !!signature && this.signers[0].verify(batch, signature)\n    }\n\n    return this._verifyMulti(batch, signature)\n  }\n\n  _inflate (signature) {\n    if (this.version >= 1) return multisig.inflate(signature)\n    const { proofs, patch } = multisig.inflatev0(signature)\n\n    return {\n      proofs: proofs.map(proofToVersion1),\n      patch\n    }\n  }\n\n  _verifyMulti (batch, signature) {\n    if (!signature || this.quorum === 0) return false\n\n    const { proofs, patch } = this._inflate(signature)\n    if (proofs.length < this.quorum) return false\n\n    const tried = new Uint8Array(this.signers.length)\n    const nodes = this.allowPatch && patch.length ? toMap(patch) : null\n\n    for (let i = 0; i < this.quorum; i++) {\n      const inp = proofs[i]\n\n      let tree = batch\n\n      if (inp.patch && this.allowPatch) {\n        tree = batch.clone()\n\n        const upgrade = generateUpgrade(nodes, batch.length, inp.patch)\n        const proof = { fork: tree.fork, block: null, hash: null, seek: null, upgrade, manifest: null }\n\n        try {\n          if (!tree.verifyUpgrade(proof)) return false\n        } catch {\n          return false\n        }\n      }\n\n      if (inp.signer >= this.signers.length || tried[inp.signer]) return false\n      tried[inp.signer] = 1\n\n      const s = this.signers[inp.signer]\n      if (!s.verify(tree, inp.signature)) return false\n    }\n\n    return true\n  }\n\n  verify (batch, signature) {\n    if (this.version !== 1) {\n      return this._verifyCompat(batch, signature)\n    }\n\n    if (this.prologue !== null && batch.length <= this.prologue.length) {\n      return batch.length === this.prologue.length && b4a.equals(batch.hash(), this.prologue.hash)\n    }\n\n    return this._verifyMulti(batch, signature)\n  }\n\n  // TODO: better api for this that is more ... multisig-ey\n  sign (batch, keyPair) {\n    if (!keyPair || !keyPair.secretKey) throw BAD_ARGUMENT('No key pair was passed')\n\n    for (const s of this.signers) {\n      if (b4a.equals(s.publicKey, keyPair.publicKey)) {\n        const signature = s.sign(batch, keyPair)\n        if (this.signers.length !== 1 || this.version === 0) return signature\n        return this.assemble([{ signer: 0, signature, patch: 0, nodes: null }])\n      }\n    }\n\n    throw BAD_ARGUMENT('Public key is not a declared signer')\n  }\n\n  assemble (inputs) {\n    return this.version === 0 ? multisig.assemblev0(inputs) : multisig.assemble(inputs)\n  }\n\n  static manifestHash (manifest) {\n    return manifestHash(manifest)\n  }\n\n  static defaultSignerManifest (publicKey) {\n    return {\n      version: 1,\n      hash: 'blake2b',\n      allowPatch: false,\n      quorum: 1,\n      signers: [{\n        signature: 'ed25519',\n        namespace: caps.DEFAULT_NAMESPACE,\n        publicKey\n      }],\n      prologue: null\n    }\n  }\n\n  static fromManifest (manifest, opts) {\n    const m = this.createManifest(manifest)\n    return new this(manifestHash(m), m, opts)\n  }\n\n  static createManifest (inp) {\n    if (!inp) return null\n\n    const manifest = {\n      version: typeof inp.version === 'number' ? inp.version : 1,\n      hash: 'blake2b',\n      allowPatch: !!inp.allowPatch,\n      quorum: defaultQuorum(inp),\n      signers: inp.signers ? inp.signers.map(parseSigner) : [],\n      prologue: null\n    }\n\n    if (inp.hash && inp.hash !== 'blake2b') throw BAD_ARGUMENT('Only Blake2b hashes are supported')\n\n    if (inp.prologue) {\n      if (!(b4a.isBuffer(inp.prologue.hash) && inp.prologue.hash.byteLength === 32) || !(inp.prologue.length >= 0)) {\n        throw BAD_ARGUMENT('Invalid prologue')\n      }\n\n      manifest.prologue = inp.prologue\n      manifest.prologue.hash = unslab(manifest.prologue.hash)\n    }\n\n    return manifest\n  }\n\n  static isValidManifest (key, manifest) {\n    return b4a.equals(key, manifestHash(manifest))\n  }\n\n  static isCompat (key, manifest) {\n    return isCompat(key, manifest)\n  }\n\n  static sign (manifest, batch, keyPair, opts) {\n    return Verifier.fromManifest(manifest, opts).sign(batch, keyPair)\n  }\n}\n\nfunction toMap (nodes) {\n  const m = new Map()\n  for (const node of nodes) m.set(node.index, node)\n  return m\n}\n\nfunction isCompat (key, manifest) {\n  return !!(manifest && manifest.signers.length === 1 && b4a.equals(key, manifest.signers[0].publicKey))\n}\n\nfunction defaultQuorum (man) {\n  if (typeof man.quorum === 'number') return man.quorum\n  if (!man.signers || !man.signers.length) return 0\n  return (man.signers.length >> 1) + 1\n}\n\nfunction generateUpgrade (patch, start, length) {\n  const upgrade = { start, length, nodes: null, additionalNodes: [], signature: null }\n\n  const from = start * 2\n  const to = from + length * 2\n\n  for (const ite = flat.iterator(0); ite.fullRoot(to); ite.nextTree()) {\n    if (ite.index + ite.factor / 2 < from) continue\n\n    if (upgrade.nodes === null && ite.contains(from - 2)) {\n      upgrade.nodes = []\n\n      const root = ite.index\n      const target = from - 2\n\n      ite.seek(target)\n\n      while (ite.index !== root) {\n        ite.sibling()\n        if (ite.index > target) upgrade.nodes.push(patch.get(ite.index))\n        ite.parent()\n      }\n\n      continue\n    }\n\n    if (upgrade.nodes === null) upgrade.nodes = []\n    upgrade.nodes.push(patch.get(ite.index))\n  }\n\n  if (upgrade.nodes === null) upgrade.nodes = []\n  return upgrade\n}\n\nfunction parseSigner (signer) {\n  validateSigner(signer)\n  return {\n    signature: 'ed25519',\n    namespace: unslab(signer.namespace || caps.DEFAULT_NAMESPACE),\n    publicKey: unslab(signer.publicKey)\n  }\n}\n\nfunction validateSigner (signer) {\n  if (!signer || !signer.publicKey) throw BAD_ARGUMENT('Signer missing public key')\n  if (signer.signature && signer.signature !== 'ed25519') throw BAD_ARGUMENT('Only Ed25519 signatures are supported')\n}\n\nfunction manifestHash (manifest) {\n  const state = { start: 0, end: 32, buffer: null }\n  m.manifest.preencode(state, manifest)\n  state.buffer = b4a.allocUnsafe(state.end)\n  c.raw.encode(state, caps.MANIFEST)\n  m.manifest.encode(state, manifest)\n  return defaultCrypto.hash(state.buffer)\n}\n\nfunction proofToVersion1 (proof) {\n  return {\n    signer: proof.signer,\n    signature: proof.signature,\n    patch: proof.patch ? proof.patch.length : 0\n  }\n}\n{\n  \"name\": \"hypercore\",\n  \"version\": \"10.38.2\",\n  \"description\": \"Hypercore is a secure, distributed append-only log\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && node test/all.js\",\n    \"test:generate\": \"brittle -r test/all.js test/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/hypercore.git\"\n  },\n  \"contributors\": [\n    {\n      \"name\": \"Mathias Buus\",\n      \"email\": \"mathiasbuus@gmail.com\",\n      \"url\": \"https://mafinto.sh\"\n    },\n    {\n      \"name\": \"Andrew Osheroff\",\n      \"email\": \"andrewosh@gmail.com\",\n      \"url\": \"https://andrewosh.com\"\n    }\n  ],\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hypercore/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hypercore#readme\",\n  \"files\": [\n    \"index.js\",\n    \"errors.js\",\n    \"messages.js\",\n    \"lib/**.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"@hyperswarm/secret-stream\": \"^6.0.0\",\n    \"b4a\": \"^1.1.0\",\n    \"bare-events\": \"^2.2.0\",\n    \"big-sparse-array\": \"^1.0.3\",\n    \"compact-encoding\": \"^2.11.0\",\n    \"crc-universal\": \"^1.0.2\",\n    \"fast-fifo\": \"^1.3.0\",\n    \"flat-tree\": \"^1.9.0\",\n    \"hypercore-crypto\": \"^3.2.1\",\n    \"hypercore-errors\": \"^1.2.0\",\n    \"hypercore-id-encoding\": \"^1.2.0\",\n    \"is-options\": \"^1.0.1\",\n    \"protomux\": \"^3.5.0\",\n    \"quickbit-universal\": \"^2.2.0\",\n    \"random-access-file\": \"^4.0.0\",\n    \"random-array-iterator\": \"^1.0.0\",\n    \"safety-catch\": \"^1.0.1\",\n    \"sodium-universal\": \"^4.0.0\",\n    \"streamx\": \"^2.12.4\",\n    \"unslab\": \"^1.3.0\",\n    \"xache\": \"^1.1.0\",\n    \"z32\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.0\",\n    \"debugging-stream\": \"^3.1.0\",\n    \"hyperswarm\": \"^4.3.6\",\n    \"rache\": \"^1.0.0\",\n    \"random-access-memory\": \"^6.1.0\",\n    \"random-access-memory-overlay\": \"^3.0.0\",\n    \"range-parser\": \"^1.2.1\",\n    \"speedometer\": \"^1.1.0\",\n    \"standard\": \"^17.0.0\",\n    \"test-tmp\": \"^1.0.2\",\n    \"tiny-byte-size\": \"^1.1.0\",\n    \"udx-native\": \"^1.6.1\"\n  }\n}\nconst DHT = require('dht-rpc')\nconst sodium = require('sodium-universal')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst safetyCatch = require('safety-catch')\nconst m = require('./lib/messages')\nconst SocketPool = require('./lib/socket-pool')\nconst Persistent = require('./lib/persistent')\nconst Router = require('./lib/router')\nconst Server = require('./lib/server')\nconst connect = require('./lib/connect')\nconst { FIREWALL, BOOTSTRAP_NODES, KNOWN_NODES, COMMANDS } = require('./lib/constants')\nconst { hash, createKeyPair } = require('./lib/crypto')\nconst { decode } = require('hypercore-id-encoding')\nconst RawStreamSet = require('./lib/raw-stream-set')\nconst ConnectionPool = require('./lib/connection-pool')\nconst { STREAM_NOT_CONNECTED } = require('./lib/errors')\n\nclass HyperDHT extends DHT {\n  constructor (opts = {}) {\n    const port = opts.port || 49737\n    const bootstrap = opts.bootstrap || BOOTSTRAP_NODES\n    const nodes = opts.nodes || KNOWN_NODES\n\n    super({ ...opts, port, bootstrap, nodes, filterNode })\n\n    const { router, persistent } = defaultCacheOpts(opts)\n\n    this.defaultKeyPair = opts.keyPair || createKeyPair(opts.seed)\n    this.listening = new Set()\n    this.connectionKeepAlive = opts.connectionKeepAlive === false\n      ? 0\n      : opts.connectionKeepAlive || 5000\n\n    // stats is inherited from dht-rpc so fwd the ones from there\n    this.stats = { punches: { consistent: 0, random: 0, open: 0 }, ...this.stats }\n\n    this._router = new Router(this, router)\n    this._socketPool = new SocketPool(this, opts.host || '0.0.0.0')\n    this._rawStreams = new RawStreamSet(this)\n    this._persistent = null\n    this._validatedLocalAddresses = new Map()\n\n    this._lastRandomPunch = 0\n    this._randomPunchInterval = opts.randomPunchInterval || 20000 // min 20s between random punches...\n    this._randomPunches = 0\n    this._randomPunchLimit = 1 // set to one for extra safety for now\n\n    this.once('persistent', () => {\n      this._persistent = new Persistent(this, persistent)\n    })\n\n    this.on('network-change', () => {\n      for (const server of this.listening) server.refresh()\n    })\n\n    this.on('network-update', () => {\n      if (!this.online) return\n      for (const server of this.listening) server.notifyOnline()\n    })\n  }\n\n  connect (remotePublicKey, opts) {\n    return connect(this, decode(remotePublicKey), opts)\n  }\n\n  createServer (opts, onconnection) {\n    if (typeof opts === 'function') return this.createServer({}, opts)\n    if (opts && opts.onconnection) onconnection = opts.onconnection\n    const s = new Server(this, opts)\n    if (onconnection) s.on('connection', onconnection)\n    return s\n  }\n\n  pool () {\n    return new ConnectionPool(this)\n  }\n\n  async resume () {\n    await super.resume()\n    const resuming = []\n    for (const server of this.listening) resuming.push(server.resume())\n    await Promise.allSettled(resuming)\n  }\n\n  async suspend () {\n    const suspending = []\n    for (const server of this.listening) suspending.push(server.suspend())\n    await Promise.allSettled(suspending)\n    await super.suspend()\n    await this._rawStreams.clear()\n  }\n\n  async destroy ({ force = false } = {}) {\n    if (!force) {\n      const closing = []\n      for (const server of this.listening) closing.push(server.close())\n      await Promise.allSettled(closing)\n    }\n    this._router.destroy()\n    if (this._persistent) this._persistent.destroy()\n    await this._rawStreams.clear()\n    await this._socketPool.destroy()\n    await super.destroy()\n  }\n\n  async validateLocalAddresses (addresses) {\n    const list = []\n    const socks = []\n    const waiting = []\n\n    for (const addr of addresses) {\n      const { host } = addr\n\n      if (this._validatedLocalAddresses.has(host)) {\n        if (await this._validatedLocalAddresses.get(host)) {\n          list.push(addr)\n        }\n        continue\n      }\n\n      const sock = this.udx.createSocket()\n      try {\n        sock.bind(0, host)\n      } catch {\n        this._validatedLocalAddresses.set(host, Promise.resolve(false))\n        continue\n      }\n\n      socks.push(sock)\n\n      // semi terrible heuristic until we proper fix local connections by racing them to the remote...\n      const promise = new Promise(resolve => {\n        sock.on('message', () => resolve(true))\n        setTimeout(() => resolve(false), 500)\n        sock.trySend(b4a.alloc(1), sock.address().port, addr.host)\n      })\n\n      this._validatedLocalAddresses.set(host, promise)\n      waiting.push(addr)\n    }\n\n    for (const addr of waiting) {\n      const { host } = addr\n      if (this._validatedLocalAddresses.has(host)) {\n        if (await this._validatedLocalAddresses.get(host)) {\n          list.push(addr)\n        }\n        continue\n      }\n    }\n\n    for (const sock of socks) await sock.close()\n\n    return list\n  }\n\n  findPeer (publicKey, opts = {}) {\n    const target = opts.hash === false ? publicKey : hash(publicKey)\n    opts = { ...opts, map: mapFindPeer }\n    return this.query({ target, command: COMMANDS.FIND_PEER, value: null }, opts)\n  }\n\n  lookup (target, opts = {}) {\n    opts = { ...opts, map: mapLookup }\n    return this.query({ target, command: COMMANDS.LOOKUP, value: null }, opts)\n  }\n\n  lookupAndUnannounce (target, keyPair, opts = {}) {\n    const unannounces = []\n    const dht = this\n    const userCommit = opts.commit || noop\n    const signUnannounce = opts.signUnannounce || Persistent.signUnannounce\n\n    if (this._persistent !== null) { // unlink self\n      this._persistent.unannounce(target, keyPair.publicKey)\n    }\n\n    opts = { ...opts, map, commit }\n    return this.query({ target, command: COMMANDS.LOOKUP, value: null }, opts)\n\n    async function commit (reply, dht, query) {\n      await Promise.all(unannounces) // can never fail, caught below\n      return userCommit(reply, dht, query)\n    }\n\n    function map (reply) {\n      const data = mapLookup(reply)\n\n      if (!data || !data.token) return data\n\n      let found = data.peers.length >= 20\n      for (let i = 0; !found && i < data.peers.length; i++) {\n        found = b4a.equals(data.peers[i].publicKey, keyPair.publicKey)\n      }\n\n      if (!found) return data\n\n      if (!data.from.id) return data\n\n      unannounces.push(\n        dht._requestUnannounce(\n          keyPair,\n          dht,\n          target,\n          data.token,\n          data.from,\n          signUnannounce\n        ).catch(safetyCatch)\n      )\n\n      return data\n    }\n  }\n\n  unannounce (target, keyPair, opts = {}) {\n    return this.lookupAndUnannounce(target, keyPair, opts).finished()\n  }\n\n  announce (target, keyPair, relayAddresses, opts = {}) {\n    const signAnnounce = opts.signAnnounce || Persistent.signAnnounce\n\n    opts = { ...opts, commit }\n\n    return opts.clear\n      ? this.lookupAndUnannounce(target, keyPair, opts)\n      : this.lookup(target, opts)\n\n    function commit (reply, dht) {\n      return dht._requestAnnounce(\n        keyPair,\n        dht,\n        target,\n        reply.token,\n        reply.from,\n        relayAddresses,\n        signAnnounce\n      )\n    }\n  }\n\n  async immutableGet (target, opts = {}) {\n    opts = { ...opts, map: mapImmutable }\n\n    const query = this.query({ target, command: COMMANDS.IMMUTABLE_GET, value: null }, opts)\n    const check = b4a.allocUnsafe(32)\n\n    for await (const node of query) {\n      const { value } = node\n      sodium.crypto_generichash(check, value)\n      if (b4a.equals(check, target)) return node\n    }\n\n    return null\n  }\n\n  async immutablePut (value, opts = {}) {\n    const target = b4a.allocUnsafe(32)\n    sodium.crypto_generichash(target, value)\n\n    opts = {\n      ...opts,\n      map: mapImmutable,\n      commit (reply, dht) {\n        return dht.request({ token: reply.token, target, command: COMMANDS.IMMUTABLE_PUT, value }, reply.from)\n      }\n    }\n\n    const query = this.query({ target, command: COMMANDS.IMMUTABLE_GET, value: null }, opts)\n    await query.finished()\n\n    return { hash: target, closestNodes: query.closestNodes }\n  }\n\n  async mutableGet (publicKey, opts = {}) {\n    let refresh = opts.refresh || null\n    let signed = null\n    let result = null\n\n    opts = { ...opts, map: mapMutable, commit: refresh ? commit : null }\n\n    const target = b4a.allocUnsafe(32)\n    sodium.crypto_generichash(target, publicKey)\n\n    const userSeq = opts.seq || 0\n    const query = this.query({ target, command: COMMANDS.MUTABLE_GET, value: c.encode(c.uint, userSeq) }, opts)\n    const latest = opts.latest !== false\n\n    for await (const node of query) {\n      if (result && node.seq <= result.seq) continue\n      if (node.seq < userSeq || !Persistent.verifyMutable(node.signature, node.seq, node.value, publicKey)) continue\n      if (!latest) return node\n      if (!result || node.seq > result.seq) result = node\n    }\n\n    return result\n\n    function commit (reply, dht) {\n      if (!signed && result && refresh) {\n        if (refresh(result)) {\n          signed = c.encode(m.mutablePutRequest, {\n            publicKey,\n            seq: result.seq,\n            value: result.value,\n            signature: result.signature\n          })\n        } else {\n          refresh = null\n        }\n      }\n\n      return signed ? dht.request({ token: reply.token, target, command: COMMANDS.MUTABLE_PUT, value: signed }, reply.from) : Promise.resolve(null)\n    }\n  }\n\n  async mutablePut (keyPair, value, opts = {}) {\n    const signMutable = opts.signMutable || Persistent.signMutable\n\n    const target = b4a.allocUnsafe(32)\n    sodium.crypto_generichash(target, keyPair.publicKey)\n\n    const seq = opts.seq || 0\n    const signature = await signMutable(seq, value, keyPair)\n\n    const signed = c.encode(m.mutablePutRequest, {\n      publicKey: keyPair.publicKey,\n      seq,\n      value,\n      signature\n    })\n\n    opts = {\n      ...opts,\n      map: mapMutable,\n      commit (reply, dht) {\n        return dht.request({ token: reply.token, target, command: COMMANDS.MUTABLE_PUT, value: signed }, reply.from)\n      }\n    }\n\n    // use seq = 0, for the query part here, as we don't care about the actual values\n    const query = this.query({ target, command: COMMANDS.MUTABLE_GET, value: c.encode(c.uint, 0) }, opts)\n    await query.finished()\n\n    return { publicKey: keyPair.publicKey, closestNodes: query.closestNodes, seq, signature }\n  }\n\n  onrequest (req) {\n    switch (req.command) {\n      case COMMANDS.PEER_HANDSHAKE: {\n        this._router.onpeerhandshake(req)\n        return true\n      }\n      case COMMANDS.PEER_HOLEPUNCH: {\n        this._router.onpeerholepunch(req)\n        return true\n      }\n    }\n\n    if (this._persistent === null) return false\n\n    switch (req.command) {\n      case COMMANDS.FIND_PEER: {\n        this._persistent.onfindpeer(req)\n        return true\n      }\n      case COMMANDS.LOOKUP: {\n        this._persistent.onlookup(req)\n        return true\n      }\n      case COMMANDS.ANNOUNCE: {\n        this._persistent.onannounce(req)\n        return true\n      }\n      case COMMANDS.UNANNOUNCE: {\n        this._persistent.onunannounce(req)\n        return true\n      }\n      case COMMANDS.MUTABLE_PUT: {\n        this._persistent.onmutableput(req)\n        return true\n      }\n      case COMMANDS.MUTABLE_GET: {\n        this._persistent.onmutableget(req)\n        return true\n      }\n      case COMMANDS.IMMUTABLE_PUT: {\n        this._persistent.onimmutableput(req)\n        return true\n      }\n      case COMMANDS.IMMUTABLE_GET: {\n        this._persistent.onimmutableget(req)\n        return true\n      }\n    }\n\n    return false\n  }\n\n  static keyPair (seed) {\n    return createKeyPair(seed)\n  }\n\n  static hash (data) {\n    return hash(data)\n  }\n\n  static connectRawStream (encryptedStream, rawStream, remoteId) {\n    const stream = encryptedStream.rawStream\n\n    if (!stream.connected) throw STREAM_NOT_CONNECTED()\n\n    rawStream.connect(\n      stream.socket,\n      remoteId,\n      stream.remotePort,\n      stream.remoteHost\n    )\n  }\n\n  createRawStream (opts) {\n    return this._rawStreams.add(opts)\n  }\n\n  async _requestAnnounce (keyPair, dht, target, token, from, relayAddresses, sign) {\n    const ann = {\n      peer: {\n        publicKey: keyPair.publicKey,\n        relayAddresses: relayAddresses || []\n      },\n      refresh: null,\n      signature: null\n    }\n\n    ann.signature = await sign(target, token, from.id, ann, keyPair)\n\n    const value = c.encode(m.announce, ann)\n\n    return dht.request({\n      token,\n      target,\n      command: COMMANDS.ANNOUNCE,\n      value\n    }, from)\n  }\n\n  async _requestUnannounce (keyPair, dht, target, token, from, sign) {\n    const unann = {\n      peer: {\n        publicKey: keyPair.publicKey,\n        relayAddresses: []\n      },\n      signature: null\n    }\n\n    unann.signature = await sign(target, token, from.id, unann, keyPair)\n\n    const value = c.encode(m.announce, unann)\n\n    return dht.request({\n      token,\n      target,\n      command: COMMANDS.UNANNOUNCE,\n      value\n    }, from)\n  }\n}\n\nHyperDHT.BOOTSTRAP = BOOTSTRAP_NODES\nHyperDHT.FIREWALL = FIREWALL\n\nmodule.exports = HyperDHT\n\nfunction mapLookup (node) {\n  if (!node.value) return null\n\n  try {\n    return {\n      token: node.token,\n      from: node.from,\n      to: node.to,\n      peers: c.decode(m.peers, node.value)\n    }\n  } catch {\n    return null\n  }\n}\n\nfunction mapFindPeer (node) {\n  if (!node.value) return null\n\n  try {\n    return {\n      token: node.token,\n      from: node.from,\n      to: node.to,\n      peer: c.decode(m.peer, node.value)\n    }\n  } catch {\n    return null\n  }\n}\n\nfunction mapImmutable (node) {\n  if (!node.value) return null\n\n  return {\n    token: node.token,\n    from: node.from,\n    to: node.to,\n    value: node.value\n  }\n}\n\nfunction mapMutable (node) {\n  if (!node.value) return null\n\n  try {\n    const { seq, value, signature } = c.decode(m.mutableGetResponse, node.value)\n\n    return {\n      token: node.token,\n      from: node.from,\n      to: node.to,\n      seq,\n      value,\n      signature\n    }\n  } catch {\n    return null\n  }\n}\n\nfunction noop () {}\n\nfunction filterNode (node) {\n  // always skip these testnet nodes that got mixed in by accident, until they get updated\n  return !(node.port === 49738 && (node.host === '134.209.28.98' || node.host === '167.99.142.185')) &&\n    !(node.port === 9400 && node.host === '35.233.47.252') && !(node.host === '150.136.142.116')\n}\n\nconst defaultMaxSize = 65536\nconst defaultMaxAge = 20 * 60 * 1000 // 20 minutes\n\nfunction defaultCacheOpts (opts) {\n  const maxSize = opts.maxSize || defaultMaxSize\n  const maxAge = opts.maxAge || defaultMaxAge\n\n  return {\n    router: {\n      forwards: { maxSize, maxAge }\n    },\n    persistent: {\n      records: { maxSize, maxAge },\n      refreshes: { maxSize, maxAge },\n      mutables: {\n        maxSize: maxSize / 2 | 0,\n        maxAge: opts.maxAge || 48 * 60 * 60 * 1000 // 48 hours\n      },\n      immutables: {\n        maxSize: maxSize / 2 | 0,\n        maxAge: opts.maxAge || 48 * 60 * 60 * 1000 // 48 hours\n      }\n    }\n  }\n}\nconst safetyCatch = require('safety-catch')\nconst c = require('compact-encoding')\nconst Signal = require('signal-promise')\nconst { encodeUnslab } = require('./encode')\nconst Sleeper = require('./sleeper')\nconst m = require('./messages')\nconst Persistent = require('./persistent')\nconst { COMMANDS } = require('./constants')\n\nconst MIN_ACTIVE = 3\n\nmodule.exports = class Announcer {\n  constructor (dht, keyPair, target, opts = {}) {\n    this.dht = dht\n    this.keyPair = keyPair\n    this.target = target\n    this.relays = []\n    this.relayAddresses = []\n    this.stopped = false\n    this.suspended = false\n    this.record = encodeUnslab(m.peer, { publicKey: keyPair.publicKey, relayAddresses: [] })\n    this.online = new Signal()\n\n    this._refreshing = false\n    this._closestNodes = null\n    this._active = null\n    this._sleeper = new Sleeper()\n    this._resumed = new Signal()\n    this._signAnnounce = opts.signAnnounce || Persistent.signAnnounce\n    this._signUnannounce = opts.signUnannounce || Persistent.signUnannounce\n    this._updating = null\n    this._activeQuery = null\n    this._unannouncing = null\n\n    this._serverRelays = [\n      new Map(),\n      new Map(),\n      new Map()\n    ]\n  }\n\n  isRelay (addr) {\n    const id = addr.host + ':' + addr.port\n    const [a, b, c] = this._serverRelays\n    return a.has(id) || b.has(id) || c.has(id)\n  }\n\n  async suspend () {\n    if (this.suspended) return\n    this.suspended = true\n\n    // Suspend has its own sleep logic\n    // so we don't want to hang on this one\n    this.online.notify()\n\n    if (this._activeQuery) this._activeQuery.destroy()\n\n    this._sleeper.resume()\n    if (this._updating) await this._updating\n\n    if (this.suspended === false || this.stopped) return\n    await this._unannounceCurrent()\n  }\n\n  resume () {\n    if (!this.suspended) return\n    this.suspended = false\n\n    this.refresh()\n    this._sleeper.resume()\n    this._resumed.notify()\n  }\n\n  refresh () {\n    if (this.stopped) return\n    this._refreshing = true\n  }\n\n  async start () {\n    if (this.stopped) return\n    this._active = this._runUpdate()\n    await this._active\n    if (this.stopped) return\n    this._active = this._background()\n  }\n\n  async stop () {\n    this.stopped = true\n    this.online.notify() // Break out of the _background loop if we're offline\n    this._sleeper.resume()\n    this._resumed.notify()\n    await this._active\n    await this._unannounceCurrent()\n  }\n\n  async _unannounceCurrent () {\n    while (this._unannouncing !== null) await this._unannouncing\n    const un = this._unannouncing = this._unannounceAll(this._serverRelays[2].values())\n    await this._unannouncing\n    if (un === this._unannouncing) this._unannouncing = null\n  }\n\n  async _background () {\n    while (!this.dht.destroyed && !this.stopped) {\n      try {\n        this._refreshing = false\n\n        // ~5min +-\n        for (let i = 0; i < 100 && !this.stopped && !this._refreshing && !this.suspended; i++) {\n          const pings = []\n\n          for (const node of this._serverRelays[2].values()) {\n            pings.push(this.dht.ping(node))\n          }\n\n          const active = await resolved(pings)\n          if (active < Math.min(pings.length, MIN_ACTIVE)) {\n            this.refresh() // we lost too many relay nodes, retry all\n          }\n\n          if (this.stopped) return\n\n          if (!this.suspended && !this._refreshing) await this._sleeper.pause(3000)\n        }\n\n        while (!this.stopped && this.suspended) await this._resumed.wait()\n\n        if (!this.stopped) await this._runUpdate()\n\n        while (!this.dht.online && !this.stopped && !this.suspended) {\n          // Being offline can make _background repeat very quickly\n          // So wait until we're back online\n          await this.online.wait()\n        }\n      } catch (err) {\n        safetyCatch(err)\n      }\n    }\n  }\n\n  async _runUpdate () {\n    this._updating = this._update()\n    await this._updating\n    this._updating = null\n  }\n\n  async _update () {\n    while (this._unannouncing) await this._unannouncing\n\n    this._cycle()\n\n    const q = this._activeQuery = this.dht.findPeer(this.target, { hash: false, nodes: this._closestNodes })\n\n    try {\n      await q.finished()\n    } catch {\n      // ignore failures...\n    }\n\n    this._activeQuery = null\n\n    if (this.stopped || this.suspended) return\n\n    const ann = []\n    const replies = pickBest(q.closestReplies)\n\n    const relays = []\n    const relayAddresses = []\n\n    if (!this.dht.firewalled) {\n      const addr = this.dht.remoteAddress()\n      if (addr) relayAddresses.push(addr)\n    }\n\n    for (const msg of replies) {\n      ann.push(this._commit(msg, relays, relayAddresses))\n    }\n\n    await Promise.allSettled(ann)\n    if (this.stopped || this.suspended) return\n\n    this._closestNodes = q.closestNodes\n    this.relays = relays\n    this.relayAddresses = relayAddresses\n\n    const removed = []\n    for (const [key, value] of this._serverRelays[1]) {\n      if (!this._serverRelays[2].has(key)) removed.push(value)\n    }\n\n    await this._unannounceAll(removed)\n  }\n\n  _unannounceAll (relays) {\n    const unann = []\n    for (const r of relays) unann.push(this._unannounce(r))\n    return Promise.allSettled(unann)\n  }\n\n  async _unannounce (to) {\n    const unann = {\n      peer: {\n        publicKey: this.keyPair.publicKey,\n        relayAddresses: []\n      },\n      refresh: null,\n      signature: null\n    }\n\n    const { from, token, value } = await this.dht.request({\n      token: null,\n      command: COMMANDS.FIND_PEER,\n      target: this.target,\n      value: null\n    }, to)\n\n    if (!token || !from.id || !value) return\n\n    unann.signature = await this._signUnannounce(this.target, token, from.id, unann, this.keyPair)\n\n    await this.dht.request({\n      token,\n      command: COMMANDS.UNANNOUNCE,\n      target: this.target,\n      value: c.encode(m.announce, unann)\n    }, to)\n  }\n\n  async _commit (msg, relays, relayAddresses) {\n    const ann = {\n      peer: {\n        publicKey: this.keyPair.publicKey,\n        relayAddresses: []\n      },\n      refresh: null,\n      signature: null\n    }\n\n    ann.signature = await this._signAnnounce(this.target, msg.token, msg.from.id, ann, this.keyPair)\n\n    const res = await this.dht.request({\n      token: msg.token,\n      command: COMMANDS.ANNOUNCE,\n      target: this.target,\n      value: c.encode(m.announce, ann)\n    }, msg.from)\n\n    if (res.error !== 0) return\n\n    if (relayAddresses.length < 3) relayAddresses.push({ host: msg.from.host, port: msg.from.port })\n    relays.push({ relayAddress: msg.from, peerAddress: msg.to })\n\n    this._serverRelays[2].set(msg.from.host + ':' + msg.from.port, msg.from)\n  }\n\n  _cycle () {\n    const tmp = this._serverRelays[0]\n    this._serverRelays[0] = this._serverRelays[1]\n    this._serverRelays[1] = this._serverRelays[2]\n    this._serverRelays[2] = tmp\n    tmp.clear()\n  }\n}\n\nfunction resolved (ps) {\n  let replied = 0\n  let ticks = ps.length + 1\n\n  return new Promise((resolve) => {\n    for (const p of ps) p.then(push, tick)\n    tick()\n\n    function push (v) {\n      replied++\n      tick()\n    }\n\n    function tick () {\n      if (--ticks === 0) resolve(replied)\n    }\n  })\n}\n\nfunction pickBest (replies) { // TODO: pick the ones closest to us RTT wise\n  return replies.slice(0, 3)\n}\nconst NoiseSecretStream = require('@hyperswarm/secret-stream')\nconst b4a = require('b4a')\nconst relay = require('blind-relay')\nconst { isPrivate, isBogon } = require('bogon')\nconst safetyCatch = require('safety-catch')\nconst unslab = require('unslab')\nconst Semaphore = require('./semaphore')\nconst NoiseWrap = require('./noise-wrap')\nconst SecurePayload = require('./secure-payload')\nconst Holepuncher = require('./holepuncher')\nconst Sleeper = require('./sleeper')\nconst { FIREWALL, ERROR } = require('./constants')\nconst { unslabbedHash } = require('./crypto')\nconst {\n  CANNOT_HOLEPUNCH,\n  HANDSHAKE_INVALID,\n  HOLEPUNCH_ABORTED,\n  HOLEPUNCH_INVALID,\n  HOLEPUNCH_PROBE_TIMEOUT,\n  HOLEPUNCH_DOUBLE_RANDOMIZED_NATS,\n  PEER_CONNECTION_FAILED,\n  PEER_NOT_FOUND,\n  REMOTE_ABORTED,\n  REMOTE_NOT_HOLEPUNCHABLE,\n  REMOTE_NOT_HOLEPUNCHING,\n  SERVER_ERROR,\n  SERVER_INCOMPATIBLE,\n  RELAY_ABORTED,\n  SUSPENDED\n} = require('./errors')\n\nmodule.exports = function connect (dht, publicKey, opts = {}) {\n  const pool = opts.pool || null\n\n  if (pool && pool.has(publicKey)) return pool.get(publicKey)\n\n  publicKey = unslab(publicKey)\n\n  const keyPair = opts.keyPair || dht.defaultKeyPair\n  const relayThrough = selectRelay(opts.relayThrough || null)\n  const encryptedSocket = (opts.createSecretStream || defaultCreateSecretStream)(true, null, {\n    publicKey: keyPair.publicKey,\n    remotePublicKey: publicKey,\n    autoStart: false,\n    keepAlive: dht.connectionKeepAlive\n  })\n\n  // in case a socket is made during suspended state, destroy it immediately\n  if (dht.suspended) {\n    encryptedSocket.destroy(SUSPENDED())\n    return encryptedSocket\n  }\n\n  if (pool) pool._attachStream(encryptedSocket, false)\n\n  const c = {\n    dht,\n    session: dht.session(),\n    relayAddresses: opts.relayAddresses || [],\n    pool,\n    round: 0,\n    target: unslabbedHash(publicKey),\n    remotePublicKey: publicKey,\n    reusableSocket: !!opts.reusableSocket,\n    handshake: (opts.createHandshake || defaultCreateHandshake)(keyPair, publicKey),\n    request: null,\n    requesting: false,\n    lan: opts.localConnection !== false,\n    firewall: FIREWALL.UNKNOWN,\n    rawStream: dht.createRawStream({ framed: true, firewall }),\n    connect: null,\n    query: null,\n    puncher: null,\n    payload: null,\n    passiveConnectTimeout: null,\n    serverSocket: null,\n    serverAddress: null,\n    onsocket: null,\n    sleeper: new Sleeper(),\n    encryptedSocket,\n\n    // Relay state\n    relayTimeout: null,\n    relayThrough,\n    relayToken: relayThrough ? relay.token() : null,\n    relaySocket: null,\n    relayClient: null,\n    relayPaired: false,\n    relayKeepAlive: opts.relayKeepAlive || 5000\n  }\n\n  // If the raw stream receives an error signal pre connect (ie from the firewall hook), make sure\n  // to forward that to the encrypted socket for proper teardown\n  c.rawStream.on('error', autoDestroy)\n  c.rawStream.once('connect', () => {\n    c.rawStream.removeListener('error', autoDestroy)\n  })\n\n  encryptedSocket.on('close', function () {\n    if (c.passiveConnectTimeout) clearPassiveConnectTimeout(c)\n    if (c.query) c.query.destroy()\n    if (c.puncher) c.puncher.destroy()\n    if (c.rawStream) c.rawStream.destroy()\n    c.session.destroy()\n    c.sleeper.resume()\n  })\n\n  // Safe to run in the background - never throws\n  if (dht.suspended) encryptedSocket.destroy(SUSPENDED())\n  else connectAndHolepunch(c, opts)\n\n  return encryptedSocket\n\n  function autoDestroy (err) {\n    maybeDestroyEncryptedSocket(c, err)\n  }\n\n  function firewall (socket, port, host) {\n    // Check if the traffic originated from the socket on which we're expecting relay traffic. If so,\n    // we haven't hole punched yet and the other side is just sending us traffic through the relay.\n    if (c.relaySocket && isRelay(c.relaySocket, socket, port, host)) {\n      return false\n    }\n\n    if (c.onsocket) {\n      c.onsocket(socket, port, host)\n    } else {\n      c.serverSocket = socket\n      c.serverAddress = { port, host }\n    }\n    return false\n  }\n}\n\nfunction isDone (c) {\n  // we are destroying or the puncher is connected - done\n  if (c.encryptedSocket.destroying || !!(c.puncher && c.puncher.connected)) {\n    return true\n  }\n  // not destroying, but no raw stream - def not done\n  if (c.encryptedSocket.rawStream === null) {\n    return false\n  }\n  // we are relayed, but the puncher is not done yet\n  if (c.relaySocket && !!(c.puncher && !c.puncher.connected && !c.puncher.destroyed)) {\n    return false\n  }\n  // we are done\n  return true\n}\n\nasync function retryRoute (c, route) {\n  const ref = c.dht._socketPool.lookup(route.socket)\n\n  if (!ref) {\n    if (route.socket === c.dht.socket) {\n      await connectThroughNode(c, route.address, c.dht.socket)\n    }\n    return\n  }\n\n  ref.active()\n\n  try {\n    await connectThroughNode(c, route.address, route.socket)\n  } catch {\n    // if error, just ignore, and continue through the existing strat\n  }\n\n  ref.inactive()\n}\n\nasync function connectAndHolepunch (c, opts) {\n  const route = c.reusableSocket ? c.dht._socketPool.routes.get(c.remotePublicKey) : null\n\n  if (route) {\n    await retryRoute(c, route)\n    if (isDone(c)) return\n  }\n\n  await findAndConnect(c, opts)\n  if (isDone(c)) return\n\n  if (!c.connect) { // TODO: just a quick fix for now, should retry prob\n    maybeDestroyEncryptedSocket(c, HANDSHAKE_INVALID())\n    return\n  }\n\n  await holepunch(c, opts)\n}\n\nfunction getFirstRemoteAddress (addrs, serverAddress) {\n  for (const addr of addrs) {\n    if (isBogon(addr.host)) continue\n    return addr\n  }\n\n  return serverAddress\n}\n\nasync function holepunch (c, opts) {\n  let { relayAddress, serverAddress, clientAddress, payload } = c.connect\n\n  const remoteHolepunchable = !!(payload.holepunch && payload.holepunch.relays.length)\n\n  const relayed = diffAddress(serverAddress, relayAddress)\n\n  if (payload.firewall === FIREWALL.OPEN || (relayed && !remoteHolepunchable)) {\n    const addr = getFirstRemoteAddress(payload.addresses4, serverAddress)\n    if (addr) {\n      const socket = c.dht.socket\n      c.dht.stats.punches.open++\n      c.onsocket(socket, addr.port, addr.host)\n      return\n    }\n    // TODO: check all addresses also obvs\n  }\n\n  const onabort = () => {\n    c.session.destroy()\n    maybeDestroyEncryptedSocket(c, HOLEPUNCH_ABORTED())\n  }\n\n  if (c.firewall === FIREWALL.OPEN) {\n    c.passiveConnectTimeout = setTimeout(onabort, 10000)\n    return\n  }\n\n  // TODO: would be better to just try local addrs in the background whilst continuing with other strategies...\n  if (c.lan && relayed && clientAddress.host === serverAddress.host) {\n    const serverAddresses = payload.addresses4.filter(onlyPrivateHosts)\n\n    if (serverAddresses.length > 0) {\n      const myAddresses = Holepuncher.localAddresses(c.dht.io.serverSocket)\n      const addr = Holepuncher.matchAddress(myAddresses, serverAddresses) || serverAddresses[0]\n\n      const socket = c.dht.io.serverSocket\n      try {\n        await c.dht.ping(addr)\n      } catch {\n        maybeDestroyEncryptedSocket(c, HOLEPUNCH_ABORTED())\n        return\n      }\n      c.onsocket(socket, addr.port, addr.host)\n      return\n    }\n  }\n\n  if (!remoteHolepunchable) {\n    maybeDestroyEncryptedSocket(c, CANNOT_HOLEPUNCH())\n    return\n  }\n\n  c.puncher = new Holepuncher(c.dht, c.session, true, payload.firewall)\n\n  c.puncher.onconnect = c.onsocket\n  c.puncher.onabort = onabort\n\n  const serverRelay = pickServerRelay(payload.holepunch.relays, relayAddress)\n\n  // Begin holepunching!\n\n  let probe\n  try {\n    probe = await probeRound(c, opts.fastOpen === false ? null : serverAddress, serverRelay, true)\n  } catch (err) {\n    destroyPuncher(c)\n    // TODO: we should retry here with some of the other relays, bail for now\n    maybeDestroyEncryptedSocket(c, err)\n    return\n  }\n\n  if (isDone(c) || !probe) return\n  const { token, peerAddress } = probe\n\n  // If the relay the server picked is the same as the relay the client picked,\n  // then we can use the peerAddress that round one indicates the server wants to use.\n  // This shaves off a roundtrip if the server chose to reroll its socket due to some NAT\n  // issue with the first one it picked (ie mobile nat inconsistencies...).\n  // If the relays were different, then the server would not have a UDP session open on this address\n  // to the client relay, which round2 uses.\n  if (!diffAddress(serverRelay.relayAddress, relayAddress) && diffAddress(serverAddress, peerAddress)) {\n    serverAddress = peerAddress\n    await c.puncher.openSession(serverAddress)\n    if (isDone(c)) return\n  }\n\n  // TODO: still continue here if a local connection might work, but then do not holepunch...\n  if (opts.holepunch && !opts.holepunch(c.puncher.remoteFirewall, c.puncher.nat.firewall, c.puncher.remoteAddresses, c.puncher.nat.addresses)) {\n    await abort(c, serverRelay, HOLEPUNCH_ABORTED('Client aborted holepunch'))\n    return\n  }\n\n  try {\n    await roundPunch(c, serverAddress, token, relayAddress, serverRelay, false)\n  } catch (err) {\n    destroyPuncher(c)\n    // TODO: retry with another relay?\n    maybeDestroyEncryptedSocket(c, err)\n  }\n}\n\nasync function findAndConnect (c, opts) {\n  let attempts = 0\n  let closestNodes = (opts.relayAddresses && opts.relayAddresses.length) ? opts.relayAddresses : null\n\n  if (c.dht._persistent) { // check if we know the route ourself...\n    const route = c.dht._router.get(c.target)\n    if (route && route.relay !== null) closestNodes = [{ host: route.relay.host, port: route.relay.port }]\n  }\n\n  // 2 is how many parallel connect attempts we want to do, we can make this configurable\n  const sem = new Semaphore(2)\n  const signal = sem.signal.bind(sem)\n  const tries = closestNodes !== null ? 2 : 1\n\n  try {\n    for (let i = 0; i < tries && !isDone(c) && !c.connect; i++) {\n      c.query = c.dht.findPeer(c.target, { hash: false, session: c.session, closestNodes, onlyClosestNodes: closestNodes !== null })\n\n      for await (const data of c.query) {\n        await sem.wait()\n        if (isDone(c)) return\n\n        if (c.connect) {\n          sem.signal()\n          break\n        }\n\n        attempts++\n        connectThroughNode(c, data.from, null).then(signal, signal)\n      }\n\n      closestNodes = null\n    }\n\n    c.query = null\n    if (isDone(c)) return\n\n    // flush the semaphore\n    await sem.flush()\n    if (isDone(c)) return\n  } catch (err) {\n    c.query = null\n    maybeDestroyEncryptedSocket(c, err)\n    return\n  }\n\n  if (!c.connect) {\n    maybeDestroyEncryptedSocket(c, attempts ? PEER_CONNECTION_FAILED() : PEER_NOT_FOUND())\n  }\n}\n\nasync function connectThroughNode (c, address, socket) {\n  if (!c.requesting) {\n    // If we have a stable server address, send it over now\n    const addr = c.dht.remoteAddress()\n    const localAddrs = c.lan ? Holepuncher.localAddresses(c.dht.io.serverSocket) : null\n    const addresses4 = []\n\n    if (addr) addresses4.push(addr)\n    if (localAddrs) addresses4.push(...localAddrs)\n\n    c.firewall = addr ? FIREWALL.OPEN : FIREWALL.UNKNOWN\n    c.requesting = true\n    c.request = await c.handshake.send({\n      error: ERROR.NONE,\n      firewall: c.firewall,\n      holepunch: null,\n      addresses4,\n      addresses6: [],\n      udx: {\n        reusableSocket: c.reusableSocket,\n        id: c.rawStream.id,\n        seq: 0\n      },\n      secretStream: {},\n      relayThrough: c.relayThrough\n        ? { publicKey: c.relayThrough, token: c.relayToken }\n        : null\n    })\n    if (isDone(c)) return\n  }\n\n  const { serverAddress, clientAddress, relayed, noise } = await c.dht._router.peerHandshake(c.target, { noise: c.request, socket, session: c.session }, address)\n  if (isDone(c) || c.connect) return\n\n  const payload = await c.handshake.recv(noise)\n  if (isDone(c) || !payload) return\n\n  if (payload.version !== 1) {\n    maybeDestroyEncryptedSocket(c, SERVER_INCOMPATIBLE())\n    return\n  }\n  if (payload.error !== ERROR.NONE) {\n    maybeDestroyEncryptedSocket(c, SERVER_ERROR())\n    return\n  }\n  if (!payload.udx) {\n    maybeDestroyEncryptedSocket(c, SERVER_ERROR('Server did not send UDX data'))\n    return\n  }\n\n  const hs = c.handshake.final()\n\n  c.handshake = null\n  c.request = null\n  c.requesting = false\n  c.connect = {\n    relayed,\n    relayAddress: address,\n    clientAddress,\n    serverAddress,\n    payload\n  }\n\n  c.payload = new SecurePayload(hs.holepunchSecret)\n\n  c.onsocket = function (socket, port, host) {\n    if (c.rawStream === null) return // Already hole punched\n\n    if (c.rawStream.connected) {\n      const remoteChanging = c.rawStream.changeRemote(socket, c.connect.payload.udx.id, port, host)\n\n      if (remoteChanging) remoteChanging.catch(safetyCatch)\n    } else {\n      c.rawStream.connect(socket, c.connect.payload.udx.id, port, host)\n      c.encryptedSocket.start(c.rawStream, { handshake: hs })\n    }\n\n    if (c.reusableSocket && payload.udx.reusableSocket) {\n      c.dht._socketPool.routes.add(c.remotePublicKey, c.rawStream)\n    }\n\n    if (c.puncher) {\n      c.puncher.onabort = noop\n      c.puncher.destroy()\n    }\n\n    if (c.passiveConnectTimeout) {\n      clearPassiveConnectTimeout(c)\n    }\n\n    c.rawStream = null\n  }\n\n  if (payload.relayThrough || c.relayThrough) {\n    relayConnection(c, c.relayThrough, payload, hs)\n  }\n\n  if (c.serverSocket) {\n    c.onsocket(c.serverSocket, c.serverAddress.port, c.serverAddress.host)\n    return\n  }\n\n  if (!relayed) {\n    c.onsocket(socket || c.dht.socket, address.port, address.host)\n  }\n\n  c.session.destroy()\n}\n\nasync function updateHolepunch (c, peerAddress, relayAddr, payload) {\n  const holepunch = await c.dht._router.peerHolepunch(c.target, {\n    id: c.connect.payload.holepunch.id,\n    payload: c.payload.encrypt(payload),\n    peerAddress,\n    socket: c.puncher.socket,\n    session: c.session\n  }, relayAddr)\n\n  if (isDone(c)) return null\n\n  const remotePayload = c.payload.decrypt(holepunch.payload)\n  if (!remotePayload) {\n    throw HOLEPUNCH_INVALID()\n  }\n\n  const { error, firewall, punching, addresses, remoteToken } = remotePayload\n\n  if (error === ERROR.TRY_LATER && c.relayToken && payload.punching) {\n    return {\n      tryLater: true,\n      ...holepunch,\n      payload: remotePayload\n    }\n  }\n\n  if (error !== ERROR.NONE) {\n    throw REMOTE_ABORTED('Remote aborted with error code ' + error)\n  }\n\n  const echoed = !!(remoteToken && payload.token && b4a.equals(remoteToken, payload.token))\n\n  c.puncher.updateRemote({ punching, firewall, addresses, verified: echoed ? peerAddress.host : null })\n\n  return {\n    tryLater: false,\n    ...holepunch,\n    payload: remotePayload\n  }\n}\n\nasync function probeRound (c, serverAddress, serverRelay, retry) {\n  // Open a quick low ttl session against what we think is the server\n  if (serverAddress) await c.puncher.openSession(serverAddress)\n\n  if (isDone(c)) return null\n\n  const reply = await updateHolepunch(c, serverRelay.peerAddress, serverRelay.relayAddress, {\n    error: ERROR.NONE,\n    firewall: c.puncher.nat.firewall,\n    round: c.round++,\n    connected: false,\n    punching: false,\n    addresses: c.puncher.nat.addresses,\n    remoteAddress: serverAddress,\n    token: null,\n    remoteToken: null\n  })\n\n  if (isDone(c) || !reply) return null\n\n  const { peerAddress } = reply\n  const { address, token } = reply.payload\n\n  c.puncher.nat.add(reply.to, reply.from)\n\n  // Open another quick low ttl session against what the server says their address is,\n  // if they haven't said they are random yet\n  if (c.puncher.remoteFirewall < FIREWALL.RANDOM && address && address.host && address.port && diffAddress(address, serverAddress)) {\n    await c.puncher.openSession(address)\n    if (isDone(c)) return null\n  }\n\n  // If the remote told us they didn't know their nat firewall yet, give them a chance to figure it out\n  // They might say this to see if the \"fast mode\" punch comes through first.\n  if (c.puncher.remoteFirewall === FIREWALL.UNKNOWN) {\n    await c.sleeper.pause(1000)\n    if (isDone(c)) return null\n  }\n\n  let stable = await c.puncher.analyze(false)\n  if (isDone(c)) return null\n\n  // If the socket seems unstable, try to make it stable by setting the \"allowReopen\" flag\n  // Mostly relevant for mobile networks\n  if (!stable) {\n    stable = await c.puncher.analyze(true)\n    if (isDone(c)) return null\n    if (stable) return probeRound(c, serverAddress, serverRelay, false)\n  }\n\n  if ((c.puncher.remoteFirewall === FIREWALL.UNKNOWN || !token) && retry) {\n    return probeRound(c, serverAddress, serverRelay, false)\n  }\n\n  if (c.puncher.remoteFirewall === FIREWALL.UNKNOWN || c.puncher.nat.firewall === FIREWALL.UNKNOWN) {\n    await abort(c, serverRelay, HOLEPUNCH_PROBE_TIMEOUT())\n    return null\n  }\n\n  if (c.puncher.remoteFirewall >= FIREWALL.RANDOM && c.puncher.nat.firewall >= FIREWALL.RANDOM) {\n    await abort(c, serverRelay, HOLEPUNCH_DOUBLE_RANDOMIZED_NATS())\n    return null\n  }\n\n  return { token, peerAddress }\n}\n\nasync function roundPunch (c, serverAddress, remoteToken, clientRelay, serverRelay, delayed) {\n  // We are gossiping our final NAT status to the other peer now\n  // so make sure we don't update our local view for now as that can make things weird\n  c.puncher.nat.freeze()\n\n  const isRandom = c.puncher.remoteFirewall >= FIREWALL.RANDOM || c.puncher.nat.firewall >= FIREWALL.RANDOM\n  if (isRandom) {\n    while (c.dht._randomPunches >= c.dht._randomPunchLimit || (Date.now() - c.dht._lastRandomPunch) < c.dht._randomPunchInterval) {\n      // if no relay can help, bail\n      if (!c.relayToken) throw HOLEPUNCH_ABORTED()\n\n      if (!delayed) {\n        delayed = true\n        await updateHolepunch(c, serverAddress, clientRelay, {\n          error: ERROR.NONE,\n          firewall: c.puncher.nat.firewall,\n          round: c.round++,\n          connected: false,\n          punching: false,\n          addresses: c.puncher.nat.addresses,\n          remoteAddress: null,\n          token: c.payload.token(serverAddress),\n          remoteToken\n        })\n        if (isDone(c)) return\n      }\n\n      await tryLater(c)\n      if (isDone(c)) return\n    }\n  }\n\n  // increment now, so we can commit to punching\n  if (isRandom) c.dht._randomPunches++\n\n  let reply\n\n  try {\n    // if delayed switch to the servers chosen relay - we validated anyway\n    reply = await updateHolepunch(c, delayed ? serverRelay.peerAddress : serverAddress, delayed ? serverRelay.relayAddress : clientRelay, {\n      error: ERROR.NONE,\n      firewall: c.puncher.nat.firewall,\n      round: c.round++,\n      connected: false,\n      punching: true,\n      addresses: c.puncher.nat.addresses,\n      remoteAddress: null,\n      token: delayed ? null : c.payload.token(serverAddress),\n      remoteToken\n    })\n  } finally {\n    // decrement as punch increments for us\n    if (isRandom) c.dht._randomPunches--\n  }\n\n  if (isDone(c)) return\n  if (!reply) return\n\n  if (reply.tryLater) {\n    await tryLater(c)\n    if (isDone(c)) return\n    return roundPunch(c, serverAddress, remoteToken, clientRelay, serverRelay, true)\n  }\n\n  if (!c.puncher.remoteHolepunching) {\n    throw REMOTE_NOT_HOLEPUNCHING()\n  }\n\n  if (!await c.puncher.punch()) {\n    throw REMOTE_NOT_HOLEPUNCHABLE()\n  }\n}\n\nasync function tryLater (c) {\n  if (!c.relayToken) throw HOLEPUNCH_ABORTED()\n  await c.sleeper.pause(10000 + Math.round(Math.random() * 10000))\n}\n\nfunction maybeDestroyEncryptedSocket (c, err) {\n  if (isDone(c)) return\n  if (c.encryptedSocket.rawStream) return\n  if (c.relaySocket) return // waiting for the relay\n  if (c.puncher && !c.puncher.destroyed) return // waiting for the puncher\n  c.session.destroy()\n  c.encryptedSocket.destroy(err)\n}\n\nasync function abort (c, { peerAddress, relayAddress }, err) {\n  try {\n    await updateHolepunch(peerAddress, relayAddress, {\n      error: ERROR.ABORTED,\n      firewall: FIREWALL.UNKNOWN,\n      round: c.round++,\n      connected: false,\n      punching: false,\n      addresses: null,\n      remoteAddress: null,\n      token: null,\n      remoteToken: null\n    })\n  } catch {}\n\n  destroyPuncher(c)\n  maybeDestroyEncryptedSocket(c, err)\n}\n\nfunction relayConnection (c, relayThrough, payload, hs) {\n  let isInitiator\n  let publicKey\n  let token\n\n  if (payload.relayThrough) {\n    isInitiator = false\n    publicKey = payload.relayThrough.publicKey\n    token = payload.relayThrough.token\n  } else {\n    isInitiator = true\n    publicKey = relayThrough\n    token = c.relayToken\n  }\n\n  c.relayToken = token\n  c.relaySocket = c.dht.connect(publicKey)\n  c.relaySocket.setKeepAlive(c.relayKeepAlive)\n  c.relayClient = relay.Client.from(c.relaySocket, { id: c.relaySocket.publicKey })\n  c.relayTimeout = setTimeout(onabort, 15000, null)\n\n  c.relayClient\n    .pair(isInitiator, token, c.rawStream)\n    .on('error', onabort)\n    .on('data', ondata)\n\n  function ondata (remoteId) {\n    if (c.relayTimeout) clearRelayTimeout(c)\n    if (c.rawStream === null) {\n      onabort(null)\n      return\n    }\n\n    c.relayPaired = true\n\n    const {\n      remotePort,\n      remoteHost,\n      socket\n    } = c.relaySocket.rawStream\n\n    c.rawStream\n      .on('close', () => c.relaySocket.destroy())\n      .connect(socket, remoteId, remotePort, remoteHost)\n\n    c.encryptedSocket.start(c.rawStream, { handshake: hs })\n  }\n\n  function onabort (err) {\n    if (c.relayTimeout) clearRelayTimeout(c)\n    const socket = c.relaySocket\n    c.relayToken = null\n    c.relaySocket = null\n    if (socket) socket.destroy()\n    maybeDestroyEncryptedSocket(c, err || RELAY_ABORTED())\n  }\n}\n\nfunction clearPassiveConnectTimeout (c) {\n  clearTimeout(c.passiveConnectTimeout)\n  c.passiveConnectTimeout = null\n}\n\nfunction clearRelayTimeout (c) {\n  clearTimeout(c.relayTimeout)\n  c.relayTimeout = null\n}\n\nfunction destroyPuncher (c) {\n  if (c.puncher) c.puncher.destroy()\n  c.session.destroy()\n}\n\nfunction pickServerRelay (relays, clientRelay) {\n  for (const r of relays) {\n    if (!diffAddress(r.relayAddress, clientRelay)) return r\n  }\n  return relays[0]\n}\n\nfunction diffAddress (a, b) {\n  return a.host !== b.host || a.port !== b.port\n}\n\nfunction defaultCreateHandshake (keyPair, remotePublicKey) {\n  return new NoiseWrap(keyPair, remotePublicKey)\n}\n\nfunction defaultCreateSecretStream (isInitiator, rawStream, opts) {\n  return new NoiseSecretStream(isInitiator, rawStream, opts)\n}\n\nfunction onlyPrivateHosts (addr) {\n  return isPrivate(addr.host)\n}\n\nfunction isRelay (relaySocket, socket, port, host) {\n  const stream = relaySocket.rawStream\n  if (!stream) return false\n  if (stream.socket !== socket) return false\n  return port === stream.remotePort && host === stream.remoteHost\n}\n\nfunction selectRelay (relayThrough) {\n  if (typeof relayThrough === 'function') relayThrough = relayThrough()\n  if (relayThrough === null) return null\n  if (Array.isArray(relayThrough)) return relayThrough[Math.floor(Math.random() * relayThrough.length)]\n  return relayThrough\n}\n\nfunction noop () {}\nconst EventEmitter = require('events')\nconst b4a = require('b4a')\nconst errors = require('./errors')\n\nmodule.exports = class ConnectionPool extends EventEmitter {\n  constructor (dht) {\n    super()\n\n    this._dht = dht\n    this._servers = new Map()\n    this._connecting = new Map()\n    this._connections = new Map()\n  }\n\n  _attachServer (server) {\n    const keyString = b4a.toString(server.publicKey, 'hex')\n\n    this._servers.set(keyString, server)\n\n    server\n      .on('close', () => {\n        this._servers.delete(keyString)\n      })\n      .on('connection', (socket) => {\n        this._attachStream(socket, true)\n      })\n  }\n\n  _attachStream (stream, opened) {\n    const existing = this.get(stream.remotePublicKey)\n\n    if (existing) {\n      const keepNew = stream.isInitiator === existing.isInitiator || b4a.compare(stream.publicKey, stream.remotePublicKey) > 0\n\n      if (keepNew) {\n        let closed = false\n\n        const onclose = () => {\n          closed = true\n        }\n\n        existing\n          .on('error', noop)\n          .on('close', () => {\n            if (closed) return\n\n            stream\n              .off('error', noop)\n              .off('close', onclose)\n\n            this._attachStream(stream, opened)\n          })\n          .destroy(errors.DUPLICATE_CONNECTION())\n\n        stream\n          .on('error', noop)\n          .on('close', onclose)\n      } else {\n        stream\n          .on('error', noop)\n          .destroy(errors.DUPLICATE_CONNECTION())\n      }\n\n      return\n    }\n\n    const session = new ConnectionRef(this, stream)\n\n    const keyString = b4a.toString(stream.remotePublicKey, 'hex')\n\n    if (opened) {\n      this._connections.set(keyString, session)\n\n      stream.on('close', () => {\n        this._connections.delete(keyString)\n      })\n\n      this.emit('connection', stream, session)\n    } else {\n      this._connecting.set(keyString, session)\n\n      stream\n        .on('error', noop)\n        .on('close', () => {\n          if (opened) this._connections.delete(keyString)\n          else this._connecting.delete(keyString)\n        })\n        .on('open', () => {\n          opened = true\n\n          this._connecting.delete(keyString)\n          this._connections.set(keyString, session)\n\n          stream.off('error', noop)\n\n          this.emit('connection', stream, session)\n        })\n    }\n\n    return session\n  }\n\n  get connecting () {\n    return this._connecting.size\n  }\n\n  get connections () {\n    return this._connections.values()\n  }\n\n  has (publicKey) {\n    const keyString = b4a.toString(publicKey, 'hex')\n\n    return this._connections.has(keyString) || this._connecting.has(keyString)\n  }\n\n  get (publicKey) {\n    const keyString = b4a.toString(publicKey, 'hex')\n\n    const existing = this._connections.get(keyString) || this._connecting.get(keyString)\n\n    return existing?._stream || null\n  }\n}\n\nclass ConnectionRef {\n  constructor (pool, stream) {\n    this._pool = pool\n    this._stream = stream\n    this._refs = 0\n  }\n\n  active () {\n    this._refs++\n  }\n\n  inactive () {\n    this._refs--\n  }\n\n  release () {\n    this._stream.destroy()\n  }\n}\n\nfunction noop () {}\nconst crypto = require('hypercore-crypto')\n\nconst COMMANDS = exports.COMMANDS = {\n  PEER_HANDSHAKE: 0,\n  PEER_HOLEPUNCH: 1,\n  FIND_PEER: 2,\n  LOOKUP: 3,\n  ANNOUNCE: 4,\n  UNANNOUNCE: 5,\n  MUTABLE_PUT: 6,\n  MUTABLE_GET: 7,\n  IMMUTABLE_PUT: 8,\n  IMMUTABLE_GET: 9\n}\n\nexports.BOOTSTRAP_NODES = global.Pear?.config.dht?.bootstrap || [\n  '88.99.3.86@node1.hyperdht.org:49737',\n  '142.93.90.113@node2.hyperdht.org:49737',\n  '138.68.147.8@node3.hyperdht.org:49737'\n]\n\nexports.KNOWN_NODES = global.Pear?.config.dht?.nodes || []\n\nexports.FIREWALL = {\n  UNKNOWN: 0,\n  OPEN: 1,\n  CONSISTENT: 2,\n  RANDOM: 3\n}\n\nexports.ERROR = {\n  // noise / connection related\n  NONE: 0,\n  ABORTED: 1,\n  VERSION_MISMATCH: 2,\n  TRY_LATER: 3,\n  // dht related\n  SEQ_REUSED: 16,\n  SEQ_TOO_LOW: 17\n}\n\nconst [\n  NS_ANNOUNCE,\n  NS_UNANNOUNCE,\n  NS_MUTABLE_PUT,\n  NS_PEER_HANDSHAKE,\n  NS_PEER_HOLEPUNCH\n] = crypto.namespace('hyperswarm/dht', [\n  COMMANDS.ANNOUNCE,\n  COMMANDS.UNANNOUNCE,\n  COMMANDS.MUTABLE_PUT,\n  COMMANDS.PEER_HANDSHAKE,\n  COMMANDS.PEER_HOLEPUNCH\n])\n\nexports.NS = {\n  ANNOUNCE: NS_ANNOUNCE,\n  UNANNOUNCE: NS_UNANNOUNCE,\n  MUTABLE_PUT: NS_MUTABLE_PUT,\n  PEER_HANDSHAKE: NS_PEER_HANDSHAKE,\n  PEER_HOLEPUNCH: NS_PEER_HOLEPUNCH\n}\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\n\nfunction hash (data) {\n  const out = b4a.allocUnsafe(32)\n  sodium.crypto_generichash(out, data)\n  return out\n}\n\nfunction unslabbedHash (data) {\n  const out = b4a.allocUnsafeSlow(32)\n  sodium.crypto_generichash(out, data)\n  return out\n}\n\nfunction createKeyPair (seed) {\n  const publicKey = b4a.alloc(32)\n  const secretKey = b4a.alloc(64)\n  if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)\n  else sodium.crypto_sign_keypair(publicKey, secretKey)\n  return { publicKey, secretKey }\n}\n\nmodule.exports = {\n  hash,\n  unslabbedHash,\n  createKeyPair\n}\nconst b4a = require('b4a')\nconst cenc = require('compact-encoding')\n\nfunction encodeUnslab (enc, m) {\n  // Faster than unslab(c.encode(enc, data)) because it avoids the mem copy.\n  // Makes sense to put in compact-encoding when we need it in other modules too\n  const state = cenc.state()\n  enc.preencode(state, m)\n  state.buffer = b4a.allocUnsafeSlow(state.end)\n  enc.encode(state, m)\n  return state.buffer\n}\n\nmodule.exports = {\n  encodeUnslab\n}\nmodule.exports = class DHTError extends Error {\n  constructor (msg, code, fn = DHTError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name () {\n    return 'DHTError'\n  }\n\n  static BAD_HANDSHAKE_REPLY (msg = 'Bad handshake reply') {\n    return new DHTError(msg, 'BAD_HANDSHAKE_REPLY', DHTError.BAD_HANDSHAKE_REPLY)\n  }\n\n  static BAD_HOLEPUNCH_REPLY (msg = 'Bad holepunch reply') {\n    return new DHTError(msg, 'BAD_HOLEPUNCH_REPLY', DHTError.BAD_HOLEPUNCH_REPLY)\n  }\n\n  static HOLEPUNCH_ABORTED (msg = 'Holepunch aborted') {\n    return new DHTError(msg, 'HOLEPUNCH_ABORTED', DHTError.HOLEPUNCH_ABORTED)\n  }\n\n  static HOLEPUNCH_INVALID (msg = 'Invalid holepunch payload') {\n    return new DHTError(msg, 'HOLEPUNCH_INVALID', DHTError.HOLEPUNCH_INVALID)\n  }\n\n  static HOLEPUNCH_PROBE_TIMEOUT (msg = 'Holepunching probe did not finish in time') {\n    return new DHTError(msg, 'HOLEPUNCH_PROBE_TIMEOUT', DHTError.HOLEPUNCH_PROBE_TIMEOUT)\n  }\n\n  static HOLEPUNCH_DOUBLE_RANDOMIZED_NATS (msg = 'Both remote and local NATs are randomized') {\n    return new DHTError(msg, 'HOLEPUNCH_DOUBLE_RANDOMIZED_NATS', DHTError.HOLEPUNCH_DOUBLE_RANDOMIZED_NATS)\n  }\n\n  static CANNOT_HOLEPUNCH (msg = 'Cannot holepunch to remote') {\n    return new DHTError(msg, 'CANNOT_HOLEPUNCH', DHTError.CANNOT_HOLEPUNCH)\n  }\n\n  static REMOTE_NOT_HOLEPUNCHING (msg = 'Remote is not holepunching') {\n    return new DHTError(msg, 'REMOTE_NOT_HOLEPUNCHING', DHTError.REMOTE_NOT_HOLEPUNCHING)\n  }\n\n  static REMOTE_NOT_HOLEPUNCHABLE (msg = 'Remote is not holepunchable') {\n    return new DHTError(msg, 'REMOTE_NOT_HOLEPUNCHABLE', DHTError.REMOTE_NOT_HOLEPUNCHABLE)\n  }\n\n  static REMOTE_ABORTED (msg = 'Remote aborted') {\n    return new DHTError(msg, 'REMOTE_ABORTED', DHTError.REMOTE_ABORTED)\n  }\n\n  static HANDSHAKE_UNFINISHED (msg = 'Handshake did not finish') {\n    return new DHTError(msg, 'HANDSHAKE_UNFINISHED', DHTError.HANDSHAKE_UNFINISHED)\n  }\n\n  static HANDSHAKE_INVALID (msg = 'Received invalid handshake') {\n    return new DHTError(msg, 'HANDSHAKE_INVALID', DHTError.HANDSHAKE_INVALID)\n  }\n\n  static ALREADY_LISTENING (msg = 'Already listening') {\n    return new DHTError(msg, 'ALREADY_LISTENING', DHTError.ALREADY_LISTENING)\n  }\n\n  static KEYPAIR_ALREADY_USED (msg = 'Keypair already used') {\n    return new DHTError(msg, 'KEYPAIR_ALREADY_USED', DHTError.KEYPAIR_ALREADY_USED)\n  }\n\n  static NODE_DESTROYED (msg = 'Node destroyed') {\n    return new DHTError(msg, 'NODE_DESTROYED', DHTError.NODE_DESTROYED)\n  }\n\n  static PEER_CONNECTION_FAILED (msg = 'Could not connect to peer') {\n    return new DHTError(msg, 'PEER_CONNECTION_FAILED', DHTError.PEER_CONNECTION_FAILED)\n  }\n\n  static PEER_NOT_FOUND (msg = 'Peer not found') {\n    return new DHTError(msg, 'PEER_NOT_FOUND', DHTError.PEER_NOT_FOUND)\n  }\n\n  static STREAM_NOT_CONNECTED (msg = 'Stream is not connected') {\n    return new DHTError(msg, 'STREAM_NOT_CONNECTED', DHTError.STREAM_DISCONNECTED)\n  }\n\n  static SERVER_INCOMPATIBLE (msg = 'Server is using an incompatible version') {\n    return new DHTError(msg, 'SERVER_INCOMPATIBLE', DHTError.SERVER_INCOMPATIBLE)\n  }\n\n  static SERVER_ERROR (msg = 'Server returned an error') {\n    return new DHTError(msg, 'SERVER_ERROR', DHTError.SERVER_ERROR)\n  }\n\n  static DUPLICATE_CONNECTION (msg = 'Duplicate connection') {\n    return new DHTError(msg, 'DUPLICATE_CONNECTION', DHTError.DUPLICATE_CONNECTION)\n  }\n\n  static RELAY_ABORTED (msg = 'Relay aborted') {\n    return new DHTError(msg, 'RELAY_ABORTED', DHTError.RELAY_ABORTED)\n  }\n\n  static SUSPENDED (msg = 'Suspended') {\n    return new DHTError(msg, 'SUSPENDED', DHTError.SUSPENDED)\n  }\n}\nconst b4a = require('b4a')\nconst Nat = require('./nat')\nconst Sleeper = require('./sleeper')\nconst { FIREWALL } = require('./constants')\n\nconst BIRTHDAY_SOCKETS = 256\nconst HOLEPUNCH = b4a.from([0])\nconst HOLEPUNCH_TTL = 5\nconst DEFAULT_TTL = 64\nconst MAX_REOPENS = 3\n\nmodule.exports = class Holepuncher {\n  constructor (dht, session, isInitiator, remoteFirewall = FIREWALL.UNKNOWN) {\n    const holder = dht._socketPool.acquire()\n\n    this.dht = dht\n    this.session = session\n\n    this.nat = new Nat(dht, session, holder.socket)\n    this.nat.autoSample()\n\n    this.isInitiator = isInitiator\n\n    // events\n    this.onconnect = noop\n    this.onabort = noop\n\n    this.punching = false\n    this.connected = false\n    this.destroyed = false\n    this.randomized = false\n\n    // track remote state\n    this.remoteFirewall = remoteFirewall\n    this.remoteAddresses = []\n    this.remoteHolepunching = false\n\n    this._sleeper = new Sleeper()\n    this._reopening = null\n    this._timeout = null\n    this._punching = null\n    this._allHolders = []\n    this._holder = this._addRef(holder)\n  }\n\n  get socket () {\n    return this._holder.socket\n  }\n\n  updateRemote ({ punching, firewall, addresses, verified }) {\n    const remoteAddresses = []\n\n    if (addresses) {\n      for (const addr of addresses) {\n        remoteAddresses.push({\n          host: addr.host,\n          port: addr.port,\n          verified: (verified === addr.host) || this._isVerified(addr.host)\n        })\n      }\n    }\n\n    this.remoteFirewall = firewall\n    this.remoteAddresses = remoteAddresses\n    this.remoteHolepunching = punching\n  }\n\n  _isVerified (host) {\n    for (const addr of this.remoteAddresses) {\n      if (addr.verified && addr.host === host) {\n        return true\n      }\n    }\n    return false\n  }\n\n  ping (addr, socket = this._holder.socket) {\n    return holepunch(socket, addr, false)\n  }\n\n  openSession (addr, socket = this._holder.socket) {\n    return holepunch(socket, addr, true)\n  }\n\n  async analyze (allowReopen) {\n    await this.nat.analyzing\n    if (this._unstable()) {\n      if (!allowReopen) return false\n      if (!this._reopening) this._reopening = this._reopen()\n      return this._reopening\n    }\n    return true\n  }\n\n  _unstable () {\n    // TODO!!: We need an additional heuristic here... If we were NOT random in the past we should also do this.\n    const firewall = this.nat.firewall\n    return (this.remoteFirewall >= FIREWALL.RANDOM && firewall >= FIREWALL.RANDOM) || firewall === FIREWALL.UNKNOWN\n  }\n\n  _reset () {\n    const prev = this._holder\n\n    this._allHolders.pop()\n    this._holder = this._addRef(this.dht._socketPool.acquire())\n\n    prev.release()\n    this.nat.destroy()\n\n    this.nat = new Nat(this.dht, this.session, this._holder.socket)\n    // TODO: maybe make auto sampling configurable somehow?\n    this.nat.autoSample()\n  }\n\n  _addRef (ref) {\n    this._allHolders.push(ref)\n    ref.onholepunchmessage = (msg, rinfo) => this._onholepunchmessage(msg, rinfo, ref)\n    return ref\n  }\n\n  _onholepunchmessage (_, addr, ref) {\n    if (!this.isInitiator) { // TODO: we don't need this if we had a way to connect a socket to many hosts\n      holepunch(ref.socket, addr, false) // never fails\n      return\n    }\n\n    if (this.connected) return\n\n    this.connected = true\n    this.punching = false\n\n    for (const r of this._allHolders) {\n      if (r === ref) continue\n      r.release()\n    }\n\n    this._allHolders[0] = ref\n    while (this._allHolders.length > 1) this._allHolders.pop()\n\n    this._decrementRandomized()\n    this.onconnect(ref.socket, addr.port, addr.host)\n  }\n\n  _done () {\n    return this.destroyed || this.connected\n  }\n\n  async _reopen () {\n    for (let i = 0; this._unstable() && i < MAX_REOPENS && !this._done() && !this.punching; i++) {\n      this._reset()\n      await this.nat.analyzing\n    }\n\n    return coerceFirewall(this.nat.firewall) === FIREWALL.CONSISTENT\n  }\n\n  punch () {\n    if (!this._punching) this._punching = this._punch()\n    return this._punching\n  }\n\n  async _punch () {\n    if (this._done() || !this.remoteAddresses.length) return false\n\n    this.punching = true\n\n    // Coerce into consistency for now. Obvs we could make this this more efficient if we use that info\n    // but that's seldomly used since those will just use tcp most of the time.\n\n    const local = coerceFirewall(this.nat.firewall)\n    const remote = coerceFirewall(this.remoteFirewall)\n\n    // Note that most of these async functions are meant to run in the background\n    // which is why we don't await them here and why they are not allowed to throw\n\n    let remoteVerifiedAddress = null\n    for (const addr of this.remoteAddresses) {\n      if (addr.verified) {\n        remoteVerifiedAddress = addr\n        break\n      }\n    }\n\n    if (local === FIREWALL.CONSISTENT && remote === FIREWALL.CONSISTENT) {\n      this.dht.stats.punches.consistent++\n      this._consistentProbe()\n      return true\n    }\n\n    if (!remoteVerifiedAddress) return false\n\n    if (local === FIREWALL.CONSISTENT && remote >= FIREWALL.RANDOM) {\n      this.dht.stats.punches.random++\n      this._incrementRandomized()\n      this._randomProbes(remoteVerifiedAddress)\n      return true\n    }\n\n    if (local >= FIREWALL.RANDOM && remote === FIREWALL.CONSISTENT) {\n      this.dht.stats.punches.random++\n      this._incrementRandomized()\n      await this._openBirthdaySockets(remoteVerifiedAddress)\n      if (this.punching) this._keepAliveRandomNat(remoteVerifiedAddress)\n      return true\n    }\n\n    return false\n  }\n\n  // Note that this never throws so it is safe to run in the background\n  async _consistentProbe () {\n    // Here we do the sleep first because the \"fast open\" mode in the server just fired a ping\n    if (!this.isInitiator) await this._sleeper.pause(1000)\n\n    let tries = 0\n\n    while (this.punching && tries++ < 10) {\n      for (const addr of this.remoteAddresses) {\n        // only try unverified addresses every 4 ticks\n        if (!addr.verified && ((tries & 3) !== 0)) continue\n        await holepunch(this._holder.socket, addr, false)\n      }\n      if (this.punching) await this._sleeper.pause(1000)\n    }\n\n    this._autoDestroy()\n  }\n\n  // Note that this never throws so it is safe to run in the background\n  async _randomProbes (remoteAddr) {\n    let tries = 1750 // ~35s\n\n    while (this.punching && tries-- > 0) {\n      const addr = { host: remoteAddr.host, port: randomPort() }\n      await holepunch(this._holder.socket, addr, false)\n      if (this.punching) await this._sleeper.pause(20)\n    }\n\n    this._autoDestroy()\n  }\n\n  // Note that this never throws so it is safe to run in the background\n  async _keepAliveRandomNat (remoteAddr) {\n    let i = 0\n    let lowTTLRounds = 1\n\n    // TODO: experiment with this here. We just bursted all the messages in\n    // openOtherSockets to ensure the sockets are open, so it's potentially\n    // a good idea to slow down for a bit.\n    await this._sleeper.pause(100)\n\n    let tries = 1750 // ~35s\n\n    while (this.punching && tries-- > 0) {\n      if (i === this._allHolders.length) {\n        i = 0\n        if (lowTTLRounds > 0) lowTTLRounds--\n      }\n\n      await holepunch(this._allHolders[i++].socket, remoteAddr, lowTTLRounds > 0)\n      if (this.punching) await this._sleeper.pause(20)\n    }\n\n    this._autoDestroy()\n  }\n\n  async _openBirthdaySockets (remoteAddr) {\n    while (this.punching && this._allHolders.length < BIRTHDAY_SOCKETS) {\n      const ref = this._addRef(this.dht._socketPool.acquire())\n      await holepunch(ref.socket, remoteAddr, HOLEPUNCH_TTL)\n    }\n  }\n\n  _autoDestroy () {\n    if (!this.connected) this.destroy()\n  }\n\n  _incrementRandomized () {\n    if (!this.randomized) {\n      this.randomized = true\n      this.dht._randomPunches++\n    }\n  }\n\n  _decrementRandomized () {\n    if (this.randomized) {\n      this.dht._lastRandomPunch = Date.now()\n      this.randomized = false\n      this.dht._randomPunches--\n    }\n  }\n\n  destroy () {\n    if (this.destroyed) return\n    this.destroyed = true\n    this.punching = false\n\n    for (const ref of this._allHolders) ref.release()\n    this._allHolders = []\n    this.nat.destroy()\n\n    if (!this.connected) {\n      this._decrementRandomized()\n      this.onabort()\n    }\n  }\n\n  static ping (socket, addr) {\n    return holepunch(socket, addr, false)\n  }\n\n  static localAddresses (socket) {\n    return localAddresses(socket)\n  }\n\n  static matchAddress (myAddresses, externalAddresses) {\n    return matchAddress(myAddresses, externalAddresses)\n  }\n}\n\nfunction holepunch (socket, addr, lowTTL) {\n  return socket.send(HOLEPUNCH, addr.port, addr.host, lowTTL ? HOLEPUNCH_TTL : DEFAULT_TTL)\n}\n\nfunction randomPort () {\n  return 1000 + (Math.random() * 64536) | 0\n}\n\nfunction coerceFirewall (fw) {\n  return fw === FIREWALL.OPEN ? FIREWALL.CONSISTENT : fw\n}\n\nfunction localAddresses (socket) {\n  const addrs = []\n  const { host, port } = socket.address()\n\n  if (host === '127.0.0.1') return [{ host, port }]\n\n  for (const n of socket.udx.networkInterfaces()) {\n    if (n.family !== 4 || n.internal) continue\n\n    addrs.push({ host: n.host, port })\n  }\n\n  if (addrs.length === 0) {\n    addrs.push({ host: '127.0.0.1', port })\n  }\n\n  return addrs\n}\n\nfunction matchAddress (localAddresses, remoteLocalAddresses) {\n  if (remoteLocalAddresses.length === 0) return null\n\n  let best = { segment: 1, addr: null }\n\n  for (const localAddress of localAddresses) {\n    // => 192.168.122.238\n    const a = localAddress.host.split('.')\n\n    for (const remoteAddress of remoteLocalAddresses) {\n      // => 192.168.0.23\n      // => 192.168.122.1\n      const b = remoteAddress.host.split('.')\n\n      // Matches 192.*.*.*\n      if (a[0] === b[0]) {\n        if (best.segment === 1) best = { segment: 2, addr: remoteAddress }\n\n        // Matches 192.168.*.*\n        if (a[1] === b[1]) {\n          if (best.segment === 2) best = { segment: 3, addr: remoteAddress }\n\n          // Matches 192.168.122.*\n          if (a[2] === b[2]) return remoteAddress\n        }\n      }\n    }\n  }\n\n  return best.addr\n}\n\nfunction noop () {}\nconst c = require('compact-encoding')\nconst net = require('compact-encoding-net')\n\nconst ipv4 = {\n  ...net.ipv4Address,\n  decode (state) {\n    const ip = net.ipv4Address.decode(state)\n    return {\n      host: ip.host,\n      port: ip.port\n    }\n  }\n}\n\nconst ipv4Array = c.array(ipv4)\n\nconst ipv6 = {\n  ...net.ipv6Address,\n  decode (state) {\n    const ip = net.ipv6Address.decode(state)\n    return {\n      host: ip.host,\n      port: ip.port\n    }\n  }\n}\n\nconst ipv6Array = c.array(ipv6)\n\nexports.handshake = {\n  preencode (state, m) {\n    state.end += 1 + 1 + (m.peerAddress ? 6 : 0) + (m.relayAddress ? 6 : 0)\n    c.buffer.preencode(state, m.noise)\n  },\n  encode (state, m) {\n    const flags = (m.peerAddress ? 1 : 0) | (m.relayAddress ? 2 : 0)\n\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.mode)\n    c.buffer.encode(state, m.noise)\n\n    if (m.peerAddress) ipv4.encode(state, m.peerAddress)\n    if (m.relayAddress) ipv4.encode(state, m.relayAddress)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n\n    return {\n      mode: c.uint.decode(state),\n      noise: c.buffer.decode(state),\n      peerAddress: (flags & 1) ? ipv4.decode(state) : null,\n      relayAddress: (flags & 2) ? ipv4.decode(state) : null\n    }\n  }\n}\n\nconst relayInfo = {\n  preencode (state, m) {\n    state.end += 12\n  },\n  encode (state, m) {\n    ipv4.encode(state, m.relayAddress)\n    ipv4.encode(state, m.peerAddress)\n  },\n  decode (state) {\n    return {\n      relayAddress: ipv4.decode(state),\n      peerAddress: ipv4.decode(state)\n    }\n  }\n}\n\nconst relayInfoArray = c.array(relayInfo)\n\nconst holepunchInfo = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.id)\n    relayInfoArray.preencode(state, m.relays)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.id)\n    relayInfoArray.encode(state, m.relays)\n  },\n  decode (state) {\n    return {\n      id: c.uint.decode(state),\n      relays: relayInfoArray.decode(state)\n    }\n  }\n}\n\nconst udxInfo = {\n  preencode (state, m) {\n    state.end += 2 // version + features\n    c.uint.preencode(state, m.id)\n    c.uint.preencode(state, m.seq)\n  },\n  encode (state, m) {\n    c.uint.encode(state, 1)\n    c.uint.encode(state, m.reusableSocket ? 1 : 0)\n    c.uint.encode(state, m.id)\n    c.uint.encode(state, m.seq)\n  },\n  decode (state) {\n    const version = c.uint.decode(state)\n    const features = c.uint.decode(state)\n\n    return {\n      version,\n      reusableSocket: (features & 1) !== 0,\n      id: c.uint.decode(state),\n      seq: c.uint.decode(state)\n    }\n  }\n}\n\nconst secretStreamInfo = {\n  preencode (state, m) {\n    c.uint.preencode(state, 1)\n  },\n  encode (state, m) {\n    c.uint.encode(state, 1)\n  },\n  decode (state) {\n    return {\n      version: c.uint.decode(state)\n    }\n  }\n}\n\nconst relayThroughInfo = {\n  preencode (state, m) {\n    c.uint.preencode(state, 1) // version\n    c.uint.preencode(state, 0) // flags\n    c.fixed32.preencode(state, m.publicKey)\n    c.fixed32.preencode(state, m.token)\n  },\n  encode (state, m) {\n    c.uint.encode(state, 1)\n    c.uint.encode(state, 0)\n    c.fixed32.encode(state, m.publicKey)\n    c.fixed32.encode(state, m.token)\n  },\n  decode (state) {\n    const version = c.uint.decode(state)\n    c.uint.decode(state)\n\n    return {\n      version,\n      publicKey: c.fixed32.decode(state),\n      token: c.fixed32.decode(state)\n    }\n  }\n}\n\nexports.noisePayload = {\n  preencode (state, m) {\n    state.end += 4 // version + flags + error + firewall\n    if (m.holepunch) holepunchInfo.preencode(state, m.holepunch)\n    if (m.addresses4 && m.addresses4.length) ipv4Array.preencode(state, m.addresses4)\n    if (m.addresses6 && m.addresses6.length) ipv6Array.preencode(state, m.addresses6)\n    if (m.udx) udxInfo.preencode(state, m.udx)\n    if (m.secretStream) secretStreamInfo.preencode(state, m.secretStream)\n    if (m.relayThrough) relayThroughInfo.preencode(state, m.relayThrough)\n  },\n  encode (state, m) {\n    let flags = 0\n\n    if (m.holepunch) flags |= 1\n    if (m.addresses4 && m.addresses4.length) flags |= 2\n    if (m.addresses6 && m.addresses6.length) flags |= 4\n    if (m.udx) flags |= 8\n    if (m.secretStream) flags |= 16\n    if (m.relayThrough) flags |= 32\n\n    c.uint.encode(state, 1) // version\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.error)\n    c.uint.encode(state, m.firewall)\n\n    if (m.holepunch) holepunchInfo.encode(state, m.holepunch)\n    if (m.addresses4 && m.addresses4.length) ipv4Array.encode(state, m.addresses4)\n    if (m.addresses6 && m.addresses6.length) ipv6Array.encode(state, m.addresses6)\n    if (m.udx) udxInfo.encode(state, m.udx)\n    if (m.secretStream) secretStreamInfo.encode(state, m.secretStream)\n    if (m.relayThrough) relayThroughInfo.encode(state, m.relayThrough)\n  },\n  decode (state) {\n    const version = c.uint.decode(state)\n\n    if (version !== 1) {\n      // Do not attempt to decode but return this back to the user so they can\n      // actually handle it\n      return {\n        version,\n        error: 0,\n        firewall: 0,\n        holepunch: null,\n        addresses4: [],\n        addresses6: [],\n        udx: null,\n        secretStream: null,\n        relayThrough: null\n      }\n    }\n\n    const flags = c.uint.decode(state)\n\n    return {\n      version,\n      error: c.uint.decode(state),\n      firewall: c.uint.decode(state),\n      holepunch: (flags & 1) !== 0 ? holepunchInfo.decode(state) : null,\n      addresses4: (flags & 2) !== 0 ? ipv4Array.decode(state) : [],\n      addresses6: (flags & 4) !== 0 ? ipv6Array.decode(state) : [],\n      udx: (flags & 8) !== 0 ? udxInfo.decode(state) : null,\n      secretStream: (flags & 16) !== 0 ? secretStreamInfo.decode(state) : null,\n      relayThrough: (flags & 32) !== 0 ? relayThroughInfo.decode(state) : null\n    }\n  }\n}\n\nexports.holepunch = {\n  preencode (state, m) {\n    state.end += 2\n    c.uint.preencode(state, m.id)\n    c.buffer.preencode(state, m.payload)\n    if (m.peerAddress) ipv4.preencode(state, m.peerAddress)\n  },\n  encode (state, m) {\n    const flags = m.peerAddress ? 1 : 0\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.mode)\n    c.uint.encode(state, m.id)\n    c.buffer.encode(state, m.payload)\n    if (m.peerAddress) ipv4.encode(state, m.peerAddress)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      mode: c.uint.decode(state),\n      id: c.uint.decode(state),\n      payload: c.buffer.decode(state),\n      peerAddress: (flags & 1) ? ipv4.decode(state) : null\n    }\n  }\n}\n\nexports.holepunchPayload = {\n  preencode (state, m) {\n    state.end += 4 // flags + error + firewall + round\n    if (m.addresses) ipv4Array.preencode(state, m.addresses)\n    if (m.remoteAddress) state.end += 6\n    if (m.token) state.end += 32\n    if (m.remoteToken) state.end += 32\n  },\n  encode (state, m) {\n    const flags = (m.connected ? 1 : 0) |\n      (m.punching ? 2 : 0) |\n      (m.addresses ? 4 : 0) |\n      (m.remoteAddress ? 8 : 0) |\n      (m.token ? 16 : 0) |\n      (m.remoteToken ? 32 : 0)\n\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.error)\n    c.uint.encode(state, m.firewall)\n    c.uint.encode(state, m.round)\n\n    if (m.addresses) ipv4Array.encode(state, m.addresses)\n    if (m.remoteAddress) ipv4.encode(state, m.remoteAddress)\n    if (m.token) c.fixed32.encode(state, m.token)\n    if (m.remoteToken) c.fixed32.encode(state, m.remoteToken)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n\n    return {\n      error: c.uint.decode(state),\n      firewall: c.uint.decode(state),\n      round: c.uint.decode(state),\n      connected: (flags & 1) !== 0,\n      punching: (flags & 2) !== 0,\n      addresses: (flags & 4) !== 0 ? ipv4Array.decode(state) : null,\n      remoteAddress: (flags & 8) !== 0 ? ipv4.decode(state) : null,\n      token: (flags & 16) !== 0 ? c.fixed32.decode(state) : null,\n      remoteToken: (flags & 32) !== 0 ? c.fixed32.decode(state) : null\n    }\n  }\n}\n\nconst peer = exports.peer = {\n  preencode (state, m) {\n    state.end += 32\n    ipv4Array.preencode(state, m.relayAddresses)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.publicKey)\n    ipv4Array.encode(state, m.relayAddresses)\n  },\n  decode (state) {\n    return {\n      publicKey: c.fixed32.decode(state),\n      relayAddresses: ipv4Array.decode(state)\n    }\n  }\n}\n\nexports.peers = c.array(peer)\n\nexports.announce = {\n  preencode (state, m) {\n    state.end++ // flags\n    if (m.peer) peer.preencode(state, m.peer)\n    if (m.refresh) state.end += 32\n    if (m.signature) state.end += 64\n  },\n  encode (state, m) {\n    const flags = (m.peer ? 1 : 0) | (m.refresh ? 2 : 0) | (m.signature ? 4 : 0)\n    c.uint.encode(state, flags)\n    if (m.peer) peer.encode(state, m.peer)\n    if (m.refresh) c.fixed32.encode(state, m.refresh)\n    if (m.signature) c.fixed64.encode(state, m.signature)\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n\n    return {\n      peer: (flags & 1) !== 0 ? peer.decode(state) : null,\n      refresh: (flags & 2) !== 0 ? c.fixed32.decode(state) : null,\n      signature: (flags & 4) !== 0 ? c.fixed64.decode(state) : null\n    }\n  }\n}\n\nexports.mutableSignable = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.seq)\n    c.buffer.preencode(state, m.value)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.seq)\n    c.buffer.encode(state, m.value)\n  },\n  decode (state) {\n    return {\n      seq: c.uint.decode(state),\n      value: c.buffer.decode(state)\n    }\n  }\n}\n\nexports.mutablePutRequest = {\n  preencode (state, m) {\n    c.fixed32.preencode(state, m.publicKey)\n    c.uint.preencode(state, m.seq)\n    c.buffer.preencode(state, m.value)\n    c.fixed64.preencode(state, m.signature)\n  },\n  encode (state, m) {\n    c.fixed32.encode(state, m.publicKey)\n    c.uint.encode(state, m.seq)\n    c.buffer.encode(state, m.value)\n    c.fixed64.encode(state, m.signature)\n  },\n  decode (state) {\n    return {\n      publicKey: c.fixed32.decode(state),\n      seq: c.uint.decode(state),\n      value: c.buffer.decode(state),\n      signature: c.fixed64.decode(state)\n    }\n  }\n}\n\nexports.mutableGetResponse = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.seq)\n    c.buffer.preencode(state, m.value)\n    c.fixed64.preencode(state, m.signature)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.seq)\n    c.buffer.encode(state, m.value)\n    c.fixed64.encode(state, m.signature)\n  },\n  decode (state) {\n    return {\n      seq: c.uint.decode(state),\n      value: c.buffer.decode(state),\n      signature: c.fixed64.decode(state)\n    }\n  }\n}\nconst { FIREWALL } = require('../lib/constants')\n\nmodule.exports = class Nat {\n  constructor (dht, session, socket) {\n    this._samplesHost = []\n    this._samplesFull = []\n    this._visited = new Map()\n    this._resolve = null\n    this._minSamples = 4\n    this._autoSampling = false\n\n    this.dht = dht\n    this.session = session\n    this.socket = socket\n\n    this.sampled = 0\n    this.firewall = dht.firewalled ? FIREWALL.UNKNOWN : FIREWALL.OPEN\n    this.addresses = null\n\n    this.analyzing = new Promise((resolve) => { this._resolve = resolve })\n  }\n\n  autoSample (retry = true) {\n    if (this._autoSampling) return\n    this._autoSampling = true\n\n    const self = this\n    const socket = this.socket\n    const maxPings = this._minSamples\n\n    let skip = this.dht.nodes.length >= 8 ? 5 : 0\n    let pending = 0\n\n    // TODO: it would be best to pick the nodes to help us based on latency to us\n    // That should reduce connect latency in general. We should investigate tracking that later on.\n\n    // TODO 2: try to pick nodes with different IPs as well, as that'll help multi IP cell connections...\n    // If we expose this from the nat sampler then the DHT should be able to help us filter out scams as well...\n\n    for (let node = this.dht.nodes.latest; node && this.sampled + pending < maxPings; node = node.prev) {\n      if (skip > 0) {\n        skip--\n        continue\n      }\n\n      const ref = node.host + ':' + node.port\n\n      if (this._visited.has(ref)) continue\n      this._visited.set(ref, 1)\n\n      pending++\n      this.session.ping(node, { socket, retry: false }).then(onpong, onskip)\n    }\n\n    pending++\n    onskip()\n\n    function onpong (res) {\n      self.add(res.to, res.from)\n      onskip()\n    }\n\n    function onskip () {\n      if (--pending === 0 && self.sampled < self._minSamples) {\n        if (retry) {\n          self._autoSampling = false\n          self.autoSample(false)\n          return\n        }\n        self._resolve()\n      }\n    }\n  }\n\n  destroy () {\n    this._autoSampling = true\n    this._minSamples = 0\n    this._resolve()\n  }\n\n  unfreeze () {\n    this.frozen = false\n    this._updateFirewall()\n    this._updateAddresses()\n  }\n\n  freeze () {\n    this.frozen = true\n  }\n\n  _updateFirewall () {\n    if (!this.dht.firewalled) {\n      this.firewall = FIREWALL.OPEN\n      return\n    }\n\n    if (this.sampled < 3) return\n\n    const max = this._samplesFull[0].hits\n\n    if (max >= 3) {\n      this.firewall = FIREWALL.CONSISTENT\n      return\n    }\n\n    if (max === 1) {\n      this.firewall = FIREWALL.RANDOM\n      return\n    }\n\n    // else max === 2\n\n    // 1 host, >= 4 total samples ie, 2 bad ones -> random\n    if (this._samplesHost.length === 1 && this.sampled > 3) {\n      this.firewall = FIREWALL.RANDOM\n      return\n    }\n\n    // double hit on two different ips -> assume consistent\n    if (this._samplesHost.length > 1 && this._samplesFull[1].hits > 1) {\n      this.firewall = FIREWALL.CONSISTENT\n      return\n    }\n\n    // (4 is just means - all the samples we expect) - no decision - assume random\n    if (this.sampled > 4) {\n      this.firewall = FIREWALL.RANDOM\n    }\n  }\n\n  _updateAddresses () {\n    if (this.firewall === FIREWALL.UNKNOWN) {\n      this.addresses = null\n      return\n    }\n\n    if (this.firewall === FIREWALL.RANDOM) {\n      this.addresses = [this._samplesHost[0]]\n      return\n    }\n\n    if (this.firewall === FIREWALL.CONSISTENT) {\n      this.addresses = []\n      for (const addr of this._samplesFull) {\n        if (addr.hits >= 2 || this.addresses.length < 2) this.addresses.push(addr)\n      }\n    }\n  }\n\n  update () {\n    if (this.dht.firewalled && this.firewall === FIREWALL.OPEN) {\n      this.firewall = FIREWALL.UNKNOWN\n    }\n    this._updateFirewall()\n    this._updateAddresses()\n  }\n\n  add (addr, from) {\n    const ref = from.host + ':' + from.port\n\n    if (this._visited.get(ref) === 2) return\n    this._visited.set(ref, 2)\n\n    addSample(this._samplesHost, addr.host, 0)\n    addSample(this._samplesFull, addr.host, addr.port)\n\n    if ((++this.sampled >= 3 || !this.dht.firewalled) && !this.frozen) {\n      this.update()\n    }\n\n    if ((this.firewall === FIREWALL.CONSISTENT || this.firewall === FIREWALL.OPEN)) {\n      this._resolve()\n    } else if (this.sampled >= this._minSamples) {\n      this._resolve()\n    }\n  }\n}\n\nfunction addSample (samples, host, port) {\n  for (let i = 0; i < samples.length; i++) {\n    const s = samples[i]\n\n    if (s.port !== port || s.host !== host) continue\n    s.hits++\n\n    for (; i > 0; i--) {\n      const prev = samples[i - 1]\n      if (prev.hits >= s.hits) return\n      samples[i - 1] = s\n      samples[i] = prev\n    }\n\n    return\n  }\n\n  samples.push({\n    host,\n    port,\n    hits: 1\n  })\n}\nconst NoiseSecretStream = require('@hyperswarm/secret-stream')\nconst NoiseHandshake = require('noise-handshake')\nconst curve = require('noise-curve-ed')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst sodium = require('sodium-universal')\nconst m = require('./messages')\nconst { NS } = require('./constants')\nconst { HANDSHAKE_UNFINISHED } = require('./errors')\n\nconst NOISE_PROLOUGE = NS.PEER_HANDSHAKE\n\nmodule.exports = class NoiseWrap {\n  constructor (keyPair, remotePublicKey) {\n    this.isInitiator = !!remotePublicKey\n    this.remotePublicKey = remotePublicKey\n    this.keyPair = keyPair\n    this.handshake = new NoiseHandshake('IK', this.isInitiator, keyPair, { curve })\n    this.handshake.initialise(NOISE_PROLOUGE, remotePublicKey)\n  }\n\n  send (payload) {\n    const buf = c.encode(m.noisePayload, payload)\n    return this.handshake.send(buf)\n  }\n\n  recv (buf) {\n    const payload = c.decode(m.noisePayload, this.handshake.recv(buf))\n    this.remotePublicKey = b4a.toBuffer(this.handshake.rs)\n    return payload\n  }\n\n  final () {\n    if (!this.handshake.complete) throw HANDSHAKE_UNFINISHED()\n\n    const holepunchSecret = b4a.allocUnsafe(32)\n\n    sodium.crypto_generichash(holepunchSecret, NS.PEER_HOLEPUNCH, this.handshake.hash)\n\n    return {\n      isInitiator: this.isInitiator,\n      publicKey: this.keyPair.publicKey,\n      streamId: this.streamId,\n      remotePublicKey: this.remotePublicKey,\n      remoteId: NoiseSecretStream.id(this.handshake.hash, !this.isInitiator),\n      holepunchSecret,\n      hash: b4a.toBuffer(this.handshake.hash),\n      rx: b4a.toBuffer(this.handshake.rx),\n      tx: b4a.toBuffer(this.handshake.tx)\n    }\n  }\n}\nconst c = require('compact-encoding')\nconst sodium = require('sodium-universal')\nconst RecordCache = require('record-cache')\nconst Cache = require('xache')\nconst b4a = require('b4a')\nconst unslab = require('unslab')\n\nconst { encodeUnslab } = require('./encode')\nconst m = require('./messages')\nconst { NS, ERROR } = require('./constants')\n\nconst EMPTY = b4a.alloc(0)\nconst TMP = b4a.allocUnsafe(32)\n\nconst rawArray = c.array(c.raw)\n\nmodule.exports = class Persistent {\n  constructor (dht, opts) {\n    this.dht = dht\n    this.records = new RecordCache(opts.records)\n    this.refreshes = new Cache(opts.refreshes)\n    this.mutables = new Cache(opts.mutables)\n    this.immutables = new Cache(opts.immutables)\n  }\n\n  onlookup (req) {\n    if (!req.target) return\n\n    const k = b4a.toString(req.target, 'hex')\n    const records = this.records.get(k, 20)\n    const fwd = this.dht._router.get(k)\n\n    if (fwd && records.length < 20) records.push(fwd.record)\n\n    req.reply(records.length ? c.encode(rawArray, records) : null)\n  }\n\n  onfindpeer (req) {\n    if (!req.target) return\n    const fwd = this.dht._router.get(req.target)\n    req.reply(fwd ? fwd.record : null)\n  }\n\n  unannounce (target, publicKey) {\n    const k = b4a.toString(target, 'hex')\n    sodium.crypto_generichash(TMP, publicKey)\n\n    if (b4a.equals(TMP, target)) this.dht._router.delete(k)\n    this.records.remove(k, publicKey)\n  }\n\n  onunannounce (req) {\n    if (!req.target || !req.token) return\n\n    const unann = decode(m.announce, req.value)\n    if (unann === null) return\n\n    const { peer, signature } = unann\n    if (!peer || !signature) return\n\n    const signable = annSignable(req.target, req.token, this.dht.id, unann, NS.UNANNOUNCE)\n\n    if (!sodium.crypto_sign_verify_detached(signature, signable, peer.publicKey)) {\n      return\n    }\n\n    this.unannounce(req.target, peer.publicKey)\n    req.reply(null, { token: false, closerNodes: false })\n  }\n\n  _onrefresh (token, req) {\n    sodium.crypto_generichash(TMP, token)\n    const activeRefresh = b4a.toString(TMP, 'hex')\n\n    const r = this.refreshes.get(activeRefresh)\n    if (!r) return\n\n    const { announceSelf, k, record } = r\n    const publicKey = record.subarray(0, 32)\n\n    if (announceSelf) {\n      this.dht._router.set(k, {\n        relay: req.from,\n        record,\n        onconnect: null,\n        onholepunch: null\n      })\n      this.records.remove(k, publicKey)\n    } else {\n      this.records.add(k, publicKey, record)\n    }\n\n    this.refreshes.delete(activeRefresh)\n    this.refreshes.set(b4a.toString(token, 'hex'), r)\n\n    req.reply(null, { token: false, closerNodes: false })\n  }\n\n  onannounce (req) {\n    if (!req.target || !req.token || !this.dht.id) return\n\n    const ann = decode(m.announce, req.value)\n    if (ann === null) return\n\n    const signable = annSignable(req.target, req.token, this.dht.id, ann, NS.ANNOUNCE)\n    const { peer, refresh, signature } = ann\n\n    if (!peer) {\n      if (!refresh) return\n      this._onrefresh(refresh, req)\n      return\n    }\n\n    if (!signature || !sodium.crypto_sign_verify_detached(signature, signable, peer.publicKey)) {\n      return\n    }\n\n    // TODO: it would be potentially be more optimal to allow more than 3 addresses here for a findPeer response\n    // and only use max 3 for a lookup reply\n    if (peer.relayAddresses.length > 3) {\n      peer.relayAddresses = peer.relayAddresses.slice(0, 3)\n    }\n\n    sodium.crypto_generichash(TMP, peer.publicKey)\n\n    const k = b4a.toString(req.target, 'hex')\n    const announceSelf = b4a.equals(TMP, req.target)\n    const record = encodeUnslab(m.peer, peer)\n\n    if (announceSelf) {\n      this.dht._router.set(k, {\n        relay: req.from,\n        record,\n        onconnect: null,\n        onholepunch: null\n      })\n      this.records.remove(k, peer.publicKey)\n    } else {\n      this.records.add(k, peer.publicKey, record)\n    }\n\n    if (refresh) {\n      this.refreshes.set(b4a.toString(refresh, 'hex'), { k, record, announceSelf })\n    }\n\n    req.reply(null, { token: false, closerNodes: false })\n  }\n\n  onmutableget (req) {\n    if (!req.target || !req.value) return\n\n    let seq = 0\n    try {\n      seq = c.decode(c.uint, req.value)\n    } catch {\n      return\n    }\n\n    const k = b4a.toString(req.target, 'hex')\n    const value = this.mutables.get(k)\n\n    if (!value) {\n      req.reply(null)\n      return\n    }\n\n    const localSeq = c.decode(c.uint, value)\n    req.reply(localSeq < seq ? null : value)\n  }\n\n  onmutableput (req) {\n    if (!req.target || !req.token || !req.value) return\n\n    const p = decode(m.mutablePutRequest, req.value)\n    if (!p) return\n\n    const { publicKey, seq, value, signature } = p\n\n    const hash = b4a.allocUnsafe(32)\n    sodium.crypto_generichash(hash, publicKey)\n    if (!b4a.equals(hash, req.target)) return\n\n    if (!value || !verifyMutable(signature, seq, value, publicKey)) return\n\n    const k = b4a.toString(hash, 'hex')\n    const local = this.mutables.get(k)\n\n    if (local) {\n      const existing = c.decode(m.mutableGetResponse, local)\n      if (existing.value && existing.seq === seq && b4a.compare(value, existing.value) !== 0) {\n        req.error(ERROR.SEQ_REUSED)\n        return\n      }\n      if (seq < existing.seq) {\n        req.error(ERROR.SEQ_TOO_LOW)\n        return\n      }\n    }\n\n    this.mutables.set(k, encodeUnslab(m.mutableGetResponse, { seq, value, signature }))\n    req.reply(null)\n  }\n\n  onimmutableget (req) {\n    if (!req.target) return\n\n    const k = b4a.toString(req.target, 'hex')\n    const value = this.immutables.get(k)\n\n    req.reply(value || null)\n  }\n\n  onimmutableput (req) {\n    if (!req.target || !req.token || !req.value) return\n\n    const hash = b4a.alloc(32)\n    sodium.crypto_generichash(hash, req.value)\n    if (!b4a.equals(hash, req.target)) return\n\n    const k = b4a.toString(hash, 'hex')\n    this.immutables.set(k, unslab(req.value))\n\n    req.reply(null)\n  }\n\n  destroy () {\n    this.records.destroy()\n    this.refreshes.destroy()\n    this.mutables.destroy()\n    this.immutables.destroy()\n  }\n\n  static signMutable (seq, value, keyPair) {\n    const signable = b4a.allocUnsafe(32 + 32)\n    const hash = signable.subarray(32)\n\n    signable.set(NS.MUTABLE_PUT, 0)\n\n    sodium.crypto_generichash(hash, c.encode(m.mutableSignable, { seq, value }))\n    return sign(signable, keyPair)\n  }\n\n  static verifyMutable (signature, seq, value, publicKey) {\n    return verifyMutable(signature, seq, value, publicKey)\n  }\n\n  static signAnnounce (target, token, id, ann, keyPair) {\n    return sign(annSignable(target, token, id, ann, NS.ANNOUNCE), keyPair)\n  }\n\n  static signUnannounce (target, token, id, ann, keyPair) {\n    return sign(annSignable(target, token, id, ann, NS.UNANNOUNCE), keyPair)\n  }\n}\n\nfunction verifyMutable (signature, seq, value, publicKey) {\n  const signable = b4a.allocUnsafe(32 + 32)\n  const hash = signable.subarray(32)\n\n  signable.set(NS.MUTABLE_PUT, 0)\n\n  sodium.crypto_generichash(hash, c.encode(m.mutableSignable, { seq, value }))\n  return sodium.crypto_sign_verify_detached(signature, signable, publicKey)\n}\n\nfunction annSignable (target, token, id, ann, ns) {\n  const signable = b4a.allocUnsafe(32 + 32)\n  const hash = signable.subarray(32)\n\n  signable.set(ns, 0)\n\n  sodium.crypto_generichash_batch(hash, [\n    target,\n    id,\n    token,\n    c.encode(m.peer, ann.peer), // note that this is the partial encoding of the announce message so we could just use that for perf\n    ann.refresh || EMPTY\n  ])\n\n  return signable\n}\n\nfunction sign (signable, keyPair) {\n  if (keyPair.sign) {\n    return keyPair.sign(signable)\n  }\n  const secretKey = keyPair.secretKey ? keyPair.secretKey : keyPair\n  const signature = b4a.allocUnsafe(64)\n  sodium.crypto_sign_detached(signature, signable, secretKey)\n  return signature\n}\n\nfunction decode (enc, val) {\n  try {\n    return val && c.decode(enc, val)\n  } catch (err) {\n    return null\n  }\n}\nmodule.exports = class RawStreamSet {\n  constructor (dht) {\n    this._dht = dht\n\n    this._prefix = 16 - 1 // 16 is the default stream-set side in udx\n    this._streams = new Map()\n  }\n\n  add (opts) {\n    const self = this\n\n    // TODO: we should prob have a udx helper for id generation, given the slight complexity\n    // of the below. requires a PRNG in udx tho.\n\n    let id = 0\n\n    while (true) {\n      id = (Math.random() * 0x100000000) >>> 0\n\n      if (this._streams.has(id & this._prefix)) continue\n      break\n    }\n\n    // always have ~50% change of rolling a free one\n    if (2 * this._streams.size >= this._prefix) {\n      // ie 0b11111 = 0b1111 + 1 + 0b1111\n      this._prefix = 2 * this._prefix + 1\n\n      // move the prefixes over\n      const next = new Map()\n      for (const stream of this._streams.values()) {\n        next.set(stream.id & this._prefix, stream)\n      }\n      this._streams = next\n    }\n\n    const stream = this._dht.udx.createStream(id, opts)\n    this._streams.set(id & this._prefix, stream)\n\n    stream.on('close', onclose)\n\n    return stream\n\n    function onclose () {\n      self._streams.delete(id & self._prefix)\n    }\n  }\n\n  async clear () {\n    const destroying = []\n\n    for (const stream of this._streams.values()) {\n      destroying.push(new Promise((resolve) => stream\n        .once('close', resolve)\n        .destroy()\n      ))\n    }\n\n    await Promise.allSettled(destroying)\n  }\n}\nconst c = require('compact-encoding')\nconst Cache = require('xache')\nconst safetyCatch = require('safety-catch')\nconst b4a = require('b4a')\nconst { handshake, holepunch } = require('./messages')\nconst { COMMANDS } = require('./constants')\nconst { BAD_HANDSHAKE_REPLY, BAD_HOLEPUNCH_REPLY } = require('./errors')\n\nconst FROM_CLIENT = 0\nconst FROM_SERVER = 1\nconst FROM_RELAY = 2\nconst FROM_SECOND_RELAY = 3\nconst REPLY = 4\n\n// TODO: While the current design is very trustless in regards to clients/servers trusting the DHT,\n// we should add a bunch of rate limits everywhere, especially including here to avoid bad users\n// using a DHT node to relay traffic indiscriminately using the connect/holepunch messages.\n// That's mostly from an abuse POV as none of the messsages do amplication.\n\nmodule.exports = class Router {\n  constructor (dht, opts) {\n    this.dht = dht\n    this.forwards = new Cache(opts.forwards)\n  }\n\n  set (target, state) {\n    if (state.onpeerhandshake) {\n      this.forwards.retain(toString(target), state)\n    } else {\n      this.forwards.set(toString(target), state)\n    }\n  }\n\n  get (target) {\n    return this.forwards.get(toString(target))\n  }\n\n  delete (target) {\n    this.forwards.delete(toString(target))\n  }\n\n  destroy () {\n    this.forwards.destroy()\n  }\n\n  async peerHandshake (target, { noise, peerAddress, relayAddress, socket, session }, to) {\n    const dht = this.dht\n\n    const requestValue = c.encode(handshake, {\n      mode: FROM_CLIENT,\n      noise,\n      peerAddress,\n      relayAddress\n    })\n\n    const res = await dht.request({ command: COMMANDS.PEER_HANDSHAKE, target, value: requestValue }, to, { socket, session })\n\n    const hs = decode(handshake, res.value)\n    if (!hs || hs.mode !== REPLY || (to.host !== res.from.host || to.port !== res.from.port) || !hs.noise) {\n      throw BAD_HANDSHAKE_REPLY()\n    }\n\n    return {\n      noise: hs.noise,\n      relayed: !!hs.peerAddress,\n      serverAddress: hs.peerAddress || to,\n      clientAddress: res.to\n    }\n  }\n\n  async onpeerhandshake (req) {\n    const hs = req.value && decode(handshake, req.value)\n    if (!hs) return\n\n    const { mode, noise, peerAddress, relayAddress } = hs\n\n    const state = req.target && this.get(req.target)\n    const isServer = !!(state && state.onpeerhandshake)\n    const relay = state && state.relay\n\n    if (isServer) {\n      let reply = null\n      try {\n        reply = noise && await state.onpeerhandshake({ noise, peerAddress }, req)\n      } catch (e) {\n        safetyCatch(e)\n        return\n      }\n      if (!reply || !reply.noise) return\n      const opts = { socket: reply.socket, closerNodes: false, token: false }\n\n      switch (mode) {\n        case FROM_CLIENT: {\n          req.reply(c.encode(handshake, { mode: REPLY, noise: reply.noise, peerAddress: null }), opts)\n          return\n        }\n        case FROM_RELAY: {\n          req.relay(c.encode(handshake, { mode: FROM_SERVER, noise: reply.noise, peerAddress }), req.from, opts)\n          return\n        }\n        case FROM_SECOND_RELAY: {\n          if (!relayAddress) return\n          req.relay(c.encode(handshake, { mode: FROM_SERVER, noise: reply.noise, peerAddress }), relayAddress, opts)\n          return // eslint-disable-line\n        }\n      }\n    } else {\n      switch (mode) {\n        case FROM_CLIENT: {\n          // TODO: if no relay is known route closer to the target instead of timing out\n          if (!noise) return\n          if (!relay && !relayAddress) { // help the user route\n            req.reply(null, { token: false, closerNodes: true })\n            return\n          }\n          req.relay(c.encode(handshake, { mode: FROM_RELAY, noise, peerAddress: req.from, relayAddress: null }), relayAddress || relay)\n          return\n        }\n        case FROM_RELAY: {\n          if (!relay || !noise) return\n          req.relay(c.encode(handshake, { mode: FROM_SECOND_RELAY, noise, peerAddress, relayAddress: req.from }), relay)\n          return\n        }\n        case FROM_SERVER: {\n          if (!peerAddress || !noise) return\n          req.reply(c.encode(handshake, { mode: REPLY, noise, peerAddress: req.from, relayAddress: null }), { to: peerAddress, closerNodes: false, token: false })\n          return // eslint-disable-line\n        }\n      }\n    }\n  }\n\n  async peerHolepunch (target, { id, payload, peerAddress, socket, session }, to) {\n    const dht = this.dht\n    const requestValue = c.encode(holepunch, {\n      mode: FROM_CLIENT,\n      id,\n      payload,\n      peerAddress\n    })\n\n    const res = await dht.request({ command: COMMANDS.PEER_HOLEPUNCH, target, value: requestValue }, to, { socket, session })\n\n    const hp = decode(holepunch, res.value)\n    if (!hp || hp.mode !== REPLY || (to.host !== res.from.host || to.port !== res.from.port)) {\n      throw BAD_HOLEPUNCH_REPLY()\n    }\n\n    return {\n      from: res.from,\n      to: res.to,\n      payload: hp.payload,\n      peerAddress: hp.peerAddress || to\n    }\n  }\n\n  async onpeerholepunch (req) {\n    const hp = req.value && decode(holepunch, req.value)\n    if (!hp) return\n\n    const { mode, id, payload, peerAddress } = hp\n\n    const state = req.target && this.get(req.target)\n    const isServer = !!(state && state.onpeerholepunch)\n    const relay = state && state.relay\n\n    switch (mode) {\n      case FROM_CLIENT: {\n        if (!peerAddress && !relay) return\n        req.relay(c.encode(holepunch, { mode: FROM_RELAY, id, payload, peerAddress: req.from }), peerAddress || relay)\n        return\n      }\n      case FROM_RELAY: {\n        if (!isServer || !peerAddress) return\n        let reply = null\n        try {\n          reply = await state.onpeerholepunch({ id, payload, peerAddress }, req)\n        } catch (e) {\n          safetyCatch(e)\n          return\n        }\n        if (!reply) return\n        const opts = { socket: reply.socket, closerNodes: false, token: false }\n        req.relay(c.encode(holepunch, { mode: FROM_SERVER, id: 0, payload: reply.payload, peerAddress }), req.from, opts)\n        return\n      }\n      case FROM_SERVER: {\n        req.reply(c.encode(holepunch, { mode: REPLY, id, payload, peerAddress: req.from }), { to: peerAddress, closerNodes: false, token: false })\n        return // eslint-disable-line\n      }\n    }\n  }\n}\n\nfunction decode (enc, val) {\n  try {\n    return c.decode(enc, val)\n  } catch {\n    return null\n  }\n}\n\nfunction toString (t) {\n  return typeof t === 'string' ? t : b4a.toString(t, 'hex')\n}\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\nconst { holepunchPayload } = require('./messages')\n\nmodule.exports = class HolepunchPayload {\n  constructor (holepunchSecret) {\n    this._sharedSecret = holepunchSecret\n    this._localSecret = b4a.allocUnsafe(32)\n\n    sodium.randombytes_buf(this._localSecret)\n  }\n\n  decrypt (buffer) {\n    const state = { start: 24, end: buffer.byteLength - 16, buffer }\n\n    if (state.end <= state.start) return null\n\n    const nonce = buffer.subarray(0, 24)\n    const msg = state.buffer.subarray(state.start, state.end)\n    const cipher = state.buffer.subarray(state.start)\n\n    if (!sodium.crypto_secretbox_open_easy(msg, cipher, nonce, this._sharedSecret)) return null\n\n    try {\n      return holepunchPayload.decode(state)\n    } catch {\n      return null\n    }\n  }\n\n  encrypt (payload) {\n    const state = { start: 24, end: 24, buffer: null }\n    holepunchPayload.preencode(state, payload)\n    state.buffer = b4a.allocUnsafe(state.end + 16)\n\n    const nonce = state.buffer.subarray(0, 24)\n    const msg = state.buffer.subarray(state.start, state.end)\n    const cipher = state.buffer.subarray(state.start)\n\n    holepunchPayload.encode(state, payload)\n    sodium.randombytes_buf(nonce)\n    sodium.crypto_secretbox_easy(cipher, msg, nonce, this._sharedSecret)\n\n    return state.buffer\n  }\n\n  token (addr) {\n    const out = b4a.allocUnsafe(32)\n    sodium.crypto_generichash(out, b4a.from(addr.host), this._localSecret)\n    return out\n  }\n}\nconst DONE = Promise.resolve(true)\nconst DESTROYED = Promise.resolve(false)\n\nmodule.exports = class Semaphore {\n  constructor (limit = 1) {\n    this.limit = limit\n    this.active = 0\n    this.waiting = []\n    this.destroyed = false\n\n    this._onwait = (resolve) => { this.waiting.push(resolve) }\n  }\n\n  wait () {\n    if (this.destroyed === true) return DESTROYED\n\n    if (this.active < this.limit && this.waiting.length === 0) {\n      this.active++\n      return DONE\n    }\n\n    return new Promise(this._onwait)\n  }\n\n  signal () {\n    if (this.destroyed === true) return\n\n    this.active--\n    while (this.active < this.limit && this.waiting.length > 0 && this.destroyed === false) {\n      this.active++\n      this.waiting.shift()(true)\n    }\n  }\n\n  async flush () {\n    if (this.destroyed === true) return\n    this.limit = 1\n    await this.wait()\n    this.signal()\n  }\n\n  destroy () {\n    this.destroyed = true\n    this.active = 0\n    while (this.waiting.length) this.waiting.pop()(false)\n  }\n}\nconst { EventEmitter } = require('events')\nconst safetyCatch = require('safety-catch')\nconst NoiseSecretStream = require('@hyperswarm/secret-stream')\nconst b4a = require('b4a')\nconst relay = require('blind-relay')\nconst NoiseWrap = require('./noise-wrap')\nconst Announcer = require('./announcer')\nconst { FIREWALL, ERROR } = require('./constants')\nconst { unslabbedHash } = require('./crypto')\nconst SecurePayload = require('./secure-payload')\nconst Holepuncher = require('./holepuncher')\nconst { isPrivate } = require('bogon')\nconst { ALREADY_LISTENING, NODE_DESTROYED, KEYPAIR_ALREADY_USED } = require('./errors')\n\nconst HANDSHAKE_CLEAR_WAIT = 10000\nconst HANDSHAKE_INITIAL_TIMEOUT = 10000\n\nmodule.exports = class Server extends EventEmitter {\n  constructor (dht, opts = {}) {\n    super()\n\n    this.dht = dht\n    this.target = null\n\n    this.closed = false\n    this.firewall = opts.firewall || (() => false)\n    this.holepunch = opts.holepunch || (() => true)\n    this.relayThrough = opts.relayThrough || null\n    this.relayKeepAlive = opts.relayKeepAlive || 5000\n    this.pool = opts.pool || null\n    this.createHandshake = opts.createHandshake || defaultCreateHandshake\n    this.createSecretStream = opts.createSecretStream || defaultCreateSecretStream\n    this.suspended = false\n\n    this._shareLocalAddress = opts.shareLocalAddress !== false\n    this._reusableSocket = !!opts.reusableSocket\n    this._neverPunch = opts.holepunch === false // useful for fully disabling punching\n    this._keyPair = null\n    this._announcer = null\n    this._connects = new Map()\n    this._holepunches = []\n    this._listening = null\n    this._closing = null\n  }\n\n  get listening () {\n    return this._listening !== null\n  }\n\n  get publicKey () {\n    return this._keyPair && this._keyPair.publicKey\n  }\n\n  get relayAddresses () {\n    return this._announcer ? this._announcer.relayAddresses : []\n  }\n\n  onconnection (encryptedSocket) {\n    this.emit('connection', encryptedSocket)\n  }\n\n  async suspend () {\n    if (this._listening !== null) await this._listening\n    this.suspended = true\n    this._clearAll()\n    return this._announcer ? this._announcer.suspend() : Promise.resolve()\n  }\n\n  async resume () {\n    if (this._listening !== null) await this._listening\n    this.suspended = false\n    return this._announcer ? this._announcer.resume() : Promise.resolve()\n  }\n\n  address () {\n    if (!this._keyPair) return null\n\n    return {\n      publicKey: this._keyPair.publicKey,\n      host: this.dht.host,\n      port: this.dht.port\n    }\n  }\n\n  close () {\n    if (this._closing) return this._closing\n    this._closing = this._close()\n    return this._closing\n  }\n\n  _gc () {\n    this.dht.listening.delete(this)\n    if (this.target) this.dht._router.delete(this.target)\n  }\n\n  async _stopListening () {\n    try {\n      if (this._announcer) await this._announcer.stop()\n    } catch {\n      // ignore\n    }\n\n    this._announcer = null\n    this._listening = null\n    this._keyPair = null\n  }\n\n  async _close () {\n    if (this._listening === null) {\n      this.closed = true\n      this.emit('close')\n      return\n    }\n\n    try {\n      await this._listening\n    } catch {}\n\n    this._gc()\n    this._clearAll()\n\n    await this._stopListening()\n\n    this.closed = true\n    this.emit('close')\n  }\n\n  _clearAll () {\n    while (this._holepunches.length > 0) {\n      const h = this._holepunches.pop()\n      if (h && h.puncher) h.puncher.destroy()\n      if (h && h.clearing) clearTimeout(h.clearing)\n      if (h && h.prepunching) clearTimeout(h.prepunching)\n      if (h && h.rawStream) h.rawStream.destroy()\n    }\n\n    this._connects.clear()\n  }\n\n  async listen (keyPair = this.dht.defaultKeyPair, opts = {}) {\n    if (this._listening !== null) throw ALREADY_LISTENING()\n    if (this.dht.destroyed) throw NODE_DESTROYED()\n\n    this._listening = this._listen(keyPair, opts)\n    await this._listening\n    return this\n  }\n\n  async _listen (keyPair, opts) {\n    // From now on, the DHT object which created me is responsible for closing me\n    this.dht.listening.add(this)\n\n    try {\n      await this.dht.bind()\n      if (this._closing) return\n\n      for (const s of this.dht.listening) {\n        if (s._keyPair && b4a.equals(s._keyPair.publicKey, keyPair.publicKey)) {\n          throw KEYPAIR_ALREADY_USED()\n        }\n      }\n\n      this.target = unslabbedHash(keyPair.publicKey)\n      this._keyPair = keyPair\n      this._announcer = new Announcer(this.dht, keyPair, this.target, opts)\n\n      this.dht._router.set(this.target, {\n        relay: null,\n        record: this._announcer.record,\n        onpeerhandshake: this._onpeerhandshake.bind(this),\n        onpeerholepunch: this._onpeerholepunch.bind(this)\n      })\n\n      // warm it up for now\n      this._localAddresses().catch(safetyCatch)\n\n      await this._announcer.start()\n    } catch (err) {\n      await this._stopListening()\n      this._gc()\n      throw err\n    }\n\n    if (this._closing) return\n    if (this.suspended) await this._announcer.suspend()\n\n    if (this._closing) return\n    if (this.dht.destroyed) throw NODE_DESTROYED()\n\n    if (this.pool) this.pool._attachServer(this)\n\n    this.emit('listening')\n  }\n\n  refresh () {\n    if (this._announcer) this._announcer.refresh()\n  }\n\n  notifyOnline () {\n    if (this._announcer) this._announcer.online.notify()\n  }\n\n  _localAddresses () {\n    return this.dht.validateLocalAddresses(Holepuncher.localAddresses(this.dht.io.serverSocket))\n  }\n\n  async _addHandshake (k, noise, clientAddress, { from, to: serverAddress, socket }, direct) {\n    let id = this._holepunches.indexOf(null)\n    if (id === -1) id = this._holepunches.push(null) - 1\n\n    const hs = {\n      round: 0,\n      reply: null,\n      puncher: null,\n      payload: null,\n      rawStream: null,\n      encryptedSocket: null,\n      prepunching: null,\n      firewalled: true,\n      clearing: null,\n      onsocket: null,\n\n      // Relay state\n      relayTimeout: null,\n      relayToken: null,\n      relaySocket: null,\n      relayClient: null,\n      relayPaired: false\n    }\n\n    this._holepunches[id] = hs\n\n    const handshake = this.createHandshake(this._keyPair, null)\n\n    let remotePayload\n    try {\n      remotePayload = await handshake.recv(noise)\n    } catch (err) {\n      safetyCatch(err)\n      this._clearLater(hs, id, k)\n      return null\n    }\n\n    if (this._closing || this.suspended) return null\n\n    try {\n      hs.firewalled = await this.firewall(handshake.remotePublicKey, remotePayload, clientAddress)\n    } catch (err) {\n      safetyCatch(err)\n    }\n\n    if (this._closing || this.suspended) return null\n\n    if (hs.firewalled) {\n      this._clearLater(hs, id, k)\n      return null\n    }\n\n    const error = remotePayload.version === 1\n      ? (remotePayload.udx ? ERROR.NONE : ERROR.ABORTED)\n      : ERROR.VERSION_MISMATCH\n\n    const addresses = []\n    const ourRemoteAddr = this.dht.remoteAddress()\n    const ourLocalAddrs = this._shareLocalAddress ? await this._localAddresses() : null\n\n    if (this._closing || this.suspended) return null\n\n    if (ourRemoteAddr) addresses.push(ourRemoteAddr)\n    if (ourLocalAddrs) addresses.push(...ourLocalAddrs)\n\n    if (error === ERROR.NONE) {\n      hs.rawStream = this.dht.createRawStream({\n        framed: true,\n        firewall (socket, port, host) {\n          // Check if the traffic originated from the socket on which we're expecting relay traffic. If so,\n          // we haven't hole punched yet and the other side is just sending us traffic through the relay.\n          if (hs.relaySocket && isRelay(hs.relaySocket, socket, port, host)) {\n            return false\n          }\n\n          hs.onsocket(socket, port, host)\n          return false\n        }\n      })\n\n      hs.rawStream.on('error', autoDestroy)\n\n      hs.onsocket = (socket, port, host) => {\n        if (hs.rawStream === null) return // Already hole punched\n\n        this._clearLater(hs, id, k)\n\n        if (hs.prepunching) {\n          clearTimeout(hs.prepunching)\n          hs.prepunching = null\n        }\n\n        if (this._reusableSocket && remotePayload.udx.reusableSocket) {\n          this.dht._socketPool.routes.add(handshake.remotePublicKey, hs.rawStream)\n        }\n\n        hs.rawStream.removeListener('error', autoDestroy)\n\n        if (hs.rawStream.connected) {\n          const remoteChanging = hs.rawStream.changeRemote(socket, remotePayload.udx.id, port, host)\n\n          if (remoteChanging) remoteChanging.catch(safetyCatch)\n        } else {\n          hs.rawStream.connect(socket, remotePayload.udx.id, port, host)\n          hs.encryptedSocket = this.createSecretStream(false, hs.rawStream, {\n            handshake: h,\n            keepAlive: this.dht.connectionKeepAlive\n          })\n\n          this.onconnection(hs.encryptedSocket)\n        }\n\n        if (hs.puncher) {\n          hs.puncher.onabort = noop\n          hs.puncher.destroy()\n        }\n\n        hs.rawStream = null\n      }\n\n      function autoDestroy () {\n        if (hs.puncher) hs.puncher.destroy()\n      }\n    }\n\n    const relayThrough = selectRelay(this.relayThrough)\n\n    if (relayThrough) hs.relayToken = relay.token()\n\n    try {\n      hs.reply = await handshake.send({\n        error,\n        firewall: ourRemoteAddr ? FIREWALL.OPEN : FIREWALL.UNKNOWN,\n        holepunch: ourRemoteAddr ? null : { id, relays: this._announcer.relays },\n        addresses4: addresses,\n        addresses6: null,\n        udx: {\n          reusableSocket: this._reusableSocket,\n          id: hs.rawStream ? hs.rawStream.id : 0,\n          seq: 0\n        },\n        secretStream: {},\n        relayThrough: relayThrough\n          ? { publicKey: relayThrough, token: hs.relayToken }\n          : null\n      })\n    } catch (err) {\n      safetyCatch(err)\n      hs.rawStream.destroy()\n      this._clearLater(hs, id, k)\n      return null\n    }\n\n    if (this._closing || this.suspended) {\n      hs.rawStream.destroy()\n      return null\n    }\n\n    const h = handshake.final()\n\n    if (error !== ERROR.NONE) {\n      hs.rawStream.destroy()\n      this._clearLater(hs, id, k)\n      return hs\n    }\n\n    if (relayThrough || remotePayload.relayThrough) {\n      this._relayConnection(hs, relayThrough, remotePayload, h)\n    }\n\n    if (remotePayload.firewall === FIREWALL.OPEN || direct) {\n      const sock = direct ? socket : this.dht.socket\n      this.dht.stats.punches.open++\n      hs.onsocket(sock, clientAddress.port, clientAddress.host)\n      return hs\n    }\n\n    const onabort = () => {\n      if (hs.prepunching) clearTimeout(hs.prepunching)\n      hs.prepunching = null\n      hs.rawStream.on('close', () => this._clearLater(hs, id, k))\n      if (hs.relayToken === null) hs.rawStream.destroy()\n    }\n\n    if (!direct && clientAddress.host === serverAddress.host) {\n      const clientAddresses = remotePayload.addresses4.filter(onlyPrivateHosts)\n\n      if (clientAddresses.length > 0 && this._shareLocalAddress) {\n        const myAddresses = await this._localAddresses()\n        const addr = Holepuncher.matchAddress(myAddresses, clientAddresses)\n\n        if (addr) {\n          hs.prepunching = setTimeout(onabort, HANDSHAKE_INITIAL_TIMEOUT)\n          return hs\n        }\n      }\n    }\n\n    if (this._closing || this.suspended) return null\n\n    if (ourRemoteAddr || this._neverPunch) {\n      hs.prepunching = setTimeout(onabort, HANDSHAKE_INITIAL_TIMEOUT)\n      return hs\n    }\n\n    hs.payload = new SecurePayload(h.holepunchSecret)\n    hs.puncher = new Holepuncher(this.dht, this.dht.session(), false, remotePayload.firewall)\n\n    hs.puncher.onconnect = hs.onsocket\n    hs.puncher.onabort = onabort\n    hs.prepunching = setTimeout(hs.puncher.destroy.bind(hs.puncher), HANDSHAKE_INITIAL_TIMEOUT)\n\n    return hs\n  }\n\n  _clearLater (hs, id, k) {\n    if (hs.clearing) return\n    hs.clearing = setTimeout(() => this._clear(hs, id, k), HANDSHAKE_CLEAR_WAIT)\n  }\n\n  _clear (hs, id, k) {\n    if (id >= this._holepunches.length || this._holepunches[id] !== hs) return\n    if (hs.clearing) clearTimeout(hs.clearing)\n\n    this._holepunches[id] = null\n    while (this._holepunches.length > 0 && this._holepunches[this._holepunches.length - 1] === null) {\n      this._holepunches.pop()\n    }\n    this._connects.delete(k)\n  }\n\n  async _onpeerhandshake ({ noise, peerAddress }, req) {\n    const k = b4a.toString(noise, 'hex')\n\n    // The next couple of statements MUST run within the same tick to prevent\n    // a malicious peer from flooding us with handshakes.\n    let p = this._connects.get(k)\n    if (!p) {\n      p = this._addHandshake(k, noise, peerAddress || req.from, req, !peerAddress)\n      this._connects.set(k, p)\n    }\n\n    const h = await p\n    if (!h) return null\n\n    if (this._closing !== null || this.suspended) return null\n\n    return { socket: h.puncher && h.puncher.socket, noise: h.reply }\n  }\n\n  async _onpeerholepunch ({ id, peerAddress, payload }, req) {\n    const h = id < this._holepunches.length ? this._holepunches[id] : null\n    if (!h) return null\n\n    if (!peerAddress || this._closing !== null || this.suspended) return null\n\n    const p = h.puncher\n    if (!p || !p.socket) return this._abort(h) // not opened\n\n    const remotePayload = h.payload.decrypt(payload)\n    if (!remotePayload) return null\n\n    const isServerRelay = this._announcer.isRelay(req.from)\n    const { error, firewall, round, punching, addresses, remoteAddress, remoteToken } = remotePayload\n\n    if (error !== ERROR.NONE) {\n      // We actually do not need to set the round here, but just do it for consistency.\n      if (round >= h.round) h.round = round\n      return this._abort(h)\n    }\n\n    const token = h.payload.token(peerAddress)\n    const echoed = isServerRelay && !!remoteToken && b4a.equals(token, remoteToken)\n\n    // Update our heuristics here\n    if (req.socket === p.socket) {\n      p.nat.add(req.to, req.from)\n    }\n\n    if (round >= h.round) {\n      h.round = round\n      p.updateRemote({ punching, firewall, addresses, verified: echoed ? peerAddress.host : null })\n    }\n\n    // Wait for the analyzer to reach a conclusion...\n    let stable = await p.analyze(false)\n    if (p.destroyed) return null\n\n    if (!p.remoteHolepunching && !stable) {\n      stable = await p.analyze(true)\n      if (p.destroyed) return null\n      if (!stable) return this._abort(h)\n    }\n\n    // Fast mode! If we are consistent and the remote has opened a session to us (remoteAddress)\n    // then fire a quick punch back. Note the await here just waits for the udp socket to flush.\n    if (isConsistent(p.nat.firewall) && remoteAddress && hasSameAddr(p.nat.addresses, remoteAddress)) {\n      await p.ping(peerAddress)\n      if (p.destroyed) return null\n    }\n\n    // Remote said they are punching (or willing to), so we will punch as well.\n    // Note that this returns when the punching has STARTED, so no guarantee\n    // we will have a connection after this promise etc.\n    if (p.remoteHolepunching) {\n      // TODO: still continue here if a local connection might work, but then do not holepunch...\n      if (!this.holepunch(p.remoteFirewall, p.nat.firewall, p.remoteAddresses, p.nat.addresses)) {\n        return p.destroyed ? null : this._abort(h)\n      }\n\n      if (h.prepunching) {\n        clearTimeout(h.prepunching)\n        h.prepunching = null\n      }\n\n      if (p.remoteFirewall >= FIREWALL.RANDOM || p.nat.firewall >= FIREWALL.RANDOM) {\n        if (this.dht._randomPunches >= this.dht._randomPunchLimit || (Date.now() - this.dht._lastRandomPunch) < this.dht._randomPunchInterval) {\n          if (!h.relayToken) return this._abort(h, ERROR.TRY_LATER)\n          return {\n            socket: p.socket,\n            payload: h.payload.encrypt({\n              error: ERROR.TRY_LATER,\n              firewall: p.nat.firewall,\n              round: h.round,\n              connected: p.connected,\n              punching: p.punching,\n              addresses: p.nat.addresses,\n              remoteAddress: null,\n              token: isServerRelay ? token : null,\n              remoteToken: remotePayload.token\n            })\n          }\n        }\n      }\n\n      const punching = await p.punch()\n      if (p.destroyed) return null\n      if (!punching) return this._abort(h)\n    }\n\n    // Freeze that analysis as soon as we have a result we are giving to the other peer\n    if (p.nat.firewall !== FIREWALL.UNKNOWN) {\n      p.nat.freeze()\n    }\n\n    return {\n      socket: p.socket,\n      payload: h.payload.encrypt({\n        error: ERROR.NONE,\n        firewall: p.nat.firewall,\n        round: h.round,\n        connected: p.connected,\n        punching: p.punching,\n        addresses: p.nat.addresses,\n        remoteAddress: null,\n        token: isServerRelay ? token : null,\n        remoteToken: remotePayload.token\n      })\n    }\n  }\n\n  _abort (h, error = ERROR.ABORTED) {\n    if (!h.payload) {\n      if (h.puncher) h.puncher.destroy()\n      return null\n    }\n\n    const payload = h.payload.encrypt({\n      error,\n      firewall: FIREWALL.UNKNOWN,\n      round: h.round,\n      connected: false,\n      punching: false,\n      addresses: null,\n      remoteAddress: null,\n      token: null,\n      remoteToken: null\n    })\n\n    h.puncher.destroy()\n\n    return { socket: this.dht.socket, payload }\n  }\n\n  _relayConnection (hs, relayThrough, remotePayload, h) {\n    let isInitiator\n    let publicKey\n    let token\n\n    if (relayThrough) {\n      isInitiator = true\n      publicKey = relayThrough\n      token = hs.relayToken\n    } else {\n      isInitiator = false\n      publicKey = remotePayload.relayThrough.publicKey\n      token = remotePayload.relayThrough.token\n    }\n\n    hs.relayToken = token\n    hs.relaySocket = this.dht.connect(publicKey)\n    hs.relaySocket.setKeepAlive(this.relayKeepAlive)\n    hs.relayClient = relay.Client.from(hs.relaySocket, { id: hs.relaySocket.publicKey })\n    hs.relayTimeout = setTimeout(onabort, 15000)\n\n    hs.relayClient\n      .pair(isInitiator, token, hs.rawStream)\n      .on('error', onabort)\n      .on('data', (remoteId) => {\n        if (hs.relayTimeout) clearRelayTimeout(hs)\n        if (hs.rawStream === null) {\n          onabort(null)\n          return\n        }\n\n        hs.relayPaired = true\n\n        if (hs.prepunching) clearTimeout(hs.prepunching)\n        hs.prepunching = null\n\n        const {\n          remotePort,\n          remoteHost,\n          socket\n        } = hs.relaySocket.rawStream\n\n        hs.rawStream\n          .on('close', () => hs.relaySocket.destroy())\n          .connect(socket, remoteId, remotePort, remoteHost)\n\n        hs.encryptedSocket = this.createSecretStream(false, hs.rawStream, { handshake: h })\n\n        this.onconnection(hs.encryptedSocket)\n      })\n\n    function onabort () {\n      if (hs.relayTimeout) clearRelayTimeout(hs)\n      const socket = hs.relaySocket\n      hs.relayToken = null\n      hs.relaySocket = null\n      if (socket) socket.destroy()\n    }\n  }\n}\n\nfunction clearRelayTimeout (hs) {\n  clearTimeout(hs.relayTimeout)\n  hs.relayTimeout = null\n}\n\nfunction isConsistent (fw) {\n  return fw === FIREWALL.OPEN || fw === FIREWALL.CONSISTENT\n}\n\nfunction hasSameAddr (addrs, other) {\n  if (addrs === null) return false\n\n  for (const addr of addrs) {\n    if (addr.port === other.port && addr.host === other.host) return true\n  }\n  return false\n}\n\nfunction defaultCreateHandshake (keyPair, remotePublicKey) {\n  return new NoiseWrap(keyPair, remotePublicKey)\n}\n\nfunction defaultCreateSecretStream (isInitiator, rawStream, opts) {\n  return new NoiseSecretStream(isInitiator, rawStream, opts)\n}\n\nfunction onlyPrivateHosts (addr) {\n  return isPrivate(addr.host)\n}\n\nfunction isRelay (relaySocket, socket, port, host) {\n  const stream = relaySocket.rawStream\n  if (!stream) return false\n  if (stream.socket !== socket) return false\n  return port === stream.remotePort && host === stream.remoteHost\n}\n\nfunction selectRelay (relayThrough) {\n  if (typeof relayThrough === 'function') relayThrough = relayThrough()\n  if (relayThrough === null) return null\n  if (Array.isArray(relayThrough)) return relayThrough[Math.floor(Math.random() * relayThrough.length)]\n  return relayThrough\n}\n\nfunction noop () {}\nmodule.exports = class Sleeper {\n  constructor () {\n    this._timeout = null\n    this._resolve = null\n\n    this._start = (resolve) => {\n      this._resolve = resolve\n    }\n\n    this._trigger = () => {\n      if (this._resolve === null) return\n      const resolve = this._resolve\n      this._timeout = null\n      this._resolve = null\n      resolve()\n    }\n  }\n\n  pause (ms) {\n    const p = new Promise(this._start)\n    if (this._timeout !== null) {\n      clearTimeout(this._timeout)\n      this._trigger()\n    }\n    this._timeout = setTimeout(this._trigger, ms)\n    return p\n  }\n\n  resume () {\n    if (this._timeout !== null) {\n      clearTimeout(this._timeout)\n      this._trigger()\n    }\n  }\n}\nconst b4a = require('b4a')\n\nconst LINGER_TIME = 3000\n\nmodule.exports = class SocketPool {\n  constructor (dht, host) {\n    this._dht = dht\n    this._sockets = new Map()\n    this._lingering = new Set() // updated by the ref\n    this._host = host\n\n    this.routes = new SocketRoutes(this)\n  }\n\n  _onmessage (ref, data, address) {\n    this._dht.onmessage(ref.socket, data, address)\n  }\n\n  _add (ref) {\n    this._sockets.set(ref.socket, ref)\n  }\n\n  _remove (ref) {\n    this._sockets.delete(ref.socket)\n    this._lingering.delete(ref)\n  }\n\n  lookup (socket) {\n    return this._sockets.get(socket) || null\n  }\n\n  setReusable (socket, bool) {\n    const ref = this.lookup(socket)\n    if (ref) ref.reusable = bool\n  }\n\n  acquire () {\n    // TODO: Enable socket reuse\n    return new SocketRef(this)\n  }\n\n  async destroy () {\n    const closing = []\n\n    for (const ref of this._sockets.values()) {\n      ref._unlinger()\n      closing.push(ref.socket.close())\n    }\n\n    await Promise.allSettled(closing)\n  }\n}\n\nclass SocketRoutes {\n  constructor (pool) {\n    this._pool = pool\n    this._routes = new Map()\n  }\n\n  add (publicKey, rawStream) {\n    if (rawStream.socket) this._onconnect(publicKey, rawStream)\n    else rawStream.on('connect', this._onconnect.bind(this, publicKey, rawStream))\n  }\n\n  get (publicKey) {\n    const id = b4a.toString(publicKey, 'hex')\n    const route = this._routes.get(id)\n    if (!route) return null\n    return route\n  }\n\n  _onconnect (publicKey, rawStream) {\n    const id = b4a.toString(publicKey, 'hex')\n    const socket = rawStream.socket\n\n    let route = this._routes.get(id)\n\n    if (!route) {\n      const gc = () => {\n        if (this._routes.get(id) === route) this._routes.delete(id)\n        socket.removeListener('close', gc)\n      }\n\n      route = {\n        socket,\n        address: { host: rawStream.remoteHost, port: rawStream.remotePort },\n        gc\n      }\n\n      this._routes.set(id, route)\n      socket.on('close', gc)\n    }\n\n    this._pool.setReusable(socket, true)\n\n    rawStream.on('error', () => {\n      this._pool.setReusable(socket, false)\n      if (!route) route = this._routes.get(id)\n      if (route && route.socket === socket) route.gc()\n    })\n  }\n}\n\n// TODO: we should just make some \"user data\" object on udx to allow to attach this info\nclass SocketRef {\n  constructor (pool) {\n    this._pool = pool\n\n    // Events\n    this.onholepunchmessage = noop\n\n    // Whether it should teardown immediately or wait a bit\n    this.reusable = false\n\n    this.socket = pool._dht.udx.createSocket()\n    this.socket\n      .on('close', this._onclose.bind(this))\n      .on('message', this._onmessage.bind(this))\n      .on('idle', this._onidle.bind(this))\n      .on('busy', this._onbusy.bind(this))\n      .bind(0, this._pool._host)\n\n    this._refs = 1\n    this._released = false\n    this._closed = false\n\n    this._timeout = null\n    this._wasBusy = false\n\n    this._pool._add(this)\n  }\n\n  _onclose () {\n    this._pool._remove(this)\n  }\n\n  _onmessage (data, address) {\n    if (data.byteLength > 1) {\n      this._pool._onmessage(this, data, address)\n    } else {\n      this.onholepunchmessage(data, address, this)\n    }\n  }\n\n  _onidle () {\n    this._closeMaybe()\n  }\n\n  _onbusy () {\n    this._wasBusy = true\n    this._unlinger()\n  }\n\n  _reset () {\n    this.onholepunchmessage = noop\n  }\n\n  _closeMaybe () {\n    if (this._refs === 0 && this.socket.idle && !this._timeout) this._close()\n  }\n\n  _lingeringClose () {\n    this._pool._lingering.delete(this)\n    this._timeout = null\n    this._closeMaybe()\n  }\n\n  _close () {\n    this._unlinger()\n\n    if (this.reusable && this._wasBusy) {\n      this._wasBusy = false\n      this._pool._lingering.add(this)\n      this._timeout = setTimeout(this._lingeringClose.bind(this), LINGER_TIME)\n      return\n    }\n\n    this._closed = true\n    this.socket.close()\n  }\n\n  _unlinger () {\n    if (this._timeout !== null) {\n      clearTimeout(this._timeout)\n      this._pool._lingering.delete(this)\n      this._timeout = null\n    }\n  }\n\n  get free () {\n    return this._refs === 0\n  }\n\n  active () {\n    this._refs++\n    this._unlinger()\n  }\n\n  inactive () {\n    this._refs--\n    this._closeMaybe()\n  }\n\n  address () {\n    return this.socket.address()\n  }\n\n  release () {\n    if (this._released) return\n\n    this._released = true\n    this._reset()\n\n    this._refs--\n    this._closeMaybe()\n  }\n}\n\nfunction noop () {}\n{\n  \"name\": \"hyperdht\",\n  \"version\": \"6.20.1\",\n  \"description\": \"The DHT powering Hyperswarm\",\n  \"main\": \"index.js\",\n  \"browser\": \"browser.js\",\n  \"bin\": {\n    \"hyperdht\": \"./bin.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"browser.js\",\n    \"testnet.js\",\n    \"bin.js\",\n    \"lib/**.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"@hyperswarm/secret-stream\": \"^6.6.2\",\n    \"b4a\": \"^1.3.1\",\n    \"bare-events\": \"^2.2.0\",\n    \"blind-relay\": \"^1.3.0\",\n    \"bogon\": \"^1.0.0\",\n    \"compact-encoding\": \"^2.4.1\",\n    \"compact-encoding-net\": \"^1.0.1\",\n    \"dht-rpc\": \"^6.15.1\",\n    \"hypercore-crypto\": \"^3.3.0\",\n    \"hypercore-id-encoding\": \"^1.2.0\",\n    \"noise-curve-ed\": \"^2.0.0\",\n    \"noise-handshake\": \"^3.0.0\",\n    \"record-cache\": \"^1.1.1\",\n    \"safety-catch\": \"^1.0.1\",\n    \"signal-promise\": \"^1.0.3\",\n    \"sodium-universal\": \"^4.0.0\",\n    \"streamx\": \"^2.16.1\",\n    \"unslab\": \"^1.3.0\",\n    \"xache\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.0\",\n    \"graceful-goodbye\": \"^1.3.0\",\n    \"newline-decoder\": \"^1.0.2\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && node test/all.js\",\n    \"test:generate\": \"brittle -r test/all.js test/*.js\",\n    \"lint\": \"standard\",\n    \"integration\": \"brittle test/integration/*.js\",\n    \"end-to-end\": \"brittle test/end-to-end/*.js\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"directories\": {\n    \"lib\": \"lib\",\n    \"test\": \"test\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/hyperdht.git\"\n  },\n  \"keywords\": [],\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hyperdht/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hyperdht#readme\",\n  \"standard\": {\n    \"ignore\": [\n      \"**/*.mjs\"\n    ]\n  }\n}\nconst Hyperbee = require('hyperbee')\nconst Hyperblobs = require('hyperblobs')\nconst isOptions = require('is-options')\nconst { Writable, Readable } = require('streamx')\nconst unixPathResolve = require('unix-path-resolve')\nconst MirrorDrive = require('mirror-drive')\nconst SubEncoder = require('sub-encoder')\nconst ReadyResource = require('ready-resource')\nconst safetyCatch = require('safety-catch')\nconst crypto = require('hypercore-crypto')\nconst Hypercore = require('hypercore')\nconst { BLOCK_NOT_AVAILABLE, BAD_ARGUMENT } = require('hypercore-errors')\nconst Monitor = require('./lib/monitor')\n\nconst keyEncoding = new SubEncoder('files', 'utf-8')\n\nconst [BLOBS] = crypto.namespace('hyperdrive', 1)\n\nmodule.exports = class Hyperdrive extends ReadyResource {\n  constructor (corestore, key, opts = {}) {\n    super()\n\n    if (isOptions(key)) {\n      opts = key\n      key = null\n    }\n\n    this.corestore = corestore\n    this.db = opts._db || makeBee(key, corestore, opts)\n    this.core = this.db.core\n    this.blobs = null\n    this.supportsMetadata = true\n    this.encryptionKey = opts.encryptionKey || null\n    this.monitors = new Set()\n\n    this._active = opts.active !== false\n    this._openingBlobs = null\n    this._onwait = opts.onwait || null\n    this._batching = !!(opts._checkout === null && opts._db)\n    this._checkout = opts._checkout || null\n\n    this.ready().catch(safetyCatch)\n  }\n\n  [Symbol.asyncIterator] () {\n    return this.entries()[Symbol.asyncIterator]()\n  }\n\n  static async getDriveKey (corestore) {\n    const core = makeBee(undefined, corestore)\n    await core.ready()\n    const key = core.key\n    await core.close()\n    return key\n  }\n\n  static getContentKey (m, key) {\n    if (m instanceof Hypercore) {\n      if (m.core.compat) return null\n      return Hyperdrive.getContentKey(m.manifest, m.key)\n    }\n\n    const manifest = generateContentManifest(m, key)\n    if (!manifest) return null\n\n    return Hypercore.key(manifest)\n  }\n\n  _generateBlobsManifest () {\n    const m = this.db.core.manifest\n    if (this.db.core.core.compat) return null\n\n    return generateContentManifest(m, this.core.key)\n  }\n\n  get id () {\n    return this.core.id\n  }\n\n  get key () {\n    return this.core.key\n  }\n\n  get discoveryKey () {\n    return this.core.discoveryKey\n  }\n\n  get contentKey () {\n    return this.blobs?.core.key\n  }\n\n  get version () {\n    return this.db.version\n  }\n\n  get writable () {\n    return this.core.writable\n  }\n\n  get readable () {\n    return this.core.readable\n  }\n\n  findingPeers () {\n    return this.corestore.findingPeers()\n  }\n\n  async truncate (version, { blobs = -1 } = {}) {\n    if (!this.opened) await this.ready()\n\n    if (version > this.core.length) {\n      throw BAD_ARGUMENT('Bad truncation length')\n    }\n\n    const blobsVersion = blobs === -1 ? await this.getBlobsLength(version) : blobs\n    const bl = await this.getBlobs()\n\n    if (blobsVersion > bl.core.length) {\n      throw BAD_ARGUMENT('Bad truncation length')\n    }\n\n    await this.core.truncate(version)\n    await bl.core.truncate(blobsVersion)\n  }\n\n  async getBlobsLength (checkout) {\n    if (!this.opened) await this.ready()\n\n    if (!checkout) checkout = this.version\n\n    const c = this.db.checkout(checkout)\n\n    try {\n      return await getBlobsLength(c)\n    } finally {\n      await c.close()\n    }\n  }\n\n  replicate (isInitiator, opts) {\n    return this.corestore.replicate(isInitiator, opts)\n  }\n\n  update (opts) {\n    return this.db.update(opts)\n  }\n\n  _makeCheckout (snapshot) {\n    return new Hyperdrive(this.corestore, this.key, {\n      onwait: this._onwait,\n      encryptionKey: this.encryptionKey,\n      _checkout: this._checkout || this,\n      _db: snapshot\n    })\n  }\n\n  checkout (version) {\n    return this._makeCheckout(this.db.checkout(version))\n  }\n\n  batch () {\n    return new Hyperdrive(this.corestore, this.key, {\n      onwait: this._onwait,\n      encryptionKey: this.encryptionKey,\n      _checkout: null,\n      _db: this.db.batch()\n    })\n  }\n\n  setActive (bool) {\n    const active = !!bool\n    if (active === this._active) return\n    this._active = active\n    this.core.setActive(active)\n    if (this.blobs) this.blobs.core.setActive(active)\n  }\n\n  async flush () {\n    await this.db.flush()\n    return this.close()\n  }\n\n  async _close () {\n    if (this.blobs && (!this._checkout || this.blobs !== this._checkout.blobs)) {\n      await this.blobs.core.close()\n    }\n\n    await this.db.close()\n\n    if (!this._checkout && !this._batching) {\n      await this.corestore.close()\n    }\n\n    await this.closeMonitors()\n  }\n\n  async _openBlobsFromHeader (opts) {\n    if (this.blobs) return true\n\n    const header = await getBee(this.db).getHeader(opts)\n    if (!header) return false\n\n    if (this.blobs) return true\n\n    const contentKey = header.metadata && header.metadata.contentFeed && header.metadata.contentFeed.subarray(0, 32)\n    const blobsKey = contentKey || Hypercore.key(this._generateBlobsManifest())\n    if (!blobsKey || blobsKey.length < 32) throw new Error('Invalid or no Blob store key set')\n\n    const blobsCore = this.corestore.get({\n      key: blobsKey,\n      cache: false,\n      onwait: this._onwait,\n      encryptionKey: this.encryptionKey,\n      keyPair: (!contentKey && this.db.core.writable) ? this.db.core.keyPair : null,\n      active: this._active\n    })\n    await blobsCore.ready()\n\n    if (this.closing) {\n      await blobsCore.close()\n      return false\n    }\n\n    this.blobs = new Hyperblobs(blobsCore)\n\n    this.emit('blobs', this.blobs)\n    this.emit('content-key', blobsCore.key)\n\n    return true\n  }\n\n  async _open () {\n    if (this._checkout) {\n      await this._checkout.ready()\n      this.blobs = this._checkout.blobs\n      return\n    }\n\n    await this._openBlobsFromHeader({ wait: false })\n\n    if (this.db.core.writable && !this.blobs) {\n      const m = this._generateBlobsManifest()\n      const blobsCore = this.corestore.get({\n        manifest: m,\n        name: m ? null : this.db.core.id + '/blobs', // simple trick to avoid blobs clashing if no namespace is provided...\n        cache: false,\n        onwait: this._onwait,\n        encryptionKey: this.encryptionKey,\n        compat: this.db.core.core.compat,\n        active: this._active,\n        keyPair: (m && this.db.core.writable) ? this.db.core.keyPair : null\n      })\n      await blobsCore.ready()\n\n      this.blobs = new Hyperblobs(blobsCore)\n\n      if (!m) getBee(this.db).metadata.contentFeed = this.blobs.core.key\n\n      this.emit('blobs', this.blobs)\n      this.emit('content-key', blobsCore.key)\n    }\n\n    await this.db.ready()\n\n    if (!this.blobs) {\n      // eagerly load the blob store....\n      this._openingBlobs = this._openBlobsFromHeader()\n      this._openingBlobs.catch(safetyCatch)\n    }\n  }\n\n  async getBlobs () {\n    if (this.blobs) return this.blobs\n\n    if (this._checkout) {\n      this.blobs = await this._checkout.getBlobs()\n    } else {\n      await this.ready()\n      await this._openingBlobs\n    }\n\n    return this.blobs\n  }\n\n  monitor (name, opts = {}) {\n    const monitor = new Monitor(this, { name, ...opts })\n    this.monitors.add(monitor)\n    return monitor\n  }\n\n  async closeMonitors () {\n    const closing = []\n    for (const monitor of this.monitors) closing.push(monitor.close())\n    await Promise.allSettled(closing)\n  }\n\n  async get (name, opts) {\n    const node = await this.entry(name, opts)\n    if (!node?.value.blob) return null\n    await this.getBlobs()\n    const res = await this.blobs.get(node.value.blob, opts)\n\n    if (res === null) throw BLOCK_NOT_AVAILABLE()\n    return res\n  }\n\n  async put (name, buf, { executable = false, metadata = null } = {}) {\n    await this.getBlobs()\n    const blob = await this.blobs.put(buf)\n    return this.db.put(std(name, false), { executable, linkname: null, blob, metadata }, { keyEncoding })\n  }\n\n  async del (name) {\n    return this.db.del(std(name, false), { keyEncoding })\n  }\n\n  compare (a, b) {\n    const diff = a.seq - b.seq\n    return diff > 0 ? 1 : (diff < 0 ? -1 : 0)\n  }\n\n  async clear (name, opts) {\n    if (!this.opened) await this.ready()\n\n    let node = null\n\n    try {\n      node = await this.entry(name, { wait: false })\n    } catch {\n      // do nothing, prop not available\n    }\n\n    if (node === null || this.blobs === null) {\n      return (opts && opts.diff) ? { blocks: 0 } : null\n    }\n\n    return this.blobs.clear(node.value.blob, opts)\n  }\n\n  async clearAll (opts) {\n    if (!this.opened) await this.ready()\n\n    if (this.blobs === null) {\n      return (opts && opts.diff) ? { blocks: 0 } : null\n    }\n\n    return this.blobs.core.clear(0, this.blobs.core.length, opts)\n  }\n\n  async purge () {\n    if (this._checkout || this._batch) throw new Error('Can only purge the main session')\n\n    await this.ready() // Ensure blobs loaded if present\n    await this.close()\n\n    const proms = [this.core.purge()]\n    if (this.blobs) proms.push(this.blobs.core.purge())\n    await Promise.all(proms)\n  }\n\n  async symlink (name, dst, { metadata = null } = {}) {\n    return this.db.put(std(name, false), { executable: false, linkname: dst, blob: null, metadata }, { keyEncoding })\n  }\n\n  async entry (name, opts) {\n    if (!opts || !opts.follow) return this._entry(name, opts)\n\n    for (let i = 0; i < 16; i++) {\n      const node = await this._entry(name, opts)\n      if (!node || !node.value.linkname) return node\n\n      name = unixPathResolve(node.key, node.value.linkname)\n    }\n\n    throw new Error('Recursive symlink')\n  }\n\n  async _entry (name, opts) {\n    if (typeof name !== 'string') return name\n\n    return this.db.get(std(name, false), { ...opts, keyEncoding })\n  }\n\n  async exists (name) {\n    return await this.entry(name) !== null\n  }\n\n  watch (folder) {\n    folder = std(folder || '/', true)\n\n    return this.db.watch(prefixRange(folder), { keyEncoding, map: (snap) => this._makeCheckout(snap) })\n  }\n\n  diff (length, folder, opts) {\n    if (typeof folder === 'object' && folder && !opts) return this.diff(length, null, folder)\n\n    folder = std(folder || '/', true)\n\n    return this.db.createDiffStream(length, prefixRange(folder), { ...opts, keyEncoding })\n  }\n\n  async downloadDiff (length, folder, opts) {\n    const dls = []\n\n    for await (const entry of this.diff(length, folder, opts)) {\n      if (!entry.left) continue\n      const b = entry.left.value.blob\n      if (!b) continue\n      const blobs = await this.getBlobs()\n      dls.push(blobs.core.download({ start: b.blockOffset, length: b.blockLength }))\n    }\n\n    const proms = []\n    for (const r of dls) proms.push(r.downloaded())\n\n    await Promise.allSettled(proms)\n  }\n\n  async downloadRange (dbRanges, blobRanges) {\n    const dls = []\n\n    await this.ready()\n\n    for (const range of dbRanges) {\n      dls.push(this.db.core.download(range))\n    }\n\n    const blobs = await this.getBlobs()\n\n    for (const range of blobRanges) {\n      dls.push(blobs.core.download(range))\n    }\n\n    const proms = []\n    for (const r of dls) proms.push(r.downloaded())\n\n    await Promise.allSettled(proms)\n  }\n\n  entries (range, opts) {\n    const stream = this.db.createReadStream(range, { ...opts, keyEncoding })\n    if (opts && opts.ignore) stream._readableState.map = createStreamMapIgnore(opts.ignore)\n    return stream\n  }\n\n  async download (folder = '/', opts) {\n    if (typeof folder === 'object') return this.download(undefined, folder)\n\n    const dls = []\n    const entry = (!folder || folder.endsWith('/')) ? null : await this.entry(folder)\n\n    if (entry) {\n      const b = entry.value.blob\n      if (!b) return\n      const blobs = await this.getBlobs()\n      await blobs.core.download({ start: b.blockOffset, length: b.blockLength }).downloaded()\n      return\n    }\n\n    // first preload the list so we can use the full power afterwards to actually preload everything\n    // eslint-disable-next-line\n    for await (const _ of this.list(folder, opts)) {\n      // ignore\n    }\n\n    for await (const entry of this.list(folder, opts)) {\n      const b = entry.value.blob\n      if (!b) continue\n\n      const blobs = await this.getBlobs()\n      dls.push(blobs.core.download({ start: b.blockOffset, length: b.blockLength }))\n    }\n\n    const proms = []\n    for (const r of dls) proms.push(r.downloaded())\n\n    await Promise.allSettled(proms)\n  }\n\n  // atm always recursive, but we should add some depth thing to it\n  list (folder, opts = {}) {\n    if (typeof folder === 'object') return this.list(undefined, folder)\n\n    folder = std(folder || '/', true)\n\n    const ignore = opts.ignore ? normalizeIgnore(opts.ignore) : null\n    const stream = opts && opts.recursive === false ? shallowReadStream(this.db, folder, false, ignore, opts) : this.entries(prefixRange(folder), { ...opts, ignore })\n    return stream\n  }\n\n  readdir (folder, opts) {\n    folder = std(folder || '/', true)\n    return shallowReadStream(this.db, folder, true, null, opts)\n  }\n\n  mirror (out, opts) {\n    return new MirrorDrive(this, out, opts)\n  }\n\n  createReadStream (name, opts) {\n    const self = this\n\n    let destroyed = false\n    let rs = null\n\n    const stream = new Readable({\n      open (cb) {\n        self.getBlobs().then(onblobs, cb)\n\n        function onblobs () {\n          self.entry(name).then(onnode, cb)\n        }\n\n        function onnode (node) {\n          if (destroyed) return cb(null)\n          if (!node) return cb(new Error('Blob does not exist'))\n          if (self.closing) return cb(new Error('Closed'))\n\n          if (!node.value.blob) {\n            stream.push(null)\n            return cb(null)\n          }\n\n          rs = self.blobs.createReadStream(node.value.blob, opts)\n\n          rs.on('data', function (data) {\n            if (!stream.push(data)) rs.pause()\n          })\n\n          rs.on('end', function () {\n            stream.push(null)\n          })\n\n          rs.on('error', function (err) {\n            stream.destroy(err)\n          })\n\n          cb(null)\n        }\n      },\n      read (cb) {\n        rs.resume()\n        cb(null)\n      },\n      predestroy () {\n        destroyed = true\n        if (rs) rs.destroy()\n      }\n    })\n\n    return stream\n  }\n\n  createWriteStream (name, { executable = false, metadata = null } = {}) {\n    const self = this\n\n    let destroyed = false\n    let ws = null\n    let ondrain = null\n    let onfinish = null\n\n    const stream = new Writable({\n      open (cb) {\n        self.getBlobs().then(onblobs, cb)\n\n        function onblobs () {\n          if (destroyed) return cb(null)\n\n          ws = self.blobs.createWriteStream()\n\n          ws.on('error', function (err) {\n            stream.destroy(err)\n          })\n\n          ws.on('close', function () {\n            const err = new Error('Closed')\n            callOndrain(err)\n            callOnfinish(err)\n          })\n\n          ws.on('finish', function () {\n            callOnfinish(null)\n          })\n\n          ws.on('drain', function () {\n            callOndrain(null)\n          })\n\n          cb(null)\n        }\n      },\n      write (data, cb) {\n        if (ws.write(data) === true) return cb(null)\n        ondrain = cb\n      },\n      final (cb) {\n        onfinish = cb\n        ws.end()\n      },\n      predestroy () {\n        destroyed = true\n        if (ws) ws.destroy()\n      }\n    })\n\n    return stream\n\n    function callOnfinish (err) {\n      if (!onfinish) return\n\n      const cb = onfinish\n      onfinish = null\n\n      if (err) return cb(err)\n      self.db.put(std(name, false), { executable, linkname: null, blob: ws.id, metadata }, { keyEncoding }).then(() => cb(null), cb)\n    }\n\n    function callOndrain (err) {\n      if (ondrain) {\n        const cb = ondrain\n        ondrain = null\n        cb(err)\n      }\n    }\n  }\n\n  static normalizePath (name) {\n    return std(name, false)\n  }\n}\n\nfunction shallowReadStream (files, folder, keys, ignore, opts) {\n  let prev = '/'\n  let prevName = ''\n\n  return new Readable({\n    async read (cb) {\n      let node = null\n\n      try {\n        node = await files.peek(prefixRange(folder, prev), { ...opts, keyEncoding })\n      } catch (err) {\n        return cb(err)\n      }\n\n      if (!node) {\n        this.push(null)\n        return cb(null)\n      }\n\n      const suffix = node.key.slice(folder.length + 1)\n      const i = suffix.indexOf('/')\n      const name = i === -1 ? suffix : suffix.slice(0, i)\n\n      prev = '/' + name + (i === -1 ? '' : '0')\n\n      // just in case someone does /foo + /foo/bar, but we should prop not even support that\n      if (name === prevName) {\n        this._read(cb)\n        return\n      }\n\n      prevName = name\n\n      if (ignore && isIgnored(node.key, ignore)) {\n        this._read(cb)\n        return\n      }\n\n      this.push(keys ? name : node)\n      cb(null)\n    }\n  })\n}\n\nfunction makeBee (key, corestore, opts = {}) {\n  const name = key ? undefined : 'db'\n  const core = corestore.get({ key, name, exclusive: true, onwait: opts.onwait, encryptionKey: opts.encryptionKey, compat: opts.compat, active: opts.active })\n\n  return new Hyperbee(core, {\n    keyEncoding: 'utf-8',\n    valueEncoding: 'json',\n    metadata: { contentFeed: null }\n  })\n}\n\nfunction getBee (bee) {\n  // A Batch instance will have a .tree property for the actual Hyperbee\n  return bee.tree || bee\n}\n\nfunction std (name, removeSlash) {\n  // Note: only remove slash if you're going to use it as prefix range\n  name = unixPathResolve('/', name)\n  if (removeSlash && name.endsWith('/')) name = name.slice(0, -1)\n  validateFilename(name)\n  return name\n}\n\nfunction validateFilename (name) {\n  if (name === '/') throw new Error('Invalid filename: ' + name)\n}\n\nfunction prefixRange (name, prev = '/') {\n  // '0' is binary +1 of /\n  return { gt: name + prev, lt: name + '0' }\n}\n\nfunction generateContentManifest (m, key) {\n  if (m.version < 1) return null\n\n  const signers = []\n\n  if (!key) key = Hypercore.key(m)\n\n  for (const s of m.signers) {\n    const namespace = crypto.hash([BLOBS, key, s.namespace])\n    signers.push({ ...s, namespace })\n  }\n\n  return {\n    version: m.version,\n    hash: 'blake2b',\n    allowPatch: m.allowPatch,\n    quorum: m.quorum,\n    signers,\n    prologue: null // TODO: could be configurable through the header still...\n  }\n}\n\nasync function getBlobsLength (db) {\n  let length = 0\n\n  for await (const { value } of db.createReadStream()) {\n    const b = value && value.blob\n    if (!b) continue\n    const len = b.blockOffset + b.blockLength\n    if (len > length) length = len\n  }\n\n  return length\n}\n\nfunction normalizeIgnore (ignore) {\n  return [].concat(ignore).map(e => unixPathResolve('/', e))\n}\n\nfunction isIgnored (key, ignore) {\n  return ignore.some(e => e === key || key.startsWith(e + '/'))\n}\n\nfunction createStreamMapIgnore (ignore) {\n  return (node) => {\n    return isIgnored(node.key, ignore) ? null : node\n  }\n}\nconst ReadyResource = require('ready-resource')\nconst safetyCatch = require('safety-catch')\nconst speedometer = require('speedometer')\n\nmodule.exports = class Monitor extends ReadyResource {\n  constructor (drive, opts = {}) {\n    super()\n    this.drive = drive\n    this.blobs = null\n    this.name = opts.name || null\n    this.entry = opts.entry || null\n    this.peers = 0\n\n    this._boundOnUpload = this._onUpload.bind(this)\n    this._boundOnDownload = this._onDownload.bind(this)\n    this._boundPeerUpdate = this._updatePeers.bind(this)\n\n    const stats = {\n      startTime: 0,\n      percentage: 0,\n      peers: 0,\n      speed: 0,\n      blocks: 0,\n      totalBytes: 0, // local + bytes loaded during monitoring\n      monitoringBytes: 0, // bytes loaded during monitoring\n      targetBytes: 0,\n      targetBlocks: 0\n    }\n\n    // Updated on each upload/download event\n    this.uploadStats = { ...stats }\n    this.downloadStats = { ...stats }\n\n    this.uploadSpeedometer = null\n    this.downloadSpeedometer = null\n\n    this.ready().catch(safetyCatch)\n  }\n\n  async _open () {\n    await this.drive.ready()\n    this.blobs = await this.drive.getBlobs()\n    if (!this.entry && this.name) this.entry = await this.drive.entry(this.name)\n    if (this.entry) this._setEntryInfo()\n\n    this.uploadSpeedometer = speedometer()\n    this.downloadSpeedometer = speedometer()\n\n    this._updatePeers()\n\n    // Handlers\n    this.blobs.core.on('peer-add', this._boundPeerUpdate)\n    this.blobs.core.on('peer-remove', this._boundPeerUpdate)\n    this.blobs.core.on('upload', this._boundOnUpload)\n    this.blobs.core.on('download', this._boundOnDownload)\n  }\n\n  async _close () {\n    this.blobs.core.off('peer-add', this._boundPeerUpdate)\n    this.blobs.core.off('peer-remove', this._boundPeerUpdate)\n    this.blobs.core.off('upload', this._boundOnUpload)\n    this.blobs.core.off('download', this._boundOnDownload)\n    this.drive.monitors.delete(this)\n  }\n\n  _setEntryInfo () {\n    if (!this.downloadStats.targetBytes || !this.downloadStats.targetBlocks) {\n      this.downloadStats.targetBytes = this.entry.value.blob.byteLength\n      this.downloadStats.targetBlocks = this.entry.value.blob.blockLength\n    }\n\n    if (!this.uploadStats.targetBytes || !this.uploadStats.targetBlocks) {\n      this.uploadStats.targetBytes = this.entry.value.blob.byteLength\n      this.uploadStats.targetBlocks = this.entry.value.blob.blockLength\n    }\n  }\n\n  _onUpload (index, bytes, from) {\n    this._updateStats(this.uploadSpeedometer, this.uploadStats, index, bytes, from)\n  }\n\n  _onDownload (index, bytes, from) {\n    this._updateStats(this.downloadSpeedometer, this.downloadStats, index, bytes, from)\n  }\n\n  _updatePeers () {\n    this.uploadStats.peers = this.downloadStats.peers = this.peers = this.blobs.core.peers.length\n  }\n\n  _updateStats (speed, stats, index, bytes, from) {\n    if (!this.entry || this.closing) return\n    if (!isWithinRange(index, this.entry)) return\n\n    if (!stats.startTime) stats.startTime = Date.now()\n\n    stats.speed = speed(bytes)\n    stats.blocks++\n    stats.monitoringBytes += bytes\n    stats.totalBytes += bytes\n    // NOTE: you should not rely on the percentage until the monitor is initialized with the local state of the file\n    stats.percentage = toFixed(stats.blocks / stats.targetBlocks * 100)\n\n    this.emit('update')\n  }\n\n  downloadSpeed () {\n    return this.downloadSpeedometer ? this.downloadSpeedometer() : 0\n  }\n\n  uploadSpeed () {\n    return this.uploadSpeedometer ? this.uploadSpeedometer() : 0\n  }\n}\n\nfunction isWithinRange (index, entry) {\n  if (!entry || !entry.value) return\n  const { blockOffset, blockLength } = entry.value.blob\n  return index >= blockOffset && index < blockOffset + blockLength\n}\n\nfunction toFixed (n) {\n  return Math.round(n * 100) / 100\n}\n{\n  \"name\": \"hyperdrive\",\n  \"version\": \"11.13.4\",\n  \"description\": \"Hyperdrive is a secure, real-time distributed file system\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib/**.js\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/hyperdrive.git\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hyperdrive/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hyperdrive#readme\",\n  \"dependencies\": {\n    \"hyperbee\": \"^2.11.1\",\n    \"hyperblobs\": \"^2.3.0\",\n    \"hypercore\": \"^10.33.0\",\n    \"hypercore-errors\": \"^1.0.0\",\n    \"is-options\": \"^1.0.2\",\n    \"mirror-drive\": \"^1.2.0\",\n    \"ready-resource\": \"^1.0.0\",\n    \"safety-catch\": \"^1.0.2\",\n    \"speedometer\": \"^1.1.0\",\n    \"streamx\": \"^2.12.4\",\n    \"sub-encoder\": \"^2.1.1\",\n    \"unix-path-resolve\": \"^1.0.2\"\n  },\n  \"devDependencies\": {\n    \"b4a\": \"^1.6.0\",\n    \"brittle\": \"^3.1.0\",\n    \"corestore\": \"^6.8.1\",\n    \"hypercore-crypto\": \"^3.4.0\",\n    \"hyperdht\": \"^6.6.0\",\n    \"hyperswarm\": \"^4.0.0\",\n    \"random-access-memory\": \"^6.0.0\",\n    \"standard\": \"^17.0.0\",\n    \"test-tmp\": \"^1.3.0\"\n  }\n}\nconst { EventEmitter } = require('events')\nconst DHT = require('hyperdht')\nconst spq = require('shuffled-priority-queue')\nconst b4a = require('b4a')\nconst unslab = require('unslab')\n\nconst PeerInfo = require('./lib/peer-info')\nconst RetryTimer = require('./lib/retry-timer')\nconst ConnectionSet = require('./lib/connection-set')\nconst PeerDiscovery = require('./lib/peer-discovery')\n\nconst MAX_PEERS = 64\nconst MAX_PARALLEL = 3\nconst MAX_CLIENT_CONNECTIONS = Infinity // TODO: Change\nconst MAX_SERVER_CONNECTIONS = Infinity\n\nconst ERR_MISSING_TOPIC = 'Topic is required and must be a 32-byte buffer'\nconst ERR_DESTROYED = 'Swarm has been destroyed'\nconst ERR_DUPLICATE = 'Duplicate connection'\n\nmodule.exports = class Hyperswarm extends EventEmitter {\n  constructor (opts = {}) {\n    super()\n    const {\n      seed,\n      relayThrough,\n      keyPair = DHT.keyPair(seed),\n      maxPeers = MAX_PEERS,\n      maxClientConnections = MAX_CLIENT_CONNECTIONS,\n      maxServerConnections = MAX_SERVER_CONNECTIONS,\n      maxParallel = MAX_PARALLEL,\n      firewall = allowAll\n    } = opts\n    this.keyPair = keyPair\n\n    this.dht = opts.dht || new DHT({\n      bootstrap: opts.bootstrap,\n      nodes: opts.nodes\n    })\n    this.server = this.dht.createServer({\n      firewall: this._handleFirewall.bind(this),\n      relayThrough: this._maybeRelayConnection.bind(this)\n    }, this._handleServerConnection.bind(this))\n\n    this.destroyed = false\n    this.suspended = false\n    this.maxPeers = maxPeers\n    this.maxClientConnections = maxClientConnections\n    this.maxServerConnections = maxServerConnections\n    this.maxParallel = maxParallel\n    this.relayThrough = relayThrough || null\n\n    this.connecting = 0\n    this.connections = new Set()\n    this.peers = new Map()\n    this.explicitPeers = new Set()\n    this.listening = null\n    this.stats = {\n      updates: 0,\n      connects: {\n        client: {\n          opened: 0,\n          closed: 0,\n          attempted: 0\n        },\n        server: {\n          // Note: there is no notion of 'attempts' for server connections\n          opened: 0,\n          closed: 0\n        }\n      }\n    }\n\n    this._discovery = new Map()\n    this._timer = new RetryTimer(this._requeue.bind(this), {\n      backoffs: opts.backoffs,\n      jitter: opts.jitter\n    })\n    this._queue = spq()\n\n    this._allConnections = new ConnectionSet()\n    this._pendingFlushes = []\n    this._flushTick = 0\n\n    this._drainingQueue = false\n    this._clientConnections = 0\n    this._serverConnections = 0\n    this._firewall = firewall\n\n    this.dht.on('network-change', this._handleNetworkChange.bind(this))\n    this.on('update', this._handleUpdate)\n  }\n\n  _maybeRelayConnection (force) {\n    if (!this.relayThrough) return null\n    return this.relayThrough(force)\n  }\n\n  _enqueue (peerInfo) {\n    if (peerInfo.queued) return\n    peerInfo.queued = true\n    peerInfo._flushTick = this._flushTick\n    this._queue.add(peerInfo)\n\n    this._attemptClientConnections()\n  }\n\n  _requeue (batch) {\n    if (this.suspended) return\n    for (const peerInfo of batch) {\n      peerInfo.waiting = false\n\n      if ((peerInfo._updatePriority() === false) || this._allConnections.has(peerInfo.publicKey) || peerInfo.queued) continue\n      peerInfo.queued = true\n      peerInfo._flushTick = this._flushTick\n      this._queue.add(peerInfo)\n    }\n\n    this._attemptClientConnections()\n  }\n\n  _flushMaybe (peerInfo) {\n    for (let i = 0; i < this._pendingFlushes.length; i++) {\n      const flush = this._pendingFlushes[i]\n      if (peerInfo._flushTick > flush.tick) continue\n      if (--flush.missing > 0) continue\n      flush.onflush(true)\n      this._pendingFlushes.splice(i--, 1)\n    }\n  }\n\n  _flushAllMaybe () {\n    if (this.connecting > 0 || (this._allConnections.size < this.maxPeers && this._clientConnections < this.maxClientConnections)) {\n      return false\n    }\n\n    while (this._pendingFlushes.length) {\n      const flush = this._pendingFlushes.pop()\n      flush.onflush(true)\n    }\n\n    return true\n  }\n\n  _shouldConnect () {\n    return !this.destroyed &&\n      !this.suspended &&\n      this.connecting < this.maxParallel &&\n      this._allConnections.size < this.maxPeers &&\n      this._clientConnections < this.maxClientConnections\n  }\n\n  _shouldRequeue (peerInfo) {\n    if (this.suspended) return false\n    if (peerInfo.explicit) return true\n    for (const topic of peerInfo.topics) {\n      if (this._discovery.has(b4a.toString(topic, 'hex')) && !this.destroyed) {\n        return true\n      }\n    }\n    return false\n  }\n\n  _connect (peerInfo) {\n    if (peerInfo.banned || this._allConnections.has(peerInfo.publicKey)) {\n      this._flushMaybe(peerInfo)\n      return\n    }\n\n    // TODO: Support async firewalling at some point.\n    if (this._handleFirewall(peerInfo.publicKey, null)) {\n      peerInfo.ban(true)\n      this._flushMaybe(peerInfo)\n      return\n    }\n\n    const relayThrough = this._maybeRelayConnection(peerInfo.forceRelaying)\n    const conn = this.dht.connect(peerInfo.publicKey, {\n      relayAddresses: peerInfo.relayAddresses,\n      keyPair: this.keyPair,\n      relayThrough\n    })\n    this._allConnections.add(conn)\n\n    this.stats.connects.client.attempted++\n\n    this.connecting++\n    this._clientConnections++\n    let opened = false\n\n    const onerror = (err) => {\n      if (this.relayThrough && shouldForceRelaying(err.code)) {\n        peerInfo.forceRelaying = true\n        // Reset the attempts in order to fast connect to relay\n        peerInfo.attempts = 0\n      }\n    }\n\n    // Removed once a connection is opened\n    conn.on('error', onerror)\n\n    conn.on('open', () => {\n      opened = true\n      this.stats.connects.client.opened++\n\n      this._connectDone()\n      this.connections.add(conn)\n      conn.removeListener('error', onerror)\n      peerInfo._connected()\n      peerInfo.client = true\n      this.emit('connection', conn, peerInfo)\n      this._flushMaybe(peerInfo)\n\n      this.emit('update')\n    })\n    conn.on('close', () => {\n      if (!opened) this._connectDone()\n      this.stats.connects.client.closed++\n\n      this.connections.delete(conn)\n      this._allConnections.delete(conn)\n      this._clientConnections--\n      peerInfo._disconnected()\n\n      peerInfo.waiting = this._shouldRequeue(peerInfo) && this._timer.add(peerInfo)\n      this._maybeDeletePeer(peerInfo)\n\n      if (!opened) this._flushMaybe(peerInfo)\n\n      this._attemptClientConnections()\n\n      this.emit('update')\n    })\n\n    this.emit('update')\n  }\n\n  _connectDone () {\n    this.connecting--\n\n    if (this.connecting < this.maxParallel) this._attemptClientConnections()\n    if (this.connecting === 0) this._flushAllMaybe()\n  }\n\n  // Called when the PeerQueue indicates a connection should be attempted.\n  _attemptClientConnections () {\n    // Guard against re-entries - unsure if it still needed but doesn't hurt\n    if (this._drainingQueue) return\n    this._drainingQueue = true\n    while (this._queue.length && this._shouldConnect()) {\n      const peerInfo = this._queue.shift()\n      peerInfo.queued = false\n      this._connect(peerInfo)\n    }\n    this._drainingQueue = false\n    if (this.connecting === 0) this._flushAllMaybe()\n  }\n\n  _handleFirewall (remotePublicKey, payload) {\n    if (this.suspended) return true\n    if (b4a.equals(remotePublicKey, this.keyPair.publicKey)) return true\n\n    const peerInfo = this.peers.get(b4a.toString(remotePublicKey, 'hex'))\n    if (peerInfo && peerInfo.banned) return true\n\n    return this._firewall(remotePublicKey, payload)\n  }\n\n  _handleServerConnectionSwap (existing, conn) {\n    let closed = false\n\n    existing.on('close', () => {\n      if (closed) return\n\n      conn.removeListener('error', noop)\n      conn.removeListener('close', onclose)\n\n      this._handleServerConnection(conn)\n    })\n\n    conn.on('error', noop)\n    conn.on('close', onclose)\n\n    function onclose () {\n      closed = true\n    }\n  }\n\n  // Called when the DHT receives a new server connection.\n  _handleServerConnection (conn) {\n    if (this.destroyed) {\n      // TODO: Investigate why a final server connection can be received after close\n      conn.on('error', noop)\n      return conn.destroy(ERR_DESTROYED)\n    }\n\n    const existing = this._allConnections.get(conn.remotePublicKey)\n\n    if (existing) {\n      // If both connections are from the same peer,\n      // - pick the new one if the existing stream is already established (has sent and received bytes),\n      //   because the other client must have lost that connection and be reconnecting\n      // - otherwise, pick the one thats expected to initiate in a tie break\n      const existingIsOutdated = existing.rawBytesRead > 0 && existing.rawBytesWritten > 0\n      const expectedInitiator = b4a.compare(conn.publicKey, conn.remotePublicKey) > 0\n      const keepNew = existingIsOutdated || (expectedInitiator === conn.isInitiator)\n\n      if (keepNew === false) {\n        existing.sendKeepAlive()\n        conn.on('error', noop)\n        conn.destroy(new Error(ERR_DUPLICATE))\n        return\n      }\n\n      existing.on('error', noop)\n      existing.destroy(new Error(ERR_DUPLICATE))\n      this._handleServerConnectionSwap(existing, conn)\n      return\n    }\n\n    // When reaching here, the connection will always be 'opened' next tick\n    this.stats.connects.server.opened++\n\n    const peerInfo = this._upsertPeer(conn.remotePublicKey, null)\n\n    this.connections.add(conn)\n    this._allConnections.add(conn)\n    this._serverConnections++\n\n    conn.on('close', () => {\n      this.connections.delete(conn)\n      this._allConnections.delete(conn)\n      this._serverConnections--\n      this.stats.connects.server.closed++\n\n      this._maybeDeletePeer(peerInfo)\n\n      this._attemptClientConnections()\n\n      this.emit('update')\n    })\n    peerInfo.client = false\n    this.emit('connection', conn, peerInfo)\n\n    this.emit('update')\n  }\n\n  _upsertPeer (publicKey, relayAddresses) {\n    if (b4a.equals(publicKey, this.keyPair.publicKey)) return null\n    const keyString = b4a.toString(publicKey, 'hex')\n    let peerInfo = this.peers.get(keyString)\n\n    if (peerInfo) {\n      peerInfo.relayAddresses = relayAddresses // new is always better\n      return peerInfo\n    }\n\n    peerInfo = new PeerInfo({\n      publicKey,\n      relayAddresses\n    })\n\n    this.peers.set(keyString, peerInfo)\n    return peerInfo\n  }\n\n  _handleUpdate () {\n    this.stats.updates++\n  }\n\n  _maybeDeletePeer (peerInfo) {\n    if (!peerInfo.shouldGC()) return\n\n    const hasActiveConn = this._allConnections.has(peerInfo.publicKey)\n    if (hasActiveConn) return\n\n    const keyString = b4a.toString(peerInfo.publicKey, 'hex')\n    this.peers.delete(keyString)\n  }\n\n  /*\n   * Called when a peer is actively discovered during a lookup.\n   *\n   * Three conditions:\n   *  1. Not a known peer -- insert into queue\n   *  2. A known peer with normal priority -- do nothing\n   *  3. A known peer with low priority -- bump priority, because it's been rediscovered\n   */\n  _handlePeer (peer, topic) {\n    const peerInfo = this._upsertPeer(peer.publicKey, peer.relayAddresses)\n    if (peerInfo) peerInfo._topic(topic)\n    if (!peerInfo || this._allConnections.has(peer.publicKey)) return\n    if (!peerInfo.prioritized || peerInfo.server) peerInfo._reset()\n    if (peerInfo._updatePriority()) {\n      this._enqueue(peerInfo)\n    }\n  }\n\n  async _handleNetworkChange () {\n    // prioritize figuring out if existing connections are dead\n    for (const conn of this._allConnections) {\n      conn.sendKeepAlive()\n    }\n\n    const refreshes = []\n\n    for (const discovery of this._discovery.values()) {\n      refreshes.push(discovery.refresh())\n    }\n\n    await Promise.allSettled(refreshes)\n  }\n\n  status (key) {\n    return this._discovery.get(b4a.toString(key, 'hex')) || null\n  }\n\n  listen () {\n    if (!this.listening) this.listening = this.server.listen(this.keyPair)\n    return this.listening\n  }\n\n  // Object that exposes a cancellation method (destroy)\n  // TODO: When you rejoin, it should reannounce + bump lookup priority\n  join (topic, opts = {}) {\n    if (!topic) throw new Error(ERR_MISSING_TOPIC)\n    topic = unslab(topic)\n\n    const topicString = b4a.toString(topic, 'hex')\n\n    let discovery = this._discovery.get(topicString)\n\n    if (discovery && !discovery.destroyed) {\n      return discovery.session(opts)\n    }\n\n    discovery = new PeerDiscovery(this, topic, {\n      wait: discovery ? discovery.destroy() : null,\n      suspended: this.suspended,\n      onpeer: peer => this._handlePeer(peer, topic)\n    })\n    this._discovery.set(topicString, discovery)\n    return discovery.session(opts)\n  }\n\n  // Returns a promise\n  async leave (topic) {\n    if (!topic) throw new Error(ERR_MISSING_TOPIC)\n    const topicString = b4a.toString(topic, 'hex')\n    if (!this._discovery.has(topicString)) return Promise.resolve()\n\n    const discovery = this._discovery.get(topicString)\n    await discovery.destroy()\n\n    if (this._discovery.get(topicString) === discovery) {\n      this._discovery.delete(topicString)\n    }\n  }\n\n  joinPeer (publicKey) {\n    const peerInfo = this._upsertPeer(publicKey, null)\n    if (!peerInfo) return\n    if (!this.explicitPeers.has(peerInfo)) {\n      peerInfo.explicit = true\n      this.explicitPeers.add(peerInfo)\n    }\n    if (this._allConnections.has(publicKey)) return\n    if (peerInfo._updatePriority()) {\n      this._enqueue(peerInfo)\n    }\n  }\n\n  leavePeer (publicKey) {\n    const keyString = b4a.toString(publicKey, 'hex')\n    if (!this.peers.has(keyString)) return\n\n    const peerInfo = this.peers.get(keyString)\n    peerInfo.explicit = false\n    this.explicitPeers.delete(peerInfo)\n    this._maybeDeletePeer(peerInfo)\n  }\n\n  // Returns a promise\n  async flush () {\n    const allFlushed = [...this._discovery.values()].map(v => v.flushed())\n    await Promise.all(allFlushed)\n    if (this._flushAllMaybe()) return true\n    const pendingSize = this._allConnections.size - this.connections.size\n    if (!this._queue.length && !pendingSize) return true\n    return new Promise((resolve) => {\n      this._pendingFlushes.push({\n        onflush: resolve,\n        missing: this._queue.length + pendingSize,\n        tick: this._flushTick++\n      })\n    })\n  }\n\n  async clear () {\n    const cleared = Promise.allSettled([...this._discovery.values()].map(d => d.destroy()))\n    this._discovery.clear()\n    return cleared\n  }\n\n  async destroy ({ force } = {}) {\n    if (this.destroyed && !force) return\n    this.destroyed = true\n\n    this._timer.destroy()\n\n    if (!force) await this.clear()\n\n    await this.server.close()\n\n    while (this._pendingFlushes.length) {\n      const flush = this._pendingFlushes.pop()\n      flush.onflush(false)\n    }\n\n    await this.dht.destroy({ force })\n  }\n\n  async suspend () {\n    if (this.suspended) return\n\n    const promises = []\n\n    promises.push(this.server.suspend())\n\n    for (const discovery of this._discovery.values()) {\n      promises.push(discovery.suspend())\n    }\n\n    for (const connection of this._allConnections) {\n      connection.destroy()\n    }\n\n    this.suspended = true\n\n    await Promise.allSettled(promises)\n    await this.dht.suspend()\n  }\n\n  async resume () {\n    if (!this.suspended) return\n\n    await this.dht.resume()\n    await this.server.resume()\n\n    for (const discovery of this._discovery.values()) {\n      discovery.resume()\n    }\n\n    this._attemptClientConnections()\n    this.suspended = false\n  }\n\n  topics () {\n    return this._discovery.values()\n  }\n}\n\nfunction noop () { }\n\nfunction allowAll () {\n  return false\n}\n\nfunction shouldForceRelaying (code) {\n  return (code === 'HOLEPUNCH_ABORTED') ||\n    (code === 'HOLEPUNCH_DOUBLE_RANDOMIZED_NATS') ||\n    (code === 'REMOTE_NOT_HOLEPUNCHABLE')\n}\nmodule.exports = class BulkTimer {\n  constructor (time, fn) {\n    this._time = time\n    this._fn = fn\n    this._interval = null\n    this._next = []\n    this._pending = []\n    this._destroyed = false\n  }\n\n  destroy () {\n    if (this._destroyed) return\n    this._destroyed = true\n    clearInterval(this._interval)\n    this._interval = null\n  }\n\n  _ontick () {\n    if (!this._next.length && !this._pending.length) return\n    if (this._next.length) this._fn(this._next)\n    this._next = this._pending\n    this._pending = []\n  }\n\n  add (info) {\n    if (this._destroyed) return\n    if (!this._interval) {\n      this._interval = setInterval(this._ontick.bind(this), Math.floor(this._time * 0.66))\n    }\n\n    this._pending.push(info)\n  }\n}\nconst b4a = require('b4a')\n\nmodule.exports = class ConnectionSet {\n  constructor () {\n    this._byPublicKey = new Map()\n  }\n\n  [Symbol.iterator] () {\n    return this._byPublicKey.values()\n  }\n\n  get size () {\n    return this._byPublicKey.size\n  }\n\n  has (publicKey) {\n    return this._byPublicKey.has(b4a.toString(publicKey, 'hex'))\n  }\n\n  get (publicKey) {\n    return this._byPublicKey.get(b4a.toString(publicKey, 'hex'))\n  }\n\n  add (connection) {\n    this._byPublicKey.set(b4a.toString(connection.remotePublicKey, 'hex'), connection)\n  }\n\n  delete (connection) {\n    const keyString = b4a.toString(connection.remotePublicKey, 'hex')\n    const existing = this._byPublicKey.get(keyString)\n    if (existing !== connection) return\n    this._byPublicKey.delete(keyString)\n  }\n}\nconst safetyCatch = require('safety-catch')\nconst b4a = require('b4a')\n\nconst REFRESH_INTERVAL = 1000 * 60 * 10 // 10 min\nconst RANDOM_JITTER = 1000 * 60 * 2 // 2 min\nconst DELAY_GRACE_PERIOD = 1000 * 30 // 30s\n\nmodule.exports = class PeerDiscovery {\n  constructor (swarm, topic, { wait = null, suspended = false, onpeer = noop, onerror = safetyCatch }) {\n    this.swarm = swarm\n    this.topic = topic\n    this.isClient = false\n    this.isServer = false\n    this.destroyed = false\n    this.destroying = null\n    this.suspended = suspended\n\n    this._sessions = []\n    this._clientSessions = 0\n    this._serverSessions = 0\n\n    this._onpeer = onpeer\n    this._onerror = onerror\n\n    this._activeQuery = null\n    this._timer = null\n    this._currentRefresh = null\n    this._closestNodes = null\n    this._firstAnnounce = true\n    this._needsUnannounce = false\n    this._refreshes = 0\n    this._wait = wait\n  }\n\n  session ({ server = true, client = true, onerror = safetyCatch }) {\n    if (this.destroyed) throw new Error('PeerDiscovery is destroyed')\n    const session = new PeerDiscoverySession(this)\n    session.refresh({ server, client }).catch(onerror)\n    this._sessions.push(session)\n    return session\n  }\n\n  _refreshLater (eager) {\n    const jitter = Math.round(Math.random() * RANDOM_JITTER)\n    const delay = !eager\n      ? REFRESH_INTERVAL + jitter\n      : jitter\n\n    if (this._timer) clearTimeout(this._timer)\n\n    const startTime = Date.now()\n    this._timer = setTimeout(() => {\n      // If your laptop went to sleep, and is coming back online...\n      const overdue = Date.now() - startTime > delay + DELAY_GRACE_PERIOD\n      if (overdue) this._refreshLater(true)\n      else this.refresh().catch(this._onerror)\n    }, delay)\n  }\n\n  _isActive () {\n    return !this.destroyed && !this.suspended\n  }\n\n  // TODO: Allow announce to be an argument to this\n  // TODO: Maybe announce should be a setter?\n  async _refresh () {\n    if (this.suspended) return\n    const clock = ++this._refreshes\n\n    if (this._wait) {\n      await this._wait\n      this._wait = null\n      if (clock !== this._refreshes || !this._isActive()) return\n    }\n\n    const clear = this.isServer && this._firstAnnounce\n    if (clear) this._firstAnnounce = false\n\n    const opts = {\n      clear,\n      closestNodes: this._closestNodes\n    }\n\n    if (this.isServer) {\n      await this.swarm.listen()\n      // if a parallel refresh is happening, yield to the new one\n      if (clock !== this._refreshes || !this._isActive()) return\n      this._needsUnannounce = true\n    }\n\n    const announcing = this.isServer\n    const query = this._activeQuery = announcing\n      ? this.swarm.dht.announce(this.topic, this.swarm.keyPair, this.swarm.server.relayAddresses, opts)\n      : this._needsUnannounce\n        ? this.swarm.dht.lookupAndUnannounce(this.topic, this.swarm.keyPair, opts)\n        : this.swarm.dht.lookup(this.topic, opts)\n\n    try {\n      for await (const data of this._activeQuery) {\n        if (!this.isClient || !this._isActive()) continue\n        for (const peer of data.peers) {\n          this._onpeer(peer, data)\n        }\n      }\n    } catch (err) {\n      if (this._isActive()) throw err\n    } finally {\n      if (this._activeQuery === query) {\n        this._activeQuery = null\n        if (!this.destroyed && !this.suspended) this._refreshLater(false)\n      }\n    }\n\n    // This is set at the very end, when the query completes successfully.\n    this._closestNodes = query.closestNodes\n\n    if (clock !== this._refreshes) return\n\n    // In this is the latest query, unannounce has been fulfilled as well\n    if (!announcing) this._needsUnannounce = false\n  }\n\n  async refresh () {\n    if (this.destroyed) throw new Error('PeerDiscovery is destroyed')\n\n    const server = this._serverSessions > 0\n    const client = this._clientSessions > 0\n\n    if (this.suspended) return\n\n    if (server === this.isServer && client === this.isClient) {\n      if (this._currentRefresh) return this._currentRefresh\n      this._currentRefresh = this._refresh()\n    } else {\n      if (this._activeQuery) this._activeQuery.destroy()\n      this.isServer = server\n      this.isClient = client\n      this._currentRefresh = this._refresh()\n    }\n\n    const refresh = this._currentRefresh\n    try {\n      await refresh\n    } finally {\n      if (refresh === this._currentRefresh) {\n        this._currentRefresh = null\n      }\n    }\n  }\n\n  async flushed () {\n    if (this.swarm.listening) await this.swarm.listening\n\n    try {\n      await this._currentRefresh\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  async _destroyMaybe () {\n    if (this.destroyed) return\n\n    try {\n      if (this._sessions.length === 0) await this.swarm.leave(this.topic)\n      else if (this._serverSessions === 0 && this._needsUnannounce) await this.refresh()\n    } catch (err) { // ignore network failures here, as we are tearing down\n      safetyCatch(err)\n    }\n  }\n\n  destroy () {\n    if (this.destroying) return this.destroying\n    this.destroying = this._destroy()\n    return this.destroying\n  }\n\n  async _abort () {\n    if (this._wait) await this._wait\n\n    if (this._activeQuery) {\n      this._activeQuery.destroy()\n      this._activeQuery = null\n    }\n    if (this._timer) {\n      clearTimeout(this._timer)\n      this._timer = null\n    }\n\n    let nodes = this._closestNodes\n\n    if (this._currentRefresh) {\n      try {\n        await this._currentRefresh\n      } catch {\n        // If the destroy causes the refresh to fail, suppress it.\n      }\n    }\n\n    if (this._isActive()) return\n\n    if (!nodes) nodes = this._closestNodes\n    else if (this._closestNodes !== nodes) {\n      const len = nodes.length\n      for (const newer of this._closestNodes) {\n        if (newer.id && !hasNode(nodes, len, newer)) nodes.push(newer)\n      }\n    }\n\n    if (this._needsUnannounce) {\n      if (nodes && nodes.length) await this.swarm.dht.unannounce(this.topic, this.swarm.keyPair, { closestNodes: nodes, onlyClosestNodes: true })\n      this._needsUnannounce = false\n    }\n  }\n\n  _destroy () {\n    if (this.destroyed) return\n    this.destroyed = true\n    return this._abort()\n  }\n\n  async suspend () {\n    if (this.suspended) return\n    this.suspended = true\n    return this._abort()\n  }\n\n  resume () {\n    if (!this.suspended) return\n    this.suspended = false\n    this.refresh().catch(noop)\n  }\n}\n\nclass PeerDiscoverySession {\n  constructor (discovery) {\n    this.discovery = discovery\n    this.isClient = false\n    this.isServer = false\n    this.destroyed = false\n  }\n\n  get swarm () {\n    return this.discovery.swarm\n  }\n\n  get topic () {\n    return this.discovery.topic\n  }\n\n  async refresh ({ client = this.isClient, server = this.isServer } = {}) {\n    if (this.destroyed) throw new Error('PeerDiscovery is destroyed')\n    if (!client && !server) throw new Error('Cannot refresh with neither client nor server option')\n\n    if (client !== this.isClient) {\n      this.isClient = client\n      this.discovery._clientSessions += client ? 1 : -1\n    }\n\n    if (server !== this.isServer) {\n      this.isServer = server\n      this.discovery._serverSessions += server ? 1 : -1\n    }\n\n    return this.discovery.refresh()\n  }\n\n  async flushed () {\n    return this.discovery.flushed()\n  }\n\n  async destroy () {\n    if (this.destroyed) return\n    this.destroyed = true\n\n    if (this.isClient) this.discovery._clientSessions--\n    if (this.isServer) this.discovery._serverSessions--\n\n    const index = this.discovery._sessions.indexOf(this)\n    const head = this.discovery._sessions.pop()\n\n    if (head !== this) this.discovery._sessions[index] = head\n\n    return this.discovery._destroyMaybe()\n  }\n}\n\nfunction hasNode (nodes, len, node) {\n  for (let i = 0; i < len; i++) {\n    const existing = nodes[i]\n    if (existing.id && b4a.equals(existing.id, node.id)) return true\n  }\n\n  return false\n}\n\nfunction noop () {}\nconst { EventEmitter } = require('events')\nconst b4a = require('b4a')\nconst unslab = require('unslab')\n\nconst MIN_CONNECTION_TIME = 15000\n\nconst VERY_LOW_PRIORITY = 0\nconst LOW_PRIORITY = 1\nconst NORMAL_PRIORITY = 2\nconst HIGH_PRIORITY = 3\nconst VERY_HIGH_PRIORITY = 4\n\nmodule.exports = class PeerInfo extends EventEmitter {\n  constructor ({ publicKey, relayAddresses }) {\n    super()\n\n    this.publicKey = unslab(publicKey)\n    this.relayAddresses = relayAddresses\n\n    this.reconnecting = true\n    this.proven = false\n    this.connectedTime = -1\n    this.banned = false\n    this.tried = false\n    this.explicit = false\n    this.waiting = false\n    this.forceRelaying = false\n\n    // Set by the Swarm\n    this.queued = false\n    this.client = false\n    this.topics = [] // TODO: remove on next major (check with mafintosh for context)\n\n    this.attempts = 0\n    this.priority = NORMAL_PRIORITY\n\n    // Used by shuffled-priority-queue\n    this._index = 0\n\n    // Used for flush management\n    this._flushTick = 0\n\n    // Used for topic multiplexing\n    this._seenTopics = new Set()\n  }\n\n  get server () {\n    return !this.client\n  }\n\n  get prioritized () {\n    return this.priority >= NORMAL_PRIORITY\n  }\n\n  _getPriority () {\n    const peerIsStale = this.tried && !this.proven\n    if (peerIsStale || this.attempts > 3) return VERY_LOW_PRIORITY\n    if (this.attempts === 3) return LOW_PRIORITY\n    if (this.attempts === 2) return HIGH_PRIORITY\n    if (this.attempts === 1) return VERY_HIGH_PRIORITY\n    return NORMAL_PRIORITY\n  }\n\n  _connected () {\n    this.proven = true\n    this.connectedTime = Date.now()\n  }\n\n  _disconnected () {\n    if (this.connectedTime > -1) {\n      if ((Date.now() - this.connectedTime) >= MIN_CONNECTION_TIME) this.attempts = 0 // fast retry\n      this.connectedTime = -1\n    }\n    this.attempts++\n  }\n\n  _deprioritize () {\n    this.attempts = 3\n  }\n\n  _reset () {\n    this.client = false\n    this.proven = false\n    this.tried = false\n    this.attempts = 0\n  }\n\n  _updatePriority () {\n    if (this.explicit && this.attempts > 3) this._deprioritize()\n    if (this.banned || this.queued || this.attempts > 3) return false\n    this.priority = this._getPriority()\n    return true\n  }\n\n  _topic (topic) {\n    const topicString = b4a.toString(topic, 'hex')\n    if (this._seenTopics.has(topicString)) return\n    this._seenTopics.add(topicString)\n    this.topics.push(topic)\n    this.emit('topic', topic)\n  }\n\n  reconnect (val) {\n    this.reconnecting = !!val\n  }\n\n  ban (val) {\n    this.banned = !!val\n  }\n\n  shouldGC () {\n    return !(this.banned || this.queued || this.explicit || this.waiting)\n  }\n}\nconst BulkTimer = require('./bulk-timer')\n\nconst BACKOFF_JITTER = 500\nconst BACKOFF_S = 1000 + Math.round(BACKOFF_JITTER * Math.random())\nconst BACKOFF_M = 5000 + Math.round(2 * BACKOFF_JITTER * Math.random())\nconst BACKOFF_L = 15000 + Math.round(4 * BACKOFF_JITTER * Math.random())\nconst BACKOFF_X = 1000 * 60 * 10 + Math.round(240 * BACKOFF_JITTER * Math.random())\n\nmodule.exports = class RetryTimer {\n  constructor (push, { backoffs = [BACKOFF_S, BACKOFF_M, BACKOFF_L, BACKOFF_X], jitter = BACKOFF_JITTER } = {}) {\n    this.jitter = jitter\n    this.backoffs = backoffs\n\n    this._sTimer = new BulkTimer(backoffs[0] + Math.round(jitter * Math.random()), push)\n    this._mTimer = new BulkTimer(backoffs[1] + Math.round(jitter * Math.random()), push)\n    this._lTimer = new BulkTimer(backoffs[2] + Math.round(jitter * Math.random()), push)\n    this._xTimer = new BulkTimer(backoffs[3] + Math.round(jitter * Math.random()), push)\n  }\n\n  _selectRetryTimer (peerInfo) {\n    if (peerInfo.banned || !peerInfo.reconnecting) return null\n\n    if (peerInfo.attempts > 3) {\n      return peerInfo.explicit ? this._xTimer : null\n    }\n\n    if (peerInfo.attempts === 0) return this._sTimer\n    if (peerInfo.proven) {\n      switch (peerInfo.attempts) {\n        case 1: return this._sTimer\n        case 2: return this._mTimer\n        case 3: return this._lTimer\n      }\n    } else {\n      switch (peerInfo.attempts) {\n        case 1: return this._mTimer\n        case 2: return this._lTimer\n        case 3: return this._lTimer\n      }\n    }\n\n    return null\n  }\n\n  add (peerInfo) {\n    const timer = this._selectRetryTimer(peerInfo)\n    if (!timer) return false\n\n    timer.add(peerInfo)\n    return true\n  }\n\n  destroy () {\n    this._sTimer.destroy()\n    this._mTimer.destroy()\n    this._lTimer.destroy()\n    this._xTimer.destroy()\n  }\n}\n{\n  \"name\": \"hyperswarm\",\n  \"version\": \"4.8.4\",\n  \"description\": \"A distributed networking stack for connecting peers\",\n  \"files\": [\n    \"index.js\",\n    \"lib/**.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.3.1\",\n    \"bare-events\": \"^2.2.0\",\n    \"hyperdht\": \"^6.11.0\",\n    \"safety-catch\": \"^1.0.2\",\n    \"shuffled-priority-queue\": \"^2.1.0\",\n    \"unslab\": \"^1.3.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.2\",\n    \"hypercore-crypto\": \"^3.4.0\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && node test/all.js\",\n    \"test:generate\": \"brittle -r test/all.js test/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/hyperswarm.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"contributors\": [\n    \"David Mark Clements (@davidmarkclem)\",\n    \"Andrew Osheroff (@andrewosh)\"\n  ],\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hyperswarm/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hyperswarm\"\n}\nconst objectState = new Map()\nconst traceFunctionSymbol = Symbol.for('hypertrace.traceFunction')\n\nclass Hypertrace {\n  constructor (ctx, opts = { }) {\n    if (!ctx) throw new Error('Context required, see hypertrace documentation')\n\n    const { parent, props } = opts\n    this.enabled = true\n    this.ctx = ctx\n    this.className = ctx.constructor.name\n    this.props = props || null\n    this.parentObject = !parent\n      ? null\n      : {\n          className: parent.className,\n          id: parent.objectId,\n          props: { ...parent.props },\n          ctx: parent.ctx\n        }\n\n    const currentObjectState = objectState.get(ctx.constructor) || { id: 0, stacktraceCache: new Map() }\n    currentObjectState.id += 1\n    this.objectId = currentObjectState.id\n    objectState.set(ctx.constructor, currentObjectState)\n  }\n\n  setParent (parentTracer) {\n    this.parentObject = !parentTracer\n      ? null\n      : {\n          className: parentTracer.className,\n          id: parentTracer.objectId,\n          props: { ...parentTracer.props },\n          ctx: parentTracer.ctx\n        }\n  }\n\n  trace (id, props) {\n    const traceFunction = globalThis[traceFunctionSymbol]\n    const shouldTrace = traceFunction\n    if (!shouldTrace) return\n\n    const hasTraceIdInArgs = typeof id === 'string'\n    if (!hasTraceIdInArgs) {\n      props = id\n      id = null\n    }\n\n    const currentObjectState = objectState.get(this.ctx.constructor)\n    let stack = id && currentObjectState.stacktraceCache.get(id)\n    const hasCachedStacktrace = !!stack\n    if (!hasCachedStacktrace) {\n      const errorToGetContext = new Error()\n      stack = errorToGetContext.stack\n      currentObjectState.stacktraceCache.set(id, stack)\n    }\n\n    const callLine = stack.split('\\n')[2]\n    const re = /.*at (.+) \\((?:file:\\/:\\/)?(.+):(\\d+):(\\d+)\\)/\n    const [, functionName, filename, line, column] = callLine.match(re)\n\n    const realFunctionName = functionName.split('.')[0] === this.className // Turn SomeModule.foobar => foobar\n      ? functionName.substr(functionName.indexOf('.') + 1)\n      : functionName\n\n    const object = {\n      className: this.className,\n      id: this.objectId,\n      props: this.props && { ...this.props },\n      ctx: this.ctx\n    }\n    const caller = {\n      functionName: realFunctionName,\n      filename,\n      line: Number(line),\n      column: Number(column),\n      props: props && { ...props }\n    }\n\n    traceFunction({\n      id: id || null,\n      object,\n      parentObject: this.parentObject,\n      caller\n    })\n  }\n}\n\nclass NoTracingClass {\n  constructor () {\n    this.enabled = false\n    this.ctx = null\n    this.className = null\n    this.props = null\n    this.parentObject = null\n    this.objectId = null\n  }\n\n  trace () { /* noop */ }\n\n  setParent () { /* noop */ }\n}\n\nconst noTracing = new NoTracingClass()\n\nmodule.exports = {\n  setTraceFunction: fn => {\n    globalThis[traceFunctionSymbol] = fn\n  },\n  clearTraceFunction: () => {\n    globalThis[traceFunctionSymbol] = undefined\n  },\n  createTracer: (ctx, opts) => {\n    // If the trace function is not set, then the returned class cannot trace.\n    // This is done for speed.\n    const isTracing = !!globalThis[traceFunctionSymbol]\n    if (!isTracing) return noTracing\n    return new Hypertrace(ctx, opts)\n  }\n}\n{\n  \"name\": \"hypertrace\",\n  \"version\": \"1.4.2\",\n  \"description\": \"Add tracing and insights to classes. Supports Prometheus/Grafana.\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && node --expose-gc test/test.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"Holepunch Inc\",\n  \"license\": \"Apache-2.0\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"standard\": \"^17.1.0\"\n  }\n}\nconst b4a = require('b4a')\n\nconst EMPTY = b4a.alloc(0)\nconst MAX = b4a.from([0xff])\nconst BUFFER = {}\n\nBUFFER.preencode = function (state, buf) {\n  if (buf === null) buf = EMPTY\n\n  let i = 0\n  let extra = 3\n\n  while ((i = b4a.indexOf(buf, 0x00, i)) > -1) {\n    i++\n    extra++\n  }\n\n  state.end += buf.byteLength + extra\n}\n\nBUFFER.encode = function (state, buf) {\n  if (buf === null) buf = EMPTY\n\n  state.buffer[state.start++] = 0x00\n\n  let prev = 0\n  let i = 0\n\n  while ((i = b4a.indexOf(buf, 0x00, i)) > -1) {\n    const slice = buf.subarray(prev, ++i)\n\n    state.buffer.set(slice, state.start)\n    state.start += slice.byteLength\n    state.buffer[state.start++] = 0x02\n    prev = i\n  }\n\n  const slice = buf.subarray(prev)\n\n  state.buffer.set(slice, state.start)\n  state.start += slice.byteLength\n\n  state.buffer[state.start++] = 0x00\n  state.buffer[state.start++] = 0x01\n}\n\nBUFFER.decode = function (state) {\n  if (state.start >= state.end) throw new Error('Out of bounds')\n  if (state.buffer[state.start++] !== 0x00) throw new Error('Invalid start of string')\n\n  let escaped = null\n\n  let prev = state.start\n  let i = state.start\n\n  while ((i = b4a.indexOf(state.buffer, 0x00, i)) > -1) {\n    const next = ++i < state.end ? state.buffer[i] : 0x00\n\n    i++\n\n    if (next === 0x01) {\n      break\n    }\n\n    if (next === 0x02) {\n      if (escaped === null) escaped = []\n      escaped.push(state.buffer.subarray(prev, i - 1))\n      prev = i\n      continue\n    }\n\n    throw new Error('Unknown value in terminator')\n  }\n\n  if (i === -1) {\n    throw new Error('No terminator found')\n  }\n\n  state.start = i\n  const last = state.buffer.subarray(prev, i - 2)\n  if (escaped === null) return last\n\n  escaped.push(last)\n  return b4a.concat(escaped)\n}\n\n// TODO: can be optimised a lot\n\nconst STRING = {}\n\nSTRING.preencode = function (state, str) {\n  BUFFER.preencode(state, b4a.from(str || ''))\n}\n\nSTRING.encode = function (state, str) {\n  BUFFER.encode(state, b4a.from(str || ''))\n}\n\nSTRING.decode = function (state, str) {\n  return b4a.toString(BUFFER.decode(state))\n}\n\nconst UINT = {}\n\nUINT.preencode = function (state, n) {\n  state.end += n <= 0xfb ? 1 : n <= 0xffff ? 3 : n <= 0xffffffff ? 5 : (n === Infinity ? 1 : 9)\n}\n\nUINT.encode = function (state, n) {\n  if (n === Infinity) {\n    state.buffer[state.start++] = 0xff\n    return\n  }\n\n  if (n <= 0xfb) {\n    state.buffer[state.start++] = n\n    return\n  }\n\n  if (n <= 0xffff) {\n    state.buffer[state.start++] = 0xfc\n    state.buffer[state.start++] = n >>> 8\n    state.buffer[state.start++] = n\n    return\n  }\n\n  if (n <= 0xffffffff) {\n    state.buffer[state.start++] = 0xfd\n    encodeUint32(state, n)\n    return\n  }\n\n  state.buffer[state.start++] = 0xfe\n\n  const r = Math.floor(n / 0x100000000)\n  encodeUint32(state, r)\n  encodeUint32(state, n)\n}\n\nUINT.decode = function (state) {\n  if (state.start >= state.end) throw new Error('Out of bounds')\n\n  const a = state.buffer[state.start++]\n\n  if (a <= 0xfb) return a\n\n  if (a === 0xfc) {\n    if (state.end - state.start < 2) throw new Error('Out of bounds')\n    return (\n      state.buffer[state.start++] * 0x100 +\n      state.buffer[state.start++]\n    )\n  }\n\n  if (a === 0xfd) {\n    return decodeUint32(state)\n  }\n\n  if (a === 0xfe) {\n    return (\n      decodeUint32(state) * 0x100000000 +\n      decodeUint32(state)\n    )\n  }\n\n  return Infinity\n}\n\nmodule.exports = class IndexEncoder {\n  constructor (encodings, { prefix = -1 } = {}) {\n    this.encodings = encodings\n    this.prefix = prefix\n  }\n\n  static BUFFER = BUFFER\n  static STRING = STRING\n  static UINT = UINT\n\n  static lookup (c) {\n    switch (c) {\n      case 'uint': return IndexEncoder.UINT\n      case 'uint8': return IndexEncoder.UINT\n      case 'uint16': return IndexEncoder.UINT\n      case 'uint24': return IndexEncoder.UINT\n      case 'uint32': return IndexEncoder.UINT\n      case 'uint40': return IndexEncoder.UINT\n      case 'uint48': return IndexEncoder.UINT\n      case 'uint56': return IndexEncoder.UINT\n      case 'uint64': return IndexEncoder.UINT\n      case 'string': return IndexEncoder.STRING\n      case 'utf8': return IndexEncoder.STRING\n      case 'ascii': return IndexEncoder.STRING\n      case 'hex': return IndexEncoder.STRING\n      case 'base64': return IndexEncoder.STRING\n      case 'fixed32': return IndexEncoder.BUFFER\n      case 'fixed64': return IndexEncoder.BUFFER\n      case 'buffer': return IndexEncoder.BUFFER\n    }\n\n    throw new Error('Unknown type')\n  }\n\n  encode (keys) {\n    return this._encode(keys, false)\n  }\n\n  _encode (keys, terminate) {\n    if (b4a.isBuffer(keys)) return keys\n\n    const state = { start: 0, end: 0, buffer: null }\n\n    if (this.prefix !== -1) UINT.preencode(state, this.prefix)\n    for (let i = 0; i < keys.length; i++) {\n      this.encodings[i].preencode(state, keys[i])\n    }\n\n    if (terminate && keys.length < this.encodings.length) {\n      state.end++\n    }\n\n    state.buffer = b4a.allocUnsafe(state.end)\n\n    if (this.prefix !== -1) UINT.encode(state, this.prefix)\n    for (let i = 0; i < keys.length; i++) {\n      this.encodings[i].encode(state, keys[i])\n    }\n\n    if (terminate && keys.length < this.encodings.length) {\n      state.buffer[state.start++] = MAX[0]\n    }\n\n    return state.buffer\n  }\n\n  decode (buffer) {\n    const state = { start: 0, end: buffer.byteLength, buffer }\n    const result = []\n\n    if (this.prefix !== -1) UINT.decode(state)\n    for (const enc of this.encodings) {\n      const key = state.start < state.end ? enc.decode(state) : (enc === UINT ? 0 : null)\n      result.push(key)\n    }\n\n    return result\n  }\n\n  encodeRange ({ gt, gte, lt, lte }) {\n    const range = {\n      gt: gt && this._encode(gt, true),\n      gte: gte && this._encode(gte, false),\n      lt: lt && this._encode(lt, false),\n      lte: lte && this._encode(lte, true)\n    }\n\n    if (this.prefix !== -1) {\n      if (!gt && !gte) range.gte = encodeUint(this.prefix)\n      if (!lt && !lte) range.lt = encodeUint(this.prefix + 1)\n    }\n\n    return range\n  }\n}\n\nfunction encodeUint (n) {\n  const state = { start: 0, end: 0, buffer: null }\n  UINT.preencode(state, n)\n  state.buffer = b4a.allocUnsafe(state.end)\n  UINT.encode(state, n)\n  return state.buffer\n}\n\nfunction encodeUint32 (state, n) {\n  state.buffer[state.start++] = n >>> 24\n  state.buffer[state.start++] = n >>> 16\n  state.buffer[state.start++] = n >>> 8\n  state.buffer[state.start++] = n\n}\n\nfunction decodeUint32 (state, n) {\n  if (state.end - state.start < 4) throw new Error('Out of bounds')\n  return (\n    state.buffer[state.start++] * 0x1000000 +\n    state.buffer[state.start++] * 0x10000 +\n    state.buffer[state.start++] * 0x100 +\n    state.buffer[state.start++]\n  )\n}\n{\n  \"name\": \"index-encoder\",\n  \"version\": \"3.3.1\",\n  \"description\": \"Encode multiple values into sorted keys\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.4\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.2.1\",\n    \"hyperbee\": \"^2.10.5\",\n    \"hypercore\": \"^10.9.2\",\n    \"random-access-memory\": \"^6.2.0\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/index-encoder.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/index-encoder/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/index-encoder\"\n}\nconst b4a = require('b4a')\n\nmodule.exports = function isOptions (opts) {\n  return typeof opts === 'object' && opts && !b4a.isBuffer(opts)\n}\n{\n  \"name\": \"is-options\",\n  \"version\": \"1.0.2\",\n  \"description\": \"Easily check if input is an options map\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.1.1\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^11.0.1\",\n    \"tape\": \"^4.9.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/is-options.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/is-options/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/is-options\"\n}\nconst { EventEmitter } = require('events')\n\nmodule.exports = class RoutingTable extends EventEmitter {\n  constructor (id, opts) {\n    if (!opts) opts = {}\n\n    super()\n\n    this.id = id\n    this.k = opts.k || 20\n    this.size = 0\n    this.rows = new Array(id.length * 8)\n  }\n\n  add (node) {\n    const i = this._diff(node.id)\n\n    let row = this.rows[i]\n\n    if (!row) {\n      row = this.rows[i] = new Row(this, i)\n      this.emit('row', row)\n    }\n\n    const len = row.nodes.length\n    if (!row.add(node, this.k)) return false\n\n    this.size += row.nodes.length - len\n    return true\n  }\n\n  remove (id) {\n    const i = this._diff(id)\n    const row = this.rows[i]\n    if (!row) return false\n    if (!row.remove(id)) return false\n    this.size--\n    return true\n  }\n\n  get (id) {\n    const i = this._diff(id)\n    const row = this.rows[i]\n    if (!row) return null\n    return row.get(id)\n  }\n\n  has (id) {\n    return this.get(id) !== null\n  }\n\n  random () {\n    let n = (Math.random() * this.size) | 0\n\n    for (let i = 0; i < this.rows.length; i++) {\n      const r = this.rows[i]\n      if (!r) continue\n      if (n < r.nodes.length) return r.nodes[n]\n      n -= r.nodes.length\n    }\n\n    return null\n  }\n\n  closest (id, k) {\n    if (!k) k = this.k\n\n    const result = []\n    const d = this._diff(id)\n\n    // push close nodes\n    for (let i = d; i >= 0 && result.length < k; i--) this._pushNodes(i, k, result)\n\n    // if we don't have enough close nodes, populate from other rows, re the paper\n    for (let i = d + 1; i < this.rows.length && result.length < k; i++) this._pushNodes(i, k, result)\n\n    return result\n  }\n\n  _pushNodes (i, k, result) {\n    const row = this.rows[i]\n    if (!row) return\n\n    const missing = Math.min(k - result.length, row.nodes.length)\n    for (let j = 0; j < missing; j++) result.push(row.nodes[j])\n  }\n\n  toArray () {\n    return this.closest(this.id, Infinity)\n  }\n\n  _diff (id) {\n    for (let i = 0; i < id.length; i++) {\n      const a = id[i]\n      const b = this.id[i]\n\n      if (a !== b) return i * 8 + Math.clz32(a ^ b) - 24\n    }\n\n    return this.rows.length - 1\n  }\n}\n\nclass Row extends EventEmitter {\n  constructor (table, index) {\n    super()\n\n    this.data = null // can be used be upstream for whatevs\n    this.byteOffset = index >> 3\n    this.index = index\n    this.table = table\n    this.nodes = []\n  }\n\n  add (node) {\n    const id = node.id\n\n    let l = 0\n    let r = this.nodes.length - 1\n\n    while (l <= r) {\n      const m = (l + r) >> 1\n      const c = this.compare(id, this.nodes[m].id)\n\n      if (c === 0) {\n        this.nodes[m] = node\n        return true\n      }\n\n      if (c < 0) r = m - 1\n      else l = m + 1\n    }\n\n    if (this.nodes.length >= this.table.k) {\n      this.emit('full', node)\n      return false\n    }\n\n    this.insert(l, node)\n    return true\n  }\n\n  remove (id) {\n    let l = 0\n    let r = this.nodes.length - 1\n\n    while (l <= r) {\n      const m = (l + r) >> 1\n      const c = this.compare(id, this.nodes[m].id)\n\n      if (c === 0) {\n        this.splice(m)\n        return true\n      }\n\n      if (c < 0) r = m - 1\n      else l = m + 1\n    }\n\n    return false\n  }\n\n  get (id) {\n    let l = 0\n    let r = this.nodes.length - 1\n\n    while (l <= r) {\n      const m = (l + r) >> 1\n      const node = this.nodes[m]\n      const c = this.compare(id, node.id)\n\n      if (c === 0) return node\n      if (c < 0) r = m - 1\n      else l = m + 1\n    }\n\n    return null\n  }\n\n  insert (i, node) {\n    this.nodes.push(node) // push node or null or whatevs, just trying to not be polymorphic\n    for (let j = this.nodes.length - 1; j > i; j--) this.nodes[j] = this.nodes[j - 1]\n    this.nodes[i] = node\n    this.emit('add', node)\n  }\n\n  splice (i) {\n    for (; i < this.nodes.length - 1; i++) this.nodes[i] = this.nodes[i + 1]\n    this.emit('remove', this.nodes.pop())\n  }\n\n  // very likely they diverge after a couple of bytes so a simple impl, like this is prop fastest vs Buffer.compare\n  compare (a, b) {\n    for (let i = this.byteOffset; i < a.length; i++) {\n      const ai = a[i]\n      const bi = b[i]\n      if (ai === bi) continue\n      return ai < bi ? -1 : 1\n    }\n    return 0\n  }\n}\n{\n  \"name\": \"kademlia-routing-table\",\n  \"version\": \"1.0.6\",\n  \"description\": \"XOR based routing table used for P2P networks such as a Kademlia DHT.\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"bare-events\": \"^2.2.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"keywords\": [\n    \"kademlia\",\n    \"p2p\",\n    \"k-bucket\",\n    \"k-buckets\",\n    \"xor\",\n    \"routing\",\n    \"distributed\",\n    \"systems\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/kademlia-routing-table.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/kademlia-routing-table/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/kademlia-routing-table\"\n}\nconst sameData = require('same-data')\nconst streamEquals = require('binary-stream-equals')\n\nmodule.exports = class MirrorDrive {\n  constructor (src, dst, opts = {}) {\n    this.src = src\n    this.dst = dst\n\n    this.prefix = opts.prefix || '/'\n    this.dryRun = !!opts.dryRun\n    this.prune = opts.prune !== false\n    this.includeEquals = !!opts.includeEquals\n    this.filter = opts.filter || null\n    this.metadataEquals = opts.metadataEquals || null\n    this.batch = !!opts.batch\n    this.entries = opts.entries || null\n\n    this.count = { files: 0, add: 0, remove: 0, change: 0 }\n    this.bytesRemoved = 0\n    this.bytesAdded = 0\n    this.iterator = this._mirror()\n    this._ignore = opts.ignore ? [].concat(opts.ignore) : null\n  }\n\n  [Symbol.asyncIterator] () {\n    return this.iterator\n  }\n\n  async done () {\n    while (true) {\n      const { done } = await this.iterator.next()\n      if (done) break\n    }\n  }\n\n  async * _mirror () {\n    await this.src.ready()\n    await this.dst.ready()\n\n    if (this.dst.core && !this.dst.core.writable) throw new Error('Destination must be writable')\n\n    const dst = this.batch ? this.dst.batch() : this.dst\n\n    if (this.prune) {\n      for await (const [key, dstEntry, srcEntry] of this._list(this.dst, this.src)) {\n        if (srcEntry) continue\n\n        this.count.remove++\n        this.bytesRemoved += blobLength(dstEntry)\n        yield { op: 'remove', key, bytesRemoved: blobLength(dstEntry), bytesAdded: 0 }\n\n        if (!this.dryRun) await dst.del(key)\n      }\n    }\n\n    if (this.src.download && !this.entries) {\n      this.src.download(this.prefix).catch(noop)\n    }\n\n    for await (const [key, srcEntry, dstEntry] of this._list(this.src, dst, { filter: this.filter })) {\n      if (!srcEntry) continue // Due entries option, src entry might not exist probably because it was pruned\n\n      this.count.files++\n\n      if (await same(this, srcEntry, dstEntry)) {\n        if (this.includeEquals) yield { op: 'equal', key, bytesRemoved: 0, bytesAdded: 0 }\n        continue\n      }\n\n      if (dstEntry) {\n        this.count.change++\n        this.bytesRemoved += blobLength(dstEntry)\n        this.bytesAdded += blobLength(srcEntry)\n        yield { op: 'change', key, bytesRemoved: blobLength(dstEntry), bytesAdded: blobLength(srcEntry) }\n      } else {\n        this.count.add++\n        this.bytesAdded += blobLength(srcEntry)\n        yield { op: 'add', key, bytesRemoved: 0, bytesAdded: blobLength(srcEntry) }\n      }\n\n      if (this.dryRun) {\n        continue\n      }\n\n      if (srcEntry.value.linkname) {\n        await dst.symlink(key, srcEntry.value.linkname)\n      } else {\n        await pipeline(\n          this.src.createReadStream(srcEntry),\n          dst.createWriteStream(key, { executable: srcEntry.value.executable, metadata: srcEntry.value.metadata })\n        )\n      }\n    }\n\n    if (this.batch) await dst.flush()\n  }\n\n  async * _list (a, b, opts) {\n    const list = this.entries || a.list(this.prefix, { ignore: this._ignore })\n\n    for await (const entry of list) {\n      const key = typeof entry === 'object' ? entry.key : entry\n\n      if (opts && opts.filter && !opts.filter(key)) continue\n\n      const entryA = await a.entry(entry)\n      const entryB = await b.entry(key)\n\n      yield [key, entryA, entryB]\n    }\n  }\n}\n\nfunction blobLength (entry) {\n  return entry.value.blob ? entry.value.blob.byteLength : 0\n}\n\nfunction pipeline (rs, ws) {\n  return new Promise((resolve, reject) => {\n    rs.pipe(ws, (err) => {\n      if (err) reject(err)\n      else resolve()\n    })\n  })\n}\n\nasync function same (m, srcEntry, dstEntry) {\n  if (!dstEntry) return false\n\n  if (srcEntry.value.linkname || dstEntry.value.linkname) {\n    return srcEntry.value.linkname === dstEntry.value.linkname\n  }\n\n  if (srcEntry.value.executable !== dstEntry.value.executable) return false\n\n  if (!sizeEquals(srcEntry, dstEntry)) return false\n\n  if (!metadataEquals(m, srcEntry, dstEntry)) return false\n\n  return streamEquals(m.src.createReadStream(srcEntry), m.dst.createReadStream(dstEntry))\n}\n\nfunction sizeEquals (srcEntry, dstEntry) {\n  const srcBlob = srcEntry.value.blob\n  const dstBlob = dstEntry.value.blob\n\n  if (!srcBlob && !dstBlob) return true\n  if (!srcBlob || !dstBlob) return false\n\n  return srcBlob.byteLength === dstBlob.byteLength\n}\n\nfunction metadataEquals (m, srcEntry, dstEntry) {\n  if (!m.src.supportsMetadata || !m.dst.supportsMetadata) return true\n\n  const srcMetadata = srcEntry.value.metadata\n  const dstMetadata = dstEntry.value.metadata\n\n  if (m.metadataEquals) {\n    return m.metadataEquals(srcMetadata, dstMetadata)\n  }\n\n  const noMetadata = !srcMetadata && !dstMetadata\n  const identicalMetadata = !!(srcMetadata && dstMetadata && sameData(srcMetadata, dstMetadata))\n\n  return noMetadata || identicalMetadata\n}\n\nfunction noop () {}\n{\n  \"name\": \"mirror-drive\",\n  \"version\": \"1.4.0\",\n  \"description\": \"Mirror a hyperdrive or localdrive into another one\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib/**.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\",\n    \"lint\": \"standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/mirror-drive.git\"\n  },\n  \"author\": \"Lucas Barrena (@LuKks)\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/mirror-drive/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/mirror-drive\",\n  \"devDependencies\": {\n    \"b4a\": \"^1.6.0\",\n    \"brittle\": \"^3.1.0\",\n    \"corestore\": \"^6.0.6\",\n    \"hyperdrive\": \"^11.0.1\",\n    \"localdrive\": \"^1.3.0\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"dependencies\": {\n    \"binary-stream-equals\": \"^1.0.0\",\n    \"same-data\": \"^1.0.0\"\n  }\n}\nvar queueTick = require('queue-tick')\n\nvar mutexify = function () {\n  var queue = []\n  var used = null\n\n  var call = function () {\n    used(release)\n  }\n\n  var acquire = function (fn) {\n    if (used) return queue.push(fn)\n    used = fn\n    acquire.locked = true\n    queueTick(call)\n    return 0\n  }\n\n  acquire.locked = false\n\n  var release = function (fn, err, value) {\n    used = null\n    acquire.locked = false\n    if (queue.length) acquire(queue.shift())\n    if (fn) fn(err, value)\n  }\n\n  return acquire\n}\n\nmodule.exports = mutexify\n{\n  \"name\": \"mutexify\",\n  \"version\": \"1.4.0\",\n  \"description\": \"mutex lock for javascript\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"queue-tick\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^14.3.3\",\n    \"tape\": \"^3.0.2\"\n  },\n  \"scripts\": {\n    \"test\": \"tape test.js\",\n    \"posttest\": \"npm run lint\",\n    \"lint\": \"standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/mutexify.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/mutexify/issues\"\n  },\n  \"keywords\": [\n    \"mutex\",\n    \"lock\"\n  ],\n  \"homepage\": \"https://github.com/mafintosh/mutexify\"\n}\nvar mutexify = require('.')\n\nvar mutexifyPromise = function () {\n  var lock = mutexify()\n\n  var acquire = function () {\n    return new Promise(lock)\n  }\n\n  Object.defineProperty(acquire, 'locked', {\n    get: function () { return lock.locked },\n    enumerable: true\n  })\n\n  return acquire\n}\n\nmodule.exports = mutexifyPromise\nmodule.exports = assert\n\nclass AssertionError extends Error {}\nAssertionError.prototype.name = 'AssertionError'\n\n/**\n * Minimal assert function\n * @param  {any} t Value to check if falsy\n * @param  {string=} m Optional assertion error message\n * @throws {AssertionError}\n */\nfunction assert (t, m) {\n  if (!t) {\n    var err = new AssertionError(m)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, assert)\n    throw err\n  }\n}\n{\n  \"name\": \"nanoassert\",\n  \"version\": \"2.0.0\",\n  \"description\": \"Nanoscale assertion module\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"tape\": \"^4.9.1\"\n  },\n  \"scripts\": {\n    \"test\": \"tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/emilbayes/nanoassert.git\"\n  },\n  \"keywords\": [\n    \"assert\",\n    \"unassert\",\n    \"power-assert\",\n    \"tiny\",\n    \"nano\",\n    \"pico\"\n  ],\n  \"author\": \"Emil Bay <github@tixz.dk>\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/emilbayes/nanoassert/issues\"\n  },\n  \"homepage\": \"https://github.com/emilbayes/nanoassert#readme\"\n}\nmodule.exports = class NatSampler {\n  constructor () {\n    this.host = null\n    this.port = 0\n    this.size = 0\n\n    this._a = null\n    this._b = null\n    this._threshold = 0\n    this._top = 0\n    this._samples = []\n  }\n\n  add (host, port) {\n    const a = this._bump(host, port, 2)\n    const b = this._bump(host, 0, 1)\n\n    if (this._samples.length < 32) {\n      this.size++\n      this._threshold = this.size - (this.size < 4 ? 0 : this.size < 8 ? 1 : this.size < 12 ? 2 : 3)\n      this._samples.push(a, b)\n      this._top += 2\n    } else {\n      if (this._top === 32) this._top = 0\n\n      const oa = this._samples[this._top]\n      this._samples[this._top++] = a\n      oa.hits--\n\n      const ob = this._samples[this._top]\n      this._samples[this._top++] = b\n      ob.hits--\n    }\n\n    if (this._a === null || this._a.hits < a.hits) this._a = a\n    if (this._b === null || this._b.hits < b.hits) this._b = b\n\n    if (this._a.hits >= this._threshold) {\n      this.host = this._a.host\n      this.port = this._a.port\n    } else if (this._b.hits >= this._threshold) {\n      this.host = this._b.host\n      this.port = 0\n    } else {\n      this.host = null\n      this.port = 0\n    }\n\n    return a.hits\n  }\n\n  _bump (host, port, inc) {\n    for (let i = 0; i < 4; i++) {\n      const j = (this._top - inc - (2 * i)) & 31\n      if (j >= this._samples.length) return { host, port, hits: 1 }\n      const s = this._samples[j]\n      if (s.port === port && s.host === host) {\n        s.hits++\n        return s\n      }\n    }\n    return { host, port, hits: 1 }\n  }\n}\n{\n  \"name\": \"nat-sampler\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Sample addresses to figure out if a host + port is consistent\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^16.0.3\",\n    \"tape\": \"^5.2.2\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/nat-sampler.git\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/nat-sampler/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/nat-sampler\"\n}\nconst runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\nif (typeof runtimeRequire.addon === 'function') { // if the platform supports native resolving prefer that\n  module.exports = runtimeRequire.addon.bind(runtimeRequire)\n} else { // else use the runtime version here\n  module.exports = require('./node-gyp-build.js')\n}\nvar fs = require('fs')\nvar path = require('path')\nvar os = require('os')\n\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\n\nvar vars = (process.config && process.config.variables) || {}\nvar prebuildsOnly = !!process.env.PREBUILDS_ONLY\nvar abi = process.versions.modules // TODO: support old node where this is undef\nvar runtime = isElectron() ? 'electron' : (isNwjs() ? 'node-webkit' : 'node')\n\nvar arch = process.env.npm_config_arch || os.arch()\nvar platform = process.env.npm_config_platform || os.platform()\nvar libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')\nvar armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''\nvar uv = (process.versions.uv || '').split('.')[0]\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.resolve(dir))\n}\n\nload.resolve = load.path = function (dir) {\n  dir = path.resolve(dir || '.')\n\n  try {\n    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')\n    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']\n  } catch (err) {}\n\n  if (!prebuildsOnly) {\n    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n    if (release) return release\n\n    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n    if (debug) return debug\n  }\n\n  var prebuild = resolve(dir)\n  if (prebuild) return prebuild\n\n  var nearby = resolve(path.dirname(process.execPath))\n  if (nearby) return nearby\n\n  var target = [\n    'platform=' + platform,\n    'arch=' + arch,\n    'runtime=' + runtime,\n    'abi=' + abi,\n    'uv=' + uv,\n    armv ? 'armv=' + armv : '',\n    'libc=' + libc,\n    'node=' + process.versions.node,\n    process.versions.electron ? 'electron=' + process.versions.electron : '',\n    typeof __webpack_require__ === 'function' ? 'webpack=true' : '' // eslint-disable-line\n  ].filter(Boolean).join(' ')\n\n  throw new Error('No native build was found for ' + target + '\\n    loaded from: ' + dir + '\\n')\n\n  function resolve (dir) {\n    // Find matching \"prebuilds/<platform>-<arch>\" directory\n    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)\n    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]\n    if (!tuple) return\n\n    // Find most specific flavor first\n    var prebuilds = path.join(dir, 'prebuilds', tuple.name)\n    var parsed = readdirSync(prebuilds).map(parseTags)\n    var candidates = parsed.filter(matchTags(runtime, abi))\n    var winner = candidates.sort(compareTags(runtime))[0]\n    if (winner) return path.join(prebuilds, winner.file)\n  }\n}\n\nfunction readdirSync (dir) {\n  try {\n    return fs.readdirSync(dir)\n  } catch (err) {\n    return []\n  }\n}\n\nfunction getFirst (dir, filter) {\n  var files = readdirSync(dir).filter(filter)\n  return files[0] && path.join(dir, files[0])\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction parseTuple (name) {\n  // Example: darwin-x64+arm64\n  var arr = name.split('-')\n  if (arr.length !== 2) return\n\n  var platform = arr[0]\n  var architectures = arr[1].split('+')\n\n  if (!platform) return\n  if (!architectures.length) return\n  if (!architectures.every(Boolean)) return\n\n  return { name, platform, architectures }\n}\n\nfunction matchTuple (platform, arch) {\n  return function (tuple) {\n    if (tuple == null) return false\n    if (tuple.platform !== platform) return false\n    return tuple.architectures.includes(arch)\n  }\n}\n\nfunction compareTuples (a, b) {\n  // Prefer single-arch prebuilds over multi-arch\n  return a.architectures.length - b.architectures.length\n}\n\nfunction parseTags (file) {\n  var arr = file.split('.')\n  var extension = arr.pop()\n  var tags = { file: file, specificity: 0 }\n\n  if (extension !== 'node') return\n\n  for (var i = 0; i < arr.length; i++) {\n    var tag = arr[i]\n\n    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {\n      tags.runtime = tag\n    } else if (tag === 'napi') {\n      tags.napi = true\n    } else if (tag.slice(0, 3) === 'abi') {\n      tags.abi = tag.slice(3)\n    } else if (tag.slice(0, 2) === 'uv') {\n      tags.uv = tag.slice(2)\n    } else if (tag.slice(0, 4) === 'armv') {\n      tags.armv = tag.slice(4)\n    } else if (tag === 'glibc' || tag === 'musl') {\n      tags.libc = tag\n    } else {\n      continue\n    }\n\n    tags.specificity++\n  }\n\n  return tags\n}\n\nfunction matchTags (runtime, abi) {\n  return function (tags) {\n    if (tags == null) return false\n    if (tags.runtime && tags.runtime !== runtime && !runtimeAgnostic(tags)) return false\n    if (tags.abi && tags.abi !== abi && !tags.napi) return false\n    if (tags.uv && tags.uv !== uv) return false\n    if (tags.armv && tags.armv !== armv) return false\n    if (tags.libc && tags.libc !== libc) return false\n\n    return true\n  }\n}\n\nfunction runtimeAgnostic (tags) {\n  return tags.runtime === 'node' && tags.napi\n}\n\nfunction compareTags (runtime) {\n  // Precedence: non-agnostic runtime, abi over napi, then by specificity.\n  return function (a, b) {\n    if (a.runtime !== b.runtime) {\n      return a.runtime === runtime ? -1 : 1\n    } else if (a.abi !== b.abi) {\n      return a.abi ? -1 : 1\n    } else if (a.specificity !== b.specificity) {\n      return a.specificity > b.specificity ? -1 : 1\n    } else {\n      return 0\n    }\n  }\n}\n\nfunction isNwjs () {\n  return !!(process.versions && process.versions.nw)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\nfunction isAlpine (platform) {\n  return platform === 'linux' && fs.existsSync('/etc/alpine-release')\n}\n\n// Exposed for unit tests\n// TODO: move to lib\nload.parseTags = parseTags\nload.matchTags = matchTags\nload.compareTags = compareTags\nload.parseTuple = parseTuple\nload.matchTuple = matchTuple\nload.compareTuples = compareTuples\n{\n  \"name\": \"node-gyp-build\",\n  \"version\": \"4.8.4\",\n  \"description\": \"Build tool and bindings loader for node-gyp that supports prebuilds\",\n  \"main\": \"index.js\",\n  \"imports\": {\n    \"fs\": {\n      \"bare\": \"builtin:fs\",\n      \"default\": \"fs\"\n    },\n    \"path\": {\n      \"bare\": \"builtin:path\",\n      \"default\": \"path\"\n    },\n    \"os\": {\n      \"bare\": \"builtin:os\",\n      \"default\": \"os\"\n    }\n  },\n  \"devDependencies\": {\n    \"array-shuffle\": \"^1.0.1\",\n    \"standard\": \"^14.0.0\",\n    \"tape\": \"^5.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && node test\"\n  },\n  \"bin\": {\n    \"node-gyp-build\": \"./bin.js\",\n    \"node-gyp-build-optional\": \"./optional.js\",\n    \"node-gyp-build-test\": \"./build-test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/prebuild/node-gyp-build.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/prebuild/node-gyp-build/issues\"\n  },\n  \"homepage\": \"https://github.com/prebuild/node-gyp-build\"\n}\n/* eslint-disable camelcase */\nconst sodium = require('sodium-universal')\nconst assert = require('nanoassert')\nconst b4a = require('b4a')\n\nconst DHLEN = sodium.crypto_scalarmult_ed25519_BYTES\nconst PKLEN = sodium.crypto_scalarmult_ed25519_BYTES\nconst SCALARLEN = sodium.crypto_scalarmult_ed25519_BYTES\nconst SKLEN = sodium.crypto_sign_SECRETKEYBYTES\nconst ALG = 'Ed25519'\n\nmodule.exports = {\n  DHLEN,\n  PKLEN,\n  SCALARLEN,\n  SKLEN,\n  ALG,\n  name: ALG,\n  generateKeyPair,\n  dh\n}\n\nfunction generateKeyPair (privKey) {\n  if (privKey) return generateSeedKeyPair(privKey.subarray(0, 32))\n\n  const keyPair = {}\n  keyPair.secretKey = b4a.alloc(SKLEN)\n  keyPair.publicKey = b4a.alloc(PKLEN)\n\n  sodium.crypto_sign_keypair(keyPair.publicKey, keyPair.secretKey)\n  return keyPair\n}\n\nfunction generateSeedKeyPair (seed) {\n  const keyPair = {}\n  keyPair.secretKey = b4a.alloc(SKLEN)\n  keyPair.publicKey = b4a.alloc(PKLEN)\n\n  sodium.crypto_sign_seed_keypair(keyPair.publicKey, keyPair.secretKey, seed)\n  return keyPair\n}\n\nfunction dh (publicKey, { scalar, secretKey }) {\n  // tweaked keys expose scalar directly\n  if (!scalar) {\n    assert(secretKey.byteLength === SKLEN)\n\n    // libsodium stores seed not actual scalar\n    const sk = b4a.alloc(64)\n    sodium.crypto_hash_sha512(sk, secretKey.subarray(0, 32))\n    sk[0] &= 248\n    sk[31] &= 127\n    sk[31] |= 64\n\n    scalar = sk.subarray(0, 32)\n  }\n\n  assert(scalar.byteLength === SCALARLEN)\n  assert(publicKey.byteLength === PKLEN)\n\n  const output = b4a.alloc(DHLEN)\n\n  // we clamp if necessary above\n  sodium.crypto_scalarmult_ed25519_noclamp(\n    output,\n    scalar,\n    publicKey\n  )\n\n  return output\n}\n{\n  \"name\": \"noise-curve-ed\",\n  \"version\": \"2.0.1\",\n  \"description\": \"Ed25519 elliptic curve operations for [`noise-handshake`](https://github.com/chm-diederichs/noise-handshake)\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"npx standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/chm-diederichs/noise-curve-ed.git\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/chm-diederichs/noise-curve-ed/issues\"\n  },\n  \"homepage\": \"https://github.com/chm-diederichs/noise-curve-ed#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.1.0\",\n    \"nanoassert\": \"^2.0.0\",\n    \"sodium-universal\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"hypercore-crypto-tweak\": \"github:holepunchto/hypercore-crypto-tweak\",\n    \"noise-handshake\": \"^3.0.0\",\n    \"standard\": \"^16.0.3\",\n    \"tape\": \"^5.2.2\"\n  }\n}\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\n\nmodule.exports = class CipherState {\n  constructor (key) {\n    this.key = key || null\n    this.nonce = 0\n    this.CIPHER_ALG = 'ChaChaPoly'\n  }\n\n  initialiseKey (key) {\n    this.key = key\n    this.nonce = 0\n  }\n\n  setNonce (nonce) {\n    this.nonce = nonce\n  }\n\n  encrypt (plaintext, ad) {\n    if (!this.hasKey) return plaintext\n    if (!ad) ad = b4a.alloc(0)\n\n    const ciphertext = encryptWithAD(this.key, this.nonce, ad, plaintext)\n    this.nonce++\n\n    return ciphertext\n  }\n\n  decrypt (ciphertext, ad) {\n    if (!this.hasKey) return ciphertext\n    if (!ad) ad = b4a.alloc(0)\n\n    const plaintext = decryptWithAD(this.key, this.nonce, ad, ciphertext)\n    this.nonce++\n\n    return plaintext\n  }\n\n  get hasKey () {\n    return this.key !== null\n  }\n\n  _clear () {\n    sodium.sodium_memzero(this.key)\n    this.key = null\n    this.nonce = null\n  }\n\n  static get MACBYTES () {\n    return 16\n  }\n\n  static get NONCEBYTES () {\n    return 8\n  }\n\n  static get KEYBYTES () {\n    return 32\n  }\n}\n\nfunction encryptWithAD (key, counter, additionalData, plaintext) {\n  // for our purposes, additionalData will always be a pubkey so we encode from hex\n  if (!b4a.isBuffer(additionalData)) additionalData = b4a.from(additionalData, 'hex')\n  if (!b4a.isBuffer(plaintext)) plaintext = b4a.from(plaintext, 'hex')\n\n  const nonce = b4a.alloc(sodium.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)\n  const view = new DataView(nonce.buffer, nonce.byteOffset, nonce.byteLength)\n  view.setUint32(4, counter, true)\n\n  const ciphertext = b4a.alloc(plaintext.byteLength + sodium.crypto_aead_chacha20poly1305_ietf_ABYTES)\n\n  sodium.crypto_aead_chacha20poly1305_ietf_encrypt(ciphertext, plaintext, additionalData, null, nonce, key)\n  return ciphertext\n}\n\nfunction decryptWithAD (key, counter, additionalData, ciphertext) {\n  // for our purposes, additionalData will always be a pubkey so we encode from hex\n  if (!b4a.isBuffer(additionalData)) additionalData = b4a.from(additionalData, 'hex')\n  if (!b4a.isBuffer(ciphertext)) ciphertext = b4a.from(ciphertext, 'hex')\n\n  const nonce = b4a.alloc(sodium.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)\n  const view = new DataView(nonce.buffer, nonce.byteOffset, nonce.byteLength)\n  view.setUint32(4, counter, true)\n\n  const plaintext = b4a.alloc(ciphertext.byteLength - sodium.crypto_aead_chacha20poly1305_ietf_ABYTES)\n\n  sodium.crypto_aead_chacha20poly1305_ietf_decrypt(plaintext, null, ciphertext, additionalData, nonce, key)\n  return plaintext\n}\n/* eslint-disable camelcase */\nconst {\n  crypto_kx_SEEDBYTES,\n  crypto_kx_keypair,\n  crypto_kx_seed_keypair,\n  crypto_scalarmult_BYTES,\n  crypto_scalarmult_SCALARBYTES,\n  crypto_scalarmult,\n  crypto_scalarmult_base\n} = require('sodium-universal')\n\nconst assert = require('nanoassert')\nconst b4a = require('b4a')\n\nconst DHLEN = crypto_scalarmult_BYTES\nconst PKLEN = crypto_scalarmult_BYTES\nconst SKLEN = crypto_scalarmult_SCALARBYTES\nconst SEEDLEN = crypto_kx_SEEDBYTES\nconst ALG = '25519'\n\nmodule.exports = {\n  DHLEN,\n  PKLEN,\n  SKLEN,\n  SEEDLEN,\n  ALG,\n  generateKeyPair,\n  generateSeedKeyPair,\n  dh\n}\n\nfunction generateKeyPair (privKey) {\n  const keyPair = {}\n\n  keyPair.secretKey = privKey || b4a.alloc(SKLEN)\n  keyPair.publicKey = b4a.alloc(PKLEN)\n\n  if (privKey) {\n    crypto_scalarmult_base(keyPair.publicKey, keyPair.secretKey)\n  } else {\n    crypto_kx_keypair(keyPair.publicKey, keyPair.secretKey)\n  }\n\n  return keyPair\n}\n\nfunction generateSeedKeyPair (seed) {\n  assert(seed.byteLength === SKLEN)\n\n  const keyPair = {}\n  keyPair.secretKey = b4a.alloc(SKLEN)\n  keyPair.publicKey = b4a.alloc(PKLEN)\n\n  crypto_kx_seed_keypair(keyPair.publicKey, keyPair.secretKey, seed)\n  return keyPair\n}\n\nfunction dh (publicKey, { secretKey }) {\n  assert(secretKey.byteLength === SKLEN)\n  assert(publicKey.byteLength === PKLEN)\n\n  const output = b4a.alloc(DHLEN)\n\n  crypto_scalarmult(\n    output,\n    secretKey,\n    publicKey\n  )\n\n  return output\n}\nconst hmacBlake2b = require('./hmac')\nconst assert = require('nanoassert')\nconst b4a = require('b4a')\n\nconst HASHLEN = 64\n\nmodule.exports = {\n  hkdf,\n  HASHLEN\n}\n\n// HMAC-based Extract-and-Expand KDF\n// https://www.ietf.org/rfc/rfc5869.txt\n\nfunction hkdf (salt, inputKeyMaterial, info = '', length = 2 * HASHLEN) {\n  const pseudoRandomKey = hkdfExtract(salt, inputKeyMaterial)\n  const result = hkdfExpand(pseudoRandomKey, info, length)\n\n  const results = []\n  let offset = 0\n  while (offset < result.length) {\n    results.push(result.subarray(offset, offset + HASHLEN))\n    offset += HASHLEN\n  }\n  return results\n\n  function hkdfExtract (salt, inputKeyMaterial) {\n    return hmacDigest(salt, inputKeyMaterial)\n  }\n\n  function hkdfExpand (key, info, length) {\n    const T = [b4a.from(info)]\n    const lengthRatio = length / HASHLEN\n\n    for (let i = 0; i < lengthRatio; i++) {\n      const infoBuf = b4a.from(info)\n      const toHash = b4a.concat([T[i], infoBuf, b4a.from([i + 1])])\n\n      T[i + 1] = hmacDigest(key, toHash)\n    }\n\n    const result = b4a.concat(T.slice(1))\n    assert(result.byteLength === length, 'key expansion failed, length not as expected')\n\n    return result\n  }\n}\n\nfunction hmacDigest (key, input) {\n  const hmac = b4a.alloc(HASHLEN)\n  hmacBlake2b(hmac, input, key)\n\n  return hmac\n}\n/* eslint-disable camelcase */\nconst b4a = require('b4a')\nconst { sodium_memzero, crypto_generichash, crypto_generichash_batch } = require('sodium-universal')\n\nconst HASHLEN = 64\nconst BLOCKLEN = 128\nconst scratch = b4a.alloc(BLOCKLEN * 3)\nconst HMACKey = scratch.subarray(BLOCKLEN * 0, BLOCKLEN * 1)\nconst OuterKeyPad = scratch.subarray(BLOCKLEN * 1, BLOCKLEN * 2)\nconst InnerKeyPad = scratch.subarray(BLOCKLEN * 2, BLOCKLEN * 3)\n\n// Post-fill is done in the cases where someone caught an exception that\n// happened before we were able to clear data at the end\n\nmodule.exports = function hmac (out, data, key) {\n  if (key.byteLength > BLOCKLEN) {\n    crypto_generichash(HMACKey.subarray(0, HASHLEN), key)\n    sodium_memzero(HMACKey.subarray(HASHLEN))\n  } else {\n    // Covers key <= BLOCKLEN\n    HMACKey.set(key)\n    sodium_memzero(HMACKey.subarray(key.byteLength))\n  }\n\n  for (let i = 0; i < HMACKey.byteLength; i++) {\n    OuterKeyPad[i] = 0x5c ^ HMACKey[i]\n    InnerKeyPad[i] = 0x36 ^ HMACKey[i]\n  }\n  sodium_memzero(HMACKey)\n\n  crypto_generichash_batch(out, [InnerKeyPad].concat(data))\n  sodium_memzero(InnerKeyPad)\n  crypto_generichash_batch(out, [OuterKeyPad].concat(out))\n  sodium_memzero(OuterKeyPad)\n}\n\nmodule.exports.BYTES = HASHLEN\nmodule.exports.KEYBYTES = BLOCKLEN\nconst assert = require('nanoassert')\nconst b4a = require('b4a')\n\nconst SymmetricState = require('./symmetric-state')\nconst { HASHLEN } = require('./hkdf')\n\nconst PRESHARE_IS = Symbol('initiator static key preshared')\nconst PRESHARE_RS = Symbol('responder static key preshared')\n\nconst TOK_PSK = Symbol('psk')\n\nconst TOK_S = Symbol('s')\nconst TOK_E = Symbol('e')\n\nconst TOK_ES = Symbol('es')\nconst TOK_SE = Symbol('se')\nconst TOK_EE = Symbol('ee')\nconst TOK_SS = Symbol('ss')\n\nconst HANDSHAKES = Object.freeze({\n  NN: [\n    [TOK_E],\n    [TOK_E, TOK_EE]\n  ],\n  NNpsk0: [\n    [TOK_PSK, TOK_E],\n    [TOK_E, TOK_EE]\n  ],\n  XX: [\n    [TOK_E],\n    [TOK_E, TOK_EE, TOK_S, TOK_ES],\n    [TOK_S, TOK_SE]\n  ],\n  XXpsk0: [\n    [TOK_PSK, TOK_E],\n    [TOK_E, TOK_EE, TOK_S, TOK_ES],\n    [TOK_S, TOK_SE]\n  ],\n  IK: [\n    PRESHARE_RS,\n    [TOK_E, TOK_ES, TOK_S, TOK_SS],\n    [TOK_E, TOK_EE, TOK_SE]\n  ]\n})\n\nclass Writer {\n  constructor () {\n    this.size = 0\n    this.buffers = []\n  }\n\n  push (b) {\n    this.size += b.byteLength\n    this.buffers.push(b)\n  }\n\n  end () {\n    const all = b4a.alloc(this.size)\n    let offset = 0\n    for (const b of this.buffers) {\n      all.set(b, offset)\n      offset += b.byteLength\n    }\n    return all\n  }\n}\n\nclass Reader {\n  constructor (buf) {\n    this.offset = 0\n    this.buffer = buf\n  }\n\n  shift (n) {\n    const start = this.offset\n    const end = this.offset += n\n    if (end > this.buffer.byteLength) throw new Error('Insufficient bytes')\n    return this.buffer.subarray(start, end)\n  }\n\n  end () {\n    return this.shift(this.buffer.byteLength - this.offset)\n  }\n}\n\nmodule.exports = class NoiseState extends SymmetricState {\n  constructor (pattern, initiator, staticKeypair, opts = {}) {\n    super(opts)\n\n    this.s = staticKeypair || this.curve.generateKeyPair()\n    this.e = null\n\n    this.psk = null\n    if (opts && opts.psk) this.psk = opts.psk\n\n    this.re = null\n    this.rs = null\n\n    this.pattern = pattern\n    this.handshake = HANDSHAKES[this.pattern].slice()\n\n    this.isPskHandshake = !!this.psk && hasPskToken(this.handshake)\n\n    this.protocol = b4a.from([\n      'Noise',\n      this.pattern,\n      this.DH_ALG,\n      this.CIPHER_ALG,\n      'BLAKE2b'\n    ].join('_'))\n\n    this.initiator = initiator\n    this.complete = false\n\n    this.rx = null\n    this.tx = null\n    this.hash = null\n  }\n\n  initialise (prologue, remoteStatic) {\n    if (this.protocol.byteLength <= HASHLEN) this.digest.set(this.protocol)\n    else this.mixHash(this.protocol)\n\n    this.chainingKey = b4a.from(this.digest)\n\n    this.mixHash(prologue)\n\n    while (!Array.isArray(this.handshake[0])) {\n      const message = this.handshake.shift()\n\n      // handshake steps should be as arrays, only\n      // preshare tokens are provided otherwise\n      assert(message === PRESHARE_RS || message === PRESHARE_IS,\n        'Unexpected pattern')\n\n      const takeRemoteKey = this.initiator\n        ? message === PRESHARE_RS\n        : message === PRESHARE_IS\n\n      if (takeRemoteKey) this.rs = remoteStatic\n\n      const key = takeRemoteKey ? this.rs : this.s.publicKey\n      assert(key != null, 'Remote pubkey required')\n\n      this.mixHash(key)\n    }\n  }\n\n  final () {\n    const [k1, k2] = this.split()\n\n    this.tx = this.initiator ? k1 : k2\n    this.rx = this.initiator ? k2 : k1\n\n    this.complete = true\n    this.hash = this.getHandshakeHash()\n\n    this._clear()\n  }\n\n  recv (buf) {\n    const r = new Reader(buf)\n\n    for (const pattern of this.handshake.shift()) {\n      switch (pattern) {\n        case TOK_PSK :\n          this.mixKeyAndHash(this.psk)\n          break\n\n        case TOK_E :\n          this.re = r.shift(this.curve.PKLEN)\n          this.mixHash(this.re)\n          if (this.isPskHandshake) this.mixKeyNormal(this.re)\n          break\n\n        case TOK_S : {\n          const klen = this.hasKey ? this.curve.PKLEN + 16 : this.curve.PKLEN\n          this.rs = this.decryptAndHash(r.shift(klen))\n          break\n        }\n\n        case TOK_EE :\n        case TOK_ES :\n        case TOK_SE :\n        case TOK_SS : {\n          const useStatic = keyPattern(pattern, this.initiator)\n\n          const localKey = useStatic.local ? this.s : this.e\n          const remoteKey = useStatic.remote ? this.rs : this.re\n\n          this.mixKey(remoteKey, localKey)\n          break\n        }\n\n        default :\n          throw new Error('Unexpected message')\n      }\n    }\n\n    const payload = this.decryptAndHash(r.end())\n\n    if (!this.handshake.length) this.final()\n    return payload\n  }\n\n  send (payload = b4a.alloc(0)) {\n    const w = new Writer()\n\n    for (const pattern of this.handshake.shift()) {\n      switch (pattern) {\n        case TOK_PSK :\n          this.mixKeyAndHash(this.psk)\n          break\n\n        case TOK_E :\n          if (this.e === null) this.e = this.curve.generateKeyPair()\n          this.mixHash(this.e.publicKey)\n          if (this.isPskHandshake) this.mixKeyNormal(this.e.publicKey)\n          w.push(this.e.publicKey)\n          break\n\n        case TOK_S :\n          w.push(this.encryptAndHash(this.s.publicKey))\n          break\n\n        case TOK_ES :\n        case TOK_SE :\n        case TOK_EE :\n        case TOK_SS : {\n          const useStatic = keyPattern(pattern, this.initiator)\n\n          const localKey = useStatic.local ? this.s : this.e\n          const remoteKey = useStatic.remote ? this.rs : this.re\n\n          this.mixKey(remoteKey, localKey)\n          break\n        }\n\n        default :\n          throw new Error('Unexpected message')\n      }\n    }\n\n    w.push(this.encryptAndHash(payload))\n    const response = w.end()\n\n    if (!this.handshake.length) this.final()\n    return response\n  }\n\n  _clear () {\n    super._clear()\n\n    this.e.secretKey.fill(0)\n    this.e.publicKey.fill(0)\n\n    this.re.fill(0)\n\n    this.e = null\n    this.re = null\n  }\n}\n\nfunction keyPattern (pattern, initiator) {\n  const ret = {\n    local: false,\n    remote: false\n  }\n\n  switch (pattern) {\n    case TOK_EE:\n      return ret\n\n    case TOK_ES:\n      ret.local ^= !initiator\n      ret.remote ^= initiator\n      return ret\n\n    case TOK_SE:\n      ret.local ^= initiator\n      ret.remote ^= !initiator\n      return ret\n\n    case TOK_SS:\n      ret.local ^= 1\n      ret.remote ^= 1\n      return ret\n  }\n}\n\nfunction hasPskToken (handshake) {\n  return handshake.some(x => {\n    return Array.isArray(x) && x.indexOf(TOK_PSK) !== -1\n  })\n}\n{\n  \"name\": \"noise-handshake\",\n  \"version\": \"3.1.0\",\n  \"description\": \"\",\n  \"main\": \"noise.js\",\n  \"scripts\": {\n    \"test\": \"standard && tape test/*.js\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/chm-diederichs/noise-handshake.git\"\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.1.0\",\n    \"nanoassert\": \"^2.0.0\",\n    \"sodium-universal\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"noise-protocol\": \"chm-diederichs/noise-protocol.git#xx-ephemeral-key\",\n    \"standard\": \"^16.0.3\",\n    \"tape\": \"^5.2.2\"\n  }\n}\nconst sodium = require('sodium-universal')\nconst assert = require('nanoassert')\nconst b4a = require('b4a')\nconst CipherState = require('./cipher')\nconst curve = require('./dh')\nconst { HASHLEN, hkdf } = require('./hkdf')\n\nmodule.exports = class SymmetricState extends CipherState {\n  constructor (opts = {}) {\n    super()\n\n    this.curve = opts.curve || curve\n    this.digest = b4a.alloc(HASHLEN)\n    this.chainingKey = null\n    this.offset = 0\n\n    this.DH_ALG = this.curve.ALG\n  }\n\n  mixHash (data) {\n    accumulateDigest(this.digest, data)\n  }\n\n  mixKeyAndHash (key) {\n    const [ck, tempH, tempK] = hkdf(this.chainingKey, key, '', 3 * HASHLEN)\n    this.chainingKey = ck\n    this.mixHash(tempH)\n    this.initialiseKey(tempK.subarray(0, 32))\n  }\n\n  mixKeyNormal (key) {\n    const [ck, tempK] = hkdf(this.chainingKey, key)\n    this.chainingKey = ck\n    this.initialiseKey(tempK.subarray(0, 32))\n  }\n\n  mixKey (remoteKey, localKey) {\n    const dh = this.curve.dh(remoteKey, localKey)\n    const hkdfResult = hkdf(this.chainingKey, dh)\n    this.chainingKey = hkdfResult[0]\n    this.initialiseKey(hkdfResult[1].subarray(0, 32))\n  }\n\n  encryptAndHash (plaintext) {\n    const ciphertext = this.encrypt(plaintext, this.digest)\n    accumulateDigest(this.digest, ciphertext)\n    return ciphertext\n  }\n\n  decryptAndHash (ciphertext) {\n    const plaintext = this.decrypt(ciphertext, this.digest)\n    accumulateDigest(this.digest, ciphertext)\n    return plaintext\n  }\n\n  getHandshakeHash (out) {\n    if (!out) return this.getHandshakeHash(b4a.alloc(HASHLEN))\n    assert(out.byteLength === HASHLEN, `output must be ${HASHLEN} bytes`)\n\n    out.set(this.digest)\n    return out\n  }\n\n  split () {\n    const res = hkdf(this.chainingKey, b4a.alloc(0))\n    return res.map(k => k.subarray(0, 32))\n  }\n\n  _clear () {\n    super._clear()\n\n    sodium.sodium_memzero(this.digest)\n    sodium.sodium_memzero(this.chainingKey)\n\n    this.digest = null\n    this.chainingKey = null\n    this.offset = null\n\n    this.curve = null\n  }\n\n  static get alg () {\n    return CipherState.alg + '_BLAKE2b'\n  }\n}\n\nfunction accumulateDigest (digest, input) {\n  const toHash = b4a.concat([digest, input])\n  sodium.crypto_generichash(digest, toHash)\n}\nconst { Transform } = require('streamx')\nconst FIFO = require('fast-fifo/fixed-size')\n\n// internals lifted from streamx\n\nmodule.exports = class ParallelTransform extends Transform {\n  constructor (opts = {}) {\n    super(opts)\n    this._queue = new FIFO(opts.highWaterMark || 16)\n    this._pending = null\n    this._concurrent = 0\n    this._finalizing = false\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transformMany(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transformMany(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    this._finalizing = true\n    if (this._concurrent === 0) cb(null)\n    else this._pending = cb\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n\n  _drain () {\n    while (this._queue.buffer[this._queue.btm] !== null && this._queue.buffer[this._queue.btm] !== undefined) {\n      const data = this._queue.shift()\n      this._concurrent--\n      this.push(data)\n      if (this._pending && (!this._finalizing || this._concurrent === 0)) {\n        const cb = this._pending\n        this._pending = null\n        cb(null)\n      }\n    }\n  }\n\n  _transformMany (data, cb) {\n    const top = this._queue.top\n    this._queue.push(null)\n    this._concurrent++\n\n    if (this._queue.top === this._queue.btm) this._pending = cb\n    else cb(null)\n\n    this._transform(data, (err, res) => {\n      if (err) this.destroy(err)\n      else this._queue.buffer[top] = res\n      this._drain()\n    })\n  }\n}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n{\n  \"name\": \"parallel-transformx\",\n  \"version\": \"1.0.4\",\n  \"description\": \"Parallel transform for streamx\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"streamx\": \"^2.7.0\"\n  },\n  \"devDependencies\": {},\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/parallel-transformx.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/parallel-transformx/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/parallel-transformx\"\n}\nconst HyperDht = require('hyperdht')\nconst { EventEmitter } = require('events')\nconst b4a = require('b4a')\nconst path = require('path')\nconst { isBare } = require('which-runtime')\n\nconst VERSION = 2\n\nclass Inspector {\n  constructor ({ dhtServer, inspectorKey, inspector, filename, bootstrap } = {}) {\n    if (dhtServer && inspectorKey) throw new Error('Inspector constructor cannot take both dhtServer and inspectorKey')\n    if (!inspector) {\n      try {\n        inspector = require('inspector')\n      } catch {\n        throw new Error('Inspector constructor needs inspector to run, like \"inspector\" or \"bare-inspector\"')\n      }\n    }\n\n    const pearFilename = global?.Pear?.config?.dir && path.join(global.Pear.config.dir, global.Pear.config.main)\n    this.filename = filename || pearFilename || require?.main?.filename || process?.argv?.[1]\n    this.inspector = inspector\n    this.dhtServer = dhtServer || null\n    this.inspectorKey = inspectorKey || null\n    this.dhtServerHandledExternally = !!dhtServer\n    this.stopping = false\n    this.oldGlobalConsole = null\n    this.bootstrap = global.Pear?.config?.dht?.bootstrap || bootstrap\n  }\n\n  _overrideGlobalConsole () {\n    // Overriding the global.console is needed for bare-inspector (and pear-inspect)\n    // to be able to read logs\n    const bareInspectorConsole = new this.inspector.Console()\n    const newGlobalConsole = {}\n    for (const method of Object.keys(bareInspectorConsole)) {\n      newGlobalConsole[method] = (...args) => {\n        bareInspectorConsole[method](...args)\n        this.oldGlobalConsole[method](...args)\n      }\n    }\n\n    this.oldGlobalConsole = global.console\n    global.console = newGlobalConsole\n  }\n\n  _resetGlobalConsole () {\n    if (!this.oldGlobalConsole) return\n\n    global.console = this.oldGlobalConsole\n    this.oldGlobalConsole = null\n  }\n\n  async enable () {\n    const shouldCreateServer = !this.dhtServer\n    const shouldGenerateSeed = shouldCreateServer && !this.inspectorKey\n\n    if (shouldGenerateSeed) {\n      const keyPair = HyperDht.keyPair()\n      const seed = keyPair.secretKey.subarray(0, 32)\n      this.inspectorKey = seed\n      this.publicKey = keyPair.publicKey\n      this.secretKey = keyPair.secretKey\n    } else {\n      const keyPair = HyperDht.keyPair(this.inspectorKey)\n      this.publicKey = keyPair.publicKey\n      this.secretKey = keyPair.secretKey\n    }\n\n    if (shouldCreateServer) {\n      this.dht = new HyperDht({ bootstrap: this.bootstrap })\n      this.dhtServer = this.dht.createServer({\n        firewall (remotePublicKey, remote) {\n          return !b4a.equals(remotePublicKey, this.publicKey)\n        }\n      })\n    }\n\n    if (isBare) this._overrideGlobalConsole()\n\n    this.connectionHandler = socket => {\n      let session = null\n\n      let hasReceivedHandshake = false\n      const disconnectSession = () => {\n        if (!session) return\n        if (isBare) {\n          session.destroy()\n          this._resetGlobalConsole()\n        } else {\n          session.disconnect()\n        }\n        session = null\n      }\n      socket.setKeepAlive(5000)\n      socket.on('close', disconnectSession)\n      socket.on('error', () => {\n        // Ignore all errors. Running pear-inspect should not affect the surrounding app\n      })\n      socket.on('data', async data => {\n        if (!hasReceivedHandshake) {\n          hasReceivedHandshake = true\n\n          const { pearInspectVersion } = JSON.parse(data)\n          const isRemoteVersionTooNew = pearInspectVersion > VERSION\n          if (isRemoteVersionTooNew) {\n            console.error('[pear-inspect] The remote end has a newer version than this one. Destroying socket.')\n            socket.destroy()\n            return\n          }\n\n          socket.write(JSON.stringify({\n            pearInspectVersion: VERSION,\n            filename: this.filename\n          }))\n          return\n        }\n\n        const { id, method, params, pearInspectMethod } = JSON.parse(data)\n\n        // This is a way to handle sending information about thread back\n        if (pearInspectMethod === 'connect') {\n          session = new this.inspector.Session()\n\n          session.connect()\n          session.on('inspectorNotification', msg => socket.write(JSON.stringify(msg)))\n\n          return\n        }\n\n        if (pearInspectMethod === 'disconnect') {\n          disconnectSession()\n          return\n        }\n\n        session?.post(method, params, (err, result) => {\n          if (err) {\n            socket.write(JSON.stringify({ id, error: err }))\n          } else {\n            socket.write(JSON.stringify({ id, result }))\n          }\n        })\n      })\n    }\n\n    this.dhtServer.on('connection', this.connectionHandler)\n\n    if (shouldCreateServer) {\n      await this.dhtServer.listen({\n        publicKey: this.publicKey,\n        secretKey: this.secretKey\n      })\n      return this.inspectorKey\n    }\n  }\n\n  async disable () {\n    if (!this.connectionHandler || this.stopping) return\n\n    this.stopping = true\n    this.dhtServer.off('connection', this.connectionHandler)\n    this.connectionHandler = null\n\n    if (isBare) this._resetGlobalConsole()\n\n    if (!this.dhtServerHandledExternally) {\n      await this.dht.destroy()\n      this.dht = null\n      this.dhtServer = null\n    }\n  }\n}\n\nclass Session extends EventEmitter {\n  constructor ({ inspectorKey, publicKey, bootstrap = global.Pear?.config?.dht?.bootstrap }) {\n    super()\n\n    const hasCorrectParams = (inspectorKey && !publicKey) || (!inspectorKey && publicKey)\n    if (!hasCorrectParams) throw new Error('Session constructor needs inspectorKey or publicKey to connect to the hyperdht stream')\n\n    let hasReceivedHandshake = false\n    this.connected = false\n    this.bootstrap = bootstrap\n    this.dhtClient = new HyperDht({ bootstrap })\n    this.dhtSocket = null\n    if (inspectorKey) {\n      const keyPair = HyperDht.keyPair(inspectorKey)\n      this.dhtSocket = this.dhtClient.connect(keyPair.publicKey, { keyPair })\n    } else {\n      this.dhtSocket = this.dhtClient.connect(publicKey)\n    }\n    this.dhtSocket.write(JSON.stringify({ pearInspectVersion: VERSION }))\n    this.dhtSocket.setKeepAlive(5000)\n    this.dhtSocket.on('data', data => {\n      if (!hasReceivedHandshake) {\n        hasReceivedHandshake = true\n\n        const { pearInspectVersion, filename } = JSON.parse(data)\n        const isRemoteVersionTooNew = pearInspectVersion > VERSION\n        if (isRemoteVersionTooNew) {\n          console.error('[pear-inspect] The remote end has a newer version than this one. Destroying socket.')\n          this.dhtSocket.destroy()\n        } else {\n          this.emit('info', { filename })\n        }\n\n        return\n      }\n\n      this.emit('message', JSON.parse(data))\n    })\n    this.dhtSocket.on('error', noop)\n    this.dhtSocket.on('close', () => {\n      this.emit('close')\n      this.destroy()\n    })\n  }\n\n  post (params) {\n    if (!this.connected) throw new Error('Session is not connected. .connect() needs to be called prior to .post()')\n\n    this.dhtSocket?.write(JSON.stringify(params))\n  }\n\n  connect () {\n    this.connected = true\n    this.dhtSocket?.write(JSON.stringify({ pearInspectMethod: 'connect' }))\n  }\n\n  disconnect () {\n    this.connected = false\n    this.dhtSocket?.write(JSON.stringify({ pearInspectMethod: 'disconnect' }))\n  }\n\n  async destroy () {\n    if (!this.dhtClient) return\n\n    await this.dhtSocket.destroy()\n    await this.dhtClient.destroy()\n    this.dhtClient = null\n    this.dhtSocket = null\n  }\n}\n\nfunction noop () {}\n\nmodule.exports = {\n  Inspector,\n  Session\n}\n{\n  \"name\": \"pear-inspect\",\n  \"version\": \"1.2.3\",\n  \"description\": \"Debug Pear applications using DevTools\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && node test/test.js\",\n    \"test-bare\": \"bare test/test.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"Apache-2.0\",\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    },\n    \"inspector\": {\n      \"bare\": \"bare-inspector\",\n      \"default\": \"inspector\"\n    },\n    \"path\": {\n      \"bare\": \"bare-path\",\n      \"default\": \"path\"\n    },\n    \"child_process\": {\n      \"bare\": \"bare-subprocess\",\n      \"default\": \"child_process\"\n    }\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.6.4\",\n    \"bare-inspector\": \"^3.0.1\",\n    \"hyperdht\": \"^6.11.5\",\n    \"which-runtime\": \"^1.2.0\"\n  },\n  \"devDependencies\": {\n    \"@hyperswarm/testnet\": \"^3.1.4\",\n    \"brittle\": \"^3.3.2\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/pear-inspect.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/pear-inspect/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/pear-inspect#readme\",\n  \"optionalDependencies\": {\n    \"bare-events\": \"^2.2.0\",\n    \"bare-path\": \"^3.0.0\",\n    \"bare-subprocess\": \"^4.0.0\"\n  }\n}\nconst DONE = Promise.resolve(true)\nconst DESTROYED = Promise.resolve(false)\n\nmodule.exports = class Semaphore {\n  constructor (limit = 1) {\n    this.limit = limit\n    this.active = 0\n    this.waiting = []\n    this.destroyed = false\n\n    this._onwait = (resolve) => { this.waiting.push(resolve) }\n  }\n\n  wait () {\n    if (this.destroyed === true) return DESTROYED\n\n    if (this.active < this.limit && this.waiting.length === 0) {\n      this.active++\n      return DONE\n    }\n\n    return new Promise(this._onwait)\n  }\n\n  signal () {\n    if (this.destroyed === true) return\n\n    this.active--\n    while (this.active < this.limit && this.waiting.length > 0 && this.destroyed === false) {\n      this.active++\n      this.waiting.shift()(true)\n    }\n  }\n\n  async flush () {\n    if (this.destroyed === true) return\n    this.limit = 1\n    await this.wait()\n    this.signal()\n  }\n\n  destroy () {\n    this.destroyed = true\n    this.active = 0\n    while (this.waiting.length) this.waiting.pop()(false)\n  }\n}\n{\n  \"name\": \"promaphore\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Promise Semaphore\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/promaphore.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/promaphore/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/promaphore\"\n}\nvar varint = require('varint')\nvar svarint = require('signed-varint')\nvar b4a = require('b4a')\n\nexports.make = encoder\n\nexports.name = function (enc) {\n  var keys = Object.keys(exports)\n  for (var i = 0; i < keys.length; i++) {\n    if (exports[keys[i]] === enc) return keys[i]\n  }\n  return null\n}\n\nexports.skip = function (type, buffer, offset) {\n  switch (type) {\n    case 0:\n      varint.decode(buffer, offset)\n      return offset + varint.decode.bytes\n\n    case 1:\n      return offset + 8\n\n    case 2:\n      var len = varint.decode(buffer, offset)\n      return offset + varint.decode.bytes + len\n\n    case 3:\n    case 4:\n      throw new Error('Groups are not supported')\n\n    case 5:\n      return offset + 4\n  }\n\n  throw new Error('Unknown wire type: ' + type)\n}\n\nexports.bytes = encoder(2,\n  function encode (val, buffer, offset) {\n    var oldOffset = offset\n    var len = bufferLength(val)\n\n    varint.encode(len, buffer, offset)\n    offset += varint.encode.bytes\n\n    if (b4a.isBuffer(val)) b4a.copy(val, buffer, offset)\n    else b4a.write(buffer, val, offset, len)\n    offset += len\n\n    encode.bytes = offset - oldOffset\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var oldOffset = offset\n\n    var len = varint.decode(buffer, offset)\n    offset += varint.decode.bytes\n\n    var val = buffer.subarray(offset, offset + len)\n    offset += val.length\n\n    decode.bytes = offset - oldOffset\n    return val\n  },\n  function encodingLength (val) {\n    var len = bufferLength(val)\n    return varint.encodingLength(len) + len\n  }\n)\n\nexports.string = encoder(2,\n  function encode (val, buffer, offset) {\n    var oldOffset = offset\n    var len = b4a.byteLength(val)\n\n    varint.encode(len, buffer, offset, 'utf-8')\n    offset += varint.encode.bytes\n\n    b4a.write(buffer, val, offset, len)\n    offset += len\n\n    encode.bytes = offset - oldOffset\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var oldOffset = offset\n\n    var len = varint.decode(buffer, offset)\n    offset += varint.decode.bytes\n\n    var val = b4a.toString(buffer, 'utf-8', offset, offset + len)\n    offset += len\n\n    decode.bytes = offset - oldOffset\n    return val\n  },\n  function encodingLength (val) {\n    var len = b4a.byteLength(val)\n    return varint.encodingLength(len) + len\n  }\n)\n\nexports.bool = encoder(0,\n  function encode (val, buffer, offset) {\n    buffer[offset] = val ? 1 : 0\n    encode.bytes = 1\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var bool = buffer[offset] > 0\n    decode.bytes = 1\n    return bool\n  },\n  function encodingLength () {\n    return 1\n  }\n)\n\nexports.int32 = encoder(0,\n  function encode (val, buffer, offset) {\n    varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset)\n    encode.bytes = varint.encode.bytes\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = varint.decode(buffer, offset)\n    decode.bytes = varint.decode.bytes\n    return val > 2147483647 ? val - 4294967296 : val\n  },\n  function encodingLength (val) {\n    return varint.encodingLength(val < 0 ? val + 4294967296 : val)\n  }\n)\n\nexports.int64 = encoder(0,\n  function encode (val, buffer, offset) {\n    if (val < 0) {\n      var last = offset + 9\n      varint.encode(val * -1, buffer, offset)\n      offset += varint.encode.bytes - 1\n      buffer[offset] = buffer[offset] | 0x80\n      while (offset < last - 1) {\n        offset++\n        buffer[offset] = 0xff\n      }\n      buffer[last] = 0x01\n      encode.bytes = 10\n    } else {\n      varint.encode(val, buffer, offset)\n      encode.bytes = varint.encode.bytes\n    }\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = varint.decode(buffer, offset)\n    if (val >= Math.pow(2, 63)) {\n      var limit = 9\n      while (buffer[offset + limit - 1] === 0xff) limit--\n      limit = limit || 9\n      var subset = b4a.allocUnsafe(limit)\n      b4a.copy(buffer, subset, 0, offset, offset + limit)\n      subset[limit - 1] = subset[limit - 1] & 0x7f\n      val = -1 * varint.decode(subset, 0)\n      decode.bytes = 10\n    } else {\n      decode.bytes = varint.decode.bytes\n    }\n    return val\n  },\n  function encodingLength (val) {\n    return val < 0 ? 10 : varint.encodingLength(val)\n  }\n)\n\nexports.sint32 =\nexports.sint64 = encoder(0,\n  svarint.encode,\n  svarint.decode,\n  svarint.encodingLength\n)\n\nexports.uint32 =\nexports.uint64 =\nexports.enum =\nexports.varint = encoder(0,\n  varint.encode,\n  varint.decode,\n  varint.encodingLength\n)\n\n// we cannot represent these in javascript so we just use buffers\nexports.fixed64 =\nexports.sfixed64 = encoder(1,\n  function encode (val, buffer, offset) {\n    b4a.copy(val, buffer, offset)\n    encode.bytes = 8\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = buffer.subarray(offset, offset + 8)\n    decode.bytes = 8\n    return val\n  },\n  function encodingLength () {\n    return 8\n  }\n)\n\nexports.double = encoder(1,\n  function encode (val, buffer, offset) {\n    b4a.writeDoubleLE(buffer, val, offset)\n    encode.bytes = 8\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = b4a.readDoubleLE(buffer, offset)\n    decode.bytes = 8\n    return val\n  },\n  function encodingLength () {\n    return 8\n  }\n)\n\nexports.fixed32 = encoder(5,\n  function encode (val, buffer, offset) {\n    b4a.writeUInt32LE(buffer, val, offset)\n    encode.bytes = 4\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = b4a.readUInt32LE(buffer, offset)\n    decode.bytes = 4\n    return val\n  },\n  function encodingLength () {\n    return 4\n  }\n)\n\nexports.sfixed32 = encoder(5,\n  function encode (val, buffer, offset) {\n    b4a.writeInt32LE(buffer, val, offset)\n    encode.bytes = 4\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = b4a.readInt32LE(buffer, offset)\n    decode.bytes = 4\n    return val\n  },\n  function encodingLength () {\n    return 4\n  }\n)\n\nexports.float = encoder(5,\n  function encode (val, buffer, offset) {\n    b4a.writeFloatLE(buffer, val, offset)\n    encode.bytes = 4\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = b4a.readFloatLE(buffer, offset)\n    decode.bytes = 4\n    return val\n  },\n  function encodingLength () {\n    return 4\n  }\n)\n\nfunction encoder (type, encode, decode, encodingLength) {\n  encode.bytes = decode.bytes = 0\n\n  return {\n    type: type,\n    encode: encode,\n    decode: decode,\n    encodingLength: encodingLength\n  }\n}\n\nfunction bufferLength (val) {\n  return b4a.isBuffer(val) ? val.length : b4a.byteLength(val)\n}\n{\n  \"name\": \"protocol-buffers-encodings\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Base encodings for protocol-buffers\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.0\",\n    \"signed-varint\": \"^2.0.1\",\n    \"varint\": \"5.0.0\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^14.3.4\",\n    \"tape\": \"^5.0.1\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/protocol-buffers-encodings.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/protocol-buffers-encodings/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/protocol-buffers-encodings\"\n}\nconst EventEmitter = require('events')\nconst Protomux = require('protomux')\nconst c = require('compact-encoding')\nconst bitfield = require('compact-encoding-bitfield')\nconst bits = require('bits-to-bytes')\nconst safetyCatch = require('safety-catch')\nconst errors = require('./lib/errors')\n\nmodule.exports = class ProtomuxRPC extends EventEmitter {\n  constructor (stream, options = {}) {\n    super()\n\n    const {\n      id,\n      protocol = 'protomux-rpc',\n      valueEncoding = c.buffer,\n      handshake,\n      handshakeEncoding\n    } = options\n\n    this._mux = Protomux.from(stream)\n    this._defaultValueEncoding = valueEncoding\n\n    this._id = 1\n    this._ending = null\n    this._destroyed = false\n    this._error = null\n    this._responding = 0\n\n    this._requests = new Map()\n    this._responders = new Map()\n\n    this._channel = this._mux.createChannel({\n      protocol,\n      id,\n      handshake: handshake ? handshakeEncoding || c.raw : null,\n      onopen: this._onopen.bind(this),\n      onclose: this._onclose.bind(this),\n      ondestroy: this._ondestroy.bind(this)\n    })\n\n    if (this._channel === null) throw errors.DUPLICATE_CHANNEL()\n\n    this._request = this._channel.addMessage({\n      encoding: request,\n      onmessage: this._onrequest.bind(this)\n    })\n\n    this._response = this._channel.addMessage({\n      encoding: response,\n      onmessage: this._onresponse.bind(this)\n    })\n\n    this._channel.open(handshake)\n  }\n\n  _onopen (handshake) {\n    this.emit('open', handshake)\n  }\n\n  _onclose () {\n    this._ending = Promise.resolve()\n\n    const err = this._error || errors.CHANNEL_CLOSED()\n\n    for (const request of this._requests.values()) {\n      request.reject(err)\n    }\n\n    this._requests.clear()\n    this._responders.clear()\n\n    this.emit('close')\n  }\n\n  _ondestroy () {\n    this._destroyed = true\n    this.emit('destroy')\n  }\n\n  async _onrequest ({ id, method, value }) {\n    let error = null\n\n    const responder = this._responders.get(method)\n\n    if (responder === undefined) error = errors.UNKNOWN_METHOD(`Unknown method '${method}'`)\n    else {\n      const {\n        valueEncoding = this._defaultValueEncoding,\n        requestEncoding = valueEncoding,\n        responseEncoding = valueEncoding\n      } = responder.options\n\n      this._responding++\n\n      try {\n        if (requestEncoding) value = c.decode(requestEncoding, value)\n\n        try {\n          value = await responder.handler(value)\n        } catch (err) {\n          safetyCatch(err)\n\n          error = errors.REQUEST_ERROR('Request failed', err)\n        }\n      } catch (err) {\n        safetyCatch(err)\n\n        error = errors.DECODE_ERROR('Could not decode request', err)\n      }\n\n      this._responding--\n\n      if (!error && responseEncoding && id) {\n        try {\n          value = c.encode(responseEncoding, value)\n        } catch (err) {\n          safetyCatch(err)\n\n          error = errors.ENCODE_ERROR('Could not encode response', err)\n        }\n      }\n    }\n\n    if (id) this._response.send({ id, error, value })\n\n    this._endMaybe()\n  }\n\n  _onresponse ({ id, error, value }) {\n    if (id === 0) return\n\n    const request = this._requests.get(id)\n\n    if (request === undefined) return\n\n    this._requests.delete(id)\n\n    if (request.timeout) clearTimeout(request.timeout)\n\n    if (error) request.reject(error)\n    else {\n      const {\n        valueEncoding = this._defaultValueEncoding,\n        responseEncoding = valueEncoding\n      } = request.options\n\n      try {\n        if (responseEncoding) value = c.decode(responseEncoding, value)\n\n        request.resolve(value)\n      } catch (err) {\n        safetyCatch(err)\n\n        request.reject(errors.DECODE_ERROR('Could not decode response', err))\n      }\n    }\n\n    this._endMaybe()\n  }\n\n  _ontimeout (id, timeout) {\n    const request = this._requests.get(id)\n\n    if (request === undefined) return\n\n    this._requests.delete(id)\n\n    request.reject(errors.TIMEOUT_EXCEEDED(`timeout of ${timeout}ms exceeded`))\n\n    this._endMaybe()\n  }\n\n  get opened () {\n    return this._channel.opened\n  }\n\n  get closed () {\n    return this._channel.closed\n  }\n\n  get mux () {\n    return this._mux\n  }\n\n  get stream () {\n    return this._mux.stream\n  }\n\n  async fullyOpened () {\n    await this._channel.fullyOpened()\n  }\n\n  respond (method, options, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = {}\n    }\n\n    this._responders.set(method, { options, handler })\n\n    return this\n  }\n\n  unrespond (method) {\n    this._responders.delete(method)\n\n    return this\n  }\n\n  async request (method, value, options = {}) {\n    if (this.closed) throw errors.CHANNEL_CLOSED()\n\n    const {\n      valueEncoding = this._defaultValueEncoding,\n      requestEncoding = valueEncoding,\n      timeout = -1\n    } = options\n\n    if (requestEncoding) value = c.encode(requestEncoding, value)\n\n    const id = this._id++\n\n    this._request.send({ id, method, value })\n\n    return new Promise((resolve, reject) => this._requests.set(id, {\n      options,\n      resolve,\n      reject,\n      timeout: timeout > 0 && setTimeout(this._ontimeout.bind(this, id, timeout), timeout)\n    }))\n  }\n\n  event (method, value, options = {}) {\n    if (this.closed) throw errors.CHANNEL_CLOSED()\n\n    const {\n      valueEncoding = this._defaultValueEncoding,\n      requestEncoding = valueEncoding\n    } = options\n\n    if (requestEncoding) value = c.encode(requestEncoding, value)\n\n    this._request.send({ id: 0, method, value })\n  }\n\n  cork () {\n    this._channel.cork()\n  }\n\n  uncork () {\n    this._channel.uncork()\n  }\n\n  async end () {\n    if (this._ending) return this._ending\n\n    this._ending = EventEmitter.once(this, 'close')\n    this._endMaybe()\n\n    return this._ending\n  }\n\n  _endMaybe () {\n    if (this._ending && this._responding === 0 && this._requests.size === 0) {\n      this._channel.close()\n    }\n  }\n\n  destroy (err) {\n    if (this._destroyed) return\n    this._destroyed = true\n\n    this._error = err || errors.CHANNEL_DESTROYED()\n    this._channel.close()\n  }\n}\n\nconst request = {\n  preencode (state, m) {\n    c.uint.preencode(state, m.id)\n    c.string.preencode(state, m.method)\n    c.raw.preencode(state, m.value)\n  },\n  encode (state, m) {\n    c.uint.encode(state, m.id)\n    c.string.encode(state, m.method)\n    c.raw.encode(state, m.value)\n  },\n  decode (state) {\n    return {\n      id: c.uint.decode(state),\n      method: c.string.decode(state),\n      value: c.raw.decode(state)\n    }\n  }\n}\n\nconst flags = bitfield(1)\n\nconst response = {\n  preencode (state, m) {\n    flags.preencode(state)\n\n    c.uint.preencode(state, m.id)\n\n    if (m.error) {\n      c.string.preencode(state, m.error.message.replace(m.error.code + ': ', ''))\n\n      if (m.error.code) c.string.preencode(state, m.error.code)\n\n      if (m.error.cause) {\n        c.string.preencode(state, m.error.cause.message)\n        c.string.preencode(state, m.error.cause.code || '')\n      }\n    } else {\n      c.raw.preencode(state, m.value)\n    }\n  },\n  encode (state, m) {\n    flags.encode(state, bits.of(\n      !!(m.error),\n      !!(m.error && m.error.code),\n      !!(m.error && m.error.cause)\n    ))\n\n    c.uint.encode(state, m.id)\n\n    if (m.error) {\n      c.string.encode(state, m.error.message.replace(m.error.code + ': ', ''))\n\n      if (m.error.code)c.string.encode(state, m.error.code)\n\n      if (m.error.cause) {\n        c.string.encode(state, m.error.cause.message)\n        c.string.encode(state, m.error.cause.code || '')\n      }\n    } else {\n      c.raw.encode(state, m.value)\n    }\n  },\n  decode (state) {\n    const [hasError, hasErrorCode, hasErrorCause] = bits.iterator(flags.decode(state))\n\n    const id = c.uint.decode(state)\n\n    let error = null\n    let value = null\n\n    if (hasError) {\n      const message = c.string.decode(state)\n      const code = hasErrorCode ? c.string.decode(state) : null\n\n      let cause\n      if (hasErrorCause) {\n        cause = new Error(c.string.decode(state))\n        const code = c.string.decode(state)\n        if (code) cause.code = code\n      }\n\n      switch (code) {\n        case 'UNKNOWN_METHOD':\n          error = errors.UNKNOWN_METHOD(message)\n          break\n        case 'REQUEST_ERROR':\n          error = errors.REQUEST_ERROR(message, cause)\n          break\n        case 'DECODE_ERROR':\n          error = errors.DECODE_ERROR(message, cause)\n          break\n        case 'ENCODE_ERROR':\n          error = errors.ENCODE_ERROR(message, cause)\n          break\n        default:\n          error = new Error(message, { cause })\n      }\n    } else {\n      value = c.raw.decode(state)\n    }\n\n    return {\n      id,\n      error,\n      value\n    }\n  }\n}\nmodule.exports = class RPCError extends Error {\n  constructor (msg, code, fn = RPCError, { cause } = {}) {\n    super(`${code}: ${msg}`, { cause })\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name () {\n    return 'RPCError'\n  }\n\n  static DUPLICATE_CHANNEL (msg = 'duplicate channel') {\n    return new RPCError(msg, 'DUPLICATE_CHANNEL', RPCError.DUPLICATE_CHANNEL)\n  }\n\n  static CHANNEL_CLOSED (msg = 'channel closed') {\n    return new RPCError(msg, 'CHANNEL_CLOSED', RPCError.CHANNEL_CLOSED)\n  }\n\n  static CHANNEL_DESTROYED (msg = 'channel destroyed') {\n    return new RPCError(msg, 'CHANNEL_DESTROYED', RPCError.CHANNEL_DESTROYED)\n  }\n\n  static REQUEST_ERROR (msg, cause) {\n    return new RPCError(msg, 'REQUEST_ERROR', RPCError.REQUEST_ERROR, { cause })\n  }\n\n  static TIMEOUT_EXCEEDED (msg) {\n    return new RPCError(msg, 'TIMEOUT_EXCEEDED', RPCError.TIMEOUT_EXCEEDED)\n  }\n\n  static UNKNOWN_METHOD (msg) {\n    return new RPCError(msg, 'UNKNOWN_METHOD', RPCError.UNKNOWN_METHOD)\n  }\n\n  static DECODE_ERROR (msg, cause) {\n    return new RPCError(msg, 'DECODE_ERROR', RPCError.DECODE_ERROR, { cause })\n  }\n\n  static ENCODE_ERROR (msg, cause) {\n    return new RPCError(msg, 'ENCODE_ERROR', RPCError.ENCODE_ERROR, { cause })\n  }\n}\n{\n  \"name\": \"protomux-rpc\",\n  \"version\": \"1.7.0\",\n  \"description\": \"RPC over Protomux channels\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/protomux-rpc.git\"\n  },\n  \"author\": \"Kasper Isager Dalsgar <kasper@funktionel.co>\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/protomux-rpc/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/protomux-rpc#readme\",\n  \"dependencies\": {\n    \"bits-to-bytes\": \"^1.0.0\",\n    \"compact-encoding\": \"^2.6.1\",\n    \"compact-encoding-bitfield\": \"^1.0.0\",\n    \"protomux\": \"^3.7.0\",\n    \"safety-catch\": \"^1.0.2\"\n  },\n  \"optionalDependencies\": {\n    \"bare-events\": \"^2.2.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.0\",\n    \"standard\": \"^17.1.0\",\n    \"streamx\": \"^2.12.4\"\n  }\n}\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\nconst queueTick = require('queue-tick')\nconst safetyCatch = require('safety-catch')\nconst unslab = require('unslab')\n\nconst MAX_BUFFERED = 32768\nconst MAX_BACKLOG = Infinity // TODO: impl \"open\" backpressure\nconst MAX_BATCH = 8 * 1024 * 1024\n\nclass Channel {\n  constructor (mux, info, userData, protocol, aliases, id, handshake, messages, onopen, onclose, ondestroy, ondrain) {\n    this.userData = userData\n    this.protocol = protocol\n    this.aliases = aliases\n    this.id = id\n    this.handshake = null\n    this.messages = []\n\n    this.opened = false\n    this.closed = false\n    this.destroyed = false\n\n    this.onopen = onopen\n    this.onclose = onclose\n    this.ondestroy = ondestroy\n    this.ondrain = ondrain\n\n    this._handshake = handshake\n    this._mux = mux\n    this._info = info\n    this._localId = 0\n    this._remoteId = 0\n    this._active = 0\n    this._extensions = null\n\n    this._decBound = this._dec.bind(this)\n    this._decAndDestroyBound = this._decAndDestroy.bind(this)\n\n    this._openedPromise = null\n    this._openedResolve = null\n\n    this._destroyedPromise = null\n    this._destroyedResolve = null\n\n    for (const m of messages) this.addMessage(m)\n  }\n\n  get drained () {\n    return this._mux.drained\n  }\n\n  fullyOpened () {\n    if (this.opened) return Promise.resolve(true)\n    if (this.closed) return Promise.resolve(false)\n    if (this._openedPromise) return this._openedPromise\n\n    this._openedPromise = new Promise((resolve) => { this._openedResolve = resolve })\n    return this._openedPromise\n  }\n\n  fullyClosed () {\n    if (this.destroyed) return Promise.resolve()\n    if (this._destroyedPromise) return this._destroyedPromise\n\n    this._destroyedPromise = new Promise((resolve) => { this._destroyedResolve = resolve })\n    return this._destroyedPromise\n  }\n\n  open (handshake) {\n    const id = this._mux._free.length > 0\n      ? this._mux._free.pop()\n      : this._mux._local.push(null) - 1\n\n    this._info.opened++\n    this._info.lastChannel = this\n    this._localId = id + 1\n    this._mux._local[id] = this\n\n    if (this._remoteId === 0) {\n      this._info.outgoing.push(this._localId)\n    }\n\n    const state = { buffer: null, start: 2, end: 2 }\n\n    c.uint.preencode(state, this._localId)\n    c.string.preencode(state, this.protocol)\n    c.buffer.preencode(state, this.id)\n    if (this._handshake) this._handshake.preencode(state, handshake)\n\n    state.buffer = this._mux._alloc(state.end)\n\n    state.buffer[0] = 0\n    state.buffer[1] = 1\n    c.uint.encode(state, this._localId)\n    c.string.encode(state, this.protocol)\n    c.buffer.encode(state, this.id)\n    if (this._handshake) this._handshake.encode(state, handshake)\n\n    this._mux._write0(state.buffer)\n  }\n\n  _dec () {\n    if (--this._active === 0 && this.closed === true) this._destroy()\n  }\n\n  _decAndDestroy (err) {\n    this._dec()\n    this._mux._safeDestroy(err)\n  }\n\n  _fullyOpenSoon () {\n    this._mux._remote[this._remoteId - 1].session = this\n    queueTick(this._fullyOpen.bind(this))\n  }\n\n  _fullyOpen () {\n    if (this.opened === true || this.closed === true) return\n\n    const remote = this._mux._remote[this._remoteId - 1]\n\n    this.opened = true\n    this.handshake = this._handshake ? this._handshake.decode(remote.state) : null\n    this._track(this.onopen(this.handshake, this))\n\n    remote.session = this\n    remote.state = null\n    if (remote.pending !== null) this._drain(remote)\n\n    this._resolveOpen(true)\n  }\n\n  _resolveOpen (opened) {\n    if (this._openedResolve !== null) {\n      this._openedResolve(opened)\n      this._openedResolve = this._openedPromise = null\n    }\n  }\n\n  _resolveDestroyed () {\n    if (this._destroyedResolve !== null) {\n      this._destroyedResolve()\n      this._destroyedResolve = this._destroyedPromise = null\n    }\n  }\n\n  _drain (remote) {\n    for (let i = 0; i < remote.pending.length; i++) {\n      const p = remote.pending[i]\n      this._mux._buffered -= byteSize(p.state)\n      this._recv(p.type, p.state)\n    }\n\n    remote.pending = null\n    this._mux._resumeMaybe()\n  }\n\n  _track (p) {\n    if (isPromise(p) === true) {\n      this._active++\n      return p.then(this._decBound, this._decAndDestroyBound)\n    }\n\n    return null\n  }\n\n  _close (isRemote) {\n    if (this.closed === true) return\n    this.closed = true\n\n    this._info.opened--\n    if (this._info.lastChannel === this) this._info.lastChannel = null\n\n    if (this._remoteId > 0) {\n      this._mux._remote[this._remoteId - 1] = null\n      this._remoteId = 0\n      // If remote has acked, we can reuse the local id now\n      // otherwise, we need to wait for the \"ack\" to arrive\n      this._mux._free.push(this._localId - 1)\n    }\n\n    this._mux._local[this._localId - 1] = null\n    this._localId = 0\n\n    this._mux._gc(this._info)\n    this._track(this.onclose(isRemote, this))\n\n    if (this._active === 0) this._destroy()\n\n    this._resolveOpen(false)\n  }\n\n  _destroy () {\n    if (this.destroyed === true) return\n    this.destroyed = true\n    this._track(this.ondestroy(this))\n    this._resolveDestroyed()\n  }\n\n  _recv (type, state) {\n    if (type < this.messages.length) {\n      const m = this.messages[type]\n      const p = m.recv(state, this)\n      if (m.autoBatch === true) return p\n    }\n    return null\n  }\n\n  cork () {\n    this._mux.cork()\n  }\n\n  uncork () {\n    this._mux.uncork()\n  }\n\n  close () {\n    if (this.closed === true) return\n\n    const state = { buffer: null, start: 2, end: 2 }\n\n    c.uint.preencode(state, this._localId)\n\n    state.buffer = this._mux._alloc(state.end)\n\n    state.buffer[0] = 0\n    state.buffer[1] = 3\n    c.uint.encode(state, this._localId)\n\n    this._close(false)\n    this._mux._write0(state.buffer)\n  }\n\n  addMessage (opts) {\n    if (!opts) return this._skipMessage()\n\n    const type = this.messages.length\n    const autoBatch = opts.autoBatch !== false\n    const encoding = opts.encoding || c.raw\n    const onmessage = opts.onmessage || noop\n\n    const s = this\n    const typeLen = encodingLength(c.uint, type)\n\n    const m = {\n      type,\n      autoBatch,\n      encoding,\n      onmessage,\n      recv (state, session) {\n        return session._track(m.onmessage(encoding.decode(state), session))\n      },\n      send (m, session = s) {\n        if (session.closed === true) return false\n\n        const mux = session._mux\n        const state = { buffer: null, start: 0, end: typeLen }\n\n        if (mux._batch !== null) {\n          encoding.preencode(state, m)\n          state.buffer = mux._alloc(state.end)\n\n          c.uint.encode(state, type)\n          encoding.encode(state, m)\n\n          mux._pushBatch(session._localId, state.buffer)\n          return true\n        }\n\n        c.uint.preencode(state, session._localId)\n        encoding.preencode(state, m)\n\n        state.buffer = mux._alloc(state.end)\n\n        c.uint.encode(state, session._localId)\n        c.uint.encode(state, type)\n        encoding.encode(state, m)\n\n        mux.drained = mux.stream.write(state.buffer)\n\n        return mux.drained\n      }\n    }\n\n    this.messages.push(m)\n\n    return m\n  }\n\n  _skipMessage () {\n    const type = this.messages.length\n    const m = {\n      type,\n      encoding: c.raw,\n      onmessage: noop,\n      recv (state, session) {},\n      send (m, session) {}\n    }\n\n    this.messages.push(m)\n    return m\n  }\n}\n\nmodule.exports = class Protomux {\n  constructor (stream, { alloc } = {}) {\n    if (stream.userData === null) stream.userData = this\n\n    this.isProtomux = true\n    this.stream = stream\n    this.corked = 0\n    this.drained = true\n\n    this._alloc = alloc || (typeof stream.alloc === 'function' ? stream.alloc.bind(stream) : b4a.allocUnsafe)\n    this._safeDestroyBound = this._safeDestroy.bind(this)\n    this._uncorkBound = this.uncork.bind(this)\n\n    this._remoteBacklog = 0\n    this._buffered = 0\n    this._paused = false\n    this._remote = []\n    this._local = []\n    this._free = []\n    this._batch = null\n    this._batchState = null\n\n    this._infos = new Map()\n    this._notify = new Map()\n\n    this.stream.on('data', this._ondata.bind(this))\n    this.stream.on('drain', this._ondrain.bind(this))\n    this.stream.on('end', this._onend.bind(this))\n    this.stream.on('error', noop) // we handle this in \"close\"\n    this.stream.on('close', this._shutdown.bind(this))\n  }\n\n  static from (stream, opts) {\n    if (stream.userData && stream.userData.isProtomux) return stream.userData\n    if (stream.isProtomux) return stream\n    return new this(stream, opts)\n  }\n\n  static isProtomux (mux) {\n    return typeof mux === 'object' && mux.isProtomux === true\n  }\n\n  * [Symbol.iterator] () {\n    for (const session of this._local) {\n      if (session !== null) yield session\n    }\n  }\n\n  isIdle () {\n    return this._local.length === this._free.length\n  }\n\n  cork () {\n    if (++this.corked === 1) {\n      this._batch = []\n      this._batchState = { buffer: null, start: 0, end: 1 }\n    }\n  }\n\n  uncork () {\n    if (--this.corked === 0) {\n      this._sendBatch(this._batch, this._batchState)\n      this._batch = null\n      this._batchState = null\n    }\n  }\n\n  getLastChannel ({ protocol, id = null }) {\n    const key = toKey(protocol, id)\n    const info = this._infos.get(key)\n    if (info) return info.lastChannel\n    return null\n  }\n\n  pair ({ protocol, id = null }, notify) {\n    this._notify.set(toKey(protocol, id), notify)\n  }\n\n  unpair ({ protocol, id = null }) {\n    this._notify.delete(toKey(protocol, id))\n  }\n\n  opened ({ protocol, id = null }) {\n    const key = toKey(protocol, id)\n    const info = this._infos.get(key)\n    return info ? info.opened > 0 : false\n  }\n\n  createChannel ({ userData = null, protocol, aliases = [], id = null, unique = true, handshake = null, messages = [], onopen = noop, onclose = noop, ondestroy = noop, ondrain = noop }) {\n    if (this.stream.destroyed) return null\n\n    const info = this._get(protocol, id, aliases)\n    if (unique && info.opened > 0) return null\n\n    if (info.incoming.length === 0) {\n      return new Channel(this, info, userData, protocol, aliases, id, handshake, messages, onopen, onclose, ondestroy, ondrain)\n    }\n\n    this._remoteBacklog--\n\n    const remoteId = info.incoming.shift()\n    const r = this._remote[remoteId - 1]\n    if (r === null) return null\n\n    const session = new Channel(this, info, userData, protocol, aliases, id, handshake, messages, onopen, onclose, ondestroy, ondrain)\n\n    session._remoteId = remoteId\n    session._fullyOpenSoon()\n\n    return session\n  }\n\n  _pushBatch (localId, buffer) {\n    if (this._batchState.end >= MAX_BATCH) {\n      this._sendBatch(this._batch, this._batchState)\n      this._batch = []\n      this._batchState = { buffer: null, start: 0, end: 1 }\n    }\n\n    if (this._batch.length === 0 || this._batch[this._batch.length - 1].localId !== localId) {\n      this._batchState.end++\n      c.uint.preencode(this._batchState, localId)\n    }\n    c.buffer.preencode(this._batchState, buffer)\n    this._batch.push({ localId, buffer })\n  }\n\n  _sendBatch (batch, state) {\n    if (batch.length === 0) return\n\n    let prev = batch[0].localId\n\n    state.buffer = this._alloc(state.end)\n    state.buffer[state.start++] = 0\n    state.buffer[state.start++] = 0\n\n    c.uint.encode(state, prev)\n\n    for (let i = 0; i < batch.length; i++) {\n      const b = batch[i]\n      if (prev !== b.localId) {\n        state.buffer[state.start++] = 0\n        c.uint.encode(state, (prev = b.localId))\n      }\n      c.buffer.encode(state, b.buffer)\n    }\n\n    this.drained = this.stream.write(state.buffer)\n  }\n\n  _get (protocol, id, aliases = []) {\n    const key = toKey(protocol, id)\n\n    let info = this._infos.get(key)\n    if (info) return info\n\n    info = { key, protocol, aliases: [], id, pairing: 0, opened: 0, incoming: [], outgoing: [], lastChannel: null }\n    this._infos.set(key, info)\n\n    for (const alias of aliases) {\n      const key = toKey(alias, id)\n      info.aliases.push(key)\n\n      this._infos.set(key, info)\n    }\n\n    return info\n  }\n\n  _gc (info) {\n    if (info.opened === 0 && info.outgoing.length === 0 && info.incoming.length === 0) {\n      this._infos.delete(info.key)\n\n      for (const alias of info.aliases) this._infos.delete(alias)\n    }\n  }\n\n  _ondata (buffer) {\n    if (buffer.byteLength === 0) return // ignore empty frames...\n    try {\n      const state = { buffer, start: 0, end: buffer.byteLength }\n      this._decode(c.uint.decode(state), state)\n    } catch (err) {\n      this._safeDestroy(err)\n    }\n  }\n\n  _ondrain () {\n    this.drained = true\n\n    for (const s of this._local) {\n      if (s !== null) s._track(s.ondrain(s))\n    }\n  }\n\n  _onend () { // TODO: support half open mode for the users who wants that here\n    this.stream.end()\n  }\n\n  _decode (remoteId, state) {\n    const type = c.uint.decode(state)\n\n    if (remoteId === 0) {\n      return this._oncontrolsession(type, state)\n    }\n\n    const r = remoteId <= this._remote.length ? this._remote[remoteId - 1] : null\n\n    // if the channel is closed ignore - could just be a pipeline message...\n    if (r === null) return null\n\n    if (r.pending !== null) {\n      this._bufferMessage(r, type, state)\n      return null\n    }\n\n    return r.session._recv(type, state)\n  }\n\n  _oncontrolsession (type, state) {\n    switch (type) {\n      case 0:\n        this._onbatch(state)\n        break\n\n      case 1:\n        // return the promise back up as this has sideeffects so we can batch reply\n        return this._onopensession(state)\n\n      case 2:\n        this._onrejectsession(state)\n        break\n\n      case 3:\n        this._onclosesession(state)\n        break\n    }\n\n    return null\n  }\n\n  _bufferMessage (r, type, { buffer, start, end }) {\n    const state = { buffer, start, end } // copy\n    r.pending.push({ type, state })\n    this._buffered += byteSize(state)\n    this._pauseMaybe()\n  }\n\n  _pauseMaybe () {\n    if (this._paused === true || this._buffered <= MAX_BUFFERED) return\n    this._paused = true\n    this.stream.pause()\n  }\n\n  _resumeMaybe () {\n    if (this._paused === false || this._buffered > MAX_BUFFERED) return\n    this._paused = false\n    this.stream.resume()\n  }\n\n  _onbatch (state) {\n    const end = state.end\n    let remoteId = c.uint.decode(state)\n\n    let waiting = null\n\n    while (state.end > state.start) {\n      const len = c.uint.decode(state)\n      if (len === 0) {\n        remoteId = c.uint.decode(state)\n        continue\n      }\n      state.end = state.start + len\n      // if batch contains more than one message, cork it so we reply back with a batch\n      if (end !== state.end && waiting === null) {\n        waiting = []\n        this.cork()\n      }\n      const p = this._decode(remoteId, state)\n      if (waiting !== null && p !== null) waiting.push(p)\n      state.start = state.end\n      state.end = end\n    }\n\n    if (waiting !== null) {\n      // the waiting promises are not allowed to throw but we destroy the stream in case we are wrong\n      Promise.all(waiting).then(this._uncorkBound, this._safeDestroyBound)\n    }\n  }\n\n  _onopensession (state) {\n    const remoteId = c.uint.decode(state)\n    const protocol = c.string.decode(state)\n    const id = unslab(c.buffer.decode(state))\n\n    // remote tried to open the control session - auto reject for now\n    // as we can use as an explicit control protocol declaration if we need to\n    if (remoteId === 0) {\n      this._rejectSession(0)\n      return null\n    }\n\n    const rid = remoteId - 1\n    const info = this._get(protocol, id)\n\n    // allow the remote to grow the ids by one\n    if (this._remote.length === rid) {\n      this._remote.push(null)\n    }\n\n    if (rid >= this._remote.length || this._remote[rid] !== null) {\n      throw new Error('Invalid open message')\n    }\n\n    if (info.outgoing.length > 0) {\n      const localId = info.outgoing.shift()\n      const session = this._local[localId - 1]\n\n      if (session === null) { // we already closed the channel - ignore\n        this._free.push(localId - 1)\n        return null\n      }\n\n      this._remote[rid] = { state, pending: null, session: null }\n\n      session._remoteId = remoteId\n      session._fullyOpen()\n      return null\n    }\n\n    const copyState = { buffer: state.buffer, start: state.start, end: state.end }\n    this._remote[rid] = { state: copyState, pending: [], session: null }\n\n    if (++this._remoteBacklog > MAX_BACKLOG) {\n      throw new Error('Remote exceeded backlog')\n    }\n\n    info.pairing++\n    info.incoming.push(remoteId)\n\n    return this._requestSession(protocol, id, info).catch(this._safeDestroyBound)\n  }\n\n  _onrejectsession (state) {\n    const localId = c.uint.decode(state)\n\n    // TODO: can be done smarter...\n    for (const info of this._infos.values()) {\n      const i = info.outgoing.indexOf(localId)\n      if (i === -1) continue\n\n      info.outgoing.splice(i, 1)\n\n      const session = this._local[localId - 1]\n\n      this._free.push(localId - 1)\n      if (session !== null) session._close(true)\n\n      this._gc(info)\n      return\n    }\n\n    throw new Error('Invalid reject message')\n  }\n\n  _onclosesession (state) {\n    const remoteId = c.uint.decode(state)\n\n    if (remoteId === 0) return // ignore\n\n    const rid = remoteId - 1\n    const r = rid < this._remote.length ? this._remote[rid] : null\n\n    if (r === null) return\n\n    if (r.session !== null) r.session._close(true)\n  }\n\n  async _requestSession (protocol, id, info) {\n    const notify = this._notify.get(toKey(protocol, id)) || this._notify.get(toKey(protocol, null))\n\n    if (notify) await notify(id)\n\n    if (--info.pairing > 0) return\n\n    while (info.incoming.length > 0) {\n      this._rejectSession(info, info.incoming.shift())\n    }\n\n    this._gc(info)\n  }\n\n  _rejectSession (info, remoteId) {\n    if (remoteId > 0) {\n      const r = this._remote[remoteId - 1]\n\n      if (r.pending !== null) {\n        for (let i = 0; i < r.pending.length; i++) {\n          this._buffered -= byteSize(r.pending[i].state)\n        }\n      }\n\n      this._remote[remoteId - 1] = null\n      this._resumeMaybe()\n    }\n\n    const state = { buffer: null, start: 2, end: 2 }\n\n    c.uint.preencode(state, remoteId)\n\n    state.buffer = this._alloc(state.end)\n\n    state.buffer[0] = 0\n    state.buffer[1] = 2\n    c.uint.encode(state, remoteId)\n\n    this._write0(state.buffer)\n  }\n\n  _write0 (buffer) {\n    if (this._batch !== null) {\n      this._pushBatch(0, buffer.subarray(1))\n      return\n    }\n\n    this.drained = this.stream.write(buffer)\n  }\n\n  destroy (err) {\n    this.stream.destroy(err)\n  }\n\n  _safeDestroy (err) {\n    safetyCatch(err)\n    this.stream.destroy(err)\n  }\n\n  _shutdown () {\n    for (const s of this._local) {\n      if (s !== null) s._close(true)\n    }\n  }\n}\n\nfunction noop () {}\n\nfunction toKey (protocol, id) {\n  return protocol + '##' + (id ? b4a.toString(id, 'hex') : '')\n}\n\nfunction byteSize (state) {\n  return 512 + (state.end - state.start)\n}\n\nfunction isPromise (p) {\n  return !!(p && typeof p.then === 'function')\n}\n\nfunction encodingLength (enc, val) {\n  const state = { buffer: null, start: 0, end: 0 }\n  enc.preencode(state, val)\n  return state.end\n}\n{\n  \"name\": \"protomux\",\n  \"version\": \"3.10.1\",\n  \"description\": \"Multiplex multiple message oriented protocols over a stream\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {\n    \"b4a\": \"^1.3.1\",\n    \"compact-encoding\": \"^2.5.1\",\n    \"queue-tick\": \"^1.0.0\",\n    \"safety-catch\": \"^1.0.1\",\n    \"unslab\": \"^1.3.0\"\n  },\n  \"devDependencies\": {\n    \"@hyperswarm/secret-stream\": \"^6.0.0\",\n    \"brittle\": \"^3.0.0\",\n    \"standard\": \"^16.0.4\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/protomux.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/protomux/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/protomux\"\n}\n{\n  \"name\": \"queue-tick\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Next tick shim that prefers process.nextTick over queueMicrotask for compat\",\n  \"main\": \"./process-next-tick.js\",\n  \"browser\": \"./queue-microtask.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^16.0.3\",\n    \"tape\": \"^5.3.1\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/queue-tick.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/queue-tick/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/queue-tick\"\n}\nmodule.exports = (typeof process !== 'undefined' && typeof process.nextTick === 'function')\n  ? process.nextTick.bind(process)\n  : require('./queue-microtask')\nmodule.exports = typeof queueMicrotask === 'function' ? queueMicrotask : (fn) => Promise.resolve().then(fn)\nmodule.exports = require('node-gyp-build')(__dirname)\nconst b4a = require('b4a')\nconst binding = require('./binding')\n\nexports.get = function get (field, bit) {\n  const n = field.byteLength * 8\n\n  if (bit < 0) bit += n\n  if (bit < 0 || bit >= n) return false\n\n  return binding.quickbit_napi_get(field, bit) !== 0\n}\n\nexports.set = function set (field, bit, value = true) {\n  const n = field.byteLength * 8\n\n  if (bit < 0) bit += n\n  if (bit < 0 || bit >= n) return false\n\n  return binding.quickbit_napi_set(field, bit, value ? 1 : 0) !== 0\n}\n\nexports.fill = function fill (field, value, start = 0, end = field.byteLength * 8) {\n  const n = field.byteLength * 8\n\n  if (start < 0) start += n\n  if (end < 0) end += n\n  if (start < 0 || start >= field.byteLength * 8 || start >= end) return field\n\n  binding.quickbit_napi_fill(field, value ? 1 : 0, start, end)\n  return field\n}\n\nexports.clear = function clear (field, ...chunks) {\n  binding.quickbit_napi_clear(field, chunks)\n}\n\nexports.findFirst = function findFirst (field, value, position = 0) {\n  const n = field.byteLength * 8\n\n  if (position < 0) position += n\n  if (position < 0) position = 0\n  if (position >= n) return -1\n\n  return binding.quickbit_napi_find_first(field, value ? 1 : 0, position)\n}\n\nexports.findLast = function findLast (field, value, position = field.byteLength * 8 - 1) {\n  const n = field.byteLength * 8\n\n  if (position < 0) position += n\n  if (position < 0) return -1\n  if (position >= n) position = n - 1\n\n  return binding.quickbit_napi_find_last(field, value ? 1 : 0, position)\n}\n\nconst Index = exports.Index = class Index {\n  static from (fieldOrChunks, byteLength = -1) {\n    if (Array.isArray(fieldOrChunks)) {\n      return new SparseIndex(fieldOrChunks, byteLength)\n    } else {\n      return new DenseIndex(fieldOrChunks, byteLength)\n    }\n  }\n\n  constructor (byteLength) {\n    this._byteLength = byteLength\n    this.handle = b4a.allocUnsafe(binding.sizeof_quickbit_index_t)\n  }\n\n  get byteLength () {\n    return this._byteLength\n  }\n\n  skipFirst (value, position = 0) {\n    const n = this.byteLength * 8\n\n    if (position < 0) position += n\n    if (position < 0) position = 0\n    if (position >= n) return n - 1\n\n    return binding.quickbit_napi_skip_first(this.handle, this.byteLength, value ? 1 : 0, position)\n  }\n\n  skipLast (value, position = this.byteLength * 8 - 1) {\n    const n = this.byteLength * 8\n\n    if (position < 0) position += n\n    if (position < 0) return 0\n    if (position >= n) position = n - 1\n\n    return binding.quickbit_napi_skip_last(this.handle, this.byteLength, value ? 1 : 0, position)\n  }\n}\n\nclass DenseIndex extends Index {\n  constructor (field, byteLength) {\n    super(byteLength)\n    this.field = field\n\n    binding.quickbit_napi_index_init(this.handle, this.field)\n  }\n\n  get byteLength () {\n    if (this._byteLength !== -1) return this._byteLength\n    return this.field.byteLength\n  }\n\n  update (bit) {\n    const n = this.byteLength * 8\n\n    if (bit < 0) bit += n\n    if (bit < 0 || bit >= n) return false\n\n    return binding.quickbit_napi_index_update(this.handle, this.field, bit) !== 0\n  }\n}\n\nfunction selectChunk (chunks, offset) {\n  for (let i = 0; i < chunks.length; i++) {\n    const next = chunks[i]\n\n    const start = next.offset\n    const end = next.offset + next.field.byteLength\n\n    if (offset >= start && offset + 16 <= end) {\n      return next\n    }\n  }\n\n  return null\n}\n\nclass SparseIndex extends Index {\n  constructor (chunks, byteLength) {\n    super(byteLength)\n    this.chunks = chunks\n\n    binding.quickbit_napi_index_init_sparse(this.handle, this.chunks)\n  }\n\n  get byteLength () {\n    if (this._byteLength !== -1) return this._byteLength\n    const last = this.chunks[this.chunks.length - 1]\n    return last ? last.offset + last.field.byteLength : 0\n  }\n\n  update (bit) {\n    const n = this.byteLength * 8\n\n    if (bit < 0) bit += n\n    if (bit < 0 || bit >= n) return false\n\n    const j = Math.floor(bit / 128)\n\n    const offset = j * 16\n\n    const chunk = selectChunk(this.chunks, offset)\n\n    if (chunk === null) return false\n\n    return binding.quickbit_napi_index_update_sparse(this.handle, chunk.field, chunk.offset, bit) !== 0\n  }\n}\n{\n  \"name\": \"quickbit-native\",\n  \"version\": \"2.3.5\",\n  \"description\": \"libquickbit JavaScript bindings for Node.js\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"macros.h\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"npm run lint && npm run test:bare && npm run test:node\",\n    \"test:bare\": \"bare test.mjs\",\n    \"test:node\": \"node test.mjs\",\n    \"lint\": \"standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/quickbit-native.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/quickbit-native/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/quickbit-native#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.0\",\n    \"node-gyp-build\": \"^4.8.2\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.0\",\n    \"cmake-bare\": \"^1.1.7\",\n    \"cmake-fetch\": \"^1.1.0\",\n    \"cmake-napi\": \"^1.0.2\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst simdle = require('simdle-universal')\n\nconst INDEX_LEN = (16 /* root */ + 128 * 16 /* children */) * 2\n\nconst get = exports.get = function get (field, bit) {\n  const n = field.byteLength * 8\n\n  if (bit < 0) bit += n\n  if (bit < 0 || bit >= n) return false\n\n  const m = field.BYTES_PER_ELEMENT * 8\n\n  const offset = bit & (m - 1)\n  const i = (bit - offset) / m\n\n  return (field[i] & (1 << offset)) !== 0\n}\n\nconst set = exports.set = function set (field, bit, value = true) {\n  const n = field.byteLength * 8\n\n  if (bit < 0) bit += n\n  if (bit < 0 || bit >= n) return false\n\n  const m = field.BYTES_PER_ELEMENT * 8\n\n  const offset = bit & (m - 1)\n  const i = (bit - offset) / m\n  const mask = 1 << offset\n\n  if (value) {\n    if ((field[i] & mask) !== 0) return false\n  } else {\n    if ((field[i] & mask) === 0) return false\n  }\n\n  field[i] ^= mask\n\n  return true\n}\n\nexports.fill = function fill (field, value, start = 0, end = field.byteLength * 8) {\n  const n = field.byteLength * 8\n\n  if (start < 0) start += n\n  if (end < 0) end += n\n  if (start < 0 || start >= field.byteLength * 8 || start >= end) return field\n\n  const m = field.BYTES_PER_ELEMENT * 8\n\n  let i, j\n\n  {\n    const offset = start & (m - 1)\n    i = (start - offset) / m\n\n    if (offset !== 0) {\n      let shift = m - offset\n      if (end - start < shift) shift = end - start\n\n      const mask = ((1 << shift) - 1) << offset\n\n      if (value) field[i] |= mask\n      else field[i] &= ~mask\n\n      i++\n    }\n  }\n\n  {\n    const offset = end & (m - 1)\n    j = (end - offset) / m\n\n    if (offset !== 0 && j >= i) {\n      const mask = (1 << offset) - 1\n\n      if (value) field[j] |= mask\n      else field[j] &= ~mask\n    }\n  }\n\n  if (i < j) field.fill(value ? (2 ** m) - 1 : 0, i, j)\n\n  return field\n}\n\nexports.clear = function clear (field, ...chunks) {\n  const n = field.byteLength\n\n  for (const chunk of chunks) {\n    if (chunk.offset >= n) continue\n\n    const m = chunk.field.byteLength\n\n    let i = chunk.offset\n    let j = 0\n\n    while (((i & 15) !== 0 || (j & 15) !== 0) && i < n && j < m) {\n      field[i] = field[i] & ~chunk.field[j]\n      i++\n      j++\n    }\n\n    if (i + 15 < n && j + 15 < m) {\n      const len = Math.min(n - (n & 15) - i, m - (m & 15) - j)\n\n      simdle.clear(field.subarray(i, i + len), chunk.field.subarray(j, j + len), field.subarray(i, i + len))\n    }\n\n    while (i < n && j < m) {\n      field[i] = field[i] & ~chunk.field[j]\n      i++\n      j++\n    }\n  }\n}\n\nfunction bitOffset (bit, offset) {\n  return !bit ? offset : (INDEX_LEN * 8 / 2) + offset\n}\n\nfunction byteOffset (bit, offset) {\n  return !bit ? offset : (INDEX_LEN / 2) + offset\n}\n\nexports.findFirst = function findFirst (field, value, position = 0) {\n  const n = field.byteLength * 8\n\n  if (position < 0) position += n\n  if (position < 0) position = 0\n  if (position >= n) return -1\n\n  value = !!value\n\n  for (let i = position; i < n; i++) {\n    if (get(field, i) === value) return i\n  }\n\n  return -1\n}\n\nexports.findLast = function findLast (field, value, position = field.byteLength * 8 - 1) {\n  const n = field.byteLength * 8\n\n  if (position < 0) position += n\n  if (position < 0) return -1\n  if (position >= n) position = n - 1\n\n  value = !!value\n\n  for (let i = position; i >= 0; i--) {\n    if (get(field, i) === value) return i\n  }\n\n  return -1\n}\n\nconst Index = exports.Index = class Index {\n  static from (fieldOrChunks, byteLength = -1) {\n    if (Array.isArray(fieldOrChunks)) {\n      return new SparseIndex(fieldOrChunks, byteLength)\n    } else {\n      return new DenseIndex(fieldOrChunks, byteLength)\n    }\n  }\n\n  constructor (byteLength) {\n    this._byteLength = byteLength\n    this.handle = new Uint32Array(INDEX_LEN / 4)\n  }\n\n  get byteLength () {\n    return this._byteLength\n  }\n\n  skipFirst (value, position = 0) {\n    const n = this.byteLength * 8\n\n    if (position < 0) position += n\n    if (position < 0) position = 0\n    if (position >= n) return n - 1\n\n    let i = Math.floor(position / 16384)\n\n    if (i > 127) return position\n\n    while (i <= 127 && get(this.handle, bitOffset(value, i))) {\n      i++\n    }\n\n    if (i === 128) return n - 1\n\n    let k = i * 16384\n    let j = 0\n\n    if (position > k) j = Math.floor((position - k) / 128)\n\n    while (j <= 127 && get(this.handle, bitOffset(value, i * 128 + j + 128))) {\n      j++\n      k += 128\n    }\n\n    if (j === 128 && i !== 127) return this.skipFirst(value, (i + 1) * 16384)\n\n    if (k > position) position = k\n\n    return position < n ? position : n - 1\n  }\n\n  skipLast (value, position = this.byteLength * 8 - 1) {\n    const n = this.byteLength * 8\n\n    if (position < 0) position += n\n    if (position < 0) return 0\n    if (position >= n) position = n - 1\n\n    let i = Math.floor(position / 16384)\n\n    if (i > 127) return position\n\n    while (i >= 0 && get(this.handle, bitOffset(value, i))) {\n      i--\n    }\n\n    if (i === -1) return 0\n\n    let k = ((i + 1) * 16384) - 1\n    let j = 127\n\n    if (position < k) j = 128 - Math.ceil((k - position) / 128)\n\n    while (j >= 0 && get(this.handle, bitOffset(value, i * 128 + j + 128))) {\n      j--\n      k -= 128\n    }\n\n    if (j === -1 && i !== 0) return this.skipLast(value, i * 16384 - 1)\n\n    if (k < position) position = k\n\n    return position\n  }\n}\n\nclass DenseIndex extends Index {\n  constructor (field, byteLength) {\n    super(byteLength)\n    this.field = field\n\n    const m = field.BYTES_PER_ELEMENT\n\n    for (let i = 0; i < 128; i++) {\n      for (let j = 0; j < 128; j++) {\n        const offset = (i * 128 + j) * 16\n        let allz = true\n        let allo = false\n\n        if (offset + 16 <= this.field.byteLength) {\n          const vec = this.field.subarray(offset / m, (offset + 16) / m)\n\n          allz = simdle.allz(vec)\n          allo = simdle.allo(vec)\n        }\n\n        const k = i * 128 + 128 + j\n\n        set(this.handle, bitOffset(false, k), allz)\n        set(this.handle, bitOffset(true, k), allo)\n      }\n\n      {\n        const offset = byteOffset(false, i * 16 + 16) / 4\n        const allo = simdle.allo(this.handle.subarray(offset, offset + 4))\n\n        set(this.handle, bitOffset(false, i), allo)\n      }\n\n      {\n        const offset = byteOffset(true, i * 16 + 16) / 4\n        const allo = simdle.allo(this.handle.subarray(offset, offset + 4))\n\n        set(this.handle, bitOffset(true, i), allo)\n      }\n    }\n  }\n\n  get byteLength () {\n    if (this._byteLength !== -1) return this._byteLength\n    return this.field.byteLength\n  }\n\n  update (bit) {\n    const n = this.byteLength * 8\n\n    if (bit < 0) bit += n\n    if (bit < 0 || bit >= n) return false\n\n    const m = this.field.BYTES_PER_ELEMENT\n\n    const i = Math.floor(bit / 16384)\n    const j = Math.floor(bit / 128)\n\n    const offset = (j * 16) / m\n    const vec = this.field.subarray(offset, offset + (16 / m))\n\n    const allz = simdle.allz(vec)\n    const allo = simdle.allo(vec)\n\n    let changed = false\n\n    if (set(this.handle, bitOffset(false, 128 + j), allz)) {\n      changed = true\n\n      const offset = byteOffset(false, i * 16 + 16) / 4\n      const allo = simdle.allo(this.handle.subarray(offset, offset + 4))\n\n      set(this.handle, bitOffset(false, i), allo)\n    }\n\n    if (set(this.handle, bitOffset(true, 128 + j), allo)) {\n      changed = true\n\n      const offset = byteOffset(true, i * 16 + 16) / 4\n      const allo = simdle.allo(this.handle.subarray(offset, offset + 4))\n\n      set(this.handle, bitOffset(true, i), allo)\n    }\n\n    return changed\n  }\n}\n\nfunction selectChunk (chunks, offset) {\n  for (let i = 0; i < chunks.length; i++) {\n    const next = chunks[i]\n\n    const start = next.offset\n    const end = next.offset + next.field.byteLength\n\n    if (offset >= start && offset + 16 <= end) {\n      return next\n    }\n  }\n\n  return null\n}\n\nclass SparseIndex extends Index {\n  constructor (chunks, byteLength) {\n    super(byteLength)\n    this.chunks = chunks\n\n    for (let i = 0; i < 128; i++) {\n      for (let j = 0; j < 128; j++) {\n        const offset = (i * 128 + j) * 16\n        let allz = true\n        let allo = false\n\n        const chunk = selectChunk(this.chunks, offset)\n\n        if (chunk !== null) {\n          const m = chunk.field.BYTES_PER_ELEMENT\n\n          const vec = chunk.field.subarray((offset - chunk.offset) / m, (offset - chunk.offset + 16) / m)\n\n          allz = simdle.allz(vec)\n          allo = simdle.allo(vec)\n        }\n\n        const k = i * 128 + 128 + j\n\n        set(this.handle, bitOffset(false, k), allz)\n        set(this.handle, bitOffset(true, k), allo)\n      }\n\n      {\n        const offset = byteOffset(false, i * 16 + 16) / 4\n        const allo = simdle.allo(this.handle.subarray(offset, offset + 4))\n\n        set(this.handle, bitOffset(false, i), allo)\n      }\n\n      {\n        const offset = byteOffset(true, i * 16 + 16) / 4\n        const allo = simdle.allo(this.handle.subarray(offset, offset + 4))\n\n        set(this.handle, bitOffset(true, i), allo)\n      }\n    }\n  }\n\n  get byteLength () {\n    if (this._byteLength !== -1) return this._byteLength\n    const last = this.chunks[this.chunks.length - 1]\n    return last ? last.offset + last.field.byteLength : 0\n  }\n\n  update (bit) {\n    const n = this.byteLength * 8\n\n    if (bit < 0) bit += n\n    if (bit < 0 || bit >= n) return false\n\n    const i = Math.floor(bit / 16384)\n    const j = Math.floor(bit / 128)\n\n    const offset = j * 16\n\n    const chunk = selectChunk(this.chunks, offset)\n\n    if (chunk === null) return false\n\n    const m = chunk.field.BYTES_PER_ELEMENT\n\n    const vec = chunk.field.subarray((offset - chunk.offset) / m, (offset - chunk.offset + 16) / m)\n\n    const allz = simdle.allz(vec)\n    const allo = simdle.allo(vec)\n\n    let changed = false\n\n    if (set(this.handle, bitOffset(false, 128 + j), allz)) {\n      changed = true\n\n      const offset = byteOffset(false, i * 16 + 16) / 4\n      const allo = simdle.allo(this.handle.subarray(offset, offset + 4))\n\n      set(this.handle, bitOffset(false, i), allo)\n    }\n\n    if (set(this.handle, bitOffset(true, 128 + j), allo)) {\n      changed = true\n\n      const offset = byteOffset(true, i * 16 + 16) / 4\n      const allo = simdle.allo(this.handle.subarray(offset, offset + 4))\n\n      set(this.handle, bitOffset(true, i), allo)\n    }\n\n    return changed\n  }\n}\nconst fallback = require('./fallback')\n\ntry {\n  const native = require('quickbit-native')\n\n  // These functions are faster in JavaScript\n  exports.get = fallback.get\n  exports.set = fallback.set\n  exports.fill = fallback.fill\n\n  // These functions are faster in C\n  exports.clear = native.clear\n  exports.findFirst = native.findFirst\n  exports.findLast = native.findLast\n  exports.Index = native.Index\n} catch {\n  module.exports = fallback\n}\n{\n  \"name\": \"quickbit-universal\",\n  \"version\": \"2.2.0\",\n  \"description\": \"Universal wrapper for libquickbit with a JavaScript fallback\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"fallback.js\",\n    \"index.js\"\n  ],\n  \"browser\": {\n    \"./index.js\": \"./fallback.js\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/quickbit-universal.git\"\n  },\n  \"author\": \"Kasper Isager Dalsgar <kasper@funktionel.co>\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/quickbit-universal/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/quickbit-universal#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.0\",\n    \"simdle-universal\": \"^1.1.0\"\n  },\n  \"optionalDependencies\": {\n    \"quickbit-native\": \"^2.2.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.0\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nclass CacheEntry {\n  constructor (key, index, map) {\n    this.key = key\n    this.index = index\n    this.map = map\n  }\n}\n\nclass CacheValue {\n  constructor (entry, value) {\n    this.entry = entry\n    this.value = value\n  }\n}\n\nclass Rache {\n  constructor ({ maxSize = 65536, parent = null } = {}) {\n    this.maxSize = parent?.maxSize || maxSize\n\n    this._array = parent?._array || []\n    this._map = new Map()\n  }\n\n  static from (cache) {\n    return cache ? new this({ parent: cache }) : new this()\n  }\n\n  get globalSize () {\n    return this._array.length\n  }\n\n  get size () {\n    return this._map.size\n  }\n\n  sub () {\n    return new Rache({ parent: this })\n  }\n\n  set (key, value) { // ~constant time\n    const existing = this._map.get(key)\n    if (existing !== undefined) {\n      existing.value = value\n      return\n    }\n\n    if (this._array.length >= this.maxSize) this._gc()\n\n    const entry = new CacheEntry(key, this._array.length, this._map)\n    this._array.push(entry)\n    const cacheValue = new CacheValue(entry, value)\n    this._map.set(key, cacheValue)\n  }\n\n  delete (key) {\n    const existing = this._map.get(key)\n    if (existing === undefined) return false\n\n    this._delete(existing.entry.index)\n    return true\n  }\n\n  get (key) {\n    const existing = this._map.get(key)\n    return existing === undefined ? undefined : existing.value\n  }\n\n  * [Symbol.iterator] () {\n    for (const [key, { value }] of this._map) {\n      yield [key, value]\n    }\n  }\n\n  keys () {\n    return this._map.keys()\n  }\n\n  * values () {\n    for (const { value } of this._map.values()) {\n      yield value\n    }\n  }\n\n  clear () {\n    // The entries in map linger on in _array,\n    // so on top of clearing the map, we also kill the ref,\n    // so that any gc running later on the old map won't interfere\n    // (in case a new entry was added with the same key as a cleared entry)\n\n    this._map.clear()\n    this._map = new Map()\n  }\n\n  destroy () {\n    this._map = null\n    this._array = null\n  }\n\n  _gc () {\n    this._delete(Math.floor(Math.random() * this._array.length))\n  }\n\n  _delete (index) { // ~constant time\n    if (index >= this._array.length) throw new Error('Cannot delete unused index (logic bug?)')\n\n    const head = this._array.pop()\n    let removed = head\n\n    if (index < this._array.length) {\n      removed = this._array[index]\n      head.index = index\n      this._array[index] = head\n    }\n\n    removed.map.delete(removed.key)\n  }\n}\n\nmodule.exports = Rache\n{\n  \"name\": \"rache\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Random-eviction cache\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js --coverage\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/rache.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/rache/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/rache#readme\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.2\",\n    \"standard\": \"^17.1.0\"\n  }\n}\nconst RandomAccessStorage = require('random-access-storage')\nconst fs = require('fs')\nconst path = require('path')\nconst constants = fs.constants\n\nlet fsext = null\ntry {\n  fsext = require('fs-native-extensions')\n} catch {}\n\nconst RDWR = constants.O_RDWR\nconst RDONLY = constants.O_RDONLY\nconst WRONLY = constants.O_WRONLY\nconst CREAT = constants.O_CREAT\n\nclass Pool {\n  constructor (maxSize) {\n    this.maxSize = maxSize\n    this.active = []\n  }\n\n  _onactive (file) {\n    // suspend a random one when the pool\n    if (this.active.length >= this.maxSize) {\n      const r = Math.floor(Math.random() * this.active.length)\n      this.active[r].suspend()\n    }\n\n    file._pi = this.active.push(file) - 1\n  }\n\n  _oninactive (file) {\n    const head = this.active.pop()\n    if (head !== file) {\n      head._pi = file._pi\n      this.active[head._pi] = head\n    }\n  }\n}\n\nmodule.exports = class RandomAccessFile extends RandomAccessStorage {\n  constructor (filename, opts = {}) {\n    const size = opts.size || (opts.truncate ? 0 : -1)\n\n    super()\n\n    if (opts.directory) filename = path.join(opts.directory, path.resolve('/', filename).replace(/^\\w+:\\\\/, ''))\n\n    this.directory = opts.directory || null\n    this.filename = filename\n    this.fd = 0\n\n    const {\n      readable = true,\n      writable = true\n    } = opts\n\n    this.mode = readable && writable ? RDWR : (readable ? RDONLY : WRONLY)\n\n    this._pi = 0 // pool index\n    this._pool = opts.pool || null\n    this._size = size\n    this._rmdir = !!opts.rmdir\n    this._lock = opts.lock === true\n    this._sparse = opts.sparse === true\n    this._alloc = opts.alloc || Buffer.allocUnsafe\n    this._alwaysCreate = size >= 0\n  }\n\n  static createPool (maxSize) {\n    return new Pool(maxSize)\n  }\n\n  _open (req) {\n    const create = this._alwaysCreate || this.writing // .writing comes from RAS\n    const self = this\n    const mode = this.mode | (create ? CREAT : 0)\n\n    if (create) fs.mkdir(path.dirname(this.filename), { recursive: true }, ondir)\n    else ondir(null)\n\n    function ondir (err) {\n      if (err) return req.callback(err)\n      fs.open(self.filename, mode, onopen)\n    }\n\n    function onopen (err, fd) {\n      if (err) return onerror(err)\n\n      self.fd = fd\n\n      if (!self._lock || !fsext) return onlock(null)\n\n      // Should we aquire a read lock?\n      const shared = self.mode === RDONLY\n\n      if (fsext.tryLock(self.fd, { shared })) onlock(null)\n      else onlock(createLockError(self.filename))\n    }\n\n    function onlock (err) {\n      if (err) return onerrorafteropen(err)\n\n      if (!self._sparse || !fsext || self.mode === RDONLY) return onsparse(null)\n\n      fsext.sparse(self.fd).then(onsparse, onsparse)\n    }\n\n    function onsparse (err) {\n      if (err) return onerrorafteropen(err)\n\n      if (self._size < 0) return ontruncate(null)\n\n      fs.ftruncate(self.fd, self._size, ontruncate)\n    }\n\n    function ontruncate (err) {\n      if (err) return onerrorafteropen(err)\n      if (self._pool !== null) self._pool._onactive(self)\n      req.callback(null)\n    }\n\n    function onerror (err) {\n      req.callback(err)\n    }\n\n    function onerrorafteropen (err) {\n      fs.close(self.fd, function () {\n        self.fd = 0\n        onerror(err)\n      })\n    }\n  }\n\n  _write (req) {\n    const data = req.data\n    const fd = this.fd\n\n    fs.write(fd, data, 0, req.size, req.offset, onwrite)\n\n    function onwrite (err, wrote) {\n      if (err) return req.callback(err)\n\n      req.size -= wrote\n      req.offset += wrote\n\n      if (!req.size) return req.callback(null)\n      fs.write(fd, data, data.length - req.size, req.size, req.offset, onwrite)\n    }\n  }\n\n  _read (req) {\n    const self = this\n    const data = req.data || this._alloc(req.size)\n    const fd = this.fd\n\n    if (!req.size) return process.nextTick(readEmpty, req)\n    fs.read(fd, data, 0, req.size, req.offset, onread)\n\n    function onread (err, read) {\n      if (err) return req.callback(err)\n      if (!read) return req.callback(createReadError(self.filename, req.offset, req.size))\n\n      req.size -= read\n      req.offset += read\n\n      if (!req.size) return req.callback(null, data)\n      fs.read(fd, data, data.length - req.size, req.size, req.offset, onread)\n    }\n  }\n\n  _del (req) {\n    if (req.size === Infinity) return this._truncate(req) // TODO: remove this when all callsites use truncate\n\n    if (!fsext) return req.callback(null)\n\n    fsext.trim(this.fd, req.offset, req.size).then(ontrim, ontrim)\n\n    function ontrim (err) {\n      req.callback(err)\n    }\n  }\n\n  _truncate (req) {\n    fs.ftruncate(this.fd, req.offset, ontruncate)\n\n    function ontruncate (err) {\n      req.callback(err)\n    }\n  }\n\n  _stat (req) {\n    fs.fstat(this.fd, onstat)\n\n    function onstat (err, st) {\n      req.callback(err, st)\n    }\n  }\n\n  _close (req) {\n    const self = this\n\n    fs.close(this.fd, onclose)\n\n    function onclose (err) {\n      if (err) return req.callback(err)\n      if (self._pool !== null) self._pool._oninactive(self)\n      self.fd = 0\n      req.callback(null)\n    }\n  }\n\n  _unlink (req) {\n    const self = this\n\n    const root = this.directory && path.resolve(path.join(this.directory, '.'))\n    let dir = path.resolve(path.dirname(this.filename))\n\n    fs.unlink(this.filename, onunlink)\n\n    function onunlink (err) {\n      // if the file isn't there, its already unlinked, ignore\n      if (err && err.code === 'ENOENT') err = null\n\n      if (err || !self._rmdir || !root || dir === root) return req.callback(err)\n      fs.rmdir(dir, onrmdir)\n    }\n\n    function onrmdir (err) {\n      dir = path.join(dir, '..')\n      if (err || dir === root) return req.callback(null)\n      fs.rmdir(dir, onrmdir)\n    }\n  }\n}\n\nfunction readEmpty (req) {\n  req.callback(null, Buffer.alloc(0))\n}\n\nfunction createLockError (path) {\n  const err = new Error('ELOCKED: File is locked')\n  err.code = 'ELOCKED'\n  err.path = path\n  return err\n}\n\nfunction createReadError (path, offset, size) {\n  const err = new Error('EPARTIALREAD: Could not satisfy length')\n  err.code = 'EPARTIALREAD'\n  err.path = path\n  err.offset = offset\n  err.size = size\n  return err\n}\n{\n  \"name\": \"random-access-file\",\n  \"version\": \"4.1.2\",\n  \"description\": \"Continuous reading or writing to a file using random offsets and lengths\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"browser\": \"./browser.js\",\n  \"files\": [\n    \"index.js\",\n    \"browser.js\"\n  ],\n  \"imports\": {\n    \"fs\": {\n      \"bare\": \"bare-fs\",\n      \"default\": \"fs\"\n    },\n    \"path\": {\n      \"bare\": \"bare-path\",\n      \"default\": \"path\"\n    }\n  },\n  \"dependencies\": {\n    \"bare-fs\": \"^4.0.1\",\n    \"bare-path\": \"^3.0.0\",\n    \"random-access-storage\": \"^3.0.0\"\n  },\n  \"optionalDependencies\": {\n    \"fs-native-extensions\": \"^1.3.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.0\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/random-access-storage/random-access-file.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/random-access-storage/random-access-file/issues\"\n  },\n  \"homepage\": \"https://github.com/random-access-storage/random-access-file\"\n}\nconst EventEmitter = require('events')\nconst queueTick = require('queue-tick')\n\nconst NOT_READABLE = defaultImpl(new Error('Not readable'))\nconst NOT_WRITABLE = defaultImpl(new Error('Not writable'))\nconst NOT_DELETABLE = defaultImpl(new Error('Not deletable'))\nconst NOT_STATABLE = defaultImpl(new Error('Not statable'))\n\nconst DEFAULT_OPEN = defaultImpl(null)\nconst DEFAULT_CLOSE = defaultImpl(null)\nconst DEFAULT_UNLINK = defaultImpl(null)\n\n// NON_BLOCKING_OPS\nconst READ_OP = 0\nconst WRITE_OP = 1\nconst DEL_OP = 2\nconst TRUNCATE_OP = 3\nconst STAT_OP = 4\n\n// BLOCKING_OPS\nconst OPEN_OP = 5\nconst SUSPEND_OP = 6\nconst CLOSE_OP = 7\nconst UNLINK_OP = 8\n\nmodule.exports = class RandomAccessStorage extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._queued = []\n    this._pending = 0\n    this._needsOpen = true\n\n    this.opened = false\n    this.suspended = false\n    this.closed = false\n    this.unlinked = false\n    this.writing = false\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.read) this._read = opts.read\n      if (opts.write) this._write = opts.write\n      if (opts.del) this._del = opts.del\n      if (opts.truncate) this._truncate = opts.truncate\n      if (opts.stat) this._stat = opts.stat\n      if (opts.suspend) this._suspend = opts.suspend\n      if (opts.close) this._close = opts.close\n      if (opts.unlink) this._unlink = opts.unlink\n    }\n\n    this.readable = this._read !== RandomAccessStorage.prototype._read\n    this.writable = this._write !== RandomAccessStorage.prototype._write\n    this.deletable = this._del !== RandomAccessStorage.prototype._del\n    this.truncatable = this._truncate !== RandomAccessStorage.prototype._truncate || this.deletable\n    this.statable = this._stat !== RandomAccessStorage.prototype._stat\n  }\n\n  read (offset, size, cb) {\n    this.run(new Request(this, READ_OP, offset, size, null, cb), false)\n  }\n\n  _read (req) {\n    return NOT_READABLE(req)\n  }\n\n  write (offset, data, cb) {\n    if (!cb) cb = noop\n    this.run(new Request(this, WRITE_OP, offset, data.length, data, cb), true)\n  }\n\n  _write (req) {\n    return NOT_WRITABLE(req)\n  }\n\n  del (offset, size, cb) {\n    if (!cb) cb = noop\n    this.run(new Request(this, DEL_OP, offset, size, null, cb), true)\n  }\n\n  _del (req) {\n    return NOT_DELETABLE(req)\n  }\n\n  truncate (offset, cb) {\n    if (!cb) cb = noop\n    this.run(new Request(this, TRUNCATE_OP, offset, 0, null, cb), true)\n  }\n\n  _truncate (req) {\n    req.size = Infinity\n    this._del(req)\n  }\n\n  stat (cb) {\n    this.run(new Request(this, STAT_OP, 0, 0, null, cb), false)\n  }\n\n  _stat (req) {\n    return NOT_STATABLE(req)\n  }\n\n  open (cb) {\n    if (!cb) cb = noop\n    if (this.opened && !this._needsOpen) return nextTickCallback(cb)\n    this._needsOpen = false\n    queueAndRun(this, new Request(this, OPEN_OP, 0, 0, null, cb))\n  }\n\n  _open (req) {\n    return DEFAULT_OPEN(req)\n  }\n\n  suspend (cb) {\n    if (!cb) cb = noop\n    if (this.closed || this.suspended) return nextTickCallback(cb)\n    this._needsOpen = true\n    queueAndRun(this, new Request(this, SUSPEND_OP, 0, 0, null, cb))\n  }\n\n  _suspend (req) {\n    this._close(req)\n  }\n\n  close (cb) {\n    if (!cb) cb = noop\n    if (this.closed) return nextTickCallback(cb)\n    queueAndRun(this, new Request(this, CLOSE_OP, 0, 0, null, cb))\n  }\n\n  _close (req) {\n    return DEFAULT_CLOSE(req)\n  }\n\n  unlink (cb) {\n    if (!cb) cb = noop\n    if (!this.closed) this.close(noop)\n    queueAndRun(this, new Request(this, UNLINK_OP, 0, 0, null, cb))\n  }\n\n  _unlink (req) {\n    return DEFAULT_UNLINK(req)\n  }\n\n  run (req, writing) {\n    if (writing && !this.writing) {\n      this.writing = true\n      this._needsOpen = true\n    }\n\n    if (this._needsOpen) this.open(noop)\n    if (this._queued.length) this._queued.push(req)\n    else req._run()\n  }\n}\n\nclass Request {\n  constructor (self, type, offset, size, data, cb) {\n    this.type = type\n    this.offset = offset\n    this.size = size\n    this.data = data\n    this.storage = self\n\n    this._sync = false\n    this._callback = cb\n    this._openError = null\n  }\n\n  _maybeOpenError (err) {\n    if (this.type !== OPEN_OP) return\n    const queued = this.storage._queued\n    for (let i = 1; i < queued.length; i++) {\n      const q = queued[i]\n      if (q.type === OPEN_OP) break\n      q._openError = err\n    }\n  }\n\n  _unqueue (err) {\n    const ra = this.storage\n    const queued = ra._queued\n\n    if (err) {\n      this._maybeOpenError(err)\n    } else if (this.type > 4) {\n      switch (this.type) {\n        case OPEN_OP:\n          if (ra.suspended) {\n            ra.suspended = false\n            ra.emit('unsuspend')\n          }\n          if (!ra.opened) {\n            ra.opened = true\n            ra.emit('open')\n          }\n          break\n\n        case SUSPEND_OP:\n          if (!ra.suspended) {\n            ra.suspended = true\n            ra.emit('suspend')\n          }\n          break\n\n        case CLOSE_OP:\n          if (!ra.closed) {\n            ra.closed = true\n            ra.emit('close')\n          }\n          break\n\n        case UNLINK_OP:\n          if (!ra.unlinked) {\n            ra.unlinked = true\n            ra.emit('unlink')\n          }\n          break\n      }\n    }\n\n    if (queued.length && queued[0] === this) queued.shift()\n\n    if (!--ra._pending) drainQueue(ra)\n  }\n\n  callback (err, val) {\n    if (this._sync) return nextTick(this, err, val)\n    this._unqueue(err)\n    this._callback(err, val)\n  }\n\n  _openAndNotClosed () {\n    const ra = this.storage\n    if (ra.opened && !ra.closed && !ra.suspended) return true\n    if (!ra.opened || ra.suspended) nextTick(this, this._openError || new Error('Not opened'))\n    else if (ra.closed) nextTick(this, new Error('Closed'))\n    return false\n  }\n\n  _open () {\n    const ra = this.storage\n\n    if (ra.opened && !ra.suspended) return nextTick(this, null)\n    if (ra.closed) return nextTick(this, new Error('Closed'))\n\n    ra._open(this)\n  }\n\n  _run () {\n    const ra = this.storage\n    ra._pending++\n\n    this._sync = true\n\n    switch (this.type) {\n      case READ_OP:\n        if (this._openAndNotClosed()) ra._read(this)\n        break\n\n      case WRITE_OP:\n        if (this._openAndNotClosed()) ra._write(this)\n        break\n\n      case DEL_OP:\n        if (this._openAndNotClosed()) ra._del(this)\n        break\n\n      case TRUNCATE_OP:\n        if (this._openAndNotClosed()) ra._truncate(this)\n        break\n\n      case STAT_OP:\n        if (this._openAndNotClosed()) ra._stat(this)\n        break\n\n      case OPEN_OP:\n        this._open()\n        break\n\n      case SUSPEND_OP:\n        if (ra.closed || !ra.opened || ra.suspended) nextTick(this, null)\n        else ra._suspend(this)\n        break\n\n      case CLOSE_OP:\n        if (ra.closed || !ra.opened || ra.suspended) nextTick(this, null)\n        else ra._close(this)\n        break\n\n      case UNLINK_OP:\n        if (ra.unlinked) nextTick(this, null)\n        else ra._unlink(this)\n        break\n    }\n\n    this._sync = false\n  }\n}\n\nfunction queueAndRun (self, req) {\n  self._queued.push(req)\n  if (!self._pending) req._run()\n}\n\nfunction drainQueue (self) {\n  const queued = self._queued\n\n  while (queued.length > 0) {\n    const blocking = queued[0].type > 4\n    if (!blocking || !self._pending) queued[0]._run()\n    if (blocking) return\n    queued.shift()\n  }\n}\n\nfunction defaultImpl (err) {\n  return overridable\n\n  function overridable (req) {\n    nextTick(req, err)\n  }\n}\n\nfunction nextTick (req, err, val) {\n  queueTick(() => req.callback(err, val))\n}\n\nfunction nextTickCallback (cb) {\n  queueTick(() => cb(null))\n}\n\nfunction noop () {}\n{\n  \"name\": \"random-access-storage\",\n  \"version\": \"3.0.2\",\n  \"description\": \"Easily make random-access-storage instances\",\n  \"main\": \"index.js\",\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"bare-events\": \"^2.2.0\",\n    \"queue-tick\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.0\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/random-access-storage/random-access-storage.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/random-access-storage/random-access-storage/issues\"\n  },\n  \"homepage\": \"https://github.com/random-access-storage/random-access-storage\"\n}\nmodule.exports = class RandomArrayIterator {\n  constructor (values) {\n    this.values = values\n    this.start = 0\n    this.length = this.values.length\n  }\n\n  next () {\n    if (this.length === 0) {\n      if (this.start === 0) return { done: true, value: undefined }\n      this.length = this.start\n      this.start = 0\n    }\n\n    const i = this.start + ((Math.random() * this.length) | 0)\n    const j = this.start + --this.length\n    const value = this.values[i]\n\n    this.values[i] = this.values[j]\n    this.values[j] = value\n\n    return { done: false, value }\n  }\n\n  dequeue () {\n    this.values[this.start + this.length] = this.values[this.values.length - 1]\n    this.values.pop()\n  }\n\n  requeue () {\n    const i = this.start + this.length\n    const value = this.values[i]\n    this.values[i] = this.values[this.start]\n    this.values[this.start++] = value\n  }\n\n  restart () {\n    this.start = 0\n    this.length = this.values.length\n    return this\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n}\n{\n  \"name\": \"random-array-iterator\",\n  \"version\": \"1.0.0\",\n  \"description\": \"An iterator to iterate an array in random order with controls to requeue or dequeue elements during the iteration\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^16.0.3\",\n    \"tape\": \"^5.0.1\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/random-array-iterator.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/random-array-iterator/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/random-array-iterator\"\n}\n/*!\n * range-parser\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = rangeParser\n\n/**\n * Parse \"Range\" header `str` relative to the given file `size`.\n *\n * @param {Number} size\n * @param {String} str\n * @param {Object} [options]\n * @return {Array}\n * @public\n */\n\nfunction rangeParser (size, str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string')\n  }\n\n  var index = str.indexOf('=')\n\n  if (index === -1) {\n    return -2\n  }\n\n  // split the range string\n  var arr = str.slice(index + 1).split(',')\n  var ranges = []\n\n  // add ranges type\n  ranges.type = str.slice(0, index)\n\n  // parse all ranges\n  for (var i = 0; i < arr.length; i++) {\n    var range = arr[i].split('-')\n    var start = parseInt(range[0], 10)\n    var end = parseInt(range[1], 10)\n\n    // -nnn\n    if (isNaN(start)) {\n      start = size - end\n      end = size - 1\n    // nnn-\n    } else if (isNaN(end)) {\n      end = size - 1\n    }\n\n    // limit last-byte-pos to current length\n    if (end > size - 1) {\n      end = size - 1\n    }\n\n    // invalid or unsatisifiable\n    if (isNaN(start) || isNaN(end) || start > end || start < 0) {\n      continue\n    }\n\n    // add range\n    ranges.push({\n      start: start,\n      end: end\n    })\n  }\n\n  if (ranges.length < 1) {\n    // unsatisifiable\n    return -1\n  }\n\n  return options && options.combine\n    ? combineRanges(ranges)\n    : ranges\n}\n\n/**\n * Combine overlapping & adjacent ranges.\n * @private\n */\n\nfunction combineRanges (ranges) {\n  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)\n\n  for (var j = 0, i = 1; i < ordered.length; i++) {\n    var range = ordered[i]\n    var current = ordered[j]\n\n    if (range.start > current.end + 1) {\n      // next range\n      ordered[++j] = range\n    } else if (range.end > current.end) {\n      // extend range\n      current.end = range.end\n      current.index = Math.min(current.index, range.index)\n    }\n  }\n\n  // trim ordered array\n  ordered.length = j + 1\n\n  // generate combined range\n  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)\n\n  // copy ranges type\n  combined.type = ranges.type\n\n  return combined\n}\n\n/**\n * Map function to add index value to ranges.\n * @private\n */\n\nfunction mapWithIndex (range, index) {\n  return {\n    start: range.start,\n    end: range.end,\n    index: index\n  }\n}\n\n/**\n * Map function to remove index value from ranges.\n * @private\n */\n\nfunction mapWithoutIndex (range) {\n  return {\n    start: range.start,\n    end: range.end\n  }\n}\n\n/**\n * Sort function to sort ranges by index.\n * @private\n */\n\nfunction sortByRangeIndex (a, b) {\n  return a.index - b.index\n}\n\n/**\n * Sort function to sort ranges by start position.\n * @private\n */\n\nfunction sortByRangeStart (a, b) {\n  return a.start - b.start\n}\n{\n  \"name\": \"range-parser\",\n  \"author\": \"TJ Holowaychuk <tj@vision-media.ca> (http://tjholowaychuk.com)\",\n  \"description\": \"Range header field string parser\",\n  \"version\": \"1.2.1\",\n  \"contributors\": [\n    \"Douglas Christopher Wilson <doug@somethingdoug.com>\",\n    \"James Wyatt Cready <wyatt.cready@lanetix.com>\",\n    \"Jonathan Ong <me@jongleberry.com> (http://jongleberry.com)\"\n  ],\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"range\",\n    \"parser\",\n    \"http\"\n  ],\n  \"repository\": \"jshttp/range-parser\",\n  \"devDependencies\": {\n    \"deep-equal\": \"1.0.1\",\n    \"eslint\": \"5.16.0\",\n    \"eslint-config-standard\": \"12.0.0\",\n    \"eslint-plugin-markdown\": \"1.0.0\",\n    \"eslint-plugin-import\": \"2.17.2\",\n    \"eslint-plugin-node\": \"8.0.1\",\n    \"eslint-plugin-promise\": \"4.1.1\",\n    \"eslint-plugin-standard\": \"4.0.0\",\n    \"mocha\": \"6.1.4\",\n    \"nyc\": \"14.1.1\"\n  },\n  \"files\": [\n    \"HISTORY.md\",\n    \"LICENSE\",\n    \"index.js\"\n  ],\n  \"engines\": {\n    \"node\": \">= 0.6\"\n  },\n  \"scripts\": {\n    \"lint\": \"eslint --plugin markdown --ext js,md .\",\n    \"test\": \"mocha --reporter spec\",\n    \"test-cov\": \"nyc --reporter=html --reporter=text npm test\",\n    \"test-travis\": \"nyc --reporter=text npm test\"\n  }\n}\nclass WriteLock {\n  constructor (parent) {\n    this.writing = false\n\n    this._waiting = []\n    this._parent = parent\n    this._wait = pushToQueue.bind(this, this._waiting)\n  }\n\n  get locked () {\n    return this.writing || this._parent.read.readers > 0\n  }\n\n  get waiting () {\n    return this._waiting.length\n  }\n\n  lock () {\n    if (this._parent._destroying) {\n      return Promise.reject(this._parent._destroyError)\n    }\n\n    if (this.writing === false && this._parent.read.readers === 0) {\n      this.writing = true\n      return Promise.resolve()\n    }\n\n    return new Promise(this._wait)\n  }\n\n  unlock () {\n    this.writing = false\n    this._parent._bump()\n  }\n\n  async flush () {\n    if (this.writing === false) return\n    try {\n      await this.lock()\n    } catch {\n      return\n    }\n    this.unlock()\n  }\n}\n\nclass ReadLock {\n  constructor (parent) {\n    this.readers = 0\n\n    this._waiting = []\n    this._parent = parent\n    this._wait = pushToQueue.bind(this, this._waiting)\n  }\n\n  get locked () {\n    return this._parent.writing\n  }\n\n  get waiting () {\n    return this._waiting.length\n  }\n\n  lock () {\n    if (this._parent._destroying) {\n      return Promise.reject(this._parent._destroyError)\n    }\n\n    if (this._parent.write.writing === false) {\n      this.readers++\n      return Promise.resolve()\n    }\n\n    return new Promise(this._wait)\n  }\n\n  unlock () {\n    this.readers--\n    this._parent._bump()\n  }\n\n  async flush () {\n    if (this.writing === false) return\n    try {\n      await this.lock()\n    } catch {\n      return\n    }\n    this.unlock()\n  }\n}\n\nmodule.exports = class ReadWriteLock {\n  constructor () {\n    this.read = new ReadLock(this)\n    this.write = new WriteLock(this)\n\n    this._destroyError = null\n    this._destroying = null\n  }\n\n  get destroyed () {\n    return !!this._destroying\n  }\n\n  destroy (err) {\n    if (this._destroying) return this._destroying\n\n    this._destroying = Promise.all([this.read.flush(), this.write.flush()])\n    this._destroyError = err || new Error('Mutex has been destroyed')\n\n    if (err) {\n      while (this.read._waiting) this._waiting.shift()[1](err)\n      while (this.write._waiting) this._waiting.shift()[1](err)\n    }\n\n    return this._destroying\n  }\n\n  _bump () {\n    if (this.write.writing === false && this.read.readers === 0 && this.write._waiting.length > 0) {\n      this.write.writing = true\n      this.write._waiting.shift()[0]()\n    }\n    while (this.write.writing === false && this.read._waiting.length > 0) {\n      this.read.readers++\n      this.read._waiting.shift()[0]()\n    }\n  }\n}\n\nfunction pushToQueue (queue, resolve, reject) {\n  queue.push([resolve, reject])\n}\n{\n  \"name\": \"read-write-mutexify\",\n  \"version\": \"2.1.0\",\n  \"description\": \"Like mutexify but with read/write locks\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.0\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/read-write-mutexify.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/read-write-mutexify/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/read-write-mutexify\"\n}\nconst EventEmitter = require('events')\n\nmodule.exports = class ReadyResource extends EventEmitter {\n  constructor () {\n    super()\n\n    this.opening = null\n    this.closing = null\n\n    this.opened = false\n    this.closed = false\n  }\n\n  ready () {\n    if (this.opening !== null) return this.opening\n    this.opening = open(this)\n    return this.opening\n  }\n\n  close () {\n    if (this.closing !== null) return this.closing\n    this.closing = close(this)\n    return this.closing\n  }\n\n  async _open () {\n    // add impl here\n  }\n\n  async _close () {\n    // add impl here\n  }\n}\n\nasync function open (self) {\n  try {\n    await self._open()\n  } catch (err) {\n    self.close() // safe to run in bg\n    throw err\n  }\n\n  self.opened = true\n  self.emit('ready')\n}\n\nasync function close (self) {\n  try {\n    if (self.opened === false && self.opening !== null) await self.opening\n  } catch {\n    // ignore errors on closing\n  }\n  if (self.opened === true || self.opening === null) await self._close()\n  self.closed = true\n  self.emit('close')\n}\n{\n  \"name\": \"ready-resource\",\n  \"version\": \"1.1.1\",\n  \"description\": \"Modern single resource management\",\n  \"main\": \"index.js\",\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.0\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/ready-resource.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/ready-resource/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/ready-resource\",\n  \"dependencies\": {\n    \"bare-events\": \"^2.2.0\"\n  }\n}\nconst b4a = require('b4a')\n\nvar EMPTY = []\n\nmodule.exports = RecordCache\n\nfunction RecordSet () {\n  this.list = []\n  this.map = new Map()\n}\n\nRecordSet.prototype.add = function (record, value) {\n  var k = toString(record)\n  var r = this.map.get(k)\n  if (r) return false\n\n  r = {index: this.list.length, record: value || record}\n  this.list.push(r)\n  this.map.set(k, r)\n  return true\n}\n\nRecordSet.prototype.remove = function (record) {\n  var k = toString(record)\n  var r = this.map.get(k)\n  if (!r) return false\n\n  swap(this.list, r.index, this.list.length - 1)\n  this.list.pop()\n  this.map.delete(k)\n  return true\n}\n\nfunction RecordStore () {\n  this.records = new Map()\n  this.size = 0\n}\n\nRecordStore.prototype.add = function (name, record, value) {\n  var r = this.records.get(name)\n\n  if (!r) {\n    r = new RecordSet()\n    this.records.set(name, r)\n  }\n\n  if (r.add(record, value)) {\n    this.size++\n    return true\n  }\n\n  return false\n}\n\nRecordStore.prototype.remove = function (name, record, value) {\n  var r = this.records.get(name)\n  if (!r) return false\n\n  if (r.remove(record, value)) {\n    this.size--\n    if (!r.map.size) this.records.delete(name)\n    return true\n  }\n\n  return false\n}\n\nRecordStore.prototype.get = function (name) {\n  var r = this.records.get(name)\n  return r ? r.list : EMPTY\n}\n\nfunction RecordCache (opts) {\n  if (!(this instanceof RecordCache)) return new RecordCache(opts)\n  if (!opts) opts = {}\n\n  this.maxSize = opts.maxSize || Infinity\n  this.maxAge = opts.maxAge || 0\n\n  this._onstale = opts.onStale || opts.onstale || null\n  this._fresh = new RecordStore()\n  this._stale = new RecordStore()\n  this._interval = null\n  this._gced = false\n\n  if (this.maxAge && this.maxAge < Infinity) {\n    // 2/3 gives us a span of 0.66-1.33 maxAge or avg maxAge\n    var tick = Math.ceil(2 / 3 * this.maxAge)\n    this._interval = setInterval(this._gcAuto.bind(this), tick)\n    if (this._interval.unref) this._interval.unref()\n  }\n}\n\nObject.defineProperty(RecordCache.prototype, 'size', {\n  get: function () {\n    return this._fresh.size + this._stale.size\n  }\n})\n\nRecordCache.prototype.add = function (name, record, value) {\n  this._stale.remove(name, record, value)\n  if (this._fresh.add(name, record, value) && this._fresh.size > this.maxSize) {\n    this._gc()\n  }\n}\n\nRecordCache.prototype.remove = function (name, record, value) {\n  this._fresh.remove(name, record, value)\n  this._stale.remove(name, record, value)\n}\n\nRecordCache.prototype.get = function (name, n) {\n  var a = this._fresh.get(name)\n  var b = this._stale.get(name)\n  var aLen = a.length\n  var bLen = b.length\n  var len = aLen + bLen\n\n  if (n > len || !n) n = len\n  var result = new Array(n)\n\n  for (var i = 0; i < n; i++) {\n    var j = Math.floor(Math.random() * (aLen + bLen))\n    if (j < aLen) {\n      result[i] = a[j].record\n      swap(a, j, --aLen)\n    } else {\n      j -= aLen\n      result[i] = b[j].record\n      swap(b, j, --bLen)\n    }\n  }\n\n  return result\n}\n\nRecordCache.prototype._gcAuto = function () {\n  if (!this._gced) this._gc()\n  this._gced = false\n}\n\nRecordCache.prototype._gc = function () {\n  if (this._onstale && this._stale.size > 0) this._onstale(this._stale)\n  this._stale = this._fresh\n  this._fresh = new RecordStore()\n  this._gced = true\n}\n\nRecordCache.prototype.clear = function () {\n  this._gc()\n  this._gc()\n}\n\nRecordCache.prototype.destroy = function () {\n  this.clear()\n  clearInterval(this._interval)\n  this._interval = null\n}\n\nfunction toString (record) {\n  return b4a.isBuffer(record) ? b4a.toString(record, 'hex') : record\n}\n\nfunction swap (list, a, b) {\n  var tmp = list[a]\n  tmp.index = b\n  list[b].index = a\n  list[a] = list[b]\n  list[b] = tmp\n}\n{\n  \"name\": \"record-cache\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Cache optimised for record like things\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.3.1\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^10.0.3\",\n    \"tape\": \"^4.8.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/record-cache.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/record-cache/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/record-cache\"\n}\nmodule.exports = safetyCatch\n\nfunction isActuallyUncaught (err) {\n  if (!err) return false\n  return err instanceof TypeError ||\n    err instanceof SyntaxError ||\n    err instanceof ReferenceError ||\n    err instanceof EvalError ||\n    err instanceof RangeError ||\n    err instanceof URIError ||\n    err.code === 'ERR_ASSERTION'\n}\n\nfunction throwErrorNT (err) {\n  queueMicrotask(() => { throw err })\n}\n\nfunction safetyCatch (err) {\n  if (isActuallyUncaught(err)) {\n    throwErrorNT(err)\n    throw err\n  }\n}\n{\n  \"name\": \"safety-catch\",\n  \"version\": \"1.0.2\",\n  \"description\": \"Small module that makes sure your catch, caught an actual error and not a programming mistake or assertion\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/safety-catch.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/safety-catch/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/safety-catch\"\n}\nmodule.exports = sameData\n\nfunction type (o) {\n  const t = typeof o\n\n  return t === 'object'\n    ? Array.isArray(o)\n      ? 'array'\n      : isTypedArray(o)\n        ? (typeof o.equals === 'function') ? 'buffer' : 'array'\n        : (o === null ? 'null' : 'object')\n    : t\n}\n\nfunction isTypedArray (a) {\n  return !!a && typeof a.length === 'number' && ArrayBuffer.isView(a.array)\n}\n\nfunction sameData (a, b) {\n  if (a === b) return true\n\n  const ta = type(a)\n  const tb = type(b)\n\n  if (ta !== tb) return false\n\n  if (ta === 'buffer') return a.equals(b)\n\n  if (ta === 'array') {\n    if (a.length !== b.length) return false\n\n    for (let i = 0; i < a.length; i++) {\n      if (!sameData(a[i], b[i])) return false\n    }\n\n    return true\n  }\n\n  if (ta !== 'object') return false\n\n  const ea = Object.entries(a)\n  const eb = Object.entries(b)\n\n  if (ea.length !== eb.length) return false\n\n  ea.sort(cmp)\n  eb.sort(cmp)\n\n  for (let i = 0; i < ea.length; i++) {\n    if (ea[i][0] !== eb[i][0] || !sameData(ea[i][1], eb[i][1])) return false\n  }\n\n  return true\n}\n\nfunction cmp (a, b) {\n  return a[0] === b[0] ? 0 : a[0] < b[0] ? -1 : 1\n}\n{\n  \"name\": \"same-data\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Deep equal with no deps and only for 'data' objects, ie basic objects, arrays, primitives and typed arrays\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.1\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/same-data.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/same-data/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/same-data\"\n}\nconst http = require('http')\nconst rangeParser = require('range-parser')\nconst getMimeType = require('get-mime-type')\nconst ReadyResource = require('ready-resource')\nconst safetyCatch = require('safety-catch')\nconst { pipelinePromise } = require('streamx')\nconst unixPathResolve = require('unix-path-resolve')\nconst HypercoreId = require('hypercore-id-encoding')\nconst crypto = require('hypercore-crypto')\nconst b4a = require('b4a')\n\nmodule.exports = class ServeDrive extends ReadyResource {\n  constructor (opts = {}) {\n    super()\n\n    this._getDrive = opts.get || nool\n    this._releaseDrive = opts.release || noop\n    this._resuming = null\n    this._token = opts.token !== false\n      ? b4a.isBuffer(opts.token)\n        ? b4a.toString(opts.token, 'hex')\n        : b4a.toString(crypto.randomBytes(32), 'hex')\n      : null\n\n    this.port = typeof opts.port !== 'undefined' ? Number(opts.port) : 49833\n    this.host = typeof opts.host !== 'undefined' ? opts.host : null\n    this.anyPort = opts.anyPort !== false\n\n    this.suspended = false\n    this.connections = new Set()\n    this.server = this._createServer(opts.server || null)\n  }\n\n  async _open () {\n    try {\n      await listen(this.server, this.port, this.host)\n    } catch (err) {\n      if (!this.anyPort) throw err\n      await listen(this.server, 0, this.host)\n    }\n    this.port = this.server.address().port\n  }\n\n  async _close () {\n    if (this._resuming) await this._resuming\n    await this._suspend(true)\n  }\n\n  _suspend (alsoServer) {\n    return new Promise(resolve => {\n      let waiting = 1\n\n      if (alsoServer) {\n        this.server.close(onclose)\n        waiting++\n      }\n      this.server.unref()\n\n      for (const c of this.connections) {\n        waiting++\n        c.on('close', onclose)\n        c.destroy()\n      }\n\n      onclose() // clear the initial one\n\n      function onclose () {\n        if (--waiting === 0) resolve()\n      }\n    })\n  }\n\n  async suspend () {\n    if (this.opened === false) await this.ready()\n    if (this.suspended) return\n    await this._suspend(false) // kill all pending connections, but keep server to try to keep the port...\n    if (this.suspended) return // in case of parallel call for some reason\n    this.suspended = true\n    this.emit('suspend')\n  }\n\n  async resume () {\n    if (!this.suspended || this.closing) return\n    if (this._resuming === null) this._resuming = this._resume()\n    await this._resuming\n    if (!this.suspended) return\n    this.server.ref()\n    this._resuming = null\n    this.suspended = false\n    this.emit('resume')\n  }\n\n  async _resume () {\n    await this._suspend(true)\n    this.server = this._createServer(null)\n    await this._open()\n  }\n\n  address () {\n    return this.opened ? this.server.address() : null\n  }\n\n  getLink (path, opts = {}) {\n    const proto = opts.https ? 'https' : 'http'\n    const host = opts.host || (getHost(this.host) + ':' + this.address().port)\n    const pathname = unixPathResolve('/', path)\n\n    const params = []\n    if (opts.key) params.push('key=' + opts.key)\n    if (opts.version) params.push('version=' + opts.version)\n    if (this._token) params.push('token=' + this._token)\n    const query = params.length ? ('?' + params.join('&')) : ''\n\n    return proto + '://' + host + encodePathName(pathname) + query\n  }\n\n  async _driveToRequest (req, res, key, drive, filename, version) {\n    if (!drive) {\n      res.writeHead(404)\n      res.end()\n      return\n    }\n\n    const snapshot = version ? drive.checkout(version) : drive\n    if (snapshot !== drive) res.on('close', () => snapshot.close().catch(safetyCatch))\n\n    let entry\n    try {\n      entry = await snapshot.entry(filename)\n    } catch (e) {\n      if (this.closing) return\n\n      if (e.code === 'SNAPSHOT_NOT_AVAILABLE') {\n        res.writeHead(404)\n        res.end()\n        return\n      }\n\n      throw e\n    }\n\n    if (this.closing) return\n\n    if (!entry || !entry.value.blob) {\n      res.writeHead(404)\n      res.end()\n      return\n    }\n\n    const contentType = getMimeType(filename)\n    res.setHeader('Content-Type', contentType === false ? 'application/octet-stream' : contentType)\n    res.setHeader('Accept-Ranges', 'bytes')\n\n    let start = 0\n    let length = entry.value.blob.byteLength\n\n    if (req.headers.range) {\n      const ranges = rangeParser(entry.value.blob.byteLength, req.headers.range)\n\n      if (ranges === -1 || ranges === -2) {\n        res.statusCode = 206\n        res.setHeader('Content-Length', 0)\n        res.end()\n        return\n      }\n\n      const range = ranges[0]\n      const byteLength = range.end - range.start + 1\n\n      res.statusCode = 206\n      res.setHeader('Content-Range', 'bytes ' + range.start + '-' + range.end + '/' + entry.value.blob.byteLength)\n      res.setHeader('Content-Length', byteLength)\n\n      start = range.start\n      length = byteLength\n    } else {\n      res.setHeader('Content-Length', entry.value.blob.byteLength)\n    }\n\n    if (req.method === 'HEAD') {\n      res.end()\n      return\n    }\n\n    const rs = snapshot.createReadStream(filename, { start, length })\n    await pipelinePromise(rs, res)\n  }\n\n  _createServer (server) {\n    if (!server) server = http.createServer()\n    server.on('connection', this._onconnection.bind(this))\n    server.on('request', this._onrequest.bind(this))\n    return server\n  }\n\n  _onconnection (socket) {\n    this.connections.add(socket)\n    socket.on('close', () => this.connections.delete(socket))\n  }\n\n  async _onrequest (req, res) {\n    if (req.method !== 'GET' && req.method !== 'HEAD') {\n      res.writeHead(400)\n      res.end()\n      return\n    }\n\n    const { pathname, searchParams } = parseURL(req.url)\n    const filename = decodePathName(pathname)\n    let key = searchParams.get('key') || null\n    const version = parseInt(searchParams.get('version') || 0, 10)\n\n    if (this._token && searchParams.get('token') !== this._token) {\n      res.writeHead(404)\n      res.end()\n      return\n    }\n\n    if (key !== null) {\n      try {\n        key = HypercoreId.decode(key)\n      } catch (err) {\n        safetyCatch(err)\n        res.writeHead(400)\n        res.end()\n        return\n      }\n    }\n\n    if (Number.isNaN(version)) {\n      res.writeHead(400)\n      res.end()\n      return\n    }\n\n    if (req.method !== 'GET' && req.method !== 'HEAD') {\n      res.writeHead(400)\n      res.end()\n      return\n    }\n\n    let drive = null\n    let error = null\n\n    try {\n      drive = await this._getDrive({ key, filename, version })\n\n      if (!this.closing) {\n        await this._driveToRequest(req, res, key, drive, filename, version)\n      }\n    } catch (e) {\n      safetyCatch(e)\n      error = e\n    }\n\n    try {\n      if (drive !== null) await this._releaseDrive({ key, drive })\n    } catch (e) {\n      safetyCatch(e)\n      // Can technically overwrite the prev error, but we are ok with that as these\n      // are for simple reporting anyway and this is the important one.\n      error = e\n    }\n\n    if (this.closing || error === null) return\n\n    if (!res.headersSent) {\n      res.writeHead(500)\n      res.end()\n    }\n\n    this.emit('request-error', error)\n  }\n}\n\nfunction listen (server, port, address) {\n  return new Promise((resolve, reject) => {\n    server.on('listening', done)\n    server.on('error', done)\n\n    if (address) server.listen(port, address)\n    else server.listen(port)\n\n    function done (err) {\n      server.off('listening', done)\n      server.off('error', done)\n\n      if (err) reject(err)\n      else resolve()\n    }\n  })\n}\n\nfunction nool () { return null }\nfunction noop () {}\n\nfunction getHost (address) {\n  if (!address || address === '::' || address === '0.0.0.0') return 'localhost'\n  return address\n}\n\nfunction parseURL (url) {\n  const [pathname, query] = url.split('?')\n  const queryParams = (query || '').split('&')\n  const searchParams = new Map()\n\n  for (const params of queryParams) {\n    if (!params) continue\n\n    const [key, value] = params.split('=')\n    searchParams.set(key, value || null)\n  }\n\n  return { pathname, searchParams }\n}\n\nfunction encodePathName (pathname) {\n  return pathname.split('/').map(encodeURIComponent).join('/')\n}\n\nfunction decodePathName (pathname) {\n  return pathname.split('/').map(decodeURIComponent).join('/')\n}\nmodule.exports = require.addon()\nconst binding = require('./binding')\n\nfunction onlookup(err, addresses) {\n  const req = this\n\n  if (err) return req.cb(err, null, 0)\n\n  const { address, family } = addresses[0]\n\n  return req.cb(null, address, family)\n}\n\nfunction onlookupall(err, addresses) {\n  const req = this\n\n  if (err) return req.cb(err, null)\n\n  return req.cb(null, addresses)\n}\n\nexports.lookup = function lookup(hostname, opts = {}, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  let { family = 0, all = false } = opts\n\n  if (typeof family === 'string') {\n    switch (family) {\n      case 'IPv4':\n        family = 4\n        break\n      case 'IPv6':\n        family = 6\n        break\n      default:\n        family = 0\n    }\n  }\n\n  const req = {\n    cb,\n    handle: null\n  }\n\n  req.handle = binding.lookup(\n    hostname,\n    family || 0,\n    all,\n    req,\n    all ? onlookupall : onlookup\n  )\n}\n{\n  \"name\": \"bare-dns\",\n  \"version\": \"2.0.4\",\n  \"description\": \"Domain name resolution for JavaScript\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./package\": \"./package.json\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-dns.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-dns/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-dns\",\n  \"engines\": {\n    \"bare\": \">=1.7.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nexports.IncomingMessage = require('./lib/incoming-message')\nexports.OutgoingMessage = require('./lib/outgoing-message')\n\nexports.Agent = require('./lib/agent')\nexports.globalAgent = exports.Agent.global\n\nexports.Server = require('./lib/server')\nexports.ServerResponse = require('./lib/server-response')\nexports.ServerConnection = require('./lib/server-connection')\n\nexports.ClientRequest = require('./lib/client-request')\nexports.ClientConnection = require('./lib/client-connection')\n\nexports.constants = require('./lib/constants')\n\nexports.STATUS_CODES = exports.constants.status // For Node.js compatibility\n\nexports.createServer = function createServer(opts, onrequest) {\n  return new exports.Server(opts, onrequest)\n}\n\nexports.request = function request(url, opts, onresponse) {\n  if (typeof opts === 'function') {\n    onresponse = opts\n    opts = {}\n  }\n\n  if (typeof url === 'string') url = new URL(url)\n\n  if (isURL(url)) {\n    opts = opts ? { ...opts } : {}\n\n    opts.host = url.hostname\n    opts.path = url.pathname + url.search\n    opts.port = url.port ? parseInt(url.port, 10) : defaultPort(url)\n  } else {\n    opts = url ? { ...url } : {}\n\n    // For Node.js compatibility\n    opts.host = opts.hostname || opts.host\n    opts.port =\n      typeof opts.port === 'string' ? parseInt(opts.port, 10) : opts.port\n  }\n\n  return new exports.ClientRequest(opts, onresponse)\n}\n\n// https://url.spec.whatwg.org/#default-port\nfunction defaultPort(url) {\n  switch (url.protocol) {\n    case 'ftp:':\n      return 21\n    case 'http:':\n    case 'ws:':\n      return 80\n    case 'https:':\n    case 'wss:':\n      return 443\n  }\n\n  return null\n}\n\n// https://url.spec.whatwg.org/#api\nfunction isURL(url) {\n  return (\n    url !== null &&\n    typeof url === 'object' &&\n    typeof url.protocol === 'string' &&\n    typeof url.hostname === 'string' &&\n    typeof url.pathname === 'string' &&\n    typeof url.search === 'string'\n  )\n}\nconst tcp = require('bare-tcp')\nconst HTTPClientConnection = require('./client-connection')\n\nmodule.exports = class HTTPAgent {\n  constructor(opts = {}) {\n    const { keepAlive = false, keepAliveMsecs = 1000 } = opts\n\n    this._sockets = new Map()\n    this._freeSockets = new Map()\n\n    this._keepAlive =\n      typeof keepAlive === 'number'\n        ? keepAlive\n        : keepAlive\n          ? keepAliveMsecs\n          : -1\n\n    this._opts = { ...opts }\n  }\n\n  createConnection(opts) {\n    return tcp.createConnection(opts)\n  }\n\n  reuseSocket(socket, req) {\n    socket.ref()\n  }\n\n  keepSocketAlive(socket) {\n    if (this._keepAlive === -1) return false\n\n    socket.setKeepAlive(true, this._keepAlive)\n    socket.unref()\n\n    return true\n  }\n\n  getName(opts) {\n    return `${opts.host}:${opts.port}`\n  }\n\n  addRequest(req, opts) {\n    opts = { ...opts, ...this._opts }\n\n    const name = this.getName(opts)\n\n    let socket\n\n    if (this._freeSockets.has(name)) {\n      const sockets = this._freeSockets.get(name)\n      socket = sockets.values().next().value\n      sockets.delete(socket)\n      if (sockets.size === 0) this._freeSockets.delete(name)\n\n      this.reuseSocket(socket, req)\n    } else {\n      socket = this.createConnection(opts)\n\n      socket\n        .on('free', () => this._onfree(socket, name))\n        .on('close', () => this._onremove(socket, name))\n        .on('timeout', () => this._ontimeout(socket, name))\n    }\n\n    let sockets = this._sockets.get(name)\n    if (sockets === undefined) {\n      sockets = new Set()\n      this._sockets.set(name, sockets)\n    }\n\n    sockets.add(socket)\n\n    req.socket = socket\n\n    const connection = HTTPClientConnection.from(socket, opts)\n\n    connection.req = req\n  }\n\n  destroy() {\n    for (const set of [this._sockets, this._freeSockets]) {\n      for (const [, sockets] of set) {\n        for (const socket of sockets) socket.destroy()\n      }\n    }\n  }\n\n  _onfree(socket, name) {\n    if (this.keepSocketAlive(socket)) {\n      this._onremove(socket, name, false)\n\n      let sockets = this._freeSockets.get(name)\n      if (sockets === undefined) {\n        sockets = new Set()\n        this._freeSockets.set(name, sockets)\n      }\n\n      sockets.add(socket)\n    } else {\n      socket.end()\n    }\n  }\n\n  _onremove(socket, name, all = true) {\n    for (const set of all\n      ? [this._sockets, this._freeSockets]\n      : [this._sockets]) {\n      const sockets = set.get(name)\n      if (sockets === undefined) continue\n\n      sockets.delete(socket)\n      if (sockets.size === 0) set.delete(name)\n    }\n  }\n\n  _ontimeout(socket, name) {\n    const sockets = this._freeSockets.get(name)\n    if (!sockets) return\n\n    if (sockets.delete(socket)) socket.destroy()\n    if (sockets.size === 0) this._freeSockets.delete(name)\n  }\n\n  static global = new this({ keepAlive: 1000, timeout: 5000 })\n}\nconst HTTPIncomingMessage = require('./incoming-message')\nconst constants = require('./constants')\nconst errors = require('./errors')\n\nconst empty = Buffer.alloc(0)\n\nmodule.exports = class HTTPClientConnection {\n  static _connections = new WeakMap()\n\n  static for(socket) {\n    return this._connections.get(socket) || null\n  }\n\n  static from(socket, opts) {\n    return this.for(socket) || new this(socket, opts)\n  }\n\n  constructor(socket, opts = {}) {\n    const { IncomingMessage = HTTPIncomingMessage } = opts\n\n    this.socket = socket\n\n    this.req = null\n    this.res = null\n\n    this._IncomingMessage = IncomingMessage\n\n    this._state = constants.state.BEFORE_HEAD\n    this._length = -1\n    this._read = 0\n    this._buffer = null\n    this._idle = true\n\n    this._onerror = this._onerror.bind(this)\n    this._onclose = this._onclose.bind(this)\n    this._onend = this._onend.bind(this)\n    this._ondata = this._ondata.bind(this)\n    this._ondrain = this._ondrain.bind(this)\n    this._ontimeout = this._ontimeout.bind(this)\n\n    socket\n      .on('error', this._onerror)\n      .on('close', this._onclose)\n      .on('end', this._onend)\n      .on('data', this._ondata)\n      .on('drain', this._ondrain)\n      .on('timeout', this._ontimeout)\n\n    HTTPClientConnection._connections.set(socket, this)\n  }\n\n  get idle() {\n    return this._idle\n  }\n\n  _onerror(err) {\n    if (this.req) this.req.destroy(err)\n  }\n\n  _onclose() {\n    if (this.req) this.req._continueFinal()\n  }\n\n  _onend() {\n    if (this.req) this.req.destroy(errors.CONNECTION_LOST())\n  }\n\n  _ondata(data) {\n    this._idle = false\n\n    if (this._state === constants.state.IN_BODY) return this._onbody(data)\n\n    if (this._buffer !== null) {\n      this._buffer = Buffer.concat([this._buffer, data])\n    } else {\n      this._buffer = data\n    }\n\n    let hits = 0\n\n    for (let i = 0; i < this._buffer.byteLength; i++) {\n      const b = this._buffer[i]\n\n      if (hits === 0 && b === 13) {\n        hits++\n      } else if (hits === 1 && b === 10) {\n        hits++\n\n        if (this._state === constants.state.BEFORE_CHUNK) {\n          const head = this._buffer.subarray(0, i - 1)\n          this._buffer =\n            i + 1 === this._buffer.byteLength\n              ? null\n              : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onchunklength(head)\n\n          if (this._buffer === null) break\n        } else if (this._state === constants.state.IN_CHUNK) {\n          const chunk = this._buffer.subarray(0, i - 1)\n\n          if (chunk.byteLength !== this._length) {\n            hits = 0\n            continue\n          }\n\n          this._buffer =\n            i + 1 === this._buffer.byteLength\n              ? null\n              : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onchunk(chunk)\n\n          if (this._buffer === null) break\n        }\n      } else if (hits === 2 && b === 13) {\n        hits++\n      } else if (hits === 3 && b === 10) {\n        if (this._state === constants.state.BEFORE_HEAD) {\n          const head = this._buffer.subarray(0, i - 3)\n          this._buffer =\n            i + 1 === this._buffer.byteLength\n              ? null\n              : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onhead(head)\n\n          if (this._buffer === null) break\n        }\n      } else {\n        hits = 0\n      }\n    }\n  }\n\n  _onhead(data) {\n    this._state = constants.state.IN_HEAD\n\n    const r = data.toString().split('\\r\\n')\n    if (r.length === 0) return this.socket.destroy()\n\n    const [, statusCode, ...statusMessage] = r[0].split(' ')\n    if (!statusCode || !statusMessage) return this.socket.destroy()\n\n    const headers = {}\n\n    for (let i = 1; i < r.length; i++) {\n      const [name, value] = r[i].split(': ')\n      headers[name.toLowerCase()] = value\n    }\n\n    this.req.on('close', () => {\n      this.req = null\n    })\n\n    this.res = new this._IncomingMessage(this.socket, headers, {\n      statusCode: parseInt(statusCode, 10),\n      statusMessage: statusMessage.join(' ')\n    })\n\n    this.res.on('close', () => {\n      this.res = null\n      this._onreset()\n    })\n\n    if (headers.connection && headers.connection.toLowerCase() === 'upgrade') {\n      const head = this._buffer\n      this._buffer = null\n      return this._onupgrade(head)\n    }\n\n    this.req.emit('response', this.res)\n\n    if (headers['transfer-encoding'] === 'chunked') {\n      this._state = constants.state.BEFORE_CHUNK\n    } else {\n      this._length = parseInt(headers['content-length'], 10) || 0\n\n      if (this._length === 0) return this._onfinished()\n\n      this._state = constants.state.IN_BODY\n\n      if (this._buffer) {\n        const body = this._buffer\n        this._buffer = null\n        this._onbody(body)\n      }\n    }\n  }\n\n  _onchunklength(data) {\n    this._length = parseInt(data.toString(), 16)\n\n    if (this._length === 0) this._onfinished()\n    else this._state = constants.state.IN_CHUNK\n  }\n\n  _onchunk(data) {\n    this._read += data.byteLength\n\n    this.res.push(data)\n\n    this._state = constants.state.BEFORE_CHUNK\n  }\n\n  _onbody(data) {\n    this._read += data.byteLength\n\n    this.res.push(data)\n\n    if (this._read === this._length) this._onfinished()\n  }\n\n  _onupgrade(head) {\n    this._ondetach()\n\n    const req = this.req\n\n    req.upgrade = true\n    req.destroy()\n\n    if (req.emit('upgrade', this.res, this.socket, head || empty)) return\n\n    this.socket.destroy()\n  }\n\n  _ontimeout() {\n    if (this.req) this.req.emit('timeout')\n  }\n\n  _onfinished() {\n    if (this.res) this.res.push(null)\n    if (this.req) this.req._continueFinal()\n  }\n\n  _onreset() {\n    this._state = constants.state.BEFORE_HEAD\n    this._length = -1\n    this._read = 0\n    this._buffer = null\n    this._idle = true\n\n    this.socket.emit('free')\n  }\n\n  _ondrain() {\n    if (this.req) this.req._continueWrite()\n  }\n\n  _ondetach() {\n    this.socket\n      .off('error', this._onerror)\n      .off('close', this._onclose)\n      .off('end', this._onend)\n      .off('data', this._ondata)\n      .off('drain', this._ondrain)\n      .off('timeout', this._ontimeout)\n\n    HTTPClientConnection._connections.delete(this.socket)\n  }\n}\nconst HTTPAgent = require('./agent')\nconst HTTPOutgoingMessage = require('./outgoing-message')\n\nmodule.exports = class HTTPClientRequest extends HTTPOutgoingMessage {\n  constructor(opts = {}, onresponse = null) {\n    if (typeof opts === 'function') {\n      onresponse = opts\n      opts = {}\n    }\n\n    opts = opts ? { ...opts } : {}\n\n    const agent =\n      opts.agent === false ? new HTTPAgent() : opts.agent || HTTPAgent.global\n    const method = opts.method || 'GET'\n    const path = opts.path || '/'\n    const host = (opts.host = opts.host || 'localhost')\n    const port = (opts.port = opts.port || 80)\n\n    super()\n\n    agent.addRequest(this, opts)\n\n    this.method = method\n    this.path = path\n    this.headers = { host: host + ':' + port, ...opts.headers }\n\n    this._chunked = method !== 'GET' && method !== 'HEAD'\n\n    this._pendingFinal = null\n\n    if (onresponse) this.once('response', onresponse)\n  }\n\n  _header() {\n    let h = `${this.method} ${this.path} HTTP/1.1\\r\\n`\n\n    let upgrade = false\n\n    for (const name of Object.keys(this.headers)) {\n      const n = name.toLowerCase()\n      const v = this.headers[name]\n\n      if (n === 'content-length') this._chunked = false\n      if (n === 'connection' && v && v.toLowerCase() === 'upgrade')\n        upgrade = true\n\n      h += `${httpCase(n)}: ${v}\\r\\n`\n    }\n\n    if (upgrade) this._chunked = false\n\n    if (this._chunked) h += 'Transfer-Encoding: chunked\\r\\n'\n\n    h += '\\r\\n'\n\n    return h\n  }\n\n  _write(data, encoding, cb) {\n    if (this.headersSent === false) this.flushHeaders()\n\n    if (this._chunked) {\n      data = Buffer.concat([\n        Buffer.from('' + data.byteLength.toString(16) + '\\r\\n'),\n        data,\n        Buffer.from('\\r\\n')\n      ])\n    }\n\n    if (this.socket.write(data)) cb(null)\n    else this._pendingWrite = cb\n  }\n\n  _final(cb) {\n    if (this.headersSent === false) this.flushHeaders()\n\n    if (this._chunked) this.socket.write(Buffer.from('0\\r\\n\\r\\n'))\n\n    this._pendingFinal = cb\n  }\n\n  _predestroy() {\n    if (this.upgrade) return this._continueFinal()\n\n    this.socket.destroy()\n  }\n\n  _continueWrite() {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite\n    this._pendingWrite = null\n    cb(null)\n  }\n\n  _continueFinal() {\n    if (this._pendingFinal === null) return\n    const cb = this._pendingFinal\n    this._pendingFinal = null\n    cb(null)\n  }\n}\n\nfunction httpCase(n) {\n  let s = ''\n  for (const part of n.split('-')) {\n    s += (s ? '-' : '') + part.slice(0, 1).toUpperCase() + part.slice(1)\n  }\n  return s\n}\nmodule.exports = {\n  state: {\n    BEFORE_HEAD: 1,\n    IN_HEAD: 2,\n    IN_BODY: 3,\n    BEFORE_CHUNK: 4,\n    IN_CHUNK: 5\n  },\n  method: {\n    GET: 'GET',\n    HEAD: 'HEAD',\n    POST: 'POST',\n    PUT: 'PUT',\n    DELETE: 'DELETE',\n    CONNECT: 'CONNECT',\n    OPTIONS: 'OPTIONS',\n    TRACE: 'TRACE',\n    PATCH: 'PATCH'\n  },\n  status: {\n    100: 'Continue',\n    101: 'Switching Protocols',\n    102: 'Processing',\n    103: 'Early Hints',\n    200: 'OK',\n    201: 'Created',\n    202: 'Accepted',\n    203: 'Non-Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    207: 'Multi-Status',\n    208: 'Already Reported',\n    226: 'IM Used',\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    307: 'Temporary Redirect',\n    308: 'Permanent Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Payload Too Large',\n    414: 'URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Range Not Satisfiable',\n    417: 'Expectation Failed',\n    418: \"I'm a Teapot\",\n    421: 'Misdirected Request',\n    422: 'Unprocessable Entity',\n    423: 'Locked',\n    424: 'Failed Dependency',\n    425: 'Too Early',\n    426: 'Upgrade Required',\n    428: 'Precondition Required',\n    429: 'Too Many Requests',\n    431: 'Request Header Fields Too Large',\n    451: 'Unavailable For Legal Reasons',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'HTTP Version Not Supported',\n    506: 'Variant Also Negotiates',\n    507: 'Insufficient Storage',\n    508: 'Loop Detected',\n    509: 'Bandwidth Limit Exceeded',\n    510: 'Not Extended',\n    511: 'Network Authentication Required'\n  }\n}\nmodule.exports = class HTTPError extends Error {\n  constructor(msg, code, fn = HTTPError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'HTTPError'\n  }\n\n  static NOT_IMPLEMENTED(msg = 'Method not implemented') {\n    return new HTTPError(msg, 'NOT_IMPLEMENTED', HTTPError.NOT_IMPLEMENTED)\n  }\n\n  static CONNECTION_LOST(msg = 'Socket hung up') {\n    return new HTTPError(msg, 'CONNECTION_LOST', HTTPError.CONNECTION_LOST)\n  }\n}\nconst { Readable } = require('bare-stream')\n\nmodule.exports = class HTTPIncomingMessage extends Readable {\n  constructor(socket = null, headers = {}, opts = {}) {\n    super()\n\n    this.socket = socket\n    this.headers = headers\n    this.upgrade = false\n\n    // Server options\n    this.method = opts.method || ''\n    this.url = opts.url || ''\n\n    // Client options\n    this.statusCode = opts.statusCode || 0\n    this.statusMessage = opts.statusMessage || ''\n  }\n\n  get httpVersion() {\n    return '1.1'\n  }\n\n  getHeader(name) {\n    return this.headers[name.toLowerCase()]\n  }\n\n  getHeaders() {\n    return { ...this.headers }\n  }\n\n  hasHeader(name) {\n    return name.toLowerCase() in this.headers\n  }\n\n  setTimeout(ms, ontimeout) {\n    if (ontimeout) this.once('timeout', ontimeout)\n\n    this.socket.setTimeout(ms)\n\n    return this\n  }\n\n  _predestroy() {\n    if (this.upgrade === false && this.socket !== null) this.socket.destroy()\n  }\n}\nconst { Writable } = require('bare-stream')\nconst errors = require('./errors')\n\nmodule.exports = class HTTPOutgoingMessage extends Writable {\n  constructor(socket = null) {\n    super()\n\n    this.socket = socket\n    this.headers = {}\n    this.headersSent = false\n    this.upgrade = false\n  }\n\n  getHeader(name) {\n    return this.headers[name.toLowerCase()]\n  }\n\n  getHeaders() {\n    return { ...this.headers }\n  }\n\n  hasHeader(name) {\n    return name.toLowerCase() in this.headers\n  }\n\n  setHeader(name, value) {\n    this.headers[name.toLowerCase()] = value\n  }\n\n  flushHeaders() {\n    if (this.headersSent === true || this.socket === null) return\n\n    this.socket.write(Buffer.from(this._header()))\n    this.headersSent = true\n  }\n\n  setTimeout(ms, ontimeout) {\n    if (ontimeout) this.once('timeout', ontimeout)\n\n    this.socket.setTimeout(ms)\n\n    return this\n  }\n\n  _header() {\n    throw errors.NOT_IMPLEMENTED()\n  }\n\n  _predestroy() {\n    if (this.upgrade === false && this.socket !== null) this.socket.destroy()\n  }\n}\nconst tcp = require('bare-tcp')\nconst { isEnded, isFinished, getStreamError } = require('bare-stream')\nconst HTTPIncomingMessage = require('./incoming-message')\nconst HTTPServerResponse = require('./server-response')\nconst constants = require('./constants')\n\nconst empty = Buffer.alloc(0)\n\nmodule.exports = class HTTPServerConnection {\n  static _connections = new WeakMap()\n\n  static for(socket) {\n    return this._connections.get(socket) || null\n  }\n\n  constructor(server, socket, opts = {}) {\n    const {\n      IncomingMessage = HTTPIncomingMessage,\n      ServerResponse = HTTPServerResponse\n    } = opts\n\n    this.server = server\n    this.socket = socket\n\n    this.req = null\n    this.res = null\n\n    this._IncomingMessage = IncomingMessage\n    this._ServerResponse = ServerResponse\n\n    this._state = constants.state.BEFORE_HEAD\n    this._length = -1\n    this._read = 0\n    this._buffer = null\n    this._idle = true\n\n    this._onclose = this._onclose.bind(this)\n    this._ondata = this._ondata.bind(this)\n    this._ondrain = this._ondrain.bind(this)\n    this._ontimeout = this._ontimeout.bind(this)\n\n    socket\n      .on('error', noop)\n      .on('close', this._onclose)\n      .on('data', this._ondata)\n      .on('drain', this._ondrain)\n      .on('timeout', this._ontimeout)\n\n    HTTPServerConnection._connections.set(socket, this)\n\n    if (this.server.timeout) socket.setTimeout(this.server.timeout)\n  }\n\n  get idle() {\n    return this._idle\n  }\n\n  _onclose() {\n    if (this.req && !isEnded(this.req)) this.req.destroy()\n    if (this.res && !isFinished(this.res)) this.res.destroy()\n    const err = getStreamError(this.socket)\n    if (err) this.socket.destroy(err)\n  }\n\n  _ondata(data) {\n    this._idle = false\n\n    if (this._state === constants.state.IN_BODY) return this._onbody(data)\n\n    if (this._buffer !== null) {\n      this._buffer = Buffer.concat([this._buffer, data])\n    } else {\n      this._buffer = data\n    }\n\n    let hits = 0\n\n    for (let i = 0; i < this._buffer.byteLength; i++) {\n      const b = this._buffer[i]\n\n      if (hits === 0 && b === 13) {\n        hits++\n      } else if (hits === 1 && b === 10) {\n        hits++\n\n        if (this._state === constants.state.BEFORE_CHUNK) {\n          const head = this._buffer.subarray(0, i - 1)\n          this._buffer =\n            i + 1 === this._buffer.byteLength\n              ? null\n              : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onchunklength(head)\n\n          if (this._buffer === null) break\n        } else if (this._state === constants.state.IN_CHUNK) {\n          const chunk = this._buffer.subarray(0, i - 1)\n\n          if (chunk.byteLength !== this._length) {\n            hits = 0\n            continue\n          }\n\n          this._buffer =\n            i + 1 === this._buffer.byteLength\n              ? null\n              : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onchunk(chunk)\n\n          if (this._buffer === null) break\n        }\n      } else if (hits === 2 && b === 13) {\n        hits++\n      } else if (hits === 3 && b === 10) {\n        if (this._state === constants.state.BEFORE_HEAD) {\n          const head = this._buffer.subarray(0, i - 3)\n          this._buffer =\n            i + 1 === this._buffer.byteLength\n              ? null\n              : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onhead(head)\n\n          if (this._buffer === null) break\n        }\n      } else {\n        hits = 0\n      }\n    }\n  }\n\n  _onhead(data) {\n    this._state = constants.state.IN_HEAD\n\n    const r = data.toString().split('\\r\\n')\n    if (r.length === 0) return this.socket.destroy()\n\n    const [method, url] = r[0].split(' ')\n    if (!method || !url) return this.socket.destroy()\n\n    const headers = {}\n\n    for (let i = 1; i < r.length; i++) {\n      const [name, value] = r[i].split(': ')\n      headers[name.toLowerCase()] = value\n    }\n\n    this.req = new this._IncomingMessage(this.socket, headers, { method, url })\n\n    this.req.on('close', () => {\n      this.req = null\n      this._onreset()\n    })\n\n    this.req.resume()\n    this.req.pause()\n\n    if (headers.connection && headers.connection.toLowerCase() === 'upgrade') {\n      const head = this._buffer\n      this._buffer = null\n      return this._onupgrade(head)\n    }\n\n    this.res = new this._ServerResponse(\n      this.socket,\n      this.req,\n      headers.connection === 'close'\n    )\n\n    this.res.on('close', () => {\n      this.res = null\n    })\n\n    this.server.emit('request', this.req, this.res)\n\n    if (headers['transfer-encoding'] === 'chunked') {\n      this._state = constants.state.BEFORE_CHUNK\n    } else {\n      this._length = parseInt(headers['content-length'], 10) || 0\n\n      if (this._length === 0) return this._onfinished()\n\n      this._state = constants.state.IN_BODY\n\n      if (this._buffer) {\n        const body = this._buffer\n        this._buffer = null\n        this._onbody(body)\n      }\n    }\n  }\n\n  _onchunklength(data) {\n    this._length = parseInt(data.toString(), 16)\n\n    if (this._length === 0) this._onfinished()\n    else this._state = constants.state.IN_CHUNK\n  }\n\n  _onchunk(data) {\n    this._read += data.byteLength\n\n    this.req.push(data)\n\n    this._state = constants.state.BEFORE_CHUNK\n  }\n\n  _onbody(data) {\n    this._read += data.byteLength\n\n    this.req.push(data)\n\n    if (this._read === this._length) this._onfinished()\n  }\n\n  _onupgrade(head) {\n    this._ondetach()\n\n    const req = this.req\n\n    req.upgrade = true\n    req.destroy()\n\n    this.server.emit('upgrade', req, this.socket, head || empty)\n  }\n\n  _ontimeout() {\n    const reqTimeout = this.req && this.req.emit('timeout')\n    const resTimeout = this.res && this.res.emit('timeout')\n    const serverTimeout = this.server.emit('timeout', this.socket)\n\n    if (!reqTimeout && !resTimeout && !serverTimeout) this.socket.destroy()\n  }\n\n  _onfinished() {\n    if (this.req) this.req.push(null)\n  }\n\n  _onreset() {\n    this._state = constants.state.BEFORE_HEAD\n    this._length = -1\n    this._read = 0\n    this._buffer = null\n    this._idle = true\n\n    if (this.server._state & tcp.constants.state.CLOSING) {\n      this.socket.destroy()\n    }\n  }\n\n  _ondrain() {\n    if (this.res) this.res._continueWrite()\n  }\n\n  _ondetach() {\n    this.socket\n      .off('error', noop)\n      .off('close', this._onclose)\n      .off('data', this._ondata)\n      .off('drain', this._ondrain)\n      .off('timeout', this._ontimeout)\n\n    HTTPServerConnection._connections.delete(this.socket)\n  }\n}\n\nfunction noop() {}\nconst HTTPOutgoingMessage = require('./outgoing-message')\nconst constants = require('./constants')\n\nmodule.exports = class HTTPServerResponse extends HTTPOutgoingMessage {\n  constructor(socket, req, close) {\n    super(socket)\n\n    this.req = req\n\n    this.statusCode = 200\n    this.statusMessage = null\n\n    this._chunked = true\n    this._close = close\n    this._finishing = false\n    this._onlyHeaders = req.method === 'HEAD'\n\n    this._pendingWrite = null\n  }\n\n  end(data) {\n    this._finishing = true\n    return super.end(data)\n  }\n\n  writeHead(statusCode, statusMessage = null, headers = {}) {\n    if (typeof statusMessage === 'object' && statusMessage !== null) {\n      headers = statusMessage\n      statusMessage = null\n    }\n\n    this.statusCode = statusCode\n    this.statusMessage = statusMessage || null\n    this.headers = headers || {}\n  }\n\n  _header() {\n    let h =\n      'HTTP/1.1 ' +\n      this.statusCode +\n      ' ' +\n      (this.statusMessage === null\n        ? constants.status[this.statusCode]\n        : this.statusMessage) +\n      '\\r\\n'\n\n    for (const name of Object.keys(this.headers)) {\n      const n = name.toLowerCase()\n      const v = this.headers[name]\n\n      if (n === 'content-length') this._chunked = false\n      if (n === 'connection' && v && v.toLowerCase() === 'close')\n        this._close = true\n\n      h += httpCase(n) + ': ' + v + '\\r\\n'\n    }\n\n    if (this._chunked) h += 'Transfer-Encoding: chunked\\r\\n'\n\n    h += '\\r\\n'\n\n    return h\n  }\n\n  _write(data, encoding, cb) {\n    if (this.headersSent === false) {\n      if (this._finishing) {\n        this.setHeader(\n          'Content-Length',\n          (data.byteLength + this._writableState.buffered).toString()\n        )\n      }\n\n      this.flushHeaders()\n    }\n\n    if (this._onlyHeaders === true) return cb(null)\n\n    if (this._chunked) {\n      data = Buffer.concat([\n        Buffer.from('' + data.byteLength.toString(16) + '\\r\\n'),\n        data,\n        Buffer.from('\\r\\n')\n      ])\n    }\n\n    if (this.socket.write(data)) cb(null)\n    else this._pendingWrite = cb\n  }\n\n  _final(cb) {\n    if (this.headersSent === false) {\n      this.setHeader('Content-Length', '0')\n      this.flushHeaders()\n    }\n\n    if (this._chunked && this._onlyHeaders === false)\n      this.socket.write(Buffer.from('0\\r\\n\\r\\n'))\n    if (this._close) this.socket.end()\n\n    cb(null)\n  }\n\n  _predestroy() {\n    super._predestroy()\n    this.req.destroy()\n    this._continueWrite()\n  }\n\n  _continueWrite() {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite\n    this._pendingWrite = null\n    cb(null)\n  }\n}\n\nfunction httpCase(n) {\n  let s = ''\n  for (const part of n.split('-')) {\n    s += (s ? '-' : '') + part.slice(0, 1).toUpperCase() + part.slice(1)\n  }\n  return s\n}\nconst TCPServer = require('bare-tcp').Server\nconst HTTPServerConnection = require('./server-connection')\n\nmodule.exports = class HTTPServer extends TCPServer {\n  constructor(opts = {}, onrequest) {\n    if (typeof opts === 'function') {\n      onrequest = opts\n      opts = {}\n    }\n\n    super({ allowHalfOpen: false })\n\n    this._timeout = 0\n\n    this.on(\n      'connection',\n      (socket) => new HTTPServerConnection(this, socket, opts)\n    )\n\n    if (onrequest) this.on('request', onrequest)\n  }\n\n  get timeout() {\n    return this._timeout || undefined // For Node.js compatibility\n  }\n\n  setTimeout(ms = 0, ontimeout) {\n    if (ontimeout) this.on('timeout', ontimeout)\n\n    this._timeout = ms\n\n    return this\n  }\n\n  close(onclose) {\n    super.close(onclose)\n\n    for (const socket of this._connections) {\n      const connection = HTTPServerConnection.for(socket)\n\n      if (connection && connection.idle) {\n        socket.destroy()\n      }\n    }\n  }\n}\n{\n  \"name\": \"bare-http1\",\n  \"version\": \"4.0.2\",\n  \"description\": \"Native HTTP/1 library for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\",\n    \"./constants\": \"./lib/constants.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-http1.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-http1/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-http1#readme\",\n  \"dependencies\": {\n    \"bare-events\": \"^2.0.0\",\n    \"bare-stream\": \"^2.3.0\",\n    \"bare-tcp\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.0\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nmodule.exports = require.addon()\n/* global Bare */\nconst EventEmitter = require('bare-events')\nconst { Duplex } = require('bare-stream')\nconst dns = require('bare-dns')\nconst binding = require('./binding')\nconst constants = require('./lib/constants')\nconst errors = require('./lib/errors')\nconst ip = require('./lib/ip')\n\nconst defaultReadBufferSize = 65536\n\nexports.Socket = class TCPSocket extends Duplex {\n  constructor(opts = {}) {\n    super({ eagerOpen: true })\n\n    const { readBufferSize = defaultReadBufferSize, allowHalfOpen = true } =\n      opts\n\n    this._state = 0\n\n    this._allowHalfOpen = allowHalfOpen\n\n    this._remotePort = -1\n    this._remoteHost = null\n    this._remoteFamily = 0\n\n    this._pendingOpen = null\n    this._pendingWrite = null\n    this._pendingFinal = null\n    this._pendingDestroy = null\n\n    this._timer = null\n    this._timeout = 0\n\n    this._buffer = Buffer.alloc(readBufferSize)\n\n    this._handle = binding.init(\n      this._buffer,\n      this,\n      noop,\n      this._onconnect,\n      this._onread,\n      this._onwrite,\n      this._onfinal,\n      this._onclose\n    )\n  }\n\n  get connecting() {\n    return (this._state & constants.state.CONNECTING) !== 0\n  }\n\n  get pending() {\n    return (this._state & constants.state.CONNECTED) === 0\n  }\n\n  get timeout() {\n    return this._timeout || undefined // For Node.js compatibility\n  }\n\n  connect(port, host = 'localhost', opts = {}, onconnect) {\n    if (\n      this._state & constants.state.CONNECTING ||\n      this._state & constants.state.CONNECTED\n    ) {\n      throw errors.SOCKET_ALREADY_CONNECTED('Socket is already connected')\n    }\n\n    this._state |= constants.state.CONNECTING\n\n    if (typeof host === 'function') {\n      onconnect = host\n      host = 'localhost'\n    } else if (typeof opts === 'function') {\n      onconnect = opts\n      opts = {}\n    }\n\n    let family = 0\n\n    if (typeof port === 'object' && port !== null) {\n      opts = port || {}\n      port = opts.port || 0\n      host = opts.host || 'localhost'\n      family = opts.family || 0\n    }\n\n    if (!host) host = 'localhost'\n\n    const type = ip.isIP(host)\n\n    if (type === 0) {\n      const { lookup = dns.lookup, hints } = opts\n\n      lookup(host, { family, hints }, (err, address, family) => {\n        if (this._state & constants.state.CLOSING) return\n\n        this.emit('lookup', err, address, family, host)\n\n        this._state &= ~constants.state.CONNECTING\n\n        if (err) {\n          if (this._pendingOpen) this._continueOpen(err)\n          else this.destroy(err)\n          return\n        }\n\n        this.connect(port, address, { ...opts, family }, onconnect)\n      })\n\n      return this\n    }\n\n    family = type\n\n    try {\n      binding.connect(this._handle, port, host, family)\n\n      if (opts.keepAlive === true) {\n        this.setKeepAlive(opts.keepAlive, opts.keepAliveInitialDelay)\n      }\n\n      if (opts.noDelay === true) {\n        this.setNoDelay()\n      }\n\n      if (opts.timeout) {\n        this.setTimeout(opts.timeout)\n      }\n\n      this._remotePort = port\n      this._remoteHost = host\n      this._remoteFamily = family\n\n      if (onconnect) this.once('connect', onconnect)\n    } catch (err) {\n      queueMicrotask(() => {\n        if (this._pendingOpen) this._pendingOpen(err)\n        else this.destroy(err)\n      })\n    }\n\n    return this\n  }\n\n  setKeepAlive(enable = false, delay = 0) {\n    if (typeof enable === 'number') {\n      delay = enable\n      enable = false\n    }\n\n    delay = Math.floor(delay / 1000)\n\n    if (delay === 0) enable = false\n\n    binding.keepalive(this._handle, enable, delay)\n\n    return this\n  }\n\n  setNoDelay(enable = true) {\n    binding.nodelay(this._handle, enable)\n\n    return this\n  }\n\n  setTimeout(ms, ontimeout) {\n    if (ms === 0) {\n      clearTimeout(this._timer)\n      this._timer = null\n    } else {\n      if (ontimeout) this.once('timeout', ontimeout)\n\n      this._timer = setTimeout(() => this.emit('timeout'), ms)\n      this._timer.unref()\n    }\n\n    this._timeout = ms\n\n    return this\n  }\n\n  ref() {\n    binding.ref(this._handle)\n  }\n\n  unref() {\n    binding.unref(this._handle)\n  }\n\n  _open(cb) {\n    if (this._state & constants.state.CONNECTED) return cb(null)\n    this._pendingOpen = cb\n  }\n\n  _read() {\n    if ((this._state & constants.state.READING) === 0) {\n      this._state |= constants.state.READING\n      binding.resume(this._handle)\n    }\n  }\n\n  _writev(batch, cb) {\n    this._pendingWrite = [cb, batch]\n    binding.writev(\n      this._handle,\n      batch.map(({ chunk }) => chunk)\n    )\n  }\n\n  _final(cb) {\n    this._pendingFinal = cb\n    binding.end(this._handle)\n  }\n\n  _predestroy() {\n    if (this._state & constants.state.CLOSING) return\n    this._state |= constants.state.CLOSING\n    binding.close(this._handle)\n  }\n\n  _destroy(err, cb) {\n    if (this._state & constants.state.CLOSING) return cb(err)\n    this._state |= constants.state.CLOSING\n    this._pendingDestroy = cb\n    binding.close(this._handle)\n  }\n\n  _continueOpen(err) {\n    if (this._pendingOpen === null) return\n    const cb = this._pendingOpen\n    this._pendingOpen = null\n    cb(err)\n  }\n\n  _continueWrite(err) {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite[0]\n    this._pendingWrite = null\n    cb(err)\n  }\n\n  _continueFinal(err) {\n    if (this._pendingFinal === null) return\n    const cb = this._pendingFinal\n    this._pendingFinal = null\n    cb(err)\n  }\n\n  _continueDestroy() {\n    if (this._pendingDestroy === null) return\n    const cb = this._pendingDestroy\n    this._pendingDestroy = null\n    cb(null)\n  }\n\n  _onconnect(err) {\n    if (err) {\n      if (this._pendingOpen) this._continueOpen(err)\n      else this.destroy(err)\n      return\n    }\n\n    this._state |= constants.state.CONNECTED\n    this._state &= ~constants.state.CONNECTING\n    this._continueOpen()\n\n    this.emit('connect')\n  }\n\n  _onread(err, read) {\n    if (this._timer) this._timer.refresh()\n\n    if (err) {\n      this.destroy(err)\n      return\n    }\n\n    if (read === 0) {\n      this.push(null)\n      if (this._allowHalfOpen === false) this.end()\n      return\n    }\n\n    const copy = Buffer.allocUnsafe(read)\n    copy.set(this._buffer.subarray(0, read))\n\n    if (this.push(copy) === false && this.destroying === false) {\n      this._state &= ~constants.state.READING\n      binding.pause(this._handle)\n    }\n  }\n\n  _onwrite(err) {\n    if (this._timer) this._timer.refresh()\n\n    this._continueWrite(err)\n  }\n\n  _onfinal(err) {\n    this._continueFinal(err)\n  }\n\n  _onclose() {\n    clearTimeout(this._timer)\n\n    this._handle = null\n    this._continueDestroy()\n  }\n}\n\nexports.Server = class TCPServer extends EventEmitter {\n  constructor(opts = {}, onconnection) {\n    if (typeof opts === 'function') {\n      onconnection = opts\n      opts = {}\n    }\n\n    super()\n\n    const { readBufferSize = defaultReadBufferSize, allowHalfOpen = true } =\n      opts\n\n    this._state = 0\n\n    this._readBufferSize = readBufferSize\n    this._allowHalfOpen = allowHalfOpen\n\n    this._keepAlive = opts.keepAlive\n    this._keepAliveDelay = opts.keepAliveInitialDelay\n    this._noDelay = opts.noDelay\n\n    this._port = -1\n    this._host = null\n    this._family = 0\n    this._connections = new Set()\n\n    this._error = null\n    this._handle = null\n\n    if (onconnection) this.on('connection', onconnection)\n  }\n\n  get listening() {\n    return (this._state & constants.state.BOUND) !== 0\n  }\n\n  address() {\n    if ((this._state & constants.state.BOUND) === 0) {\n      return null\n    }\n\n    return {\n      address: this._host,\n      family: `IPv${this._family}`,\n      port: this._port\n    }\n  }\n\n  listen(port = 0, host = 'localhost', backlog = 511, opts = {}, onlistening) {\n    if (\n      this._state & constants.state.BINDING ||\n      this._state & constants.state.BOUND\n    ) {\n      throw errors.SERVER_ALREADY_LISTENING('Server is already listening')\n    }\n\n    if (this._state & constants.state.CLOSING) {\n      throw errors.SERVER_IS_CLOSED('Server is closed')\n    }\n\n    this._state |= constants.state.BINDING\n\n    if (typeof port === 'function') {\n      onlistening = port\n      port = 0\n    } else if (typeof host === 'function') {\n      onlistening = host\n      host = 'localhost'\n    } else if (typeof backlog === 'function') {\n      onlistening = backlog\n      backlog = 511\n    } else if (typeof opts === 'function') {\n      onlistening = opts\n      opts = {}\n    }\n\n    let family = 0\n\n    if (typeof port === 'object' && port !== null) {\n      opts = port || {}\n      port = opts.port || 0\n      host = opts.host || 'localhost'\n      family = opts.family || 0\n      backlog = opts.backlog || 511\n    }\n\n    if (!host) host = 'localhost'\n    if (!backlog) backlog = 511\n\n    const type = ip.isIP(host)\n\n    if (type === 0) {\n      const { lookup = dns.lookup, hints } = opts\n\n      lookup(host, { family, hints }, (err, address, family) => {\n        if (this._state & constants.state.CLOSING) return\n\n        this.emit('lookup', err, address, family, host)\n\n        this._state &= ~constants.state.BINDING\n\n        if (err) return this.emit('error', err)\n\n        this.listen(port, address, backlog, { ...opts, family }, onlistening)\n      })\n\n      return this\n    }\n\n    family = type\n\n    this._handle = binding.init(\n      empty,\n      this,\n      this._onconnection,\n      noop,\n      noop,\n      noop,\n      noop,\n      this._onclose\n    )\n\n    if (this._state & constants.state.UNREFED) binding.unref(this._handle)\n\n    try {\n      this._port = binding.bind(this._handle, port, host, backlog, family)\n      this._host = host\n      this._family = family\n      this._state |= constants.state.BOUND\n      this._state &= ~constants.state.BINDING\n\n      if (onlistening) this.once('listening', onlistening)\n\n      queueMicrotask(() => this.emit('listening'))\n    } catch (err) {\n      this._error = err\n\n      binding.close(this._handle)\n    }\n\n    return this\n  }\n\n  close(onclose) {\n    if (onclose) this.once('close', onclose)\n    if (this._state & constants.state.CLOSING) return\n    this._state |= constants.state.CLOSING\n    this._closeMaybe()\n  }\n\n  ref() {\n    this._state &= ~constants.state.UNREFED\n    if (this._handle !== null) binding.ref(this._handle)\n  }\n\n  unref() {\n    this._state |= constants.state.UNREFED\n    if (this._handle !== null) binding.unref(this._handle)\n  }\n\n  _closeMaybe() {\n    if (this._state & constants.state.CLOSING && this._connections.size === 0) {\n      if (this._handle !== null) binding.close(this._handle)\n      else queueMicrotask(() => this.emit('close'))\n    }\n  }\n\n  _onconnection(err) {\n    if (err) {\n      this.emit('error', err)\n      return\n    }\n\n    if (this._state & constants.state.CLOSING) return\n\n    const socket = new exports.Socket({\n      readBufferSize: this._readBufferSize,\n      allowHalfOpen: this._allowHalfOpen\n    })\n\n    try {\n      binding.accept(this._handle, socket._handle)\n\n      socket._state |= constants.state.CONNECTED\n\n      this._connections.add(socket)\n\n      if (this._keepAlive === true) {\n        socket.setKeepAlive(this._keepAlive, this._keepAliveDelay)\n      }\n\n      if (this._noDelay === true) {\n        socket.setNoDelay()\n      }\n\n      socket.on('close', () => {\n        this._connections.delete(socket)\n        this._closeMaybe()\n      })\n\n      this.emit('connection', socket)\n    } catch (err) {\n      socket.destroy()\n\n      throw err\n    }\n  }\n\n  _onclose() {\n    const err = this._error\n\n    this._state &= ~constants.state.BINDING\n    this._error = null\n    this._handle = null\n\n    if (err) this.emit('error', err)\n    else this.emit('close')\n  }\n}\n\nexports.constants = constants\nexports.errors = errors\n\nexports.isIP = ip.isIP\nexports.isIPv4 = ip.isIPv4\nexports.isIPv6 = ip.isIPv6\n\nexports.createConnection = function createConnection(\n  port,\n  host,\n  opts,\n  onconnect\n) {\n  if (typeof host === 'function') {\n    onconnect = host\n    host = 'localhost'\n  } else if (typeof opts === 'function') {\n    onconnect = opts\n    opts = {}\n  }\n\n  if (typeof port === 'object' && port !== null) {\n    opts = port || {}\n    port = opts.port || 0\n    host = opts.host || 'localhost'\n  }\n\n  return new exports.Socket(opts).connect(port, host, opts, onconnect)\n}\n\n// For Node.js compatibility\nexports.connect = exports.createConnection\n\nexports.createServer = function createServer(opts, onconnection) {\n  return new exports.Server(opts, onconnection)\n}\n\nconst empty = Buffer.alloc(0)\n\nfunction noop() {}\nmodule.exports = {\n  state: {\n    CONNECTING: 0x1,\n    CONNECTED: 0x2,\n    BINDING: 0x4,\n    BOUND: 0x8,\n    READING: 0x10,\n    CLOSING: 0x20,\n    UNREFED: 0x40\n  }\n}\nmodule.exports = class TCPError extends Error {\n  constructor(msg, code, fn = TCPError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'TCPError'\n  }\n\n  static SOCKET_ALREADY_CONNECTED(msg) {\n    return new TCPError(\n      msg,\n      'SOCKET_ALREADY_CONNECTED',\n      TCPError.SOCKET_ALREADY_CONNECTED\n    )\n  }\n\n  static SERVER_ALREADY_LISTENING(msg) {\n    return new TCPError(\n      msg,\n      'SERVER_ALREADY_LISTENING',\n      TCPError.SERVER_ALREADY_LISTENING\n    )\n  }\n\n  static SERVER_IS_CLOSED(msg) {\n    return new TCPError(msg, 'SERVER_IS_CLOSED', TCPError.SERVER_IS_CLOSED)\n  }\n\n  static INVALID_HOST(msg = 'Unrecognizable host format') {\n    return new TCPError(msg, 'INVALID_HOST', TCPError.INVALID_HOST)\n  }\n}\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`\nconst IPv4Pattern = new RegExp(`^${v4Str}$`)\n\nconst v6Seg = '(?:[0-9a-fA-F]{1,4})'\nconst IPv6Pattern = new RegExp(\n  '^(' +\n    `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n    `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n    `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` +\n    `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` +\n    `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` +\n    `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` +\n    `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` +\n    `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` +\n    ')(%[0-9a-zA-Z-.:]{1,})?$'\n)\n\nconst isIPv4 = (exports.isIPv4 = function isIPv4(host) {\n  return IPv4Pattern.test(host)\n})\n\nconst isIPv6 = (exports.isIPv6 = function isIPv6(host) {\n  return IPv6Pattern.test(host)\n})\n\nexports.isIP = function isIP(host) {\n  if (isIPv4(host)) return 4\n  if (isIPv6(host)) return 6\n  return 0\n}\n{\n  \"name\": \"bare-tcp\",\n  \"version\": \"2.0.3\",\n  \"description\": \"Native TCP sockets for JavaScript\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./package\": \"./package.json\",\n    \"./constants\": \"./lib/constants.js\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-tcp.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-tcp/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-tcp#readme\",\n  \"engines\": {\n    \"bare\": \">=1.7.0\"\n  },\n  \"dependencies\": {\n    \"bare-dns\": \"^2.0.4\",\n    \"bare-events\": \"^2.5.4\",\n    \"bare-stream\": \"^2.6.4\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.0\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\n{\n  \"name\": \"serve-drive\",\n  \"version\": \"5.2.0\",\n  \"description\": \"HTTP drive server for entries delivery. Auto detects types like video, images, etc\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"imports\": {\n    \"http\": {\n      \"bare\": \"bare-http1\",\n      \"default\": \"http\"\n    }\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/serve-drive.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/serve-drive/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/serve-drive\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.3\",\n    \"corestore\": \"^6.4.3\",\n    \"hyperdrive\": \"^11.0.1\",\n    \"localdrive\": \"^1.5.0\",\n    \"random-access-memory\": \"^6.1.0\",\n    \"standard\": \"^17.0.0\",\n    \"test-tmp\": \"^1.0.2\"\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.6.7\",\n    \"bare-http1\": \"^4.0.0\",\n    \"get-mime-type\": \"^1.0.0\",\n    \"hypercore-crypto\": \"^3.4.2\",\n    \"hypercore-id-encoding\": \"^1.0.2\",\n    \"range-parser\": \"^1.2.1\",\n    \"ready-resource\": \"^1.0.0\",\n    \"safety-catch\": \"^1.0.2\",\n    \"streamx\": \"^2.13.2\",\n    \"unix-path-resolve\": \"^1.0.2\"\n  }\n}\nconst set = require('unordered-set')\n\nmodule.exports = opts => new ShuffledPriorityQueue(opts)\n\nclass ShuffledPriorityQueue {\n  constructor (opts) {\n    this.priorities = []\n    this.equals = (opts && opts.equals) || null\n  }\n\n  get length () {\n    return this.priorities.reduce(add, 0)\n  }\n\n  [Symbol.iterator] () {\n    return new Iterator(this)\n  }\n\n  head () {\n    for (let i = this.priorities.length - 1; i >= 0; i--) {\n      const q = this.priorities[i]\n      if (q.length) return shuffle(q, 0)\n    }\n    return null\n  }\n\n  tail () {\n    for (let i = 0; i < this.priorities.length; i++) {\n      const q = this.priorities[i]\n      if (q.length) return shuffle(q, 0)\n    }\n    return null\n  }\n\n  prev (prev) {\n    if (!prev) return this.tail()\n    return next(this.priorities, prev, 1)\n  }\n\n  next (prev) {\n    if (!prev) return this.head()\n    return next(this.priorities, prev, -1)\n  }\n\n  shift () {\n    return this.remove(this.head())\n  }\n\n  pop () {\n    return this.remove(this.tail())\n  }\n\n  add (val) {\n    const prio = val.priority || 0\n    while (prio >= this.priorities.length) this.priorities.push([])\n    set.add(this.priorities[prio], val)\n    return val\n  }\n\n  remove (val) {\n    if (!val) return null\n\n    if (val._index === undefined) {\n      val = this.find(val)\n      if (!val) return null\n    }\n\n    return set.remove(this.priorities[val.priority || 0], val)\n  }\n\n  has (val) {\n    if (val._index === undefined) return this.find(val)\n    const priority = val.priority || 0\n    if (priority >= this.priorities.length) return false\n    return set.has(this.priorities[priority], val)\n  }\n\n  find (val) {\n    if (val._index !== undefined) return val\n\n    const prio = val.priority || 0\n    const qs = this.priorities\n    if (prio >= qs.length) return null\n\n    const q = qs[prio]\n\n    for (let i = 0; i < q.length; i++) {\n      if (this.equals(q[i], val)) return q[i]\n    }\n\n    return null\n  }\n}\n\nclass Iterator {\n  constructor (queue) {\n    this.prev = null\n    this.queue = queue\n  }\n\n  next () {\n    const next = this.queue.next(this.prev)\n    this.prev = next\n    return { done: !next, value: next }\n  }\n}\n\nfunction shuffle (q, i) {\n  const ran = i + Math.floor(Math.random() * (q.length - i))\n  set.swap(q, q[ran], q[i])\n  return q[i]\n}\n\nfunction next (queues, prev, inc) {\n  let i = prev.priority || 0\n  let j = (prev._index || 0) + 1\n\n  while (true) {\n    if (i < 0 || i >= queues.length) return null\n    const q = queues[i]\n\n    if (j >= q.length) {\n      i += inc\n      j = 0\n      continue\n    }\n\n    return shuffle(q, j)\n  }\n}\n\nfunction add (len, b) {\n  return len + b.length\n}\n{\n  \"name\": \"shuffled-priority-queue\",\n  \"version\": \"2.1.0\",\n  \"description\": \"A priority queue that shuffles elements with the same priority.\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"dependencies\": {\n    \"unordered-set\": \"^2.0.1\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^12.0.1\",\n    \"tape\": \"^4.9.1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/shuffled-priority-queue.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/shuffled-priority-queue/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/shuffled-priority-queue\"\n}\nmodule.exports = class Signal {\n  constructor () {\n    this._resolve = null\n    this._reject = null\n    this._promise = null\n    this._bind = bind.bind(this)\n    this._onerror = clear.bind(this)\n    this._onsuccess = clear.bind(this, null)\n    this._timers = new Set()\n  }\n\n  wait (max) {\n    if (!this._promise) {\n      this._promise = new Promise(this._bind)\n      this._promise.then(this._onsuccess).catch(this._onerror)\n    }\n    if (max) return this._sleep(max)\n    return this._promise\n  }\n\n  _sleep (max) {\n    const s = new Promise((resolve, reject) => {\n      const done = () => {\n        this._timers.delete(state)\n        resolve(true)\n      }\n      const id = setTimeout(done, max)\n      const state = { id, resolve, reject }\n      this._timers.add(state)\n    })\n\n    return s\n  }\n\n  notify (err) {\n    if (!this._promise) return\n    const resolve = this._resolve\n    const reject = this._reject\n    this._promise = null\n    if (err) reject(err)\n    else resolve(true)\n  }\n}\n\nfunction clear (err) {\n  for (const { id, resolve, reject } of this._timers) {\n    clearTimeout(id)\n    if (err) reject(err)\n    else resolve(true)\n  }\n  this._timers.clear()\n}\n\nfunction bind (resolve, reject) {\n  this._resolve = resolve\n  this._reject = reject\n}\n{\n  \"name\": \"signal-promise\",\n  \"version\": \"1.0.3\",\n  \"description\": \"Simple wait/notify promise with optional max wait time\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/signal-promise.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/signal-promise/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/signal-promise\"\n}\nvar varint = require('varint')\nexports.encode = function encode (v, b, o) {\n  v = v >= 0 ? v*2 : v*-2 - 1\n  var r = varint.encode(v, b, o)\n  encode.bytes = varint.encode.bytes\n  return r\n}\nexports.decode = function decode (b, o) {\n  var v = varint.decode(b, o)\n  decode.bytes = varint.decode.bytes\n  return v & 1 ? (v+1) / -2 : v / 2\n}\n\nexports.encodingLength = function (v) {\n  return varint.encodingLength(v >= 0 ? v*2 : v*-2 - 1)\n}\n{\n  \"name\": \"signed-varint\",\n  \"description\": \"efficiently store signed integers in varint\",\n  \"version\": \"2.0.1\",\n  \"homepage\": \"https://github.com/dominictarr/signed-varint\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/dominictarr/signed-varint.git\"\n  },\n  \"dependencies\": {\n    \"varint\": \"~5.0.0\"\n  },\n  \"devDependencies\": {\n    \"tape\": \"~2.12.3\"\n  },\n  \"scripts\": {\n    \"test\": \"node test.js\"\n  },\n  \"author\": \"Dominic Tarr <dominic.tarr@gmail.com> (http://dominictarr.com)\",\n  \"license\": \"MIT\"\n}\nmodule.exports = require('node-gyp-build')(__dirname)\nconst binding = require('./binding')\nconst b4a = require('b4a')\n\nfunction unary (u8, u16, u32) {\n  return function unary (buf, result = b4a.allocUnsafe(buf.byteLength)) {\n    if (buf.byteLength % 16 !== 0) {\n      throw new Error('Buffer length must be a multiple of 16')\n    }\n\n    if (buf.byteLength !== result.byteLength) {\n      throw new Error('Length of result buffer is insufficient')\n    }\n\n    const n = buf.BYTES_PER_ELEMENT\n\n    if (n === 1) u8(buf, result)\n    else if (n === 2) u16(buf, result)\n    else u32(buf, result)\n\n    return result\n  }\n}\n\nfunction binary (u8, u16, u32) {\n  return function binary (a, b, result = b4a.allocUnsafe(a.byteLength)) {\n    if (a.byteLength % 16 !== 0) {\n      throw new Error('Buffer length must be a multiple of 16')\n    }\n\n    if (a.byteLength !== b.byteLength || a.byteLength !== result.byteLength) {\n      throw new Error('Buffers must be the same length')\n    }\n\n    const n = a.BYTES_PER_ELEMENT\n\n    if (n === 1) u8(a, b, result)\n    else if (n === 2) u16(a, b, result)\n    else u32(a, b, result)\n\n    return result\n  }\n}\n\nfunction reduce (u8, u16, u32) {\n  return function reduce (buf) {\n    if (buf.byteLength % 16 !== 0) {\n      throw new Error('Buffer length must be a multiple of 16')\n    }\n\n    const n = buf.BYTES_PER_ELEMENT\n\n    if (n === 1) return u8(buf)\n    if (n === 2) return u16(buf)\n    return u32(buf)\n  }\n}\n\nexports.allo = function allo (buf) {\n  if (buf.byteLength % 16 !== 0) {\n    throw new Error('Buffer length must be a multiple of 16')\n  }\n\n  return binding.simdle_napi_allo_v128(buf) !== 0\n}\n\nexports.allz = function allz (buf) {\n  if (buf.byteLength % 16 !== 0) {\n    throw new Error('Buffer length must be a multiple of 16')\n  }\n\n  return binding.simdle_napi_allz_v128(buf) !== 0\n}\n\nexports.and = binary(\n  binding.simdle_napi_and_v128_u8,\n  binding.simdle_napi_and_v128_u16,\n  binding.simdle_napi_and_v128_u32\n)\n\nexports.clear = binary(\n  binding.simdle_napi_clear_v128_u8,\n  binding.simdle_napi_clear_v128_u16,\n  binding.simdle_napi_clear_v128_u32\n)\n\nexports.clo = unary(\n  binding.simdle_napi_clo_v128_u8,\n  binding.simdle_napi_clo_v128_u16,\n  binding.simdle_napi_clo_v128_u32\n)\n\nexports.clz = unary(\n  binding.simdle_napi_clz_v128_u8,\n  binding.simdle_napi_clz_v128_u16,\n  binding.simdle_napi_clz_v128_u32\n)\n\nexports.cnt = unary(\n  binding.simdle_napi_cnt_v128_u8,\n  binding.simdle_napi_cnt_v128_u16,\n  binding.simdle_napi_cnt_v128_u32\n)\n\nexports.cto = unary(\n  binding.simdle_napi_cto_v128_u8,\n  binding.simdle_napi_cto_v128_u16,\n  binding.simdle_napi_cto_v128_u32\n)\n\nexports.ctz = unary(\n  binding.simdle_napi_ctz_v128_u8,\n  binding.simdle_napi_ctz_v128_u16,\n  binding.simdle_napi_ctz_v128_u32\n)\n\nexports.not = unary(\n  binding.simdle_napi_not_v128_u8,\n  binding.simdle_napi_not_v128_u16,\n  binding.simdle_napi_not_v128_u32\n)\n\nexports.or = binary(\n  binding.simdle_napi_or_v128_u8,\n  binding.simdle_napi_or_v128_u16,\n  binding.simdle_napi_or_v128_u32\n)\n\nexports.sum = reduce(\n  binding.simdle_napi_sum_v128_u8,\n  binding.simdle_napi_sum_v128_u16,\n  binding.simdle_napi_sum_v128_u32\n)\n\nexports.xor = binary(\n  binding.simdle_napi_xor_v128_u8,\n  binding.simdle_napi_xor_v128_u16,\n  binding.simdle_napi_xor_v128_u32\n)\n{\n  \"name\": \"simdle-native\",\n  \"version\": \"1.3.5\",\n  \"description\": \"libsimdle JavaScript bindings for Node.js\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"macros.h\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"npm run lint && npm run test:bare && npm run test:node\",\n    \"test:bare\": \"bare test.mjs\",\n    \"test:node\": \"node test.mjs\",\n    \"lint\": \"standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/simdle-native.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/simdle-native/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/simdle-native#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.0\",\n    \"node-gyp-build\": \"^4.8.2\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.0\",\n    \"cmake-bare\": \"^1.1.7\",\n    \"cmake-fetch\": \"^1.1.0\",\n    \"cmake-napi\": \"^1.0.2\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst b4a = require('b4a')\nconst scalar = require('./scalar')\n\nfunction view (buf, n) {\n  if (n === buf.BYTES_PER_ELEMENT) return buf\n\n  let TypedArray\n\n  if (n === 1) TypedArray = Uint8Array\n  else if (n === 2) TypedArray = Uint16Array\n  else TypedArray = Uint32Array\n\n  return new TypedArray(buf.buffer, buf.byteOffset, buf.byteLength / n)\n}\n\nfunction unary (u8, u16 = u8, u32 = u16) {\n  return function unary (buf, result = b4a.allocUnsafe(buf.byteLength)) {\n    if (buf.byteLength % 16 !== 0) {\n      throw new Error('Buffer length must be a multiple of 16')\n    }\n\n    if (buf.byteLength !== result.byteLength) {\n      throw new Error('Length of result buffer is insufficient')\n    }\n\n    const n = buf.BYTES_PER_ELEMENT\n\n    if (n === 1) u8(buf, view(result, n))\n    else if (n === 2) u16(buf, view(result, n))\n    else u32(buf, view(result, n))\n\n    return result\n  }\n}\n\nfunction binary (u8, u16 = u8, u32 = u16) {\n  return function binary (a, b, result = b4a.allocUnsafe(a.byteLength)) {\n    if (a.byteLength % 16 !== 0) {\n      throw new Error('Buffer length must be a multiple of 16')\n    }\n\n    if (a.byteLength !== b.byteLength || a.byteLength !== result.byteLength) {\n      throw new Error('Buffers must be the same length')\n    }\n\n    const n = a.BYTES_PER_ELEMENT\n\n    if (n === 1) u8(a, b, view(result, n))\n    else if (n === 2) u16(a, b, view(result, n))\n    else u32(a, b, view(result, n))\n\n    return result\n  }\n}\n\nfunction reduce (u8, u16 = u8, u32 = u16) {\n  return function reduce (buf) {\n    if (buf.byteLength % 16 !== 0) {\n      throw new Error('Buffer length must be a multiple of 16')\n    }\n\n    const n = buf.BYTES_PER_ELEMENT\n\n    if (n === 1) return u8(buf)\n    if (n === 2) return u16(buf)\n    return u32(buf)\n  }\n}\n\nexports.allo = function allo (buf) {\n  if (buf.byteLength % 16 !== 0) {\n    throw new Error('Buffer length must be a multiple of 16')\n  }\n\n  const m = 2 ** (buf.BYTES_PER_ELEMENT * 8) - 1\n\n  for (let i = 0, n = buf.length; i < n; i++) {\n    if (buf[i] !== m) return false\n  }\n\n  return true\n}\n\nexports.allz = function allz (buf) {\n  if (buf.byteLength % 16 !== 0) {\n    throw new Error('Buffer length must be a multiple of 16')\n  }\n\n  for (let i = 0, n = buf.length; i < n; i++) {\n    if (buf[i] !== 0) return false\n  }\n\n  return true\n}\n\nexports.and = binary(\n  (a, b, result) => {\n    for (let i = 0, n = result.length; i < n; i++) {\n      result[i] = a[i] & b[i]\n    }\n  }\n)\n\nexports.clear = binary(\n  (a, b, result) => {\n    for (let i = 0, n = result.length; i < n; i++) {\n      result[i] = a[i] & ~b[i]\n    }\n  }\n)\n\nexports.clo = unary(\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = 24 - scalar.clo(buf[i])\n    }\n  },\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = 16 - scalar.clo(buf[i])\n    }\n  },\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = scalar.clo(buf[i])\n    }\n  }\n)\n\nexports.clz = unary(\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = 24 - scalar.clz(buf[i])\n    }\n  },\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = 16 - scalar.clz(buf[i])\n    }\n  },\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = scalar.clz(buf[i])\n    }\n  }\n)\n\nexports.cnt = unary(\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = scalar.cnt(buf[i]) & 0xff\n    }\n  },\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = scalar.cnt(buf[i]) & 0xffff\n    }\n  },\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = scalar.cnt(buf[i])\n    }\n  }\n)\n\nexports.cto = unary(\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = Math.min(scalar.cto(buf[i]), 8)\n    }\n  },\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = Math.min(scalar.cto(buf[i]), 16)\n    }\n  },\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = scalar.cto(buf[i])\n    }\n  }\n)\n\nexports.ctz = unary(\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = Math.min(scalar.ctz(buf[i]), 8)\n    }\n  },\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = Math.min(scalar.ctz(buf[i]), 16)\n    }\n  },\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = scalar.ctz(buf[i])\n    }\n  }\n)\n\nexports.not = unary(\n  (buf, result) => {\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result[i] = ~buf[i]\n    }\n  }\n)\n\nexports.or = binary(\n  (a, b, result) => {\n    for (let i = 0, n = result.length; i < n; i++) {\n      result[i] = a[i] | b[i]\n    }\n  }\n)\n\nexports.sum = reduce(\n  (buf) => {\n    let result = 0n\n\n    for (let i = 0, n = buf.length; i < n; i++) {\n      result += BigInt(buf[i])\n    }\n\n    return result\n  }\n)\n\nexports.xor = binary(\n  (a, b, result) => {\n    for (let i = 0, n = result.length; i < n; i++) {\n      result[i] = a[i] ^ b[i]\n    }\n  }\n)\ntry {\n  module.exports = require('simdle-native')\n} catch {\n  module.exports = require('./fallback')\n}\n{\n  \"name\": \"simdle-universal\",\n  \"version\": \"1.1.2\",\n  \"description\": \"Universal wrapper for libsimdle with a JavaScript fallback\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"fallback.js\",\n    \"index.js\",\n    \"scalar.js\"\n  ],\n  \"browser\": {\n    \"./index.js\": \"./fallback.js\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/simdle-universal.git\"\n  },\n  \"author\": \"Kasper Isager Dalsgar <kasper@funktionel.co>\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/simdle-universal/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/simdle-universal#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.0\"\n  },\n  \"optionalDependencies\": {\n    \"simdle-native\": \"^1.1.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.0\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst clz = exports.clz = function clz (n) {\n  return Math.clz32(n)\n}\n\nexports.clo = function clo (n) {\n  return clz(~n)\n}\n\nconst ctz = exports.ctz = function ctz (n) {\n  return 32 - (n === 0 ? 0 : (clz(n & -n) + 1))\n}\n\nexports.cto = function cto (n) {\n  return ctz(~n)\n}\n\nexports.cnt = function cnt (n) {\n  n = n - ((n >>> 1) & 0x55555555)\n  n = (n & 0x33333333) + ((n >>> 2) & 0x33333333)\n  n = (n + (n >>> 4)) & 0x0f0f0f0f\n  n = (n * 0x01010101) >>> 24\n  return n\n}\nmodule.exports = require('node-gyp-build')(__dirname)\n{\n  \"name\": \"sodium-native\",\n  \"version\": \"4.3.1\",\n  \"description\": \"Low level bindings for libsodium\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"binding.c\",\n    \"macros.h\",\n    \"extensions\",\n    \"prebuilds\",\n    \"CMakeLists.txt\"\n  ],\n  \"addon\": true,\n  \"dependencies\": {\n    \"node-gyp-build\": \"^4.8.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.0\",\n    \"cmake-bare\": \"^1.1.10\",\n    \"cmake-fetch\": \"^1.0.1\",\n    \"cmake-napi\": \"^1.0.5\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"standard\": {\n    \"ignore\": [\n      \"/test/fixtures/*.js\"\n    ]\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/sodium-native.git\"\n  },\n  \"contributors\": [\n    \"Emil Bay <github@tixz.dk> (http://bayes.dk)\",\n    \"Mathias Buus <mathiasbuus@gmail.com> (https://mafinto.sh)\",\n    \"Christophe Diederichs <chm-diederichs@hyperdivision.dk>\"\n  ],\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/sodium-native/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/sodium-native\"\n}\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\n\nconst ABYTES = sodium.crypto_secretstream_xchacha20poly1305_ABYTES\nconst TAG_MESSAGE = sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE\nconst TAG_FINAL = sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\nconst STATEBYTES = sodium.crypto_secretstream_xchacha20poly1305_STATEBYTES\nconst HEADERBYTES = sodium.crypto_secretstream_xchacha20poly1305_HEADERBYTES\nconst KEYBYTES = sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES\nconst TAG_FINAL_BYTE = b4a.isBuffer(TAG_FINAL) ? TAG_FINAL[0] : TAG_FINAL\n\nconst EMPTY = b4a.alloc(0)\nconst TAG = b4a.alloc(1)\n\nclass Push {\n  constructor (key, state = b4a.allocUnsafeSlow(STATEBYTES), header = b4a.allocUnsafeSlow(HEADERBYTES)) {\n    if (!TAG_FINAL) throw new Error('JavaScript sodium version needs to support crypto_secretstream_xchacha20poly')\n\n    this.key = key\n    this.state = state\n    this.header = header\n\n    sodium.crypto_secretstream_xchacha20poly1305_init_push(this.state, this.header, this.key)\n  }\n\n  next (message, cipher = b4a.allocUnsafe(message.byteLength + ABYTES)) {\n    sodium.crypto_secretstream_xchacha20poly1305_push(this.state, cipher, message, null, TAG_MESSAGE)\n    return cipher\n  }\n\n  final (message = EMPTY, cipher = b4a.allocUnsafe(ABYTES)) {\n    sodium.crypto_secretstream_xchacha20poly1305_push(this.state, cipher, message, null, TAG_FINAL)\n    return cipher\n  }\n}\n\nclass Pull {\n  constructor (key, state = b4a.allocUnsafeSlow(STATEBYTES)) {\n    if (!TAG_FINAL) throw new Error('JavaScript sodium version needs to support crypto_secretstream_xchacha20poly')\n\n    this.key = key\n    this.state = state\n    this.final = false\n  }\n\n  init (header) {\n    sodium.crypto_secretstream_xchacha20poly1305_init_pull(this.state, header, this.key)\n  }\n\n  next (cipher, message = b4a.allocUnsafe(cipher.byteLength - ABYTES)) {\n    sodium.crypto_secretstream_xchacha20poly1305_pull(this.state, message, TAG, cipher, null)\n    this.final = TAG[0] === TAG_FINAL_BYTE\n    return message\n  }\n}\n\nfunction keygen (buf = b4a.alloc(KEYBYTES)) {\n  sodium.crypto_secretstream_xchacha20poly1305_keygen(buf)\n  return buf\n}\n\nmodule.exports = {\n  keygen,\n  KEYBYTES,\n  ABYTES,\n  STATEBYTES,\n  HEADERBYTES,\n  Push,\n  Pull\n}\n{\n  \"name\": \"sodium-secretstream\",\n  \"version\": \"1.1.1\",\n  \"description\": \"Wraps libsodiums secretstream in a higher level abstraction\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.1.1\",\n    \"sodium-universal\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^17.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/sodium-secretstream.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/sodium-secretstream/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/sodium-secretstream\"\n}\nmodule.exports = require('sodium-native')\n{\n  \"name\": \"sodium-universal\",\n  \"version\": \"4.0.1\",\n  \"description\": \"Universal wrapper for sodium-javascript and sodium-native working in Node.js and the Browser\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"sodium-native\": \"^4.0.0\"\n  },\n  \"peerDependencies\": {\n    \"sodium-javascript\": \"~0.8.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"sodium-javascript\": {\n      \"optional\": true\n    }\n  },\n  \"scripts\": {\n    \"prepublish\": \"./build-scripts/generate.js\"\n  },\n  \"browser\": {\n    \"sodium-native\": \"sodium-javascript\"\n  },\n  \"browserify\": {\n    \"transform\": [\n      \"./build-scripts/transform.js\"\n    ]\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/sodium-friends/sodium-universal.git\"\n  },\n  \"keywords\": [\n    \"libsodium\",\n    \"sodium\",\n    \"sodium-native\",\n    \"sodium-javascript\",\n    \"browserify\"\n  ],\n  \"author\": \"Emil Bay <github@tixz.dk>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/sodium-friends/sodium-universal/issues\"\n  },\n  \"homepage\": \"https://github.com/sodium-friends/sodium-universal#readme\"\n}\nconst { Readable } = require('streamx')\n\nmodule.exports = class SortedUnionStream extends Readable {\n  constructor (left, right, opts) {\n    super()\n\n    if (typeof opts === 'function') opts = { compare: opts }\n    if (!left.destroy || !right.destroy) throw new Error('Only modern stream supported')\n\n    this.left = new Peaker(left)\n    this.right = new Peaker(right)\n    this.compare = (opts && opts.compare) || defaultCompare\n\n    this._missing = 2\n    this._onclose = null\n    this._both = !!(opts && opts.both)\n    this._map = (opts && opts.map) || defaultMap\n\n    this._track(left)\n    this._track(right)\n  }\n\n  _read (cb) {\n    const self = this\n\n    this.left.read(function (err, l) {\n      if (err) return cb(err)\n      self.right.read(function (err, r) {\n        if (err) return cb(err)\n        self._readBoth(l, r, cb)\n      })\n    })\n  }\n\n  _readBoth (l, r, cb) {\n    if (l === null && r === null) {\n      this.push(null)\n      return cb(null)\n    }\n\n    if (l === null) {\n      this._push(null, r, cb)\n      return\n    }\n    if (r === null) {\n      this._push(l, null, cb)\n      return\n    }\n\n    const cmp = this.compare(l, r)\n\n    if (cmp === 0) {\n      this._push(l, r, cb)\n      return\n    }\n\n    if (cmp < 0) this._push(l, null, cb)\n    else this._push(null, r, cb)\n  }\n\n  _push (l, r, cb) {\n    const data = this._map(l, r)\n    const pushed = this.push(data)\n\n    if (this._both && l && r) this.push(data)\n\n    if (l !== null) this.left.consume()\n    if (r !== null) this.right.consume()\n\n    if (pushed) cb(null)\n    else this._read(cb)\n  }\n\n  _predestroy () {\n    this.left.destroy()\n    this.right.destroy()\n  }\n\n  _destroy (cb) {\n    if (!this.missing) return cb(null)\n    this._onclose = cb\n  }\n\n  _track (stream) {\n    const self = this\n    let closed = false\n\n    stream.on('error', onclose)\n    stream.on('close', onclose)\n\n    function onclose (err) {\n      if (err && typeof err === 'object') self.destroy(err)\n      if (closed) return\n      closed = true\n      if (!--self._missing && self._onclose) self._onclose()\n    }\n  }\n}\n\nclass Peaker {\n  constructor (stream) {\n    this.stream = stream\n    this.stream.on('readable', this._onreadable.bind(this))\n    this.stream.on('end', this._onend.bind(this))\n    this.value = null\n    this._reading = null\n    this._ended = false\n  }\n\n  read (cb) {\n    if (this.value) return cb(null, this.value)\n    this._reading = cb\n    this._onreadable()\n  }\n\n  consume () {\n    this.value = null\n  }\n\n  destroy () {\n    this._continue(new Error('Destroyed'), null)\n    this.stream.destroy()\n  }\n\n  _onend () {\n    this._ended = true\n    this._onreadable()\n  }\n\n  _continue (err, value) {\n    if (this._reading === null) return\n    const cb = this._reading\n    this._reading = null\n    cb(err, value)\n  }\n\n  _onreadable () {\n    if (this.value) return\n    this.value = this.stream.read()\n    if ((this.value !== null || this._ended)) {\n      this._continue(null, this.value)\n    }\n  }\n}\n\nfunction defaultCompare (a, b) {\n  return a < b ? -1 : a > b ? 1 : 0\n}\n\nfunction defaultMap (a, b) {\n  return a === null ? b : a\n}\n{\n  \"name\": \"sorted-union-stream\",\n  \"version\": \"3.2.3\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/mafintosh/sorted-union-stream.git\"\n  },\n  \"license\": \"MIT\",\n  \"description\": \"Get the union of two sorted streams\",\n  \"keywords\": [\n    \"union\",\n    \"sorted\",\n    \"stream\"\n  ],\n  \"author\": \"Mathias Buus Madsen <mathiasbuus@gmail.com>\",\n  \"scripts\": {\n    \"test\": \"tape test.js\"\n  },\n  \"dependencies\": {\n    \"streamx\": \"^2.6.0\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^14.3.1\",\n    \"tape\": \"^4.13.0\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/sorted-union-stream/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/sorted-union-stream\",\n  \"main\": \"index.js\"\n}\nvar tick = 1\nvar maxTick = 65535\nvar resolution = 4\nvar timer\nvar inc = function () {\n  tick = (tick + 1) & maxTick\n}\n\n\nmodule.exports = function (seconds) {\n  if (!timer) {\n    timer = setInterval(inc, (1000 / resolution) | 0)\n    if (timer.unref) timer.unref()\n  }\n\n  var size = resolution * (seconds || 5)\n  var buffer = [0]\n  var pointer = 1\n  var last = (tick - 1) & maxTick\n\n  return function (delta) {\n    var dist = (tick - last) & maxTick\n    if (dist > size) dist = size\n    last = tick\n\n    while (dist--) {\n      if (pointer === size) pointer = 0\n      buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1]\n      pointer++\n    }\n\n    if (delta) buffer[pointer - 1] += delta\n\n    var top = buffer[pointer - 1]\n    var btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer]\n\n    return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length\n  }\n}\n{\n  \"name\": \"speedometer\",\n  \"version\": \"1.1.0\",\n  \"repository\": \"git://github.com/mafintosh/speedometer\",\n  \"description\": \"simple speed measurement in javascript\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"speed\",\n    \"bytes\",\n    \"per\",\n    \"second\",\n    \"transfer\"\n  ],\n  \"author\": \"Mathias Buus Madsen <mathiasbuus@gmail.com>\"\n}\nconst { EventEmitter } = require('events')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\nconst READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueMicrotask(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTickIfOpen () {\n    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueMicrotask(this.afterUpdateNextTick)\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueMicrotask(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isDisturbed (stream) {\n  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  isDisturbed,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n{\n  \"name\": \"streamx\",\n  \"version\": \"2.22.0\",\n  \"description\": \"An iteration of the Node.js core streams with a series of improvements\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"fast-fifo\": \"^1.3.2\",\n    \"text-decoder\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"b4a\": \"^1.6.6\",\n    \"brittle\": \"^3.1.1\",\n    \"end-of-stream\": \"^1.4.4\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"optionalDependencies\": {\n    \"bare-events\": \"^2.2.0\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/streamx.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/streamx/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/streamx\"\n}\nconst codecs = require('codecs')\nconst b = require('b4a')\n\nconst SEP = b.alloc(1)\nconst SEP_BUMPED = b.from([0x1])\nconst EMPTY = b.alloc(0)\n\nmodule.exports = class SubEncoder {\n  constructor (prefix, encoding, parent = null) {\n    this.userEncoding = codecs(encoding)\n    this.prefix = prefix != null ? createPrefix(prefix, parent) : null\n    this.lt = this.prefix && b.concat([this.prefix.subarray(0, this.prefix.byteLength - 1), SEP_BUMPED])\n  }\n\n  _encodeRangeUser (r) {\n    if (this.userEncoding.encodeRange) return this.userEncoding.encodeRange(r)\n\n    const res = {}\n    if (r.gt != null) res.gt = this.userEncoding.encode(r.gt)\n    if (r.gte != null) res.gte = this.userEncoding.encode(r.gte)\n    if (r.lte != null) res.lte = this.userEncoding.encode(r.lte)\n    if (r.lt != null) res.lt = this.userEncoding.encode(r.lt)\n\n    return res\n  }\n\n  _addPrefix (key) {\n    return this.prefix ? b.concat([this.prefix, key]) : key\n  }\n\n  encode (key) {\n    return this._addPrefix(this.userEncoding.encode(key))\n  }\n\n  encodeRange (range) {\n    const r = this._encodeRangeUser(range)\n\n    if (r.gt) r.gt = this._addPrefix(r.gt)\n    else if (r.gte) r.gte = this._addPrefix(r.gte)\n    else if (this.prefix) r.gte = this.prefix\n\n    if (r.lt) r.lt = this._addPrefix(r.lt)\n    else if (r.lte) r.lte = this._addPrefix(r.lte)\n    else if (this.prefix) r.lt = this.lt\n\n    return r\n  }\n\n  decode (key) {\n    return this.userEncoding.decode(this.prefix ? key.subarray(this.prefix.byteLength) : key)\n  }\n\n  sub (prefix, encoding) {\n    return new SubEncoder(prefix || EMPTY, compat(encoding), this.prefix)\n  }\n}\n\nfunction createPrefix (prefix, parent) {\n  prefix = typeof prefix === 'string' ? b.from(prefix) : prefix\n\n  if (prefix && parent) return b.concat([parent, prefix, SEP])\n  if (prefix) return b.concat([prefix, SEP])\n  if (parent) return b.concat([parent, SEP])\n  return SEP\n}\n\nfunction compat (enc) {\n  if (enc && enc.keyEncoding) return enc.keyEncoding\n  return enc\n}\n{\n  \"name\": \"sub-encoder\",\n  \"version\": \"2.1.3\",\n  \"description\": \"Generate sub encodings for key/value stores\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/sub-encoder.git\"\n  },\n  \"keywords\": [\n    \"kv-store\",\n    \"encoding\",\n    \"hyperbee\"\n  ],\n  \"author\": \"Andrew Osheroff <andrewosh@gmail.com>\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/sub-encoder/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/sub-encoder#readme\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.1\",\n    \"compact-encoding\": \"^2.12.0\",\n    \"hyperbee\": \"^2.11.0\",\n    \"hypercore\": \"^10.3.2\",\n    \"index-encoder\": \"^3.0.0\",\n    \"random-access-memory\": \"^6.0.0\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.6.0\",\n    \"codecs\": \"^3.1.0\"\n  }\n}\nconst PassThroughDecoder = require('./lib/pass-through-decoder')\nconst UTF8Decoder = require('./lib/utf8-decoder')\n\nmodule.exports = class TextDecoder {\n  constructor (encoding = 'utf8') {\n    this.encoding = normalizeEncoding(encoding)\n\n    switch (this.encoding) {\n      case 'utf8':\n        this.decoder = new UTF8Decoder()\n        break\n      case 'utf16le':\n      case 'base64':\n        throw new Error('Unsupported encoding: ' + this.encoding)\n      default:\n        this.decoder = new PassThroughDecoder(this.encoding)\n    }\n  }\n\n  get remaining () {\n    return this.decoder.remaining\n  }\n\n  push (data) {\n    if (typeof data === 'string') return data\n    return this.decoder.decode(data)\n  }\n\n  // For Node.js compatibility\n  write (data) {\n    return this.push(data)\n  }\n\n  end (data) {\n    let result = ''\n    if (data) result = this.push(data)\n    result += this.decoder.flush()\n    return result\n  }\n}\n\nfunction normalizeEncoding (encoding) {\n  encoding = encoding.toLowerCase()\n\n  switch (encoding) {\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8'\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return 'utf16le'\n    case 'latin1':\n    case 'binary':\n      return 'latin1'\n    case 'base64':\n    case 'ascii':\n    case 'hex':\n      return encoding\n    default:\n      throw new Error('Unknown encoding: ' + encoding)\n  }\n};\nconst b4a = require('b4a')\n\nmodule.exports = class PassThroughDecoder {\n  constructor (encoding) {\n    this.encoding = encoding\n  }\n\n  get remaining () {\n    return 0\n  }\n\n  decode (tail) {\n    return b4a.toString(tail, this.encoding)\n  }\n\n  flush () {\n    return ''\n  }\n}\nconst b4a = require('b4a')\n\n/**\n * https://encoding.spec.whatwg.org/#utf-8-decoder\n */\nmodule.exports = class UTF8Decoder {\n  constructor () {\n    this.codePoint = 0\n    this.bytesSeen = 0\n    this.bytesNeeded = 0\n    this.lowerBoundary = 0x80\n    this.upperBoundary = 0xbf\n  }\n\n  get remaining () {\n    return this.bytesSeen\n  }\n\n  decode (data) {\n    // If we have a fast path, just sniff if the last part is a boundary\n    if (this.bytesNeeded === 0) {\n      let isBoundary = true\n\n      for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++) {\n        isBoundary = data[i] <= 0x7f\n      }\n\n      if (isBoundary) return b4a.toString(data, 'utf8')\n    }\n\n    let result = ''\n\n    for (let i = 0, n = data.byteLength; i < n; i++) {\n      const byte = data[i]\n\n      if (this.bytesNeeded === 0) {\n        if (byte <= 0x7f) {\n          result += String.fromCharCode(byte)\n        } else {\n          this.bytesSeen = 1\n\n          if (byte >= 0xc2 && byte <= 0xdf) {\n            this.bytesNeeded = 2\n            this.codePoint = byte & 0x1f\n          } else if (byte >= 0xe0 && byte <= 0xef) {\n            if (byte === 0xe0) this.lowerBoundary = 0xa0\n            else if (byte === 0xed) this.upperBoundary = 0x9f\n            this.bytesNeeded = 3\n            this.codePoint = byte & 0xf\n          } else if (byte >= 0xf0 && byte <= 0xf4) {\n            if (byte === 0xf0) this.lowerBoundary = 0x90\n            if (byte === 0xf4) this.upperBoundary = 0x8f\n            this.bytesNeeded = 4\n            this.codePoint = byte & 0x7\n          } else {\n            result += '\\ufffd'\n          }\n        }\n\n        continue\n      }\n\n      if (byte < this.lowerBoundary || byte > this.upperBoundary) {\n        this.codePoint = 0\n        this.bytesNeeded = 0\n        this.bytesSeen = 0\n        this.lowerBoundary = 0x80\n        this.upperBoundary = 0xbf\n\n        result += '\\ufffd'\n\n        continue\n      }\n\n      this.lowerBoundary = 0x80\n      this.upperBoundary = 0xbf\n\n      this.codePoint = (this.codePoint << 6) | (byte & 0x3f)\n      this.bytesSeen++\n\n      if (this.bytesSeen !== this.bytesNeeded) continue\n\n      result += String.fromCodePoint(this.codePoint)\n\n      this.codePoint = 0\n      this.bytesNeeded = 0\n      this.bytesSeen = 0\n    }\n\n    return result\n  }\n\n  flush () {\n    const result = this.bytesNeeded > 0 ? '\\ufffd' : ''\n\n    this.codePoint = 0\n    this.bytesNeeded = 0\n    this.bytesSeen = 0\n    this.lowerBoundary = 0x80\n    this.upperBoundary = 0xbf\n\n    return result\n  }\n}\n{\n  \"name\": \"text-decoder\",\n  \"version\": \"1.2.3\",\n  \"description\": \"Streaming text decoder that preserves multibyte Unicode characters\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib\"\n  ],\n  \"browser\": {\n    \"./lib/pass-through-decoder.js\": \"./lib/browser-decoder.js\",\n    \"./lib/utf8-decoder.js\": \"./lib/browser-decoder.js\"\n  },\n  \"react-native\": {\n    \"./lib/pass-through-decoder.js\": \"./lib/pass-through-decoder.js\",\n    \"./lib/utf8-decoder.js\": \"./lib/utf8-decoder.js\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/text-decoder.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/text-decoder/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/text-decoder#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.4\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nmodule.exports = class TimeOrderedSet {\n  constructor () {\n    this.oldest = null\n    this.latest = null\n    this.length = 0\n  }\n\n  has (node) {\n    return !!(node.next || node.prev) || node === this.oldest\n  }\n\n  add (node) {\n    if (this.has(node)) this.remove(node)\n\n    if (!this.latest && !this.oldest) {\n      this.latest = this.oldest = node\n      node.prev = node.next = null\n    } else {\n      this.latest.next = node\n      node.prev = this.latest\n      node.next = null\n      this.latest = node\n    }\n\n    this.length++\n\n    return node\n  }\n\n  remove (node) {\n    if (!this.has(node)) return node\n\n    if (this.oldest !== node && this.latest !== node) {\n      node.prev.next = node.next\n      node.next.prev = node.prev\n    } else {\n      if (this.oldest === node) {\n        this.oldest = node.next\n        if (this.oldest) this.oldest.prev = null\n      }\n      if (this.latest === node) {\n        this.latest = node.prev\n        if (this.latest) this.latest.next = null\n      }\n    }\n\n    node.next = node.prev = null\n    this.length--\n\n    return node\n  }\n\n  toArray ({ limit = Infinity, reverse = false } = {}) {\n    const list = []\n\n    if (reverse) {\n      let node = this.latest\n      while (node && limit--) {\n        list.push(node)\n        node = node.prev\n      }\n    } else {\n      let node = this.oldest\n      while (node && limit--) {\n        list.push(node)\n        node = node.next\n      }\n    }\n\n    return list\n  }\n}\n{\n  \"name\": \"time-ordered-set\",\n  \"version\": \"2.0.1\",\n  \"description\": \"Efficiently maintain a set of nodes ordered by the time they were added to the set\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.0\",\n    \"standard\": \"^17.1.2\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/time-ordered-set.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/time-ordered-set/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/time-ordered-set\"\n}\nmodule.exports = class TimerBrowser {\n  constructor (ms, fn, ctx = null, interval = false) {\n    this.ms = ms\n    this.ontimeout = fn\n    this.context = ctx || null\n    this.interval = interval\n    this.done = false\n\n    this._timer = interval\n      ? setInterval(callInterval, ms, this)\n      : setTimeout(callTimeout, ms, this)\n  }\n\n  unref () {}\n\n  ref () {}\n\n  refresh () {\n    if (this.done) return\n\n    if (this.interval) {\n      clearInterval(this._timer)\n      this._timer = setInterval(callInterval, this.ms, this)\n    } else {\n      clearTimeout(this._timer)\n      this._timer = setTimeout(callTimeout, this.ms, this)\n    }\n  }\n\n  destroy () {\n    this.done = true\n    this.ontimeout = null\n\n    if (this.interval) clearInterval(this._timer)\n    else clearTimeout(this._timer)\n  }\n\n  static once (ms, fn, ctx) {\n    return new this(ms, fn, ctx, false)\n  }\n\n  static on (ms, fn, ctx) {\n    return new this(ms, fn, ctx, true)\n  }\n}\n\nfunction callTimeout (self) {\n  self.done = true\n  self.ontimeout.call(self.context)\n}\n\nfunction callInterval (self) {\n  self.ontimeout.call(self.context)\n}\nmodule.exports = isNode()\n  ? require('./node')\n  : require('./browser')\n\nfunction isNode () {\n  const to = setTimeout(function () {}, 1000)\n  clearTimeout(to)\n  return !!to.refresh\n}\nmodule.exports = class Timer {\n  constructor (ms, fn, ctx = null, interval = false) {\n    this.ms = ms\n    this.ontimeout = fn\n    this.context = ctx\n    this.interval = interval\n    this.done = false\n\n    this._timer = interval\n      ? setInterval(callInterval, ms, this)\n      : setTimeout(callTimeout, ms, this)\n  }\n\n  unref () {\n    this._timer.unref()\n  }\n\n  ref () {\n    this._timer.ref()\n  }\n\n  refresh () {\n    if (this.done !== true) this._timer.refresh()\n  }\n\n  destroy () {\n    this.done = true\n    this.ontimeout = null\n    if (this.interval) clearInterval(this._timer)\n    else clearTimeout(this._timer)\n  }\n\n  static once (ms, fn, ctx) {\n    return new this(ms, fn, ctx, false)\n  }\n\n  static on (ms, fn, ctx) {\n    return new this(ms, fn, ctx, true)\n  }\n}\n\nfunction callTimeout (self) {\n  self.done = true\n  self.ontimeout.call(self.context)\n}\n\nfunction callInterval (self) {\n  self.ontimeout.call(self.context)\n}\n{\n  \"name\": \"timeout-refresh\",\n  \"version\": \"2.0.1\",\n  \"description\": \"Efficiently refresh a timer\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^16.0.4\",\n    \"tape\": \"^5.5.2\"\n  },\n  \"browser\": \"./browser.js\",\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/timeout-refresh.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/timeout-refresh/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/timeout-refresh\"\n}\nconst b4a = require('b4a')\n\nmodule.exports = class BufferMap {\n  constructor (other) {\n    this.m = other ? new Map([...other.m]) : new Map()\n  }\n\n  get size () {\n    return this.m.size\n  }\n\n  get (key) {\n    if (b4a.isBuffer(key)) key = b4a.toString(key, 'hex')\n    return this.m.get(key)\n  }\n\n  set (key, value) {\n    if (b4a.isBuffer(key)) key = b4a.toString(key, 'hex')\n    return this.m.set(key, value)\n  }\n\n  delete (key) {\n    if (b4a.isBuffer(key)) key = b4a.toString(key, 'hex')\n    return this.m.delete(key)\n  }\n\n  has (key) {\n    if (b4a.isBuffer(key)) key = b4a.toString(key, 'hex')\n    return this.m.has(key)\n  }\n\n  * [Symbol.iterator] () {\n    for (const [key, value] of this.m) {\n      yield [b4a.from(key, 'hex'), value]\n    }\n  }\n\n  * keys () {\n    for (const key of this.m.keys()) {\n      yield b4a.from(key, 'hex')\n    }\n  }\n\n  values () {\n    return this.m.values()\n  }\n\n  clear () {\n    return this.m.clear()\n  }\n}\n{\n  \"name\": \"tiny-buffer-map\",\n  \"version\": \"1.1.1\",\n  \"description\": \"A very simple map for Buffers\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/andrewosh/tiny-buffer-map.git\"\n  },\n  \"keywords\": [\n    \"buffer\",\n    \"map\"\n  ],\n  \"author\": \"Andrew Osheroff <andrewosh@gmail.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/andrewosh/tiny-buffer-map/issues\"\n  },\n  \"homepage\": \"https://github.com/andrewosh/tiny-buffer-map#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.4\"\n  }\n}\n// This file is a tmp workaround until variadic args land in tiny-buffer-rpc\n\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\nconst { uint, utf8 } = c\n\nconst anyUndefined = {\n  preencode (state, n) {\n    // do nothing\n  },\n  encode (state, n) {\n    // do nothing\n  },\n  decode (state) {\n    return undefined\n  }\n}\n\n// \"any\" encoders here for helping just structure any object without schematising it\n\nconst anyArray = {\n  preencode (state, arr) {\n    uint.preencode(state, arr.length)\n    for (let i = 0; i < arr.length; i++) {\n      any.preencode(state, arr[i])\n    }\n  },\n  encode (state, arr) {\n    uint.encode(state, arr.length)\n    for (let i = 0; i < arr.length; i++) {\n      any.encode(state, arr[i])\n    }\n  },\n  decode (state) {\n    const arr = []\n    let len = uint.decode(state)\n    while (len-- > 0) {\n      arr.push(any.decode(state))\n    }\n    return arr\n  }\n}\n\nconst anyObject = {\n  preencode (state, o) {\n    const keys = Object.keys(o)\n    uint.preencode(state, keys.length)\n    for (const key of keys) {\n      utf8.preencode(state, key)\n      any.preencode(state, o[key])\n    }\n  },\n  encode (state, o) {\n    const keys = Object.keys(o)\n    uint.encode(state, keys.length)\n    for (const key of keys) {\n      utf8.encode(state, key)\n      any.encode(state, o[key])\n    }\n  },\n  decode (state) {\n    let len = uint.decode(state)\n    const o = {}\n    while (len-- > 0) {\n      const key = utf8.decode(state)\n      o[key] = any.decode(state)\n    }\n    return o\n  }\n}\n\nconst anyTypes = [\n  c.none,\n  anyUndefined,\n  c.bool,\n  c.string,\n  c.buffer,\n  c.uint,\n  c.int,\n  c.float64,\n  anyArray,\n  anyObject\n]\n\nconst any = module.exports = {\n  preencode (state, o) {\n    const t = getType(o)\n    uint.preencode(state, t)\n    anyTypes[t].preencode(state, o)\n  },\n  encode (state, o) {\n    const t = getType(o)\n    uint.encode(state, t)\n    anyTypes[t].encode(state, o)\n  },\n  decode (state) {\n    const t = uint.decode(state)\n    if (t >= anyTypes.length) throw new Error('Unknown type: ' + t)\n    return anyTypes[t].decode(state)\n  }\n}\n\nfunction getType (o) {\n  if (o === null) return 0\n  if (o === undefined) return 1\n  if (typeof o === 'boolean') return 2\n  if (typeof o === 'string') return 3\n  if (b4a.isBuffer(o)) return 4\n  if (typeof o === 'number') {\n    if (Number.isInteger(o)) return o >= 0 ? 5 : 6\n    return 7\n  }\n  if (Array.isArray(o)) return 8\n  if (typeof o === 'object') return 9\n\n  throw new Error('Unsupported type for ' + o)\n}\nconst { getStreamError, Duplex } = require('streamx')\nconst c = require('compact-encoding')\nconst safetyCatch = require('safety-catch')\nconst b4a = require('b4a')\n\n// Primary message flags (4 bits)\nconst MESSAGE_SEND = 0b0001\nconst MESSAGE_REQUEST = 0b0010\nconst MESSAGE_RESPONSE = 0b0100\nconst MESSAGE_ERROR = 0b1000\n\n// Stream message flags (6 bits, with a 4 bit offset for primary message flags)\nconst STREAMING_MASK = ((1 << 6) - 1) << 4\nconst STREAM_OPEN = 0b000001 << 4\nconst STREAM_CLOSE = 0b000010 << 4\nconst STREAM_PAUSE = 0b000100 << 4\nconst STREAM_RESUME = 0b001000 << 4\nconst STREAM_DATA = 0b010000 << 4\nconst STREAM_END = 0b100000 << 4\n\n// Stream status flags (2 bits, with a 10 bit offset)\nconst STREAM_IS_INITIATOR = 0b01 << 10\nconst STREAM_HAS_ERROR = 0b10 << 10\n\nconst REQUEST = MESSAGE_SEND | MESSAGE_REQUEST\n\nconst {\n  Header,\n  Message,\n  ErrorMessage\n} = require('./messages.js')\n\nclass Request {\n  constructor (method, id, type, data) {\n    this.type = type\n    this.id = id\n    this.method = method\n    this.sent = false\n    this.data = data\n  }\n\n  _respond (data) {\n    if (this._sent) throw new Error('Response already sent')\n    this.sent = true\n    this.method._rpc._sendMessage({\n      bitfield: MESSAGE_RESPONSE,\n      id: this.id,\n      method: this.method._method,\n      data: c.encode(this.method._response, data)\n    })\n  }\n\n  _error (err) {\n    if (this._sent) throw new Error('Response already sent')\n    this.sent = true\n    this.method._rpc._sendMessage({\n      bitfield: MESSAGE_ERROR,\n      id: this.id,\n      method: this.method._method,\n      data: c.encode(ErrorMessage, err)\n    })\n  }\n}\n\nclass RPCStream extends Duplex {\n  constructor (method, id, initiator, remoteId) {\n    super({ eagerOpen: true })\n\n    this._method = method\n    this._initiator = initiator\n\n    this._localId = id\n    this._remoteId = remoteId\n\n    this._remotePaused = true\n    this._sentPause = false\n    this._sentOpen = false\n    this._initiatedDestroy = false\n\n    this._writeBatch = null\n    this._writeCallback = null\n    this._openCallback = null\n  }\n\n  _sendBatch (batch) {\n    const bitfield = MESSAGE_SEND | STREAM_DATA\n    const dataEncoding = this._initiator ? this._method._responseArray : this._method._requestArray\n    const data = c.encode(dataEncoding, batch)\n    this._method._sendMessage(this._remoteId, bitfield, data)\n  }\n\n  _remoteOpened (remoteId) {\n    this._remoteId = remoteId\n    this._continueOpen(null)\n  }\n\n  _remoteClosed (err) {\n    this._remoteId = -1\n    this.destroy(err)\n  }\n\n  _remotePause () {\n    this._remotePaused = true\n  }\n\n  _remoteResume () {\n    this._remotePaused = false\n    if (!this._writeBatch) return\n\n    this._sendBatch(this._writeBatch)\n    this._writeBatch = null\n    this._continueWrite(null)\n  }\n\n  _sendOpen () {\n    if (this._sentOpen) return\n\n    let bitfield = MESSAGE_SEND | STREAM_OPEN\n    if (this._initiator) bitfield |= STREAM_IS_INITIATOR\n\n    const id = this._initiator ? this._localId : this._remoteId\n    const data = this._initiator ? null : c.encode(c.uint, this._localId)\n\n    this._sentOpen = true\n    this._method._sendMessage(id, bitfield, data)\n  }\n\n  _open (cb) {\n    this._sendOpen()\n\n    if (this._initiator) {\n      this._openCallback = cb\n    } else {\n      cb()\n    }\n  }\n\n  _continueOpen (err) {\n    if (this._openCallback === null) return\n    const cb = this._openCallback\n    this._openCallback = null\n    cb(err)\n  }\n\n  _read (cb) {\n    this._method._sendMessage(this._remoteId, MESSAGE_SEND | STREAM_RESUME)\n    cb()\n  }\n\n  _writev (batch, cb) {\n    if (this._remotePaused) {\n      this._writeBatch = batch\n      this._writeCallback = cb\n    } else {\n      this._sendBatch(batch)\n      cb()\n    }\n  }\n\n  _continueWrite (err) {\n    if (this._writeCallback === null) return\n    const cb = this._writeCallback\n    this._writeCallback = null\n    cb(err)\n  }\n\n  _final (cb) {\n    this._method._sendMessage(this._remoteId, MESSAGE_SEND | STREAM_END)\n    cb()\n  }\n\n  _predestroy () {\n    this._initiatedDestroy = true\n    this._continueWrite(null)\n  }\n\n  _destroy (cb) {\n    if (this._remoteId === -1 || this._initiatedDestroy === false || this._method.destroyed) {\n      // if the remote side already sent a close or we are the initiator and we didn't open,\n      // then we don't need to send a close message\n      cb()\n      return\n    }\n\n    const err = getStreamError(this)\n\n    let bitfield = MESSAGE_SEND | STREAM_CLOSE\n    if (err) bitfield |= STREAM_HAS_ERROR\n    const data = err ? c.encode(ErrorMessage, err) : null\n\n    this._method._sendMessage(this._remoteId, bitfield, data)\n    cb()\n  }\n}\n\nclass Method {\n  constructor (rpc, method, { request, response, onrequest, onstream } = {}) {\n    this.destroyed = false\n\n    this._rpc = rpc\n    this._method = method\n\n    this._request = request || c.buffer\n    this._response = response || c.buffer\n    this._requestArray = c.array(this._request)\n    this._responseArray = c.array(this._response)\n\n    this._onrequest = onrequest\n    this._onstream = onstream\n\n    this._streams = []\n    this._free = []\n  }\n\n  async _callOnRequest (req) {\n    try {\n      const data = await this._onrequest(req.data)\n      req._respond(data)\n    } catch (err) {\n      req._error(err)\n    }\n  }\n\n  async _callOnSend (data) {\n    try {\n      await this._onrequest(data)\n    } catch (err) {\n      safetyCatch(err)\n    }\n  }\n\n  _createStream (initiator, remoteId) {\n    const id = this._free.length ? this._free.pop() : (this._streams.push(null) - 1)\n    const stream = new RPCStream(this, id, initiator, remoteId)\n    this._streams[id] = stream\n    return stream\n  }\n\n  _handleStreamOpen (id, bitfield, state) {\n    if (bitfield & STREAM_IS_INITIATOR) {\n      // Create the responder stream\n      const stream = this._createStream(false, id)\n      this._onstream(stream)\n    } else {\n      const stream = this._streams[id]\n      stream._remoteOpened(c.uint.decode(state))\n    }\n  }\n\n  _handleStreamClose (id, bitfield, state) {\n    const stream = this._streams[id]\n    if (bitfield & STREAM_HAS_ERROR) {\n      const err = ErrorMessage.decode(state)\n      stream._remoteClosed(err)\n    } else {\n      stream._remoteClosed(null)\n    }\n    this._streams[id] = null\n    this._free.push(id)\n  }\n\n  _handleStreamPause (id) {\n    const stream = this._streams[id]\n    if (stream) stream._remotePause()\n  }\n\n  _handleStreamResume (id) {\n    const stream = this._streams[id]\n    if (stream) stream._remoteResume()\n  }\n\n  _handleStreamEnd (id) {\n    const stream = this._streams[id]\n    if (stream) stream.push(null)\n  }\n\n  _handleStreamData (id, state) {\n    const stream = this._streams[id]\n    if (!stream) return\n\n    let data = null\n    if (stream._initiator) {\n      data = this._responseArray.decode(state)\n    } else {\n      data = this._requestArray.decode(state)\n    }\n\n    // TODO: Should we buffer the remainder of the array?\n    let stop = false\n    for (const item of data) {\n      stop = stream.push(item)\n    }\n\n    if (stop === false) {\n      if (!stream._sentPause) {\n        stream._sentPause = true\n        this._sendMessage(stream._remoteId, MESSAGE_SEND | STREAM_PAUSE)\n      }\n    }\n  }\n\n  _handleStreamSend (id, bitfield, state) {\n    if (bitfield & STREAM_OPEN) {\n      this._handleStreamOpen(id, bitfield, state)\n    } else if (bitfield & STREAM_CLOSE) {\n      this._handleStreamClose(id, bitfield, state)\n    } else if (bitfield & STREAM_PAUSE) {\n      this._handleStreamPause(id)\n    } else if (bitfield & STREAM_RESUME) {\n      this._handleStreamResume(id)\n    } else if (bitfield & STREAM_DATA) {\n      this._handleStreamData(id, state)\n    } else if (bitfield & STREAM_END) {\n      this._handleStreamEnd(id)\n    }\n  }\n\n  _handleSend (id, bitfield, state) {\n    if (bitfield & STREAMING_MASK) {\n      this._handleStreamSend(id, bitfield, state)\n    } else {\n      this._callOnSend(this._request.decode(state))\n    }\n  }\n\n  _handleRequest (id, bitfield, state) {\n    if (this.destroyed) return\n    if (bitfield & MESSAGE_SEND) {\n      this._handleSend(id, bitfield, state)\n    } else {\n      const req = new Request(this, id, bitfield, this._request.decode(state))\n      this._callOnRequest(req)\n    }\n  }\n\n  _handleResponse (req, bitfield, state) {\n    if (this.destroyed) return\n    if (bitfield & MESSAGE_ERROR) {\n      const { errno, message, stack, code } = ErrorMessage.decode(state)\n      const err = new Error()\n      err.errno = errno\n      err.message = message\n      err.stack = stack\n      err.code = code\n      req.reject(err)\n    } else {\n      req.resolve(this._response.decode(state))\n    }\n    this._rpc._reqs[req.id] = null\n    this._rpc._free.push(req.id)\n  }\n\n  _sendMessage (id, bitfield, data) {\n    this._rpc._sendMessage({\n      method: this._method,\n      bitfield,\n      id,\n      data\n    })\n  }\n\n  request (data) {\n    if (this.destroyed) return Promise.reject(new Error('RPC destroyed'))\n    const req = this._rpc._createRequest()\n    this._sendMessage(req.id, MESSAGE_REQUEST, c.encode(this._request, data))\n    return req.promise\n  }\n\n  send (data) {\n    if (this.destroyed) return\n    this._sendMessage(0, MESSAGE_SEND, c.encode(this._request, data))\n  }\n\n  createRequestStream () {\n    if (this.destroyed) throw new Error('RPC destroyed')\n    return this._createStream(true, -1)\n  }\n\n  destroy () {\n    this.destroyed = true\n    for (const s of this._streams) {\n      if (s === null) continue\n      s.destroy(new Error('RPC destroyed'))\n    }\n  }\n}\n\nmodule.exports = class TinyBufferRPC {\n  constructor (send) {\n    this.destroyed = false\n    this._send = send\n    this._handlers = []\n    this._pending = []\n    this._reqs = []\n    this._free = []\n    this._corked = false\n  }\n\n  _createRequest () {\n    const id = this._free.length ? this._free.pop() : (this._reqs.push(null) - 1)\n    const req = { id, promise: null, resolve: null, reject: null }\n    this._reqs[id] = req\n    req.promise = new Promise((resolve, reject) => {\n      req.resolve = resolve\n      req.reject = reject\n    })\n    return req\n  }\n\n  _sendMessage (msg) {\n    if (this.destroyed) return\n    const data = c.encode(Message, msg)\n    if (this._corked) {\n      this._pending.push(data)\n      return\n    }\n    this._send(data)\n  }\n\n  register (id, opts = {}) {\n    if (this._handlers[id]) throw new Error('Handler for this ID already exists')\n    while (this._handlers.length <= id) this._handlers.push(null)\n    const method = new Method(this, id, opts)\n    this._handlers[id] = method\n    return method\n  }\n\n  cork () {\n    this._corked = true\n  }\n\n  uncork () {\n    this._corked = false\n    // TODO: Use a slab pattern here to avoid the concat\n    if (!this.destroyed) this._send(b4a.concat(this._pending))\n    this._pending = []\n  }\n\n  recv (buf) {\n    const state = { start: 0, end: buf.length, buffer: buf }\n    while (state.start < state.end) {\n      const { id, bitfield, method } = Header.decode(state)\n      if (bitfield & REQUEST) {\n        const handler = this._handlers[method]\n        if (!handler) throw new Error('Got a request for an unsupported method')\n        else handler._handleRequest(id, bitfield, state)\n      } else {\n        const req = this._reqs[id]\n        const handler = this._handlers[method]\n        if (!req) throw new Error('Got a response for an invalid request ID')\n        if (!handler) throw new Error('Got a response for an invalid method ID')\n        handler._handleResponse(req, bitfield, state)\n      }\n    }\n  }\n\n  destroy () {\n    this.destroyed = true\n    while (this._reqs.length) {\n      const req = this._reqs.pop()\n      if (req === null) continue\n      req.reject(new Error('RPC destroyed'))\n    }\n    for (const h of this._handlers) {\n      if (h === null) continue\n      h.destroy()\n    }\n  }\n}\nconst c = require('compact-encoding')\n\nconst KNOWN_BYTE = 0x74 // 't' for tiny-buffer-rpc\n\nconst Header = {\n  preencode (state, h) {\n    c.uint.preencode(state, KNOWN_BYTE)\n    c.uint.preencode(state, h.method)\n    c.uint.preencode(state, h.id)\n    c.uint.preencode(state, h.bitfield)\n  },\n  encode (state, h) {\n    c.uint.encode(state, KNOWN_BYTE)\n    c.uint.encode(state, h.method)\n    c.uint.encode(state, h.id)\n    c.uint.encode(state, h.bitfield)\n  },\n  decode (state) {\n    const known = c.uint.decode(state)\n    if (known !== KNOWN_BYTE) throw Error('Message does not look like a TinyRPC message')\n\n    return {\n      method: c.uint.decode(state),\n      id: c.uint.decode(state),\n      bitfield: c.uint.decode(state)\n    }\n  }\n}\nmodule.exports.Header = Header\n\nmodule.exports.Message = {\n  preencode (state, m) {\n    Header.preencode(state, m)\n    if (m.data) c.raw.preencode(state, m.data)\n  },\n  encode (state, m) {\n    Header.encode(state, m)\n    if (m.data) c.raw.encode(state, m.data)\n  },\n  decode (state) {\n    return {\n      ...Header.decode(state),\n      data: c.raw.decode(state)\n    }\n  }\n}\n\nmodule.exports.ErrorMessage = {\n  preencode (state, e) {\n    state.end++ // flags\n    c.int.preencode(state, e.errno || 0)\n    if (e.message) c.string.preencode(state, e.message)\n    if (e.stack) c.string.preencode(state, e.stack)\n    if (e.code) c.string.preencode(state, e.code)\n  },\n  encode (state, e) {\n    const start = state.start++ // flags\n    c.int.encode(state, e.errno || 0)\n\n    let flags = 0\n    if (e.message) {\n      flags |= 1\n      c.string.encode(state, e.message)\n    }\n    if (e.stack) {\n      flags |= 2\n      c.string.encode(state, e.stack)\n    }\n    if (e.code) {\n      flags |= 4\n      c.string.encode(state, e.code)\n    }\n\n    state.buffer[start] = flags\n  },\n  decode (state) {\n    const flags = c.uint.decode(state)\n    return {\n      errno: c.int.decode(state),\n      message: (flags & 1) !== 0 ? c.string.decode(state) : null,\n      stack: (flags & 2) !== 0 ? c.string.decode(state) : null,\n      code: (flags & 4) !== 0 ? c.string.decode(state) : null\n    }\n  }\n}\n{\n  \"name\": \"tiny-buffer-rpc\",\n  \"version\": \"2.2.2\",\n  \"description\": \"Lightweight binary RPC\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/tiny-buffer-rpc.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/tiny-buffer-rpc/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/tiny-buffer-rpc#readme\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.2.1\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.6.3\",\n    \"compact-encoding\": \"^2.11.0\",\n    \"safety-catch\": \"^1.0.2\",\n    \"streamx\": \"^2.13.2\"\n  }\n}\nmodule.exports = require('node-gyp-build')(__dirname)\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`\nconst IPv4Pattern = new RegExp(`^${v4Str}$`)\n\nconst v6Seg = '(?:[0-9a-fA-F]{1,4})'\nconst IPv6Pattern = new RegExp('^(' +\n  `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` +\n  `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` +\n  `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` +\n  `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` +\n  `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` +\n  `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` +\n')(%[0-9a-zA-Z-.:]{1,})?$')\n\nconst isIPv4 = exports.isIPv4 = function isIPv4 (host) {\n  return IPv4Pattern.test(host)\n}\n\nconst isIPv6 = exports.isIPv6 = function isIPv6 (host) {\n  return IPv6Pattern.test(host)\n}\n\nexports.isIP = function isIP (host) {\n  if (isIPv4(host)) return 4\n  if (isIPv6(host)) return 6\n  return 0\n}\nconst events = require('events')\nconst b4a = require('b4a')\nconst binding = require('../binding')\n\nmodule.exports = class NetworkInterfaces extends events.EventEmitter {\n  constructor (udx) {\n    super()\n\n    this._handle = b4a.allocUnsafe(binding.sizeof_udx_napi_interface_event_t)\n    this._watching = false\n    this._destroying = null\n\n    binding.udx_napi_interface_event_init(udx._handle, this._handle, this,\n      this._onevent,\n      this._onclose\n    )\n\n    this.interfaces = binding.udx_napi_interface_event_get_addrs(this._handle)\n  }\n\n  _onclose () {\n    this.emit('close')\n  }\n\n  _onevent () {\n    this.interfaces = binding.udx_napi_interface_event_get_addrs(this._handle)\n\n    this.emit('change', this.interfaces)\n  }\n\n  watch () {\n    if (this._watching) return this\n    this._watching = true\n\n    binding.udx_napi_interface_event_start(this._handle)\n\n    return this\n  }\n\n  unwatch () {\n    if (!this._watching) return this\n    this._watching = false\n\n    binding.udx_napi_interface_event_stop(this._handle)\n\n    return this\n  }\n\n  async destroy () {\n    if (this._destroying) return this._destroying\n    this._destroying = events.once(this, 'close')\n\n    binding.udx_napi_interface_event_close(this._handle)\n\n    return this._destroying\n  }\n\n  [Symbol.iterator] () {\n    return this.interfaces[Symbol.iterator]()\n  }\n}\nconst events = require('events')\nconst b4a = require('b4a')\nconst binding = require('../binding')\nconst ip = require('./ip')\n\nmodule.exports = class UDXSocket extends events.EventEmitter {\n  constructor (udx, opts = {}) {\n    super()\n\n    this.udx = udx\n\n    this._handle = b4a.allocUnsafe(binding.sizeof_udx_napi_socket_t)\n    this._inited = false\n    this._host = null\n    this._family = 0\n    this._ipv6Only = opts.ipv6Only === true\n    this._reuseAddress = opts.reuseAddress === true\n    this._port = 0\n    this._reqs = []\n    this._free = []\n    this._closing = null\n    this._closed = false\n\n    this._view64 = new BigUint64Array(this._handle.buffer, this._handle.byteOffset, this._handle.byteLength >> 3)\n\n    this.streams = new Set()\n\n    this.userData = null\n  }\n\n  get bound () {\n    return this._port !== 0\n  }\n\n  get closing () {\n    return this._closing !== null\n  }\n\n  get idle () {\n    return this.streams.size === 0\n  }\n\n  get busy () {\n    return this.streams.size > 0\n  }\n\n  get bytesTransmitted () {\n    if (this._inited !== true) return 0\n    return Number(this._view64[binding.offsetof_udx_socket_t_bytes_tx >> 3])\n  }\n\n  get packetsTransmitted () {\n    if (this._inited !== true) return 0\n    return Number(this._view64[binding.offsetof_udx_socket_t_packets_tx >> 3])\n  }\n\n  get bytesReceived () {\n    if (this._inited !== true) return 0\n    return Number(this._view64[binding.offsetof_udx_socket_t_bytes_rx >> 3])\n  }\n\n  get packetsReceived () {\n    if (this._inited !== true) return 0\n    return Number(this._view64[binding.offsetof_udx_socket_t_packets_rx >> 3])\n  }\n\n  get packetsDroppedByKernel () {\n    if (this._inited !== true) return 0\n    return Number(this._view64[binding.offsetof_udx_socket_t_packets_dropped_by_kernel >> 3])\n  }\n\n  toJSON () {\n    return {\n      bound: this.bound,\n      closing: this.closing,\n      streams: this.streams.size,\n      address: this.address(),\n      ipv6Only: this._ipv6Only,\n      reuseAddress: this._reuseAddress,\n      idle: this.idle,\n      busy: this.busy\n    }\n  }\n\n  _init () {\n    if (this._inited) return\n\n    binding.udx_napi_socket_init(this.udx._handle, this._handle, this,\n      this._onsend,\n      this._onmessage,\n      this._onclose,\n      this._reallocMessage\n    )\n\n    this._inited = true\n  }\n\n  _onsend (id, err) {\n    const req = this._reqs[id]\n\n    const onflush = req.onflush\n\n    req.buffer = null\n    req.onflush = null\n\n    this._free.push(id)\n\n    onflush(err >= 0)\n\n    // gc the free list\n    if (this._free.length >= 16 && this._free.length === this._reqs.length) {\n      this._free = []\n      this._reqs = []\n    }\n  }\n\n  _onmessage (len, port, host, family) {\n    this.emit('message', this.udx._consumeMessage(len), { host, family, port })\n    return this.udx._buffer\n  }\n\n  _onclose () {\n    this.emit('close')\n  }\n\n  _reallocMessage () {\n    return this.udx._reallocMessage()\n  }\n\n  _onidle () {\n    this.emit('idle')\n  }\n\n  _onbusy () {\n    this.emit('busy')\n  }\n\n  _addStream (stream) {\n    if (this.streams.has(stream)) return false\n    this.streams.add(stream)\n    if (this.streams.size === 1) this._onbusy()\n    return true\n  }\n\n  _removeStream (stream) {\n    if (!this.streams.has(stream)) return false\n    this.streams.delete(stream)\n    const closed = this._closeMaybe()\n    if (this.idle && !closed) this._onidle()\n    return true\n  }\n\n  address () {\n    if (!this.bound) return null\n    return { host: this._host, family: this._family, port: this._port }\n  }\n\n  bind (port, host) {\n    if (this.bound) throw new Error('Already bound')\n    if (this.closing) throw new Error('Socket is closed')\n\n    if (!port) port = 0\n\n    let flags = 0\n    if (this._ipv6Only) flags |= binding.UV_UDP_IPV6ONLY\n    if (this._reuseAddress) flags |= binding.UV_UDP_REUSEADDR\n\n    let family\n\n    if (host) {\n      family = ip.isIP(host)\n      if (!family) throw new Error(`${host} is not a valid IP address`)\n\n      if (!this._inited) this._init()\n\n      this._port = binding.udx_napi_socket_bind(this._handle, port, host, family, flags)\n    } else {\n      if (!this._inited) this._init()\n\n      try {\n        host = '::'\n        family = 6\n        this._port = binding.udx_napi_socket_bind(this._handle, port, host, family, flags)\n      } catch {\n        host = '0.0.0.0'\n        family = 4\n        this._port = binding.udx_napi_socket_bind(this._handle, port, host, family, flags)\n      }\n    }\n\n    this._host = host\n    this._family = family\n\n    this.emit('listening')\n  }\n\n  async close () {\n    if (this._closing) return this._closing\n    this._closing = new Promise(resolve => this.once('close', resolve))\n    this._closeMaybe()\n    return this._closing\n  }\n\n  _closeMaybe () {\n    if (this._closed || this._closing === null) return this._closed\n\n    if (!this._inited) {\n      this._closed = true\n      this.emit('close')\n      return true\n    }\n\n    if (this.idle) {\n      binding.udx_napi_socket_close(this._handle)\n      this._closed = true\n    }\n\n    return this._closed\n  }\n\n  setTTL (ttl) {\n    if (!this._inited) throw new Error('Socket not active')\n    binding.udx_napi_socket_set_ttl(this._handle, ttl)\n  }\n\n  getRecvBufferSize () {\n    if (!this._inited) throw new Error('Socket not active')\n    return binding.udx_napi_socket_get_recv_buffer_size(this._handle)\n  }\n\n  setRecvBufferSize (size) {\n    if (!this._inited) throw new Error('Socket not active')\n    return binding.udx_napi_socket_set_recv_buffer_size(this._handle, size)\n  }\n\n  getSendBufferSize () {\n    if (!this._inited) throw new Error('Socket not active')\n    return binding.udx_napi_socket_get_send_buffer_size(this._handle)\n  }\n\n  setSendBufferSize (size) {\n    if (!this._inited) throw new Error('Socket not active')\n    return binding.udx_napi_socket_set_send_buffer_size(this._handle, size)\n  }\n\n  addMembership (group, ifaceAddress) {\n    if (!this._inited) throw new Error('Socket not active')\n    return binding.udx_napi_socket_set_membership(this._handle, group, ifaceAddress || '', true)\n  }\n\n  dropMembership (group, ifaceAddress) {\n    if (!this._inited) throw new Error('Socket not active')\n    return binding.udx_napi_socket_set_membership(this._handle, group, ifaceAddress || '', false)\n  }\n\n  async send (buffer, port, host, ttl) {\n    if (this.closing) return false\n\n    if (!host) host = '127.0.0.1'\n\n    const family = ip.isIP(host)\n    if (!family) throw new Error(`${host} is not a valid IP address`)\n\n    if (!this.bound) this.bind(0)\n\n    const id = this._allocSend()\n    const req = this._reqs[id]\n\n    req.buffer = buffer\n\n    const promise = new Promise((resolve) => {\n      req.onflush = resolve\n    })\n\n    binding.udx_napi_socket_send_ttl(this._handle, req.handle, id, buffer, port, host, family, ttl || 0)\n\n    return promise\n  }\n\n  trySend (buffer, port, host, ttl) {\n    if (this.closing) return\n\n    if (!host) host = '127.0.0.1'\n\n    const family = ip.isIP(host)\n    if (!family) throw new Error(`${host} is not a valid IP address`)\n\n    if (!this.bound) this.bind(0)\n\n    const id = this._allocSend()\n    const req = this._reqs[id]\n\n    req.buffer = buffer\n    req.onflush = noop\n\n    binding.udx_napi_socket_send_ttl(this._handle, req.handle, id, buffer, port, host, family, ttl || 0)\n  }\n\n  _allocSend () {\n    if (this._free.length > 0) return this._free.pop()\n    const handle = b4a.allocUnsafe(binding.sizeof_udx_socket_send_t)\n    return this._reqs.push({ handle, buffer: null, onflush: null }) - 1\n  }\n}\n\nfunction noop () {}\nconst streamx = require('streamx')\nconst b4a = require('b4a')\nconst binding = require('../binding')\nconst ip = require('./ip')\n\nconst MAX_PACKET = 2048\nconst BUFFER_SIZE = 65536 + MAX_PACKET\n\nmodule.exports = class UDXStream extends streamx.Duplex {\n  constructor (udx, id, opts = {}) {\n    super({ mapWritable: toBuffer, eagerOpen: true })\n\n    this.udx = udx\n    this.socket = null\n\n    this._handle = b4a.allocUnsafe(binding.sizeof_udx_napi_stream_t)\n    this._view = new Uint32Array(this._handle.buffer, this._handle.byteOffset, this._handle.byteLength >> 2)\n    this._view16 = new Uint16Array(this._handle.buffer, this._handle.byteOffset, this._handle.byteLength >> 1)\n    this._view64 = new BigUint64Array(this._handle.buffer, this._handle.byteOffset, this._handle.byteLength >> 3)\n\n    this._wreqs = []\n    this._wfree = []\n\n    this._sreqs = []\n    this._sfree = []\n    this._closed = false\n\n    this._flushing = 0\n    this._flushes = []\n\n    this._buffer = null\n    this._reallocData()\n\n    this._onwrite = null\n    this._ondestroy = null\n    this._firewall = opts.firewall || firewallAll\n\n    this._remoteChanging = null\n    this._previousSocket = null\n\n    this.id = id\n    this.remoteId = 0\n    this.remoteHost = null\n    this.remoteFamily = 0\n    this.remotePort = 0\n\n    this.userData = null\n\n    binding.udx_napi_stream_init(this.udx._handle, this._handle, id, opts.framed ? 1 : 0, this,\n      this._ondata,\n      this._onend,\n      this._ondrain,\n      this._onack,\n      this._onsend,\n      this._onmessage,\n      this._onclose,\n      this._onfirewall,\n      this._onremotechanged,\n      this._reallocData,\n      this._reallocMessage\n    )\n\n    if (opts.seq) binding.udx_napi_stream_set_seq(this._handle, opts.seq)\n\n    binding.udx_napi_stream_recv_start(this._handle, this._buffer)\n  }\n\n  get connected () {\n    return this.socket !== null\n  }\n\n  get mtu () {\n    return this._view16[binding.offsetof_udx_stream_t_mtu >> 1]\n  }\n\n  get rtt () {\n    return this._view[binding.offsetof_udx_stream_t_srtt >> 2]\n  }\n\n  get cwnd () {\n    return this._view[binding.offsetof_udx_stream_t_cwnd >> 2]\n  }\n\n  get rtoCount () {\n    return this._view16[binding.offsetof_udx_stream_t_rto_count >> 1]\n  }\n\n  get retransmits () {\n    return this._view16[binding.offsetof_udx_stream_t_retransmit_count >> 1]\n  }\n\n  get fastRecoveries () {\n    return this._view16[binding.offsetof_udx_stream_t_fast_recovery_count >> 1]\n  }\n\n  get inflight () {\n    return this._view[binding.offsetof_udx_stream_t_inflight >> 2]\n  }\n\n  get bytesTransmitted () {\n    return Number(this._view64[binding.offsetof_udx_stream_t_bytes_tx >> 3])\n  }\n\n  get packetsTransmitted () {\n    return Number(this._view64[binding.offsetof_udx_stream_t_packets_tx >> 3])\n  }\n\n  get bytesReceived () {\n    return Number(this._view64[binding.offsetof_udx_stream_t_bytes_rx >> 3])\n  }\n\n  get packetsReceived () {\n    return Number(this._view64[binding.offsetof_udx_stream_t_packets_rx >> 3])\n  }\n\n  get localHost () {\n    return this.socket ? this.socket.address().host : null\n  }\n\n  get localFamily () {\n    return this.socket ? this.socket.address().family : 0\n  }\n\n  get localPort () {\n    return this.socket ? this.socket.address().port : 0\n  }\n\n  setInteractive (bool) {\n    if (!this._closed) return\n    binding.udx_napi_stream_set_mode(this._handle, bool ? 0 : 1)\n  }\n\n  connect (socket, remoteId, port, host, opts = {}) {\n    if (this._closed) return\n\n    if (this.connected) throw new Error('Already connected')\n    if (socket.closing) throw new Error('Socket is closed')\n\n    if (typeof host === 'object') {\n      opts = host\n      host = null\n    }\n\n    if (!host) host = '127.0.0.1'\n\n    const family = ip.isIP(host)\n    if (!family) throw new Error(`${host} is not a valid IP address`)\n    if (!(port > 0 && port < 65536)) throw new Error(`${port} is not a valid port`)\n\n    if (!socket.bound) socket.bind(0)\n\n    this.remoteId = remoteId\n    this.remotePort = port\n    this.remoteHost = host\n    this.remoteFamily = family\n    this.socket = socket\n\n    if (opts.ack) binding.udx_napi_stream_set_ack(this._handle, opts.ack)\n\n    binding.udx_napi_stream_connect(this._handle, socket._handle, remoteId, port, host, family)\n\n    this.socket._addStream(this)\n\n    this.emit('connect')\n  }\n\n  changeRemote (socket, remoteId, port, host) {\n    if (this._remoteChanging) throw new Error('Remote already changing')\n\n    if (!this.connected) throw new Error('Not yet connected')\n    if (socket.closing) throw new Error('Socket is closed')\n\n    if (this.socket.udx !== socket.udx) {\n      throw new Error('Cannot change to a socket on another UDX instance')\n    }\n\n    if (!host) host = '127.0.0.1'\n\n    const family = ip.isIP(host)\n    if (!family) throw new Error(`${host} is not a valid IP address`)\n    if (!(port > 0 && port < 65536)) throw new Error(`${port} is not a valid port`)\n\n    if (this.socket !== socket) this._previousSocket = this.socket\n\n    this.remoteId = remoteId\n    this.remotePort = port\n    this.remoteHost = host\n    this.remoteFamily = family\n    this.socket = socket\n\n    this._remoteChanging = new Promise((resolve, reject) => {\n      const onchanged = () => {\n        this.off('close', onclose)\n        resolve()\n      }\n\n      const onclose = () => {\n        this.off('remote-changed', onchanged)\n        reject(new Error('Stream is closed'))\n      }\n\n      this\n        .once('remote-changed', onchanged)\n        .once('close', onclose)\n    })\n\n    binding.udx_napi_stream_change_remote(this._handle, socket._handle, remoteId, port, host, family)\n\n    this.socket._addStream(this)\n\n    return this._remoteChanging\n  }\n\n  relayTo (destination) {\n    if (this._closed) return\n\n    binding.udx_napi_stream_relay_to(this._handle, destination._handle)\n  }\n\n  async send (buffer) {\n    if (!this.connected || this._closed) return false\n\n    const id = this._allocSend()\n    const req = this._sreqs[id]\n\n    req.buffer = buffer\n\n    const promise = new Promise((resolve) => {\n      req.onflush = resolve\n    })\n\n    binding.udx_napi_stream_send(this._handle, req.handle, id, buffer)\n\n    return promise\n  }\n\n  trySend (buffer) {\n    if (!this.connected || this._closed) return\n\n    const id = this._allocSend()\n    const req = this._sreqs[id]\n\n    req.buffer = buffer\n    req.onflush = noop\n\n    binding.udx_napi_stream_send(this._handle, req.handle, id, buffer)\n  }\n\n  async flush () {\n    if ((await streamx.Writable.drained(this)) === false) return false\n    if (this.destroying) return false\n\n    const missing = this._wreqs.length - this._wfree.length\n    if (missing === 0) return true\n\n    return new Promise((resolve) => {\n      this._flushes.push({ flush: this._flushing++, missing, resolve })\n    })\n  }\n\n  toJSON () {\n    return {\n      id: this.id,\n      connected: this.connected,\n      destroying: this.destroying,\n      destroyed: this.destroyed,\n      remoteId: this.remoteId,\n      remoteHost: this.remoteHost,\n      remoteFamily: this.remoteFamily,\n      remotePort: this.remotePort,\n      mtu: this.mtu,\n      rtt: this.rtt,\n      cwnd: this.cwnd,\n      inflight: this.inflight,\n      socket: this.socket ? this.socket.toJSON() : null\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  _writeContinue (err) {\n    if (this._onwrite === null) return\n    const cb = this._onwrite\n    this._onwrite = null\n    cb(err)\n  }\n\n  _destroyContinue (err) {\n    if (this._ondestroy === null) return\n    const cb = this._ondestroy\n    this._ondestroy = null\n    cb(err)\n  }\n\n  _writev (buffers, cb) {\n    if (!this.connected) throw customError('Writing while not connected not currently supported', 'ERR_ASSERTION')\n\n    let drained = true\n\n    if (buffers.length === 1) {\n      const id = this._allocWrite(1)\n      const req = this._wreqs[id]\n\n      req.flush = this._flushing\n      req.buffer = buffers[0]\n\n      drained = binding.udx_napi_stream_write(this._handle, req.handle, id, req.buffer) !== 0\n    } else {\n      const id = this._allocWrite(nextBatchSize(buffers.length))\n      const req = this._wreqs[id]\n\n      req.flush = this._flushing\n      req.buffers = buffers\n\n      drained = binding.udx_napi_stream_writev(this._handle, req.handle, id, req.buffers) !== 0\n    }\n\n    if (drained) cb(null)\n    else this._onwrite = cb\n  }\n\n  _final (cb) {\n    const id = this._allocWrite(1)\n    const req = this._wreqs[id]\n\n    req.flush = this._flushes\n    req.buffer = b4a.allocUnsafe(0)\n\n    const drained = binding.udx_napi_stream_write_end(this._handle, req.handle, id, req.buffer) !== 0\n\n    if (drained) cb(null)\n    else this._onwrite = cb\n  }\n\n  _predestroy () {\n    if (!this._closed) binding.udx_napi_stream_destroy(this._handle)\n    this._closed = true\n    this._writeContinue(null)\n  }\n\n  _destroy (cb) {\n    if (this.connected) this._ondestroy = cb\n    else cb(null)\n  }\n\n  _ondata (read) {\n    this.push(this._consumeData(read))\n    return this._buffer\n  }\n\n  _onend (read) {\n    if (read > 0) this.push(this._consumeData(read))\n    this.push(null)\n  }\n\n  _ondrain () {\n    this._writeContinue(null)\n  }\n\n  _flushAck (flush) {\n    for (let i = this._flushes.length - 1; i >= 0; i--) {\n      const f = this._flushes[i]\n      if (f.flush < flush) break\n      f.missing--\n    }\n\n    while (this._flushes.length > 0 && this._flushes[0].missing === 0) {\n      this._flushes.shift().resolve(true)\n    }\n  }\n\n  _onack (id) {\n    const req = this._wreqs[id]\n\n    req.buffers = req.buffer = null\n    this._wfree.push(id)\n\n    if (this._flushes.length > 0) this._flushAck(req.flush)\n\n    // gc the free list\n    if (this._wfree.length >= 64 && this._wfree.length === this._wreqs.length) {\n      this._wfree = []\n      this._wreqs = []\n    }\n  }\n\n  _onsend (id, err) {\n    const req = this._sreqs[id]\n\n    const onflush = req.onflush\n\n    req.buffer = null\n    req.onflush = null\n\n    this._sfree.push(id)\n\n    onflush(err >= 0)\n\n    // gc the free list\n    if (this._sfree.length >= 16 && this._sfree.length === this._sreqs.length) {\n      this._sfree = []\n      this._sreqs = []\n    }\n  }\n\n  _onmessage (len) {\n    this.emit('message', this.udx._consumeMessage(len))\n    return this.udx._buffer\n  }\n\n  _onclose (err) {\n    this._closed = true\n\n    if (this.socket) {\n      this.socket._removeStream(this)\n      this.socket = null\n    }\n\n    if (this._previousSocket) {\n      this._previousSocket._removeStream(this)\n      this._previousSocket = null\n    }\n\n    // no error, we don't need to do anything\n    if (!err) return this._destroyContinue(null)\n\n    if (this._ondestroy === null) this.destroy(err)\n    else this._destroyContinue(err)\n  }\n\n  _onfirewall (socket, port, host, family) {\n    return this._firewall(socket, port, host, family) ? 1 : 0\n  }\n\n  _onremotechanged () {\n    if (this._previousSocket) {\n      this._previousSocket._removeStream(this)\n      this._previousSocket = null\n    }\n\n    this._remoteChanging = null\n    this.emit('remote-changed')\n  }\n\n  _consumeData (len) {\n    const next = this._buffer.subarray(0, len)\n    this._buffer = this._buffer.subarray(len)\n    if (this._buffer.byteLength < MAX_PACKET) this._reallocData()\n    return next\n  }\n\n  _reallocData () {\n    this._buffer = b4a.allocUnsafe(BUFFER_SIZE)\n    return this._buffer\n  }\n\n  _reallocMessage () {\n    return this.udx._reallocMessage()\n  }\n\n  _allocWrite (size) {\n    if (this._wfree.length === 0) {\n      const handle = b4a.allocUnsafe(binding.udx_napi_stream_write_sizeof(size))\n      return this._wreqs.push({ handle, size, buffers: null, buffer: null, flush: 0 }) - 1\n    }\n\n    const free = this._wfree.pop()\n    if (size === 1) return free\n\n    const next = this._wreqs[free]\n    if (next.size < size) {\n      next.handle = b4a.allocUnsafe(binding.udx_napi_stream_write_sizeof(size))\n      next.size = size\n    }\n\n    return free\n  }\n\n  _allocSend () {\n    if (this._sfree.length > 0) return this._sfree.pop()\n    const handle = b4a.allocUnsafe(binding.sizeof_udx_stream_send_t)\n    return this._sreqs.push({ handle, buffer: null, resolve: null, reject: null }) - 1\n  }\n}\n\nfunction noop () {}\n\nfunction toBuffer (data) {\n  return typeof data === 'string' ? b4a.from(data) : data\n}\n\nfunction firewallAll (socket, port, host) {\n  return true\n}\n\nfunction customError (message, code) {\n  const error = new Error(message)\n  error.code = code\n  return error\n}\n\nfunction nextBatchSize (n) { // try to coerce the the writevs into sameish size\n  if (n === 1) return 1\n  // group all < 8 to the same size, low mem overhead but save some small allocs\n  if (n < 8) return 8\n  if (n < 16) return 16\n  if (n < 32) return 32\n  if (n < 64) return 64\n  return n\n}\nconst b4a = require('b4a')\nconst binding = require('../binding')\nconst ip = require('./ip')\nconst Socket = require('./socket')\nconst Stream = require('./stream')\nconst NetworkInterfaces = require('./network-interfaces')\n\nconst MAX_MESSAGE = 4096\nconst BUFFER_SIZE = 65536 + MAX_MESSAGE\n\nmodule.exports = class UDX {\n  constructor () {\n    this._handle = b4a.allocUnsafe(binding.sizeof_udx_napi_t)\n    this._watchers = new Set()\n    this._view64 = new BigUint64Array(this._handle.buffer, this._handle.byteOffset, this._handle.byteLength >> 3)\n\n    this._buffer = null\n    this._reallocMessage()\n\n    binding.udx_napi_init(this._handle, this._buffer)\n  }\n\n  static isIPv4 (host) {\n    return ip.isIPv4(host)\n  }\n\n  static isIPv6 (host) {\n    return ip.isIPv6(host)\n  }\n\n  static isIP (host) {\n    return ip.isIP(host)\n  }\n\n  get bytesTransmitted () {\n    return Number(this._view64[binding.offsetof_udx_t_bytes_tx >> 3])\n  }\n\n  get packetsTransmitted () {\n    return Number(this._view64[binding.offsetof_udx_t_packets_tx >> 3])\n  }\n\n  get bytesReceived () {\n    return Number(this._view64[binding.offsetof_udx_t_bytes_rx >> 3])\n  }\n\n  get packetsReceived () {\n    return Number(this._view64[binding.offsetof_udx_t_packets_rx >> 3])\n  }\n\n  get packetsDroppedByKernel () {\n    return Number(this._view64[binding.offsetof_udx_t_packets_dropped_by_kernel >> 3])\n  }\n\n  _consumeMessage (len) {\n    const next = this._buffer.subarray(0, len)\n    this._buffer = this._buffer.subarray(len)\n    if (this._buffer.byteLength < MAX_MESSAGE) this._reallocMessage()\n    return next\n  }\n\n  _reallocMessage () {\n    this._buffer = b4a.allocUnsafe(BUFFER_SIZE)\n    return this._buffer\n  }\n\n  createSocket (opts) {\n    return new Socket(this, opts)\n  }\n\n  createStream (id, opts) {\n    return new Stream(this, id, opts)\n  }\n\n  networkInterfaces () {\n    let [watcher = null] = this._watchers\n    if (watcher) return watcher.interfaces\n\n    watcher = new NetworkInterfaces(this)\n    watcher.destroy()\n\n    return watcher.interfaces\n  }\n\n  watchNetworkInterfaces (onchange) {\n    const watcher = new NetworkInterfaces(this)\n\n    this._watchers.add(watcher)\n    watcher.on('close', () => {\n      this._watchers.delete(watcher)\n    })\n\n    if (onchange) watcher.on('change', onchange)\n\n    return watcher.watch()\n  }\n\n  async lookup (host, opts = {}) {\n    const {\n      family = 0\n    } = opts\n\n    const req = b4a.allocUnsafe(binding.sizeof_udx_napi_lookup_t)\n    const ctx = {\n      req,\n      resolve: null,\n      reject: null\n    }\n\n    const promise = new Promise((resolve, reject) => {\n      ctx.resolve = resolve\n      ctx.reject = reject\n    })\n\n    binding.udx_napi_lookup(this._handle, req, host, family, ctx, onlookup)\n\n    return promise\n  }\n}\n\nfunction onlookup (err, host, family) {\n  if (err) this.reject(err)\n  else this.resolve({ host, family })\n}\n{\n  \"name\": \"udx-native\",\n  \"version\": \"1.17.3\",\n  \"description\": \"udx is reliable, multiplexed, and congestion-controlled streams over udp\",\n  \"main\": \"lib/udx.js\",\n  \"files\": [\n    \"lib\",\n    \"prebuilds\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"npm run lint && npm run test:bare && npm run test:node\",\n    \"test:node\": \"node test/all.js\",\n    \"test:bare\": \"bare test/all.js\",\n    \"test:all\": \"brittle test/*.js test/slow/*.js\",\n    \"test:generate\": \"brittle -r test/all.js test/*.js\",\n    \"bench\": \"brittle test/bench/*.js\",\n    \"lint\": \"standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/udx-native.git\"\n  },\n  \"keywords\": [\n    \"tcp\",\n    \"udp\",\n    \"stream\",\n    \"reliable\"\n  ],\n  \"author\": \"Holepunch Inc.\",\n  \"license\": \"Apache-2.0\",\n  \"gypfile\": true,\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/udx-native/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/udx-native#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.5.0\",\n    \"bare-events\": \"^2.2.0\",\n    \"node-gyp-build\": \"^4.4.0\",\n    \"streamx\": \"^2.14.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.0\",\n    \"cmake-bare\": \"^1.1.10\",\n    \"cmake-fetch\": \"^1.0.1\",\n    \"cmake-napi\": \"^1.0.5\",\n    \"is-ci\": \"^3.0.1\",\n    \"standard\": \"^17.1.0\",\n    \"tiny-byte-size\": \"^1.1.0\"\n  }\n}\nmodule.exports = resolve\n\nfunction parse (addr) {\n  const names = addr.split(/[/\\\\]/)\n\n  const r = {\n    isAbsolute: false,\n    names\n  }\n\n  // don't think this ever happens, but whatevs\n  if (names.length === 0) return r\n\n  if (names.length > 1 && names[0].endsWith(':')) {\n    r.isAbsolute = true\n\n    if (names[0].length === 2) { // windows\n      r.names = names.slice(1)\n      return r\n    }\n\n    if (names[0] === 'file:') {\n      r.names = names.slice(1)\n      return r\n    }\n\n    r.names = names.slice(3)\n    return r\n  }\n\n  r.isAbsolute = addr.startsWith('/') || addr.startsWith('\\\\')\n\n  return r\n}\n\nfunction resolve (a, b = '') {\n  const ap = parse(a)\n  const bp = parse(b)\n\n  if (bp.isAbsolute) {\n    return resolveNames([], bp.names)\n  }\n\n  if (!ap.isAbsolute) {\n    throw new Error('One of the two paths must be absolute')\n  }\n\n  return resolveNames(ap.names, bp.names)\n}\n\nfunction toString (p, names) {\n  for (let i = 0; i < names.length; i++) {\n    if (names[i] === '') continue\n    if (names[i] === '.') continue\n    if (names[i] === '..') {\n      if (p.length === 1) throw new Error('Path cannot be resolved, too many \\'..\\'')\n      p = p.slice(0, p.lastIndexOf('/')) || '/'\n      continue\n    }\n    p += (p.length === 1 ? names[i] : '/' + names[i])\n  }\n\n  return p\n}\n\nfunction resolveNames (a, b) {\n  return toString(toString('/', a), b)\n}\n{\n  \"name\": \"unix-path-resolve\",\n  \"version\": \"1.0.2\",\n  \"description\": \"Cross platform resolve that always returns a UNIX style `/` seperated path\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"brittle\": \"^2.0.1\",\n    \"standard\": \"^16.0.4\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/unix-path-resolve.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/unix-path-resolve/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/unix-path-resolve\"\n}\nexports.add = add\nexports.has = has\nexports.remove = remove\nexports.swap = swap\n\nfunction add (list, item) {\n  if (has(list, item)) return item\n  item._index = list.length\n  list.push(item)\n  return item\n}\n\nfunction has (list, item) {\n  return item._index < list.length && list[item._index] === item\n}\n\nfunction remove (list, item) {\n  if (!has(list, item)) return null\n\n  var last = list.pop()\n  if (last !== item) {\n    list[item._index] = last\n    last._index = item._index\n  }\n\n  return item\n}\n\nfunction swap (list, a, b) {\n  if (!has(list, a) || !has(list, b)) return\n  var tmp = a._index\n  a._index = b._index\n  list[a._index] = a\n  b._index = tmp\n  list[b._index] = b\n}\n{\n  \"name\": \"unordered-set\",\n  \"version\": \"2.0.1\",\n  \"description\": \"A couple of functions that make it easy to maintain an unordered set as an array in an efficient way\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^6.0.4\",\n    \"tape\": \"^4.4.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/unordered-set.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/unordered-set/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/unordered-set\"\n}\nconst b4a = require('b4a')\n\nunslab.all = all\nunslab.is = is\n\nmodule.exports = unslab\n\nfunction unslab (buf) {\n  if (buf === null || buf.buffer.byteLength === buf.byteLength) return buf\n  const copy = b4a.allocUnsafeSlow(buf.byteLength)\n  copy.set(buf, 0)\n  return copy\n}\n\nfunction is (buf) {\n  return buf.buffer.byteLength !== buf.byteLength\n}\n\nfunction all (list) {\n  let size = 0\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i]\n    size += buf === null || buf.buffer.byteLength === buf.byteLength ? 0 : buf.byteLength\n  }\n\n  const copy = b4a.allocUnsafeSlow(size)\n  const result = new Array(list.length)\n\n  let offset = 0\n  for (let i = 0; i < list.length; i++) {\n    let buf = list[i]\n\n    if (buf !== null && buf.buffer.byteLength !== buf.byteLength) {\n      copy.set(buf, offset)\n      buf = copy.subarray(offset, offset += buf.byteLength)\n    }\n\n    result[i] = buf\n  }\n\n  return result\n}\n{\n  \"name\": \"unslab\",\n  \"version\": \"1.3.0\",\n  \"description\": \"Unslab some slab'ed buffers\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {\n    \"b4a\": \"^1.6.6\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.2\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/unslab.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/unslab/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/unslab\"\n}\nmodule.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\nmodule.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\nmodule.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n{\n  \"name\": \"varint\",\n  \"version\": \"5.0.0\",\n  \"description\": \"protobuf-style varint bytes - use msb to create integer values of varying sizes\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"node test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/chrisdickinson/varint.git\"\n  },\n  \"keywords\": [\n    \"varint\",\n    \"protobuf\",\n    \"encode\",\n    \"decode\"\n  ],\n  \"author\": \"Chris Dickinson <chris@neversaw.us>\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"tape\": \"~2.12.3\"\n  }\n}\nconst { runtime, platform, arch } = typeof Bare !== 'undefined'\n  ? { runtime: 'bare', platform: global.Bare.platform, arch: global.Bare.arch }\n  : typeof process !== 'undefined'\n    ? { runtime: 'node', platform: global.process.platform, arch: global.process.arch }\n    : typeof Window !== 'undefined'\n      ? { runtime: 'browser', platform: 'unknown', arch: 'unknown' }\n      : { runtime: 'unknown', platform: 'unknown', arch: 'unknown' }\n\nexports.runtime = runtime\nexports.platform = platform\nexports.arch = arch\nexports.isBare = runtime === 'bare'\nexports.isNode = runtime === 'node'\nexports.isBrowser = runtime === 'browser'\nexports.isWindows = platform === 'win32'\nexports.isLinux = platform === 'linux'\nexports.isMac = platform === 'darwin'\nexports.isIOS = platform === 'ios' || platform === 'ios-simulator'\nexports.isAndroid = platform === 'android'\nexports.isElectron = !!(typeof process !== 'undefined' && global.process.versions.electron)\nexports.isElectronRenderer = !!(typeof process !== 'undefined' && global.process.versions.electron && global.process.type === 'renderer')\nexports.isElectronWorker = !!(typeof process !== 'undefined' && global.process.versions.electron && global.process.type === 'worker')\n{\n  \"name\": \"which-runtime\",\n  \"version\": \"1.2.1\",\n  \"description\": \"Detect if you are in Bare or Node and which os etc\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^17.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/which-runtime.git\"\n  },\n  \"author\": \"Holepunch Inc.\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/which-runtime/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/which-runtime\"\n}\nmodule.exports = class MaxCache {\n  constructor ({ maxSize, maxAge, createMap, ongc }) {\n    this.maxSize = maxSize\n    this.maxAge = maxAge\n    this.ongc = ongc || null\n\n    this._createMap = createMap || defaultCreateMap\n    this._latest = this._createMap()\n    this._oldest = this._createMap()\n    this._retained = this._createMap()\n    this._gced = false\n    this._interval = null\n\n    if (this.maxAge > 0 && this.maxAge < Infinity) {\n      const tick = Math.ceil(2 / 3 * this.maxAge)\n      this._interval = setInterval(this._gcAuto.bind(this), tick)\n      if (this._interval.unref) this._interval.unref()\n    }\n  }\n\n  * [Symbol.iterator] () {\n    for (const it of [this._latest, this._oldest, this._retained]) {\n      yield * it\n    }\n  }\n\n  * keys () {\n    for (const it of [this._latest, this._oldest, this._retained]) {\n      yield * it.keys()\n    }\n  }\n\n  * values () {\n    for (const it of [this._latest, this._oldest, this._retained]) {\n      yield * it.values()\n    }\n  }\n\n  destroy () {\n    this.clear()\n    clearInterval(this._interval)\n    this._interval = null\n  }\n\n  clear () {\n    this._gced = true\n    this._latest.clear()\n    this._oldest.clear()\n    this._retained.clear()\n  }\n\n  set (k, v) {\n    if (this._retained.has(k)) return this\n    this._latest.set(k, v)\n    this._oldest.delete(k) || this._retained.delete(k)\n    if (this._latest.size >= this.maxSize) this._gc()\n    return this\n  }\n\n  retain (k, v) {\n    this._retained.set(k, v)\n    this._latest.delete(k) || this._oldest.delete(k)\n    return this\n  }\n\n  delete (k) {\n    return this._latest.delete(k) || this._oldest.delete(k) || this._retained.delete(k)\n  }\n\n  has (k) {\n    return this._latest.has(k) || this._oldest.has(k) || this._retained.has(k)\n  }\n\n  get (k) {\n    if (this._latest.has(k)) {\n      return this._latest.get(k)\n    }\n\n    if (this._oldest.has(k)) {\n      const v = this._oldest.get(k)\n      this._latest.set(k, v)\n      this._oldest.delete(k)\n      return v\n    }\n\n    if (this._retained.has(k)) {\n      return this._retained.get(k)\n    }\n\n    return null\n  }\n\n  _gcAuto () {\n    if (!this._gced) this._gc()\n    this._gced = false\n  }\n\n  _gc () {\n    this._gced = true\n    if (this.ongc !== null && this._oldest.size > 0) this.ongc(this._oldest)\n    this._oldest = this._latest\n    this._latest = this._createMap()\n  }\n}\n\nfunction defaultCreateMap () {\n  return new Map()\n}\n{\n  \"name\": \"xache\",\n  \"version\": \"1.2.1\",\n  \"description\": \"Yet another auto expiring, max sizable cache\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/xache.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/xache/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/xache\"\n}\nmodule.exports = dist\n\nfunction dist (a, b) {\n  if (a.length !== b.length) throw new Error('Inputs should have the same length')\n  var result = Buffer.allocUnsafe(a.length)\n  for (var i = 0; i < a.length; i++) result[i] = a[i] ^ b[i]\n  return result\n}\n\ndist.compare = function compare (a, b) {\n  if (a.length !== b.length) throw new Error('Inputs should have the same length')\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] === b[i]) continue\n    return a[i] < b[i] ? -1 : 1\n  }\n  return 0\n}\n\ndist.gt = function gt (a, b) {\n  return dist.compare(a, b) === 1\n}\n\ndist.lt = function lt (a, b) {\n  return dist.compare(a, b) === -1\n}\n\ndist.eq = function eq (a, b) {\n  return dist.compare(a, b) === 0\n}\n{\n  \"name\": \"xor-distance\",\n  \"version\": \"2.0.0\",\n  \"description\": \"Calculate the distance between two buffers as a new buffer and compare computed distances with eachother\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"tape\": \"^4.2.0\"\n  },\n  \"scripts\": {\n    \"test\": \"tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/xor-distance.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/xor-distance/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/xor-distance\"\n}\nconst b4a = require('b4a')\n\nconst ALPHABET = 'ybndrfg8ejkmcpqxot1uwisza345h769'\nconst MIN = 0x31 // 1\nconst MAX = 0x7a // z\nconst REVERSE = new Int8Array(1 + MAX - MIN)\n\nREVERSE.fill(-1)\n\nfor (let i = 0; i < ALPHABET.length; i++) {\n  const v = ALPHABET.charCodeAt(i) - MIN\n  REVERSE[v] = i\n}\n\nexports.encode = encode\nexports.decode = decode\nexports.ALPHABET = ALPHABET\n\nfunction decode (s, out) {\n  let pb = 0\n  let ps = 0\n\n  const r = s.length & 7\n  const q = (s.length - r) / 8\n\n  if (!out) out = b4a.allocUnsafe(Math.ceil(s.length * 5 / 8))\n\n  // 0 5 2 7 4 1 6 3 (+5 mod 8)\n  for (let i = 0; i < q; i++) {\n    const a = quintet(s, ps++)\n    const b = quintet(s, ps++)\n    const c = quintet(s, ps++)\n    const d = quintet(s, ps++)\n    const e = quintet(s, ps++)\n    const f = quintet(s, ps++)\n    const g = quintet(s, ps++)\n    const h = quintet(s, ps++)\n\n    out[pb++] = (a << 3) | (b >>> 2)\n    out[pb++] = ((b & 0b11) << 6) | (c << 1) | (d >>> 4)\n    out[pb++] = ((d & 0b1111) << 4) | (e >>> 1)\n    out[pb++] = ((e & 0b1) << 7) | (f << 2) | (g >>> 3)\n    out[pb++] = ((g & 0b111) << 5) | h\n  }\n\n  if (r === 0) return out.subarray(0, pb)\n\n  const a = quintet(s, ps++)\n  const b = quintet(s, ps++)\n\n  out[pb++] = (a << 3) | (b >>> 2)\n\n  if (r <= 2) return out.subarray(0, pb)\n\n  const c = quintet(s, ps++)\n  const d = quintet(s, ps++)\n\n  out[pb++] = ((b & 0b11) << 6) | (c << 1) | (d >>> 4)\n\n  if (r <= 4) return out.subarray(0, pb)\n\n  const e = quintet(s, ps++)\n\n  out[pb++] = ((d & 0b1111) << 4) | (e >>> 1)\n\n  if (r <= 5) return out.subarray(0, pb)\n\n  const f = quintet(s, ps++)\n  const g = quintet(s, ps++)\n\n  out[pb++] = ((e & 0b1) << 7) | (f << 2) | (g >>> 3)\n\n  if (r <= 7) return out.subarray(0, pb)\n\n  const h = quintet(s, ps++)\n\n  out[pb++] = ((g & 0b111) << 5) | h\n\n  return out.subarray(0, pb)\n}\n\nfunction encode (buf) {\n  if (typeof buf === 'string') buf = b4a.from(buf)\n\n  const max = buf.byteLength * 8\n\n  let s = ''\n\n  for (let p = 0; p < max; p += 5) {\n    const i = p >>> 3\n    const j = p & 7\n\n    if (j <= 3) {\n      s += ALPHABET[(buf[i] >>> (3 - j)) & 0b11111]\n      continue\n    }\n\n    const of = j - 3\n    const h = (buf[i] << of) & 0b11111\n    const l = (i >= buf.byteLength ? 0 : buf[i + 1]) >>> (8 - of)\n\n    s += ALPHABET[h | l]\n  }\n\n  return s\n}\n\nfunction quintet (s, i) {\n  if (i > s.length) {\n    return 0\n  }\n\n  const v = s.charCodeAt(i)\n\n  if (v < MIN || v > MAX) {\n    throw Error('Invalid character in base32 input: \"' + s[i] + '\" at position ' + i)\n  }\n\n  const bits = REVERSE[v - MIN]\n\n  if (bits === -1) {\n    throw Error('Invalid character in base32 input: \"' + s[i] + '\" at position ' + i)\n  }\n\n  return bits\n}\n{\n  \"name\": \"z32\",\n  \"version\": \"1.1.0\",\n  \"description\": \"Encode & decode z-base32\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.5.3\"\n  },\n  \"devDependencies\": {\n    \"base-x\": \"^4.0.0\",\n    \"base32\": \"0.0.7\",\n    \"brittle\": \"^3.1.3\",\n    \"nanobench\": \"^3.0.0\",\n    \"rfc4648\": \"^1.5.2\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/z32.git\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\",\n    \"bench\": \"node benchmark.js\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/z32/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/z32\"\n}\n{\n  \"name\": \"Keet\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"scripts\": {\n    \"android\": \"react-native run-android\",\n    \"ios\": \"react-native run-ios\",\n    \"lint\": \"eslint .\",\n    \"start\": \"react-native start\",\n    \"test\": \"jest\",\n    \"pod\": \"npx pod-install\",\n    \"gen\": \"npx bare-pack --out main.bundle.js main.js --target ios-arm64 --target ios-arm64-simulator --target ios-x64-simulator --target android-arm --target android-arm64 --target android-ia32 --target android-x64 --linked\"\n  },\n  \"dependencies\": {\n    \"react\": \"18.3.1\",\n    \"react-native\": \"0.76.3\",\n    \"@holepunchto/keet-backend\": \"17.4.1\",\n    \"@holepunchto/keet-backend-rpc\": \"1.2.0\",\n    \"events\": \"3.3.0\",\n    \"expo\": \"^52.0.17\",\n    \"expo-build-properties\": \"^0.13.1\",\n    \"expo-constants\": \"^17.0.3\",\n    \"expo-linking\": \"^7.0.3\",\n    \"expo-system-ui\": \"^4.0.5\",\n    \"pear-inspect\": \"^1.2.3\",\n    \"random-access-memory\": \"6.2.1\",\n    \"react-dom\": \"^18.3.1\",\n    \"react-native-bare-kit\": \"0.4.3\",\n    \"react-native-safe-area-context\": \"^4.14.0\",\n    \"tiny-buffer-rpc\": \"2.2.2\",\n    \"expo-file-system\": \"~18.0.10\",\n    \"@expo/vector-icons\": \"^14.0.2\",\n    \"expo-application\": \"~6.0.2\",\n    \"expo-av\": \"~15.0.2\",\n    \"expo-blur\": \"~14.0.3\",\n    \"expo-camera\": \"~16.0.16\",\n    \"expo-cellular\": \"~7.0.2\",\n    \"expo-clipboard\": \"~7.0.1\",\n    \"expo-crypto\": \"~14.0.2\",\n    \"expo-device\": \"~7.0.2\",\n    \"expo-document-picker\": \"~13.0.3\",\n    \"expo-haptics\": \"~14.0.1\",\n    \"expo-image\": \"~2.0.5\",\n    \"expo-image-manipulator\": \"~13.0.6\",\n    \"expo-image-picker\": \"~16.0.6\",\n    \"expo-local-authentication\": \"~15.0.2\",\n    \"expo-localization\": \"~16.0.1\",\n    \"expo-media-library\": \"~17.0.5\",\n    \"expo-screen-orientation\": \"~8.0.4\",\n    \"expo-splash-screen\": \"~0.29.21\",\n    \"expo-video\": \"~2.0.5\",\n    \"expo-video-thumbnails\": \"~9.0.3\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.25.2\",\n    \"@babel/preset-env\": \"^7.25.3\",\n    \"@babel/runtime\": \"^7.25.0\",\n    \"@react-native-community/cli\": \"15.0.1\",\n    \"@react-native-community/cli-platform-android\": \"15.0.1\",\n    \"@react-native-community/cli-platform-ios\": \"15.0.1\",\n    \"@react-native/babel-preset\": \"0.76.3\",\n    \"@react-native/eslint-config\": \"0.76.3\",\n    \"@react-native/metro-config\": \"0.76.3\",\n    \"@react-native/typescript-config\": \"0.76.3\",\n    \"@types/react\": \"^18.2.6\",\n    \"@types/react-test-renderer\": \"^18.0.0\",\n    \"babel-jest\": \"^29.6.3\",\n    \"eslint\": \"^8.19.0\",\n    \"jest\": \"^29.6.3\",\n    \"prettier\": \"2.8.8\",\n    \"react-test-renderer\": \"18.3.1\",\n    \"typescript\": \"5.0.4\"\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  }\n}\n"
